{"c_oaecc": {"notes": "", "logical": "", "code_id": "oaecc", "physical": "", "protection": "", "introduced": "[Greg Kuperberg, \u201cThe capacity of hybrid quantum memory\u201d. quant-ph/0203105][C. B\u00e9ny, A. Kempf, and D. W. Kribs, \u201cGeneralization of Quantum Error Correction via the Heisenberg Picture\u201d, Physical Review Letters 98, (2007). DOI; quant-ph/0608071][C. B\u00e9ny, A. Kempf, and D. W. Kribs, \u201cQuantum error correction of observables\u201d, Physical Review A 76, (2007). DOI; 0705.1574][C. B\u00c9NY, D. W. KRIBS, and A. PASIEKA, \u201cALGEBRAIC FORMULATION OF QUANTUM ERROR CORRECTION\u201d, International Journal of Quantum Information 06, 597 (2008). DOI]", "description": "Stub.", "name": "Operator-algebra error-correcting code", "realizations": "", "short_name": "Operator-algebra QECC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parent_of_code_id": "ecc\nholographic\nqecc\noecc", "parent_of_detail": "\nProperties of holographic codes are often quantified in the Heisenberg picture, i.e., in terms of operator algebras [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][F. Pastawski and J. Preskill, \u201cCode Properties from Holographic Geometries\u201d, Physical Review X 7, (2017). DOI; 1612.00017].\n\n", "cousin_of_code_id": "eacq", "cousin_of_detail": "Entanglement-assisted hybrid codes are hybrid classical-quantum codes utilizing pre-shared entanglement.", "_type": "ecc", "_page_id": "c_oaecc", "_href": "c/oaecc"}, "c_eacq": {"notes": "", "logical": "", "code_id": "eacq", "physical": "", "protection": "", "introduced": "[I. Kremsky, M.-H. Hsieh, and T. A. Brun, \u201cClassical enhancement of quantum-error-correcting codes\u201d, Physical Review A 78, (2008). DOI; 0802.2414][Andrew Nemec and Andreas Klappenecker, \u201cInfinite Families of Quantum-Classical Hybrid Codes\u201d. 1911.12260][Manideep Mamindlapally and Andreas Winter, \u201cSingleton bounds for entanglement-assisted classical and quantum error correcting codes\u201d. 2202.02184]", "description": "Stub.", "name": "Entanglement-assisted hybrid classical-quantum (EACQ) code", "realizations": "", "short_name": "EACQ", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parent_of_code_id": "eaqecc\neaoecc", "parent_of_detail": "\n", "cousins_code_id": "oaecc", "cousins_detail": "Entanglement-assisted hybrid codes are hybrid classical-quantum codes utilizing pre-shared entanglement.", "_type": "ecc", "_page_id": "c_eacq", "_href": "c/eacq"}, "c_ecc": {"notes": "The modern theory of error-correcting codes is rooted in the foundational work of C. Shannon [C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI], but error-correcting codes have been used prior to that work [A. Barg, \u201cAt the Dawn of the Theory of Codes\u201d, The Mathematical Intelligencer 15, 20 (1993). DOI].", "logical": "", "code_id": "ecc", "physical": "", "protection": "A code corrects errors associated with a noise channel if it is possible to recover any codeword after its coordinates have been changed after going through the channel. More technically, an error-correcting code \\((u,\\mathcal{E})\\) is an encoder function \\(u:[1\\cdots K]\\to[1\\cdots N]\\) with a set of correctable errors \\(E:[1\\cdots N]\\to [1\\cdots M]\\) with the following property: there exists a decoder function \\(d:[1\\cdots M]\\to [1\\cdots K]\\) such that for all \\(E\\in\\cal{E}\\) and states \\(x\\in[1\\cdots K]\\), \\(d(E(e(x)))=x\\) [D. Gottesman. Surviving as a quantum computer in a classical world].", "introduced": "", "description": "A code is a subset of a set or alphabet, with each element called a codeword. An error-correcting code consists of \\(K\\) codewords over an alphabet with \\(N\\) elements such that it is possible to recover the codewords from errors \\(E\\) from some error set \\(\\mathcal{E}\\).", "name": "Error-correcting code (ECC)", "realizations": "", "short_name": "ECC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Capacity-achieving Guessing Random Additive Noise Decoding (GRAND) [K. R. Duffy, J. Li, and M. Medard, \u201cCapacity-Achieving Guessing Random Additive Noise Decoding\u201d, IEEE Transactions on Information Theory 65, 4023 (2019). DOI; 1802.07010].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oaecc", "parents_detail": "", "parent_of_code_id": "bits_into_bits\ndistributed_storage\nq-ary_digits_into_q-ary_digits\ngeneralized_concatenated\ngroup_classical\nipp\npoints_into_lattices\nlinear\nmatrices_into_matrices\nparallel_concatenated\nquasi_cyclic\nrandom\nrings_into_rings\npoints_into_spheres\nweighed_covering", "parent_of_detail": "\n\n\n\n\n\nError-correcting codes are defined for a finite alphabet, so only finite lattice-based codes are children.\n\n\n\n\n\n\n\n", "_type": "ecc", "_page_id": "c_ecc", "_href": "c/ecc"}, "c_regenerating": {"notes": "", "logical": "q-ary_digits", "code_id": "regenerating", "physical": "matrices", "protection": "", "introduced": "", "description": "Stub.", "name": "Regenerating code (RGC)", "realizations": "", "short_name": "RGC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "distributed_storage\nmatrices_into_matrices", "parents_detail": "\n", "parent_of_code_id": "mbr\nmsr", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_regenerating", "_href": "c/regenerating"}, "c_matrix_computation": {"notes": "", "logical": "matrices", "code_id": "matrix_computation", "physical": "matrices", "protection": "Allows computation to complete without waiting for stragglers, or nodes that either do not finish or finish their portion of the computation much later than all other nodes.", "introduced": "", "description": "Encoding that provides an extra redundancy for distributed matrix computation algorithms such as matrix multiplication. Parallelized algorithms distribute a desired computation over many nodes, and a key performance bottleneck is due to some nodes completing their individual tasks much later than other nodes. Matrix computation codes provide a layer of redundancy such that the computation can be performed without having all nodes finish their piece of the computation. ", "name": "Matrix computation code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "matrices_into_matrices", "parents_detail": "", "cousins_code_id": "mds", "cousins_detail": "The first matrix multiplication code encoded each entry of the matrices to be multiplied into an MDS code [K. Lee et al., \u201cSpeeding Up Distributed Machine Learning Using Codes\u201d, IEEE Transactions on Information Theory 64, 1514 (2018). DOI; 1512.02673].", "_type": "ecc", "_page_id": "c_matrix_computation", "_href": "c/matrix_computation"}, "c_rank_metric": {"notes": "See Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333] for a discussion of MacWilliams identities and the relationship between rank metric and Gabidulin codes.", "logical": "matrices", "code_id": "rank_metric", "physical": "matrices", "protection": "Protects against errors with rank \\(\\leq \\lfloor \\frac{d-1}2 \\rfloor\\).", "introduced": "[P. Delsarte, \u201cBilinear forms over a finite field, with applications to coding theory\u201d, Journal of Combinatorial Theory, Series A 25, 226 (1978). DOI]", "description": "Also called a Delsarte code. Each codeword is a matrix over \\(GF(q)\\), with codewords forming a \\(GF(q)\\)-linear subspace, and with the metric being the rank of the difference of matrices. The distance \\(d\\) is the minimum rank of all nonzero matrices in the code. Rank-metric codes on \\(n\\times m\\) matrices are denoted as \\([n\\times m,k,d]_q\\).\n\nThe number of codewords satisfies \\(k \\leq \\max(n, m) M\\), where \\(M\\) is the maximum rank of all matrices in the code. Codes that achieve this bound with equality are called Delsarte optimal anticodes. ", "name": "Rank-metric code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Polynomial-reconstruction Berlekamp-Welch based decoder [P. Loidreau, \u201cA Welch\u2013Berlekamp Like Algorithm for Decoding Gabidulin Codes\u201d, Coding and Cryptography 36 (2006). DOI].\nBerlekamp-Massey based decoder [G. Richter and S. Plass, \u201cFast decoding of rank-codes with rank errors and column erasures\u201d, International Symposium onInformation Theory, 2004. ISIT 2004. Proceedings.. DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "matrices_into_matrices", "parents_detail": "", "parent_of_code_id": "gabidulin\nmaximum_rank_distance", "parent_of_detail": "Gabidulin codes over \\(GF(q^N)\\), when expressed as matrices over \\(GF(q)\\), are rank-metric codes (see Def. 14 in Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333]). The reverse is not always true since Gabidulin codes are not always \\(GF(q^N)\\)-linear (see Rm. 16 in Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333]).\n", "_type": "ecc", "_page_id": "c_rank_metric", "_href": "c/rank_metric"}, "c_alamouti": {"notes": "", "logical": "points", "code_id": "alamouti", "physical": "matrices", "protection": "", "introduced": "[S. M. Alamouti, \u201cA simple transmit diversity technique for wireless communications\u201d, IEEE Journal on Selected Areas in Communications 16, 1451 (1998). DOI]", "description": "The simplest OSTBC, with two time slots, two channels, and with unitary coding matrix \\begin{align}\n  \\begin{pmatrix}c_{1} & c_{2}\\\\\n  -c_{2}^{\\star} & c_{1}^{\\star}\n  \\end{pmatrix}~,\n\\end{align} where \\(c_i\\) are complex numbers. ", "name": "Alamouti code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The only OSTBC with unity rate.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "orth_spacetime_block", "parents_detail": "", "_type": "ecc", "_page_id": "c_alamouti", "_href": "c/alamouti"}, "c_matrices_into_matrices": {"notes": "", "logical": "", "code_id": "matrices_into_matrices", "physical": "matrices", "protection": "", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in an \\(m\\times n\\)-dimensional matrix of coordinates over a field (e.g., the Galois field \\(GF(q)\\) or the complex numbers \\(\\mathbb{C}\\)).", "name": "Matrix-based code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "matrix_computation\nrank_metric\nregenerating\nspacetime\ntensor", "parent_of_detail": "\n\n\n\n", "_type": "ecc", "_page_id": "c_matrices_into_matrices", "_href": "c/matrices_into_matrices"}, "c_spacetime": {"notes": "See the chapter [B. Clerckx and C. Oestges, \u201cFrom Multi-Dimensional Propagation to Multi-Link MIMO Channels\u201d, Mimo Wireless Networks 29 (2013). DOI] or the Ch. 28 of Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI] for an introduction to spacetime coding.", "logical": "points", "code_id": "spacetime", "physical": "matrices", "protection": "", "introduced": "[V. Tarokh, N. Seshadri, and A. R. Calderbank, \u201cSpace-time codes for high data rate wireless communication: performance criterion and code construction\u201d, IEEE Transactions on Information Theory 44, 744 (1998). DOI]", "description": "Code designed for wireless transmission of information (via, e.g., radio waves) such that the sender can send multiple times from multiple locations. A spacetime code uses a modulation scheme to encode a message into signals that are sent at different times through different antennas, thereby utilizing both spatial and temporal (i.e., spacetime) degrees of freedom. ", "name": "Spacetime code (STC)", "realizations": "", "short_name": "STC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "matrices_into_matrices", "parents_detail": "", "parent_of_code_id": "spacetime_block", "parent_of_detail": "Spacetime codes also use spatial and temporal diversity, but do not necessarily use blocks as codewords.", "cousin_of_code_id": "cws\nhomological_cv", "cousin_of_detail": "CWS codes have been considered in the context of spacetime replication of quantum data [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913][P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544], while STCs are designed to replicate classical data.\nHomological CV codes have been considered in the context of spacetime replication of quantum data [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913][P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544], while STCs are designed to replicate classical data.", "_type": "ecc", "_page_id": "c_spacetime", "_href": "c/spacetime"}, "c_spacetime_block": {"notes": "", "logical": "points", "code_id": "spacetime_block", "physical": "matrices", "protection": "Provides protection against errors due to thermal noise and destructive interference arising from traversing an environment with scattering, reflection, and/or refraction.", "introduced": "[S. M. Alamouti, \u201cA simple transmit diversity technique for wireless communications\u201d, IEEE Journal on Selected Areas in Communications 16, 1451 (1998). DOI]", "description": "In a space-time block code, \\(n\\) spatially separated channels transmit symbols in \\(T\\) time slots. These symbols can be arranged in a \\(T\\times n\\) matrix where the columns correspond to the channels, and the rows correspond to the time slots. The codewords \\(\\{X\\}\\) are \\(T\\times n\\) matrices such that the codeword difference matrices have rank \\(n\\), and \\(\\min_{X\\neq 0}\\det(XX^*)\\) is maximized.", "name": "Spacetime block code (STBC)", "realizations": "High data-rate wireless communication, e.g., WiMAX (IEEE 802.16m) [R. Vidhya\u00a0Lavanya and M. Madheswaran, \u201cWimax (IEEE 802.16 m) system based on space time block code and discrete multiwavelet transform and implementation in FPGA\u201d, Telecommunication Systems 56, 327 (2013). DOI][S. P. Alex and L. M. A. Jalloul, \u201cPerformance Evaluation of MIMO in IEEE802.16e/WiMAX\u201d, IEEE Journal of Selected Topics in Signal Processing 2, 181 (2008). DOI].", "short_name": "STBC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "spacetime", "parents_detail": "Spacetime codes also use spatial and temporal diversity, but do not necessarily use blocks as codewords.", "parent_of_code_id": "orth_spacetime_block", "parent_of_detail": "The same construction without the constraint that the codeword matrices are orthogonal.", "_type": "ecc", "_page_id": "c_spacetime_block", "_href": "c/spacetime_block"}, "c_mbr": {"notes": "", "logical": "q-ary_digits", "code_id": "mbr", "physical": "matrices", "protection": "", "introduced": "", "description": "Stub.", "name": "Minimum-bandwidth regenerating (MBR) code", "realizations": "", "short_name": "MBR", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "regenerating", "parents_detail": "", "_type": "ecc", "_page_id": "c_mbr", "_href": "c/mbr"}, "c_orth_spacetime_block": {"notes": "", "logical": "points", "code_id": "orth_spacetime_block", "physical": "matrices", "protection": "If the matrix \\(C-C'\\), where \\(C\\) and \\(C'\\) are distinct codewords, has minimum rank \\(b\\), the code has diversity order \\(bn_R\\) (see Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 28.2.1), where \\(n_R\\) is the number of receivers. The maximum possible diversity order is \\(nn_R\\).", "introduced": "[S. M. Alamouti, \u201cA simple transmit diversity technique for wireless communications\u201d, IEEE Journal on Selected Areas in Communications 16, 1451 (1998). DOI]", "description": "The codewords are \\(T\\times n\\) matrices as defined for spacetime codes, with the additional condition that columns of the coding matrix are orthogonal. The parameter \\(n\\) is the number of channels, and \\(T\\) is the number of time slots.", "name": "Orthogonal Spacetime Block Code (OSTBC)", "realizations": "", "short_name": "OSTBC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Maximum-likelihood decoding can be achieved with only linear processing [V. Tarokh, H. Jafarkhani, and A. R. Calderbank, \u201cSpace-time block coding for wireless communications: performance results\u201d, IEEE Journal on Selected Areas in Communications 17, 451 (1999). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The greatest rate which can be achieved is \\(\\frac{n_0+1}{2n_0}\\), where either \\(n=2n_0\\) or \\(n=2n_0-1\\) [Xue-Bin Liang, \u201cOrthogonal designs with maximal rates\u201d, IEEE Transactions on Information Theory 49, 2468 (2003). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "spacetime_block", "parents_detail": "The same construction without the constraint that the codeword matrices are orthogonal.", "parent_of_code_id": "alamouti", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_orth_spacetime_block", "_href": "c/orth_spacetime_block"}, "c_msr": {"notes": "", "logical": "q-ary_digits", "code_id": "msr", "physical": "matrices", "protection": "", "introduced": "", "description": "Stub.", "name": "Minimum-storage regenerating (MSR) code", "realizations": "", "short_name": "MSR", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "regenerating", "parents_detail": "", "_type": "ecc", "_page_id": "c_msr", "_href": "c/msr"}, "c_maximum_rank_distance": {"notes": "", "logical": "matrices", "code_id": "maximum_rank_distance", "physical": "matrices", "protection": "", "introduced": "[P. Delsarte, \u201cBilinear forms over a finite field, with applications to coding theory\u201d, Journal of Combinatorial Theory, Series A 25, 226 (1978). DOI][E. M. Gabidulin, \"Theory of Codes with Maximum Rank Distance\", Problemy Peredachi Informacii, Volume 21, Issue 1, 3\u201316 (1985)][R. M. Roth, \u201cMaximum-rank array codes and their application to crisscross error correction\u201d, IEEE Transactions on Information Theory 37, 328 (1991). DOI]", "description": "Also called an optimal rank-distance code. An \\([n\\times m,k,d]_q\\) rank-metric code whose parameters are such that the Singleton-like bound \\begin{align}\nk \\leq \\max(n, m) (\\min(n, m) - d + 1)\n\\end{align} become an equality. ", "name": "Maximum-rank distance (MRD) code", "realizations": "Useful for error and erasure correction in network coding [Ralf Koetter and Frank Kschischang, \u201cCoding for Errors and Erasures in Random Network Coding\u201d. cs/0703061][D. Silva, F. R. Kschischang, and R. Koetter, \u201cA Rank-Metric Approach to Error Control in Random Network Coding\u201d, IEEE Transactions on Information Theory 54, 3951 (2008). DOI; 0711.0708].", "short_name": "MRD", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "rank_metric", "parents_detail": "", "cousins_code_id": "mds\nreed_solomon", "cousins_detail": "MRD codes are matrix-code analogues of MDS codes.\nMRD rank-metric codes can be thought of as matrix analogues of MDS Reed-Solomon codes as both constructions utilize a Vandermonde matrix [R. Koetter and F. R. Kschischang, \u201cCoding for Errors and Erasures in Random Network Coding\u201d, IEEE Transactions on Information Theory 54, 3579 (2008). DOI].", "cousin_of_code_id": "gabidulin", "cousin_of_detail": "Gabidulin codes over \\(GF(q^N)\\) with maximum rank-distance, when expressed as matrices over \\(GF(q)\\), are MRD codes.", "_type": "ecc", "_page_id": "c_maximum_rank_distance", "_href": "c/maximum_rank_distance"}, "c_tensor": {"notes": "See Refs. ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 18; [Wolf, Jack Keil. \"An introduction to tensor product codes and applications to digital storage systems.\" 2006 IEEE Information Theory Workshop-ITW 2006 Chengdu. IEEE, 2006.]) for expositions.", "logical": "", "code_id": "tensor", "physical": "matrices", "protection": "For linear codes \\(C_A=[n_A,k_A,d_A]\\) and \\(C_B=[n_B,k_B,d_B]\\), the resulting tensor code is \\(C_A \\otimes C_B=[n_A n_B,k_A k_B,d_A d_B]\\). Tensor codes can be useful for protecting against burst errors [L. Bahl and R. Chien, \u201cSingle- and multiple-burst-correcting properties of a class of cyclic product codes\u201d, IEEE Transactions on Information Theory 17, 594 (1971). DOI][R. Chien and S. Ng, \u201cDual product codes for correction of multiple low-density burst errors\u201d, IEEE Transactions on Information Theory 19, 672 (1973). DOI]. Dual codes of tensor codes formed by two random linear codes are robustly testable, a property useful for constructing asymptotically good QLDPC codes [Irit Dinur et al., \u201cGood Quantum LDPC Codes with Linear Time Decoders\u201d. 2206.07750][Gleb Kalachev and Pavel Panteleev, \u201cTwo-sided Robustly Testable Codes\u201d. 2206.09973] and proving distance bounds [Anthony Leverrier and Gilles Z\u00e9mor, \u201cA parallel decoder for good quantum LDPC codes\u201d. 2208.05537]. ", "introduced": "[P. Elias, \u201cError-free Coding\u201d, Transactions of the IRE Professional Group on Information Theory 4, 29 (1954). DOI][H. Burton and E. Weldon, \u201cCyclic product codes\u201d, IEEE Transactions on Information Theory 11, 433 (1965). DOI][G. D. Forney, Jr (1966). Concatenated Codes. MIT Press, Cambridge, MA.][W. Gore, \u201cFurther results on product codes\u201d, IEEE Transactions on Information Theory 16, 446 (1970). DOI]", "description": "Also called tensor code, Kroneckerian code, or product code. A matrix-based code constructed out of two linear binary or \\(q\\)-ary codes \\(C_A,C_B\\) in an outer-product construction denoted as \\(C_A \\otimes C_B\\).\n\nCodewords are those matrices whose column vectors are in \\(C_A\\) and whose row vectors are in \\(C_B\\). In other words, the matrix-valued codewords \\(c\\) of a tensor code satisfy the parity check equation \\(H_A c H^{\\text{T}}_B = 0\\). ", "name": "Tensor-product code", "realizations": "Construction can be used in magnetic recording by taking the tensor product of a Reed-Solomon code and a parity-check code [P. Chaichanavong and P. H. Siegel, \u201cTensor-product parity code for magnetic recording\u201d, IEEE Transactions on Magnetics 42, 350 (2006). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The simple decoding algorithm (first decode all columns with \\(C_1\\), then all rows with \\(C_2\\)) corrects up to \\((d_A d_B-1)/4 \\) errors.\nAlgorithms such as generalized minimum-distance decoding [G. Forney, \u201cGeneralized minimum distance decoding\u201d, IEEE Transactions on Information Theory 12, 125 (1966). DOI] or the min-sum algorithm can decode all errors of weight up to \\((d_A d_B-1)/2\\). Error location may be coupled with Viterbi decoding for every faulty sub-block [P. Chaichanavong and P. H. Siegel, \u201cTensor-product parity code for magnetic recording\u201d, IEEE Transactions on Magnetics 42, 350 (2006). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Rate of the tensor-product code \\(C_A \\otimes C_B\\) is a product of the rates of the codes \\(C_A\\) and \\(C_B\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "matrices_into_matrices\ngeneralized_concatenated", "parents_detail": "\n", "cousin_of_code_id": "dhlv\nquantum_tanner", "cousin_of_detail": "Tensor codes are used in constructing quantum DHLV codes.\nTensor codes are used in constructing quantum Tanner codes.", "_type": "ecc", "_page_id": "c_tensor", "_href": "c/tensor"}, "c_nonlinear_ag": {"notes": "", "logical": "q-ary_digits", "code_id": "nonlinear_ag", "physical": "q-ary_digits", "protection": "", "introduced": "[Noam D. Elkies, \u201cExcellent nonlinear codes from modular curves\u201d. math/0104115][Chaoping Xing, \u201cNonlinear codes from algebraic curves improving the Tsfasman-Vladut-Zink bound\u201d, IEEE Transactions on Information Theory 49, 1653 (2003). DOI][Noam D. Elkies, \u201cStill better nonlinear codes from modular curves\u201d. math/0308046][H. Niederreiter and F. \u00d6zbudak, \u201cConstructive Asymptotic Codes with an Improvement on the Tsfasman-Vl\u0103du\u0163-Zink and Xing Bounds\u201d, Coding, Cryptography and Combinatorics 259 (2004). DOI][H. Stichtenoth and C. Xing, \u201cExcellent Nonlinear Codes From Algebraic Function Fields\u201d, IEEE Transactions on Information Theory 51, 4044 (2005). DOI]", "description": "Nonlinear \\(q\\)-ary code constructed by evaluating functions on an algebraic curve. ", "name": "Nonlinear AG code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Certain nonlinear code sequences beat the Tsfasman-Vladut-Zink bound, outperforming linear AG codes.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ag", "parents_detail": "", "_type": "ecc", "_page_id": "c_nonlinear_ag", "_href": "c/nonlinear_ag"}, "c_q-ary_parity_check": {"notes": "", "logical": "q-ary_digits", "code_id": "q-ary_parity_check", "physical": "q-ary_digits", "protection": "", "introduced": "", "description": "Also known as a sum-zero code. An \\([n,n-1,2]_q\\) linear \\(q\\)-ary code whose codewords consist of the message string appended with a parity-check digit such that the sum over all coordinates of each codeword is zero.", "name": "\\(q\\)-ary parity-check code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "reed_solomon\nq-ary_cyclic\nmds", "parents_detail": "RS codes for \\(k=n-1\\) are parity-check codes [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cExtended Reed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html].\nSince permutations preserve coordinate sums, the cyclic permutation of a parity-check codeword is another codeword.\n", "cousin_of_code_id": "parity_check", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_q-ary_parity_check", "_href": "c/q-ary_parity_check"}, "c_q-ary_digits_into_q-ary_digits": {"notes": "Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by Brouwer [Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.], are maintained by M. Grassl at this website.", "logical": "q-ary_digits", "code_id": "q-ary_digits_into_q-ary_digits", "physical": "q-ary_digits", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) \\(q\\)-ary coordinates over the field \\(GF(q)=\\mathbb{F}_q\\) and has distance \\(d\\). Usually denoted as \\((n,K,d)_q\\). The distance is the minimum number of coordinates where two strings in the code differ.", "name": "Galois-field \\(q\\)-ary code", "realizations": "", "short_name": "\\(q\\)-ary", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "For small \\(n\\), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.\nGiven a received string \\(x\\) and an error bound \\(e\\), a list decoder returns a list of all codewords that are at most \\(e\\) from \\(x\\). The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\).", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "q-ary_additive\nag\nmatrix_product", "parent_of_detail": "\n\n", "_type": "ecc", "_page_id": "c_q-ary_digits_into_q-ary_digits", "_href": "c/q-ary_digits_into_q-ary_digits"}, "c_q-ary_additive": {"notes": "", "logical": "q-ary_digits", "code_id": "q-ary_additive", "physical": "q-ary_digits", "protection": "", "introduced": "", "description": "A \\(q\\)-ary code whose codewords are closed under addition, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword.", "name": "Additive \\(q\\)-ary code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "dual_additive\nq-ary_linear", "parent_of_detail": "\nFor \\(q>2\\), additive codes need not be linear since linearity also requires closure under multiplication.", "cousin_of_code_id": "galois_stabilizer", "cousin_of_detail": "A Galois-qudit stabilizer code is the closest quantum analogue of an additive code over \\(GF(q)\\) because addition in the field corresponds to multiplication of stabilizers in the quantum case.", "_type": "ecc", "_page_id": "c_q-ary_additive", "_href": "c/q-ary_additive"}, "c_q-ary_hamming": {"notes": "", "logical": "q-ary_digits", "code_id": "q-ary_hamming", "physical": "q-ary_digits", "protection": "Can detect 1-bit and 2-bit errors, and can correct 1-dit errors.", "introduced": "[M. J. E. Golay, Notes on digital coding, Proc. IEEE, 37 (1949) 657.]", "description": "Member of an infinite family of perfect linear \\(q\\)-ary codes with parameters \\([(q^r-1)/(q-1),(q^r-1)/(q-1)-r, 3]_q\\) for \\(r \\geq 2\\).", "name": "\\(q\\)-ary Hamming code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_linear\nperfect", "parents_detail": "\n", "cousins_code_id": "projective\nq-ary_cyclic\nbch\ngeneralized_reed_muller", "cousins_detail": "Columns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(q)^n\\).\nHamming codes are equivalent to cyclic codes when \\(q\\) and \\(r\\) are relatively prime ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 194).\nSome narrow sense BCH codes of length \\(n=(q^r-1)/(q-1)\\) such that \\(\\text{gcd}(r,q-1)=1\\) are \\(q\\)-ary Hamming codes ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thm. 5.1.4).\nHamming codes are dual to first-order GRM codes ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 45).", "cousin_of_code_id": "hamming\nsimplex", "cousin_of_detail": "\nHamming and simplex codes are dual to each other.", "_type": "ecc", "_page_id": "c_q-ary_hamming", "_href": "c/q-ary_hamming"}, "c_q-ary_linear": {"notes": "Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\).\nUniversity of Salzburg's MinT application generates an optimal parameter table for a linear code \\([n,k,d]_q\\), contingent on an optional fluctuation of maximal Hamming code distance, rank, and length, along with other specifications.", "logical": "q-ary_digits", "code_id": "q-ary_linear", "physical": "q-ary_digits", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set such that the difference of any pair of distinct elements of the set is a codeword.", "introduced": "", "description": "An \\((n,K,d)_q\\) linear code is denoted as \\([n,k,d]_q\\), where \\(k=\\log_{q}K\\) need not be an integer. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any \\(q\\)-ary digits \\(\\alpha,\\beta\\).\n\nLinear codes can be defined in terms of a generator matrix \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a message \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its standard or systematic form \\(G = [I_k~~A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) \\(q\\)-ary matrix. ", "name": "Linear \\(q\\)-ary code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Soft-decision maximum-likelihood trellis-based decoder [J. Wolf, \u201cEfficient maximum likelihood decoding of linear block codes using a trellis\u201d, IEEE Transactions on Information Theory 24, 76 (1978). DOI].\nRandom linear codes over large fields are list-recoverable and list-decodable up to near-optimal rates [Atri Rudra and Mary Wootters, \u201cAverage-radius list-recovery of random linear codes: it really ties the room together\u201d. 1704.02420].\nExtensions of algebraic-geometry decoders to linear codes [R. Kotter. A unified description of an error locating procedure for linear codes. In D. Yorgov, editor, Proc. 3rd International Workshop on Algebraic and Combinatorial Coding Theory, pages 113\u2013117, Voneshta Voda, Bulgaria, June 1992. Hermes.][R. Pellikaan, \u201cOn decoding by error location and dependent sets of error positions\u201d, Discrete Mathematics 106-107, 369 (1992). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_additive\nlinear", "parents_detail": "For \\(q>2\\), additive codes need not be linear since linearity also requires closure under multiplication.\n", "parent_of_code_id": "q-ary_cyclic\nevaluation\nfolded_reed_solomon\ngabidulin\ngeneralized_reed_muller\ninterleaved_reed_solomon\nprojective\nwozencraft\nq-ary_hamming", "parent_of_detail": "\nThe degree of the divisor for evaluation AG codes is restricted to be less than \\(n\\). When there is no restriction, any \\(q\\)-ary linear code can be formulated as an evaluation AG code [R. Pellikan, B.-Z. Shen, and G. J. M. van Wee, \u201cWhich linear codes are algebraic-geometric?\u201d, IEEE Transactions on Information Theory 37, 583 (1991). DOI].\n\n\n\nIRS codes are linear over \\(GF(q)\\) but not necessarily over \\(GF(q^t)\\).\nColumns of the generator matrix of a projective linear \\([n,k]_q\\) code correspond to distinct nonzero points in projective space. In general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], Thm. 1.1).\n\n", "cousin_of_code_id": "eaqecc\neastab\nevaluation_varieties\ngalois_css\nqudit_css\ngalois_true_stabilizer", "cousin_of_detail": "Any linear \\(q\\)-ary code can be used to construct an EAQECC.\nAny linear quaternary (\\(q=4\\)) code can be used to construct an EA stabilizer code.\nEvaluation codes are defined using polynomial or rational functions evaluated on a subset of affine or projective space. Given access to more general structures (i.e., morphisms of algebras), any \\(q\\)-ary linear code can be formulated as an evaluation code ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Sec. 4.1; [M. Tsfasman, S. Vl\u01cedu\u0163, and D. Nogin. Algebraic geometric codes: basic notions. Vol. 139. American Mathematical Society, 2022.], Prop. 1.1.4).\nConstruction uses two related \\(q\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).\nConstruction for prime \\(q=p\\) uses two related \\(p\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).\nA true Galois-qudit stabilizer code is the closest quantum analogue of a linear code over \\(GF(q)\\) because the \\(q\\)-ary vectors corresponding to the symplectic representation of the stabilizers form a linear subspace.", "_type": "ecc", "_page_id": "c_q-ary_linear", "_href": "c/q-ary_linear"}, "c_gabidulin": {"notes": "", "logical": "q-ary_digits", "code_id": "gabidulin", "physical": "q-ary_digits", "protection": "Set of vectors \\(\\{x_1, x_2, \\ldots, x_M\\}\\) determines a rank code with distance \\(d=\\min d(x_i, x_j)\\). The code with distance \\(d\\) corrects all errors with rank of the error not greater than \\(\\lfloor (d-1)/2\\rfloor\\).", "introduced": "[E. M. Gabidulin, Theory of Codes with Maximum Rank Distance, Problemy Peredachi Informacii, Volume 21, Issue 1, 3\u201316 (1985)][R. M. Roth, \u201cMaximum-rank array codes and their application to crisscross error correction\u201d, IEEE Transactions on Information Theory 37, 328 (1991). DOI]", "description": "Also called a vector rank-metric code. A linear code over \\(GF(q^N)\\) that corrects errors over rank metric instead of the traditional Hamming distance. Every element \\(GF(q^N)\\) can be written as an \\(N\\)-dimensional vector with coefficients in \\(GF(q)\\), and the rank of a set of elements is rank of the matrix formed by their coefficients.\n\nGiven \\(X^n=\\text{span}\\{x_i\\}\\), an \\(n\\)-dimensional vector space over \\(GF(q^N)\\) (where \\(q\\) is a power of a prime number), the rank metric \\(d(x, y)\\) is defined via the rank norm \\(r(x, q) = \\mathrm{rank}(A(x))\\), where \\begin{align}\nA(x) = \\begin{pmatrix} a_{11} & a_{12} & \\ldots & a_{1n} \\\\ a_{21} & a_{22} & \\ldots & a_{2n} \\\\  a_{N1} & a_{N2} & \\ldots & a_{Nn}~, \\end{pmatrix}\n\\end{align} and \\(x_i = a_{1i} u_1 + a_{2i} u_2 + \\ldots + a_{Ni}u_N \\) for some fixed basis \\(\\{u_i\\}_{i=1}^N\\). ", "name": "Gabidulin code", "realizations": "Public-key cryptosystems [T. P. Berger and P. Loidreau, \u201cHow to Mask the Structure of Codes for a Cryptographic Use\u201d, Designs, Codes and Cryptography 35, 63 (2005). DOI].\nDigital watermarking. The Gabidulin code provides efficient correction against luminance tampering and image-slicing distortion due to the consistency of the rank against alterations such as column swapping [P. Lefevre, P. Carre, and P. Gaborit, \u201cWatermarking and Rank Metric Codes\u201d, 2018 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP) (2018). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Fast decoder based on a transform-domain approach [D. Silva and F. R. Kschischang, \u201cFast encoding and decoding of Gabidulin codes\u201d, 2009 IEEE International Symposium on Information Theory (2009). DOI; 0901.2483].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_linear\nrank_metric", "parents_detail": "\nGabidulin codes over \\(GF(q^N)\\), when expressed as matrices over \\(GF(q)\\), are rank-metric codes (see Def. 14 in Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333]). The reverse is not always true since Gabidulin codes are not always \\(GF(q^N)\\)-linear (see Rm. 16 in Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333]).", "cousins_code_id": "maximum_rank_distance", "cousins_detail": "Gabidulin codes over \\(GF(q^N)\\) with maximum rank-distance, when expressed as matrices over \\(GF(q)\\), are MRD codes.", "_type": "ecc", "_page_id": "c_gabidulin", "_href": "c/gabidulin"}, "c_ipp": {"notes": "", "logical": "q-ary_digits", "code_id": "ipp", "physical": "q-ary_digits", "protection": "", "introduced": "[H. D. L. Hollmann et al., \u201cOn Codes with the Identifiable Parent Property\u201d, Journal of Combinatorial Theory, Series A 82, 121 (1998). DOI]", "description": "Stub.", "name": "Identifiable parent property (IPP) code", "realizations": "", "short_name": "IPP", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "_type": "ecc", "_page_id": "c_ipp", "_href": "c/ipp"}, "c_alternant": {"notes": "", "logical": "q-ary_digits", "code_id": "alternant", "physical": "q-ary_digits", "protection": "", "introduced": "[H. J. Helgert, \u201cAlternant codes\u201d, Information and Control 26, 369 (1974). DOI]", "description": "Given a length-\\(n\\) GRS code \\(C\\) over \\(GF(q^m)\\), an alternant code is the \\(GF(q)\\)-subfield subcode of the dual of \\(C\\). ", "name": "Alternant code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Guruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_reed_solomon", "parents_detail": "Alternant codes are subfield subcodes of GRS codes.", "_type": "ecc", "_page_id": "c_alternant", "_href": "c/alternant"}, "c_ag": {"notes": "See book by Goppa [V. D. Goppa, Geometry and Codes (Springer Netherlands, 1988). DOI].", "logical": "q-ary_digits", "code_id": "ag", "physical": "q-ary_digits", "protection": "", "introduced": "[V. D. Goppa, \u201cCodes Associated with Divisors\u201d, Probl. Peredachi Inf., 13:1 (1977), 33\u201339; Problems Inform. Transmission, 13:1 (1977), 22\u201327][V. D. Goppa, \u201cCodes on algebraic curves\u201d, Dokl. Akad. Nauk SSSR, 259:6 (1981), 1289\u20131290][V. D. Goppa, \u201cAlgebraico-geometric codes\u201d, Izv. Akad. Nauk SSSR Ser. Mat., 46:4 (1982), 762\u2013781; Izv. Math., 21:1 (1983), 75\u201391]", "description": "Binary or \\(q\\)-ary code constructed from an algebraic curve of some genus over a finite field via the evaluation construction, the residue construction, or more general constructions that yield nonlinear codes. Linear AG codes from the first two constructions are also called geometric Goppa codes.\n\nIn alternative conventions (not used here), AG codes are often restricted to be linear and/or include evaluation codes defined using algebraic varieties. ", "name": "Algebraic-geometry (AG) code", "realizations": "", "short_name": "AG", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Several sequences of linear AG codes beat the Gilbert-Varshamov bound and/or are asymptotically good [A. Garcia and H. Stichtenoth, \u201cA tower of Artin-Schreier extensions of function fields attaining the Drinfeld-Vladut bound\u201d, Inventiones Mathematicae 121, 211 (1995). DOI][A. Garcia and H. Stichtenoth, \u201cOn the Asymptotic Behaviour of Some Towers of Function Fields over Finite Fields\u201d, Journal of Number Theory 61, 248 (1996). DOI] (see Ref. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.] for details). The rate of any linear AG code satisfies \\begin{align} \\frac{k}{n} \\geq 1 - \\frac{d}{n} - \\frac{1}{\\sqrt{q}-1}~, \\end{align} which comes from the Drinfeld-Vladut bound [S. G. Vla\u0306dut\u0327, V. G. Drinfeld, \u201cNumber of points of an algebraic curve\u201d, Funktsional. Anal. i Prilozhen., 17:1 (1983), 68\u201369; Funct. Anal. Appl., 17:1 (1983), 53\u201354]. Nonlinear AG codes can outperform this bound.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "evaluation\nnonlinear_ag\nresidue", "parent_of_detail": "\n\n", "cousins_code_id": "mds", "cousins_detail": "Near MDS \\([n,k,d]_{GF(p^m)}\\) AG codes exist when \\(n,p,m\\) satisfy certain relations according to the Tsfasman-Vladut bound [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI].", "_type": "ecc", "_page_id": "c_ag", "_href": "c/ag"}, "c_wozencraft": {"notes": "", "logical": "q-ary_digits", "code_id": "wozencraft", "physical": "q-ary_digits", "protection": "", "introduced": "[J. L. Massey, Threshold Decoding. Cambridge, MA: M.I.T. Press, 1963.]", "description": "Stub.", "name": "Wozencraft ensemble code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_linear", "parents_detail": "", "cousin_of_code_id": "justesen", "cousin_of_detail": "Wozencraft ensemble forms the inner codes of Justesen codes.", "_type": "ecc", "_page_id": "c_wozencraft", "_href": "c/wozencraft"}, "c_matrix_product": {"notes": "", "logical": "q-ary_digits", "code_id": "matrix_product", "physical": "q-ary_digits", "protection": "", "introduced": "[T. Blackmore and G. H. Norton, \u201cMatrix-Product Codes over ? q\u201d, Applicable Algebra in Engineering, Communication and Computing 12, 477 (2001). DOI]", "description": "Code constructed using a concatenation procedure that yields a code consisting of all products of codewords in \\(M\\) length-\\(n\\) \\(q\\)-ary codes and an \\(M\\times N\\) \\(q\\)-ary matrix with \\(N\\geq M\\). A prominent subclass is the case with \\(A\\) is non-singular by columns (NSC). ", "name": "Matrix-product code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoder up to half of the minimum distance for NSC codes [F. Hernando, K. Lally, and D. Ruano, \u201cConstruction and decoding of matrix-product codes from nested codes\u201d, Applicable Algebra in Engineering, Communication and Computing 20, 497 (2009). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "generalized_reed_muller", "parent_of_detail": "Applying a special case of the matrix-product procedure yields GRM codes [T. Blackmore and G. H. Norton, \u201cMatrix-Product Codes over ? q\u201d, Applicable Algebra in Engineering, Communication and Computing 12, 477 (2001). DOI].", "cousin_of_code_id": "galois_true_stabilizer", "cousin_of_detail": "Hermitian self-orthogonal matrix-product codes over \\(GF(q^2)\\) can be used to construct true stabilizer codes [M. Cao and J. Cui, \u201cConstruction of new quantum codes via Hermitian dual-containing matrix-product codes\u201d, Quantum Information Processing 19, (2020). DOI][Xiusheng Liu, Hualu Liu, and Long Yu, \u201cOn New Quantum Codes From Matrix Product Codes\u201d. 1604.05823].", "_type": "ecc", "_page_id": "c_matrix_product", "_href": "c/matrix_product"}, "c_dual_additive": {"notes": "", "description": "For any \\(q\\)-ary additive code \\(C\\), the dual additive (or orthogonal additive) code is \\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{n} ~|~ x \\star y=0 \\forall x\\in C\\},\n\\end{align} where the trace inner product is \\(x\\star y = \\sum_{i=1}^n \\text{tr}(x_i y_i)\\) for coordinates \\(x_i,y_i\\), and the trace maps elements of the field \\(GF(q)\\) with \\(q=p^m\\) to elements of \\(GF(p)\\) as \\begin{align}\n  \\text{tr}(\\gamma)=\\sum_{k=0}^{m-1}\\gamma^{p^{k}}~.\n\\end{align}\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called self-orthogonal additive or weakly self-dual additive. A code that contains its dual, \\(C^\\perp \\subseteq C\\), is called dual-containing additive. A code that is equal to its dual, \\(C^\\perp = C\\), is called self-dual additive. A code is dual-containing additive iff its dual is self-orthogonal additive.\n\nFor cases when \\(q\\) is a square, an alternative definition of dual substitutes the trace inner product for the trace-Hermitian inner product, \\(x\\star y \\to \\sum_{i=1}^n \\text{tr}(x_i y^{\\sqrt{q}}_i)\\). Another extension, relevant to certain stabilizer codes and reducing to the trace-Hermitian case for \\(q=4\\), is the trace-alternating inner product, \\begin{align}\n  x\\star y \\to \\sum_{i=1}^{n}\\text{tr}\\left(\\frac{x_{i}y_{i}^{\\sqrt{q}}-x_{i}^{\\sqrt{q}}y_{i}}{\\alpha-\\alpha^{q}}\\right)~,\n\\end{align} where \\(\\{1,\\alpha\\}\\) is a basis of \\(GF(q)\\) over \\(GF(\\sqrt{q})\\). Self-dual additive codes with respect to the trace-Hermitian (trace-alternating) inner product are called trace Hermitian (trace-alternating) self-dual additive; similar definitions hold for self-orthogonal additive and dual-containing additive.", "name": "Dual additive code", "code_id": "dual_additive", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_additive", "parents_detail": "", "cousins_code_id": "dual", "cousins_detail": "The difference between the definitions of dual linear and dual additive codes is in the trace used in the inner product. Self-dual linear codes are also self-dual additive codes.", "cousin_of_code_id": "galois_stabilizer\noctacode\nstabilizer_over_gf4\nstabilizer_over_gfqsq", "cousin_of_detail": "An additive code of length \\(2n\\) over \\(GF(q)\\) that is self-orthogonal with respect to the trace-symplectic inner product corresponds to symplectic representations of an \\(n\\) Galois-qudit stabilizer group [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]. Moreover, any additive code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code.\nThe octacode is self-dual with respect to the Euclidean inner product.\nThe stabilizer commutation condition for stabilizer codes over \\(GF(4)\\) can equivalently be stated in the representation of stabilizers as quaternary vectors. A pair of \\(n\\)-qubit stabilizers commute iff the trace-Hermitian inner product of their corresponding vectors is zero. Stabilizer codes over \\(GF(4)\\) can thus be constructed from trace-Hermitian self-orthogonal additive quaternary codes.\nThe stabilizer commutation condition for stabilizer codes over \\(GF(q^2)\\) can equivalently be stated in the representation of stabilizers as vectors over \\(GF(q^2)\\). A pair of \\(n\\) Galois-qudit stabilizers commute iff the trace-alternating inner product of their their corresponding vectors is zero. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\).", "_type": "ecc", "_page_id": "c_dual_additive", "_href": "c/dual_additive"}, "c_ternary_golay": {"notes": "The automorphism group of the ternary Golay code is the Mathieu group \\(\\mathcal{M}_{11}\\), and the automorphism group of the extended ternary Golay code is the Mathieu group \\(\\mathcal{M}_{12}\\), two of the sporadic simple groups.", "logical": "q-ary_digits", "code_id": "ternary_golay", "physical": "q-ary_digits", "protection": "", "introduced": "[M. J. E. Golay, Notes on digital coding, Proc. IEEE, 37 (1949) 657.]", "description": "A \\([11,6,5]_{GF(3)}\\) perfect ternary linear code with connections to various areas of mathematics, e.g., lattices [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI] and sporadic simple groups [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.]. Adding a parity bit to the code results in the \\([12, 6, 6]\\) extended ternary Golay code. Up to equivalence, both codes are unique for their respective parameters.\n\nA generator matrix for the ternary Golay code is \\begin{align}\n\\left[\\begin{array}{ccccccccccc}\n  1 & 0 & 0 & 0 & 0 & | & 1 & 1 & 1 & 2 & 2 & 0 \\\\\n  0 & 1 & 0 & 0 & 0 & | & 1 & 1 & 2 & 1 & 0 & 2 \\\\\n  0 & 0 & 1 & 0 & 0 & | & 1 & 2 & 1 & 0 & 1 & 2 \\\\\n  0 & 0 & 0 & 1 & 0 & | & 1 & 2 & 0 & 1 & 2 & 1 \\\\\n  0 & 0 & 0 & 0 & 1 & | & 1 & 0 & 2 & 2 & 1 & 1 \\\\\n\\end{array}\\right]~.\n\\end{align} ", "name": "Ternary Golay Code", "realizations": "Code used in football pools with at least one good bet [H. H\u00e4m\u00e4l\u00e4inen and S. Rankinen, \u201cUpper bounds for football pool problems and mixed covering codes\u201d, Journal of Combinatorial Theory, Series A 56, 84 (1991). DOI][A. Barg, \u201cAt the Dawn of the Theory of Codes\u201d, The Mathematical Intelligencer 15, 20 (1993). DOI]. In fact, the code was originally constructed by Juhani Virtakallio and published in the Finnish football pool magazine Veikkaaja [A. Barg, \u201cAt the Dawn of the Theory of Codes\u201d, The Mathematical Intelligencer 15, 20 (1993). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoder for the extended ternary Golay code using the tetracode [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "perfect\nq-ary_quad_residue", "parents_detail": "The ternary Golay code is perfect.\nThe ternary Golay code is a quadratic residue code over \\(GF(3)\\) with residue set \\(Q = \\{1, 3, 4, 5, 9\\} \\) and generator polynomial \\(x^5 + x^4 - x^3 + x^2 - 1\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 16).", "cousins_code_id": "golay\ndual\nprojective\ndivisible", "cousins_detail": "\nThe extended ternary Golay code is self-dual.\nThe extended ternary Golay code admits a projective geometric construction ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 296).\nExtended ternary Golay code is 3-divisible ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 296).", "cousin_of_code_id": "tetracode", "cousin_of_detail": "Extended ternary Golay codewords can be obtained from tetracodewords [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. The tetracode can be used to decode the extended ternary Golay code [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI].", "_type": "ecc", "_page_id": "c_ternary_golay", "_href": "c/ternary_golay"}, "c_hexacode": {"notes": "See corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cHexacode.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CHexa.html].", "logical": "q-ary_digits", "code_id": "hexacode", "physical": "q-ary_digits", "protection": "", "introduced": "[J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]", "description": "The \\([6,3,4]_{GF(4)}\\) self-dual MDS code with generator matrix \\begin{align}\n  \\begin{pmatrix}\n  1 & 0 & 0 & 1 & 1 & \\omega\\\\\n  0 & 1 & 0 & 1 & \\omega & 1\\\\\n  0 & 0 & 1 & \\omega & 1 & 1\n  \\end{pmatrix}~,\n\\end{align} where \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\). Has connections to projective geometry, lattices [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI] and conformal field theory [J. A. Harvey and G. W. Moore, \u201cMoonshine, superconformal symmetry, and quantum error correction\u201d, Journal of High Energy Physics 2020, (2020). DOI; 2003.13700]. ", "name": "Hexacode", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Bounded-distance decoder requiring at most 34 real operations [A. Vardy, \u201cEven more efficient bounded-distance decoding of the hexacode, the Golay code, and the Leech lattice\u201d, IEEE Transactions on Information Theory 41, 1495 (1995). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation\nprojective\nq-ary_quad_residue\ndenniston\nmds", "parents_detail": "The hexacode is an evaluation AG code over \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\) with \\(\\cal X\\) defined by \\(x^2 y + \\omega y^2 z + \\bar{\\omega} z^2 x = 0\\) ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.77).\nColumns of hexacode's generator matrix represent the six homogeneous coordinates of a hyperoval in the projective plane \\(PG(2,4)\\) ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 289).\nThe hexacode is the smallest example of an extended quadratic residue code of Type \\(4^H\\) ([Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI], Sec. 2.4.6).\nA version of the hexacode is recovered for Dennison code parameters \\(i=1\\) and \\(a=2\\) [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI].\n", "cousins_code_id": "stab_5_1_3\ndual\ngolay", "cousins_detail": "Applying the stabilizer-over-\\(GF(4)\\) construction to the hexacode yields a \\([[6,0,4]]\\) quantum code [A. J. Scott, \u201cMultipartite entanglement, quantum-error-correcting codes, and entangling power of quantum evolutions\u201d, Physical Review A 69, (2004). DOI; quant-ph/0310137] corresponding to the six-qubit perfect state. The \\([[5,1,3]]\\) code can be obtained from this code by tracing out a qubit [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nThe hexacode is Euclidean and Hermitian self-dual.\nExtended Golay codewords can be obtained from hexacodewords [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. The hexacode can be used to decode the extended Golay code [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI]. There is also a connection between automoprhisms of the even Golay code and the holomorph of the hexacode [J. A. Harvey and G. W. Moore, \u201cMoonshine, superconformal symmetry, and quantum error correction\u201d, Journal of High Energy Physics 2020, (2020). DOI; 2003.13700].", "_type": "ecc", "_page_id": "c_hexacode", "_href": "c/hexacode"}, "c_tetracode": {"notes": "See corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cTetracode.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CTetra.html].", "logical": "q-ary_digits", "code_id": "tetracode", "physical": "q-ary_digits", "protection": "", "introduced": "[J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]", "description": "The \\([4,2,3]_{GF(3)}\\) self-dual MDS code with generator matrix \\begin{align}\n  \\begin{pmatrix}1 & 0 & 1 & 1\\\\\n  0 & 1 & 1 & 2\n  \\end{pmatrix}~,\n\\end{align} where \\(GF(3) = \\{0,1,2\\}\\). Has connections to lattices [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. ", "name": "Tetracode", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "simplex\nhamming\nmds", "parents_detail": "The tetracode is equivalent to \\(S(3,2)\\).\nThe tetracode is equivalent to the \\(r=2\\) Hamming code.\n", "cousins_code_id": "dual\nternary_golay", "cousins_detail": "The tetracode is self-dual.\nExtended ternary Golay codewords can be obtained from tetracodewords [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. The tetracode can be used to decode the extended ternary Golay code [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI].", "_type": "ecc", "_page_id": "c_tetracode", "_href": "c/tetracode"}, "c_dodecacode": {"notes": "", "logical": "q-ary_digits", "code_id": "dodecacode", "physical": "q-ary_digits", "protection": "", "introduced": "[A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006][Gerald Hoehn, \u201cSelf-dual Codes over the Kleinian Four Group\u201d. math/0005266]", "description": "Self-dual \\([12,6,6]_{GF(4)}\\) code whose codewords are cyclic permutations of \\((\\omega 10100100101)\\), where \\(GF(4)=\\{0,1,\\omega,\\bar{\\omega}\\}\\). ", "name": "Dodecacode", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_cyclic", "parents_detail": "", "cousins_code_id": "dual", "cousins_detail": "The dodecacode is self-dual.", "_type": "ecc", "_page_id": "c_dodecacode", "_href": "c/dodecacode"}, "c_incidence_matrix": {"notes": "", "logical": "q-ary_digits", "code_id": "incidence_matrix", "physical": "q-ary_digits", "protection": "", "introduced": "[E. Prange, The use of coset equivalene in the analysis and decoding of group codes. AIR FORCE CAMBRIDGE RESEARCH LABS HANSCOM AFB MA, 1959.][L. Rudolph, \u201cA class of majority logic decodable codes (Corresp.)\u201d, IEEE Transactions on Information Theory 13, 305 (1967). DOI][E. Prange, \"Some cyclic error-correcting codes with simple decoding algorithms.\" AFCRC-TN-58-156 (1985).]", "description": "Code whose generator matrix is the incidence matrix of points and hyperplanes of a projective spaces. Has been generalized to incidence matrices of other structures ([B. Bagchi and S. P. Inamdar, \u201cProjective Geometric Codes\u201d, Journal of Combinatorial Theory, Series A 99, 128 (2002). DOI][M. Lavrauw, L. Storme, and G. Van de Voorde (2010). Linear codes from projective spaces. In A. Bruen & D. Wehlau (Eds.), Contemporary Mathematics (Vol. 523, pp. 185\u2013202). Providence, RI, USA: American Mathematical Society (AMS).]; [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 14.4). ", "name": "Incidence-matrix projective code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "projective", "parents_detail": "", "_type": "ecc", "_page_id": "c_incidence_matrix", "_href": "c/incidence_matrix"}, "c_griesmer": {"notes": "", "logical": "q-ary_digits", "code_id": "griesmer", "physical": "q-ary_digits", "protection": "", "introduced": "[J. H. Griesmer, \u201cA Bound for Error-Correcting Codes\u201d, IBM Journal of Research and Development 4, 532 (1960). DOI][G. Solomon and J. J. Stiffler, \u201cAlgebraically punctured cyclic codes\u201d, Information and Control 8, 170 (1965). DOI][R. R. Varshamov, On the general theory of linear coding, Ph.D. Thesis, Moscow State University, 1959.]", "description": "A \\([n,k,d]\\) binary or \\(q\\)-ary linear code is a Griesmer code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Griesmer bound \\begin{align}\n  n\\geq\\sum_{j=0}^{k-1}\\left\\lceil \\frac{d}{q^{j}}\\right\\rceil ~,\n\\end{align} where \\(\\left\\lceil x\\right\\rceil \\) is the ceiling function, becomes an equality.\n\nAn \\([n,2,d]_q\\) code exists if and only if it is not excluded by the Griesmer bound. Every Griesmer code is generated by its minimum-weight codewords [S. Dodunekov, Optimal linear codes, Ph.D. Thesis, Sofia, 1985.]. ", "name": "Griesmer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "mds", "parents_detail": "Singleton bound implies the Griesmer bound.", "parent_of_code_id": "denniston\nsimplex", "parent_of_detail": "\nSimplex codes saturate the Griesmer bound ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], Exer. 5.1.11).", "cousins_code_id": "divisible", "cousins_detail": "Griesmer codes over prime fields are divisible [H. N. Ward, \u201cDivisibility of Codes Meeting the Griesmer Bound\u201d, Journal of Combinatorial Theory, Series A 83, 79 (1998). DOI].", "cousin_of_code_id": "anticode\nbch\ngrassmannian\nprojective_reed_muller\nprojective", "cousin_of_detail": "Several anticode (e.g., [B. I. Belov, V. N. Logachev, V. P. Sandimirov, \u201cConstruction of a Class of Linear Binary Codes Achieving the Varshamov-Griesmer Bound\u201d, Probl. Peredachi Inf., 10:3 (1974), 36\u201344; Problems Inform. Transmission, 10:3 (1974), 211\u2013217][R. Hill, \"Optimal Linear Codes in: C. Mitchell (Ed.) Crytography and Coding.\" (1992): 75-104.]) and related [B. I. Belov, \"A conjecture on the Griesmer bound.\" Optimization Methods and Their Applications,(Russian), Sibirsk. Energet. Inst. Sibirsk. Otdel. Akad. Nauk SSSR, Irkutsk 182 (1974): 100-106.] constructions saturate the Griesmer bound; see Refs. [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI][F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for more details.\nThe \\([15,5,7]\\) BCH code extended with a parity check saturates the Griesmer bound ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 157).\nThe binary Grassmannian \\([35,6,16]\\) code, whose points lie on the Grassmannian \\({\\mathbb{G}(2,4)}\\), attains the Griesmer bound [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].\nPRM codes for \\(r=1\\) attain the Griesmer bound for all \\(m\\) [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].\nAcrs corresponding to Griesmer codes are called Griesmer arcs ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], pg. 248). There is a one-to-one correspondence between Griesmer codes and minihypers [N. Hamada and M. Deza, \u201cA characterization of \u03bd\u03bc + 1 + \u03b5, \u03bd\u03bc; t, q-min.hypers and its applications to error-correcting codes and factorial designs\u201d, Journal of Statistical Planning and Inference 22, 323 (1989). DOI][N. Hamada, Characterization of minihypers in a finite projective geometry and its applications to error-correcting codes, Bull. Osaka Women's Univ. 24 (1987), 1-24.]; see Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 14.2.4 and Ref. [J. W. P. Hirschfeld and L. Storme, \u201cThe Packing Problem in Statistics, Coding Theory and Finite Projective Spaces: Update 2001\u201d, Developments in Mathematics 201 (2001). DOI] for more details.", "_type": "ecc", "_page_id": "c_griesmer", "_href": "c/griesmer"}, "c_simplex": {"notes": "See corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cSimplex Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html].", "logical": "q-ary_digits", "code_id": "simplex", "physical": "q-ary_digits", "protection": "", "introduced": "", "description": "Also known as a maximum length feedback shift register code. An \\([n,k,q^{k-1}]_q\\) projective code with \\(n=\\frac{q^k-1}{q-1}\\), denoted as \\(S(q,k)\\). The columns of the generator matrix are in one-to-one correspondence with the elements of the projective space \\(PG(k-1,q)\\), with each column being a chosen representative of the corresponding element. Its dual code is the \\([n,n-k,3]_q\\) \\(q\\)-ary Hamming code. The name of the code comes from the property that, for \\(q=2\\), the codewords form a \\((2^k-1)\\)-simplex of constant edge length if the codewords are interpreted as points in \\(\\mathbb{R}^n\\). ", "name": "Simplex code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Due to the small size, it can be decoded according to maximum likelihood.\nSome faster decoders for the \\(q=2\\) case: [R. R. Green, \"A serial orthogonal decoder,\" JPL Space Programs Summary, vol. 37\u201339-IV, pp. 247\u2013253, 1966.][A. Ashikhmin and S. Litsyn, \u201cSimple MAP decoding of first order Reed-Muller and Hamming codes\u201d, Proceedings 2003 IEEE Information Theory Workshop (Cat. No.03EX674). DOI]\nA quantum decoder for the \\(q=2\\) case: [A. Barg and S. Zhou, \u201cA quantum decoding algorithm for the simplex code\u201d, in Proceedings of the 36th Annual Allerton Conference on Communication, Control and Computing, Monticello, IL, 23\u201325 September 1998 (UIUC 1998) 359\u2013365].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "projective\ngriesmer\nconstant_weight", "parents_detail": "Columns of the simplex code's generator matrix are in one-to-one correspondence with elements of a projective space.\nSimplex codes saturate the Griesmer bound ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], Exer. 5.1.11).\nAll non-zero simplex codewords have a constant weight of \\(q^{k-1}\\).", "parent_of_code_id": "tetracode", "parent_of_detail": "The tetracode is equivalent to \\(S(3,2)\\).", "cousins_code_id": "extended_reed_solomon\nrepetition\nq-ary_hamming\nreed_muller", "cousins_detail": "\\(S(2,k)\\) is an extended RS code [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cSimplex Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html].\n\\(S(2,1)\\) reduces to the repetition code.\nHamming and simplex codes are dual to each other.\nBinary simplex codes can be constructed from the generator matrix of RM\\((1,k)\\) by removing first the all-ones row, and then the all-zero column. Punctured RM codes and simplex codes are interconvertible via expurgation and augmentation ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 31).", "_type": "ecc", "_page_id": "c_simplex", "_href": "c/simplex"}, "c_denniston": {"notes": "", "logical": "q-ary_digits", "code_id": "denniston", "physical": "q-ary_digits", "protection": "", "introduced": "[J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI]", "description": "Projective code that is part of a family of \\([2^{a+i}+2^i-2^a,3,2^{a+i}-2^a]_{GF(2^a)}\\) codes for \\(i < a\\) constructed using Denniston arcs. ", "name": "Denniston code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "projective\ngriesmer", "parents_detail": "Columns of Denniston code generator matrices represent points of a Denniston arc.\n", "parent_of_code_id": "hexacode", "parent_of_detail": "A version of the hexacode is recovered for Dennison code parameters \\(i=1\\) and \\(a=2\\) [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI].", "_type": "ecc", "_page_id": "c_denniston", "_href": "c/denniston"}, "c_projective": {"notes": "See corresponding definition in MinT.", "logical": "q-ary_digits", "code_id": "projective", "physical": "q-ary_digits", "protection": "Distance \\(d\\) is \\(n\\) minus the maximum number of points that are contained in a hyperplane. For \\(n \\geq 3\\), a code is projective if and only if the distance of its dual code is at least three.", "introduced": "", "description": "Linear \\(q\\)-ary \\([n,k,d]\\) code such that columns of its generator matrix \\(G\\) does not contain any repeated columns or the zero column. That way, each column corresponds to a distinct point in the projective space \\(PG(k-1,q)\\) arising from a \\(k\\)-dimensional vector space over \\(GF(q)\\). If the columns are linearly independent, then the codewords are collectively called an information set. Columns of a code's parity-check matrix can similarly correspond to points in projective space. This formulation yields connections to projective geometry, which can be applied to determine code properties.\n\nRecall that a linear code encodes a message \\(h\\) into a codeword \\(c = hG\\). The \\(i\\)th coordinate of a codeword is given the dot product \\(h \\cdot G_{i}\\) with \\(G_{i}\\) being the \\(i\\)th column of the generator matrix. The zero-coordinate condition \\(h \\cdot x = 0\\) defines a hyperplane of points \\(x\\) with normal vector \\(h\\). Therefore, the Hamming weight of the corresponding codeword is the number of points \\(G_i\\) not contained in said hyperplane.\n\nIn general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], Thm. 1.1; [I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI]). Multisets can also be used to construct parity-check matrices of linear codes.", "name": "Projective geometry code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_linear", "parents_detail": "Columns of the generator matrix of a projective linear \\([n,k]_q\\) code correspond to distinct nonzero points in projective space. In general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], Thm. 1.1).", "parent_of_code_id": "denniston\nhexacode\nincidence_matrix\nsimplex", "parent_of_detail": "Columns of Denniston code generator matrices represent points of a Denniston arc.\nColumns of hexacode's generator matrix represent the six homogeneous coordinates of a hyperoval in the projective plane \\(PG(2,4)\\) ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 289).\n\nColumns of the simplex code's generator matrix are in one-to-one correspondence with elements of a projective space.", "cousins_code_id": "evaluation_varieties\nextended_reed_solomon\ngriesmer\nanticode", "cousins_detail": "Codewords of an evaluation code of multivariate polynomials up to degree one evaluated at points in projective space yields a projective code.\nColumns of parity-check matrices of doubly extended narrow-sense RS codes consist of points of a normal rational curve ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Def. 14.2.6).\nAcrs corresponding to Griesmer codes are called Griesmer arcs ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], pg. 248). There is a one-to-one correspondence between Griesmer codes and minihypers [N. Hamada and M. Deza, \u201cA characterization of \u03bd\u03bc + 1 + \u03b5, \u03bd\u03bc; t, q-min.hypers and its applications to error-correcting codes and factorial designs\u201d, Journal of Statistical Planning and Inference 22, 323 (1989). DOI][N. Hamada, Characterization of minihypers in a finite projective geometry and its applications to error-correcting codes, Bull. Osaka Women's Univ. 24 (1987), 1-24.]; see Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 14.2.4 and Ref. [J. W. P. Hirschfeld and L. Storme, \u201cThe Packing Problem in Statistics, Coding Theory and Finite Projective Spaces: Update 2001\u201d, Developments in Mathematics 201 (2001). DOI] for more details.\nThere is a relation between anticodes and minihypers ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 295).", "cousin_of_code_id": "hamming\nmds\nprojective_reed_muller\nternary_golay\nq-ary_hamming", "cousin_of_detail": "Columns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(2)^n\\).\nA linear code is MDS (almost MDS) if and only if columns of its parity-check matrix form an \\(n\\)-arc (\\(n\\)-track) in projective space [S. M. Dodunekov and I. N. Landgev, \u201cOn near-MDS codes\u201d, Proceedings of 1994 IEEE International Symposium on Information Theory. DOI][J. W. P. Hirschfeld and L. Storme, \u201cThe Packing Problem in Statistics, Coding Theory and Finite Projective Spaces: Update 2001\u201d, Developments in Mathematics 201 (2001). DOI]. The dual of a MDS code is an MDS code, so MDS codes are projective.\nNonzero codewords of minimum weight of a \\(r\\)th-order \\(q\\)-ary projective RM code correspond to algebraic hypersurfaces of degree \\(r\\) having the largest number of points in the projective space \\(PG(n,q)\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 14.3.3).\nThe extended ternary Golay code admits a projective geometric construction ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 296).\nColumns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(q)^n\\).", "_type": "ecc", "_page_id": "c_projective", "_href": "c/projective"}, "c_generalized_reed_muller": {"notes": "See books [E. F. Assmus and J. D. Key, Designs and Their Codes (Cambridge University Press, 1992). DOI][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI][E. F. Assmus, Jr. and J. D. Key, \u201cPolynomial codes and finite geometries,\u201d in Handbook of Coding Theory, eds. V. S. Pless and W. C. Huffman. Amsterdam: Elsevier, 1998, pp. 1269\u20131343.] for details of GRM codes.", "logical": "q-ary_digits", "code_id": "generalized_reed_muller", "physical": "q-ary_digits", "protection": "Code parameters for specific \\(m,r\\) are given in Ref. [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 46.", "introduced": "[T. Kasami, Shu Lin, and W. Peterson, \u201cNew generalizations of the Reed-Muller codes--I: Primitive codes\u201d, IEEE Transactions on Information Theory 14, 189 (1968). DOI][E. Weldon, \u201cNew generalizations of the Reed-Muller codes--II: Nonprimitive codes\u201d, IEEE Transactions on Information Theory 14, 199 (1968). DOI][P. Delsarte, J. M. Goethals, and F. J. Mac Williams, \u201cOn generalized ReedMuller codes and their relatives\u201d, Information and Control 16, 403 (1970). DOI]", "description": "Reed-Muller code GRM\\(_q(r,m)\\) of length \\(n=q^m\\) over \\(GF(q)\\) with \\(0\\leq r\\leq m(q-1)\\). Its codewords are evaluations of the set of all degree-\\(\\leq r\\) polynomials in \\(m\\) variables at a set of distinct points \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) in \\(GF(q)\\).\n\nSince \\(\\beta^q=\\beta\\) for any \\(\\beta\\in GF(q)\\), the above definition is not injective. Replacing each factor in each polynomial as \\(x^q\\to x\\), the above set reduces to the set of all degree-\\(\\leq r\\) polynomials in \\(m\\) variables such that no term has an exponent \\(q\\) or higher on any variable. ", "name": "Generalized RM (GRM) code", "realizations": "", "short_name": "GRM", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_linear\nevaluation_polynomial\nmatrix_product", "parents_detail": "\nGRM (PRM) codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine (projective) space over \\(GF(q)\\) ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pgs. 44-46; [S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nApplying a special case of the matrix-product procedure yields GRM codes [T. Blackmore and G. H. Norton, \u201cMatrix-Product Codes over ? q\u201d, Applicable Algebra in Engineering, Communication and Computing 12, 477 (2001). DOI].", "parent_of_code_id": "projective_reed_muller", "parent_of_detail": "", "cousins_code_id": "reed_muller\nq-ary_cyclic\nextended_reed_solomon", "cousins_detail": "\nGRM codes with nonzero evaluation points are cyclic ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 52).\nGRM codes for univariate polynomials (\\(m=1\\)) reduce to extended RS codes [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].", "cousin_of_code_id": "q-ary_hamming", "cousin_of_detail": "Hamming codes are dual to first-order GRM codes ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 45).", "_type": "ecc", "_page_id": "c_generalized_reed_muller", "_href": "c/generalized_reed_muller"}, "c_projective_reed_muller": {"notes": "", "logical": "q-ary_digits", "code_id": "projective_reed_muller", "physical": "q-ary_digits", "protection": "", "introduced": "[G. Lachaud, \u201cThe parameters of projective Reed\u2013M\u00fcller codes\u201d, Discrete Mathematics 81, 217 (1990). DOI][A. B. Sorensen, \u201cProjective Reed-Muller codes\u201d, IEEE Transactions on Information Theory 37, 1567 (1991). DOI]", "description": "Reed-Muller code for nonzero points \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) whose leftmost nonzero coordinate is one, corresponding to an evaluation code of polynomials over projective coordinates. PRM codes PRM\\(_q(r,m)\\) for \\(r<q\\) are injective evaluation codes with parameters [G. Lachaud, \u201cNumber of points of plane sections and linear codes defined on algebraic varieties\u201d, Arithmetic, Geometry, and Coding Theory. DOI] \\begin{align}\n  \\left[ q^m+q^{m-1}\\cdots +1, {m+r \\choose r},(q+1-r)q^{m-1} \\right]~.\n\\end{align} ", "name": "Projective RM (PRM) code", "realizations": "", "short_name": "PRM", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_reed_muller", "parents_detail": "", "cousins_code_id": "projective\ngriesmer", "cousins_detail": "Nonzero codewords of minimum weight of a \\(r\\)th-order \\(q\\)-ary projective RM code correspond to algebraic hypersurfaces of degree \\(r\\) having the largest number of points in the projective space \\(PG(n,q)\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 14.3.3).\nPRM codes for \\(r=1\\) attain the Griesmer bound for all \\(m\\) [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].", "_type": "ecc", "_page_id": "c_projective_reed_muller", "_href": "c/projective_reed_muller"}, "c_schubert": {"notes": "", "logical": "q-ary_digits", "code_id": "schubert", "physical": "q-ary_digits", "protection": "Minimum distance bounds computed in Refs. [Hao Chen, \u201cOn the minimum distances of Schubert codes\u201d, IEEE Transactions on Information Theory 46, 1535 (2000). DOI][L. Guerra and R. Vincenti, \u201cOn the Linear Codes Arising from Schubert Varieties\u201d, Designs, Codes and Cryptography 33, 173 (2004). DOI][S. R. Ghorpade and M. A. Tsfasman, \u201cSchubert varieties, linear codes and enumerative combinatorics\u201d, Finite Fields and Their Applications 11, 684 (2005). DOI].", "introduced": "[S. R. Ghorpade and G. Lachaud, \u201cHigher Weights of Grassmann Codes\u201d, Coding Theory, Cryptography and Related Areas 122 (2000). DOI][Hao Chen, \u201cOn the minimum distances of Schubert codes\u201d, IEEE Transactions on Information Theory 46, 1535 (2000). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Schubert variety. ", "name": "Schubert code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "flag_variety", "parents_detail": "Schubert codes are flag-variety evaluation codes with the flag variety being a Schubert variety.", "cousins_code_id": "grassmannian", "cousins_detail": "Schubert varieties are subvarieties of Grassmannians, and Schubert codes were initially constructed as a generalization of Grassmannian codes.", "_type": "ecc", "_page_id": "c_schubert", "_href": "c/schubert"}, "c_serge": {"notes": "", "logical": "q-ary_digits", "code_id": "serge", "physical": "q-ary_digits", "protection": "", "introduced": "[M. Gonz\u00e1lez-Sarabia, C. Renter\u0131\u0301a, and H. Tapia-Recillas, \u201cReed-Muller-Type Codes Over the Segre Variety\u201d, Finite Fields and Their Applications 8, 511 (2002). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Serge variety. ", "name": "Serge-variety RM-type code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation_polynomial", "parents_detail": "Serge-variety RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a Serge variety.", "_type": "ecc", "_page_id": "c_serge", "_href": "c/serge"}, "c_ruled_surface": {"notes": "", "logical": "q-ary_digits", "code_id": "ruled_surface", "physical": "q-ary_digits", "protection": "", "introduced": "[S. H. Hansen, \u201cError-Correcting Codes from Higher-Dimensional Varieties\u201d, Finite Fields and Their Applications 7, 530 (2001). DOI][Chris Lomont, \u201cError Correcting Codes on Algebraic Surfaces\u201d. math/0309123]", "description": "Evaluation code of polynomials evaluated on points lying on a ruled surface. ", "name": "Ruled-surface code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation_polynomial", "parents_detail": "Ruled-surface codes are polynomial evaluation codes with \\(\\cal X\\) being a ruled surface.", "_type": "ecc", "_page_id": "c_ruled_surface", "_href": "c/ruled_surface"}, "c_complete_intersections": {"notes": "", "logical": "q-ary_digits", "code_id": "complete_intersections", "physical": "q-ary_digits", "protection": "Distance bounds formulated in Ref. [L. Gold, J. Little, and H. Schenck, \u201cCayley\u2013Bacharach and evaluation codes on complete intersections\u201d, Journal of Pure and Applied Algebra 196, 91 (2005). DOI].", "introduced": "[I. M. Duursma, C. Renter\u00eda, and H. Tapia-Recillas, \u201cReed-Muller Codes on Complete Intersections\u201d, Applicable Algebra in Engineering, Communication and Computing 11, 455 (2001). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a complete intersection. ", "name": "Complete-intersection RM-type code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation_polynomial", "parents_detail": "Complete-intersection RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a complete intersection.", "_type": "ecc", "_page_id": "c_complete_intersections", "_href": "c/complete_intersections"}, "c_quadric": {"notes": "", "logical": "q-ary_digits", "code_id": "quadric", "physical": "q-ary_digits", "protection": "", "introduced": "[J. Wolfmann, \u201cCodes projectifs a deux ou trois poids associfs aux hyperquadriques d'une geometrie finie\u201d, Discrete Mathematics 13, 185 (1975). DOI][Y. Aubry, \u201cReed-Muller codes associated to projective algebraic varieties\u201d, Lecture Notes in Mathematics 4 (1992). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a quadric hypersurface. ", "name": "Quadric code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "flag_variety", "parents_detail": "Quadric codes are flag-variety evaluation codes with the flag variety being a quadric hypersurface.", "_type": "ecc", "_page_id": "c_quadric", "_href": "c/quadric"}, "c_toric_classical": {"notes": "See Ref. [Delio Jaramillo, Maria Vaz Pinto, and Rafael H. Villarreal, \u201cEvaluation codes and their basic parameters\u201d. 1907.13217] for various examples and implementations in Magma.", "logical": "q-ary_digits", "code_id": "toric_classical", "physical": "q-ary_digits", "protection": "Parameters of toric RM-type codes and various generalizations have been determined in Refs. [Diego Ruano, \u201cOn the Parameters of r-dimensional Toric Codes\u201d. math/0512285][John Little and Hal Schenck, \u201cToric surface codes and Minkowski sums\u201d. math/0507598][Eliseo Sarmiento, Maria Vaz Pinto, and Rafael H. Villarreal, \u201cThe minimum distance of parameterized codes on projective tori\u201d. 1009.4966][Hiram H. Lopez, Carlos Renteria, and Rafael H. Villarreal, \u201cAffine cartesian codes\u201d. 1202.0085][Peter Beelen and Mrinmoy Datta, \u201cGeneralized Hamming weights of affine cartesian codes\u201d. 1706.02114][Delio Jaramillo, Maria Vaz Pinto, and Rafael H. Villarreal, \u201cEvaluation codes and their basic parameters\u201d. 1907.13217].", "introduced": "[J. P. Hansen, \u201cToric Surfaces and Error-correcting Codes\u201d, Coding Theory, Cryptography and Related Areas 132 (2000). DOI][David Joyner, \u201cToric codes over finite fields\u201d. math/0208155]", "description": "Evaluation code of a linear space of polynomials evaluated on points lying on an affine or projective toric variety. If the space is taken to be all polynomials up to some degree, the code is called a toric RM-type code of that degree. ", "name": "Hansen toric code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation_polynomial", "parents_detail": "Hansen toric codes are polynomial evaluation codes with \\(\\cal X\\) being a toric variety.", "_type": "ecc", "_page_id": "c_toric_classical", "_href": "c/toric_classical"}, "c_grassmannian": {"notes": "", "logical": "q-ary_digits", "code_id": "grassmannian", "physical": "q-ary_digits", "protection": "", "introduced": "[C. T. Ryan, An application of Grassmannian varieties to coding theory. Congr. Numer. 57 (1987) 257\u2013271.][C.T. Ryan, Projective codes based on Grassmann varieties, Congr. Numer. 57, 273\u2013279 (1987).][C. T. Ryan and K. M. Ryan, \u201cThe minimum weight of the Grassmann codes C(k,n),\u201d, Discrete Applied Mathematics 28, 149 (1990). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Grassmannian \\({\\mathbb{G}}(\\ell,m)\\). ", "name": "Grassmannian code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "flag_variety", "parents_detail": "Grassmannian codes are flag-variety evaluation codes with the flag variety being a Grassmannian.", "cousins_code_id": "griesmer", "cousins_detail": "The binary Grassmannian \\([35,6,16]\\) code, whose points lie on the Grassmannian \\({\\mathbb{G}(2,4)}\\), attains the Griesmer bound [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].", "cousin_of_code_id": "schubert", "cousin_of_detail": "Schubert varieties are subvarieties of Grassmannians, and Schubert codes were initially constructed as a generalization of Grassmannian codes.", "_type": "ecc", "_page_id": "c_grassmannian", "_href": "c/grassmannian"}, "c_deligne_lusztig": {"notes": "", "logical": "q-ary_digits", "code_id": "deligne_lusztig", "physical": "q-ary_digits", "protection": "", "introduced": "[S. H. Hansen, \u201cError-Correcting Codes from Higher-Dimensional Varieties\u201d, Finite Fields and Their Applications 7, 530 (2001). DOI][S.H. Hansen, The geometry of Deligne-Lusztig varieties: Higher dimensional AG codes, Ph.D. Thesis, University of Aarhus, 1999.][S. H. Hansen, \u201cCanonical bundles of Deligne-Lusztig varieties\u201d, manuscripta mathematica 98, 363 (1999). DOI][J. P. Hansen, \u201cDeligne-Lusztig varieties and group codes\u201d, Lecture Notes in Mathematics 63 (1992). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Deligne-Lusztig variety. ", "name": "Deligne-Lusztig code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation_polynomial", "parents_detail": "Deligne-Lusztig codes are polynomial evaluation codes with \\(\\cal X\\) a Deligne-Lusztig variety.", "_type": "ecc", "_page_id": "c_deligne_lusztig", "_href": "c/deligne_lusztig"}, "c_flag_variety": {"notes": "", "logical": "q-ary_digits", "code_id": "flag_variety", "physical": "q-ary_digits", "protection": "", "introduced": "[F. Rodier, \u201cCodes from flag varieties over a finite field\u201d, Journal of Pure and Applied Algebra 178, 203 (2003). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a flag variety. ", "name": "Flag-variety code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation_polynomial", "parents_detail": "Flag-variety codes are polynomial evaluation codes with \\(\\cal X\\) being a flag variety.", "parent_of_code_id": "grassmannian\nhermitian_hypersurface\nquadric\nschubert", "parent_of_detail": "Grassmannian codes are flag-variety evaluation codes with the flag variety being a Grassmannian.\nHermitian-hypersurface codes are flag-variety evaluation codes with the flag variety being a Hermitian hypersurface.\nQuadric codes are flag-variety evaluation codes with the flag variety being a quadric hypersurface.\nSchubert codes are flag-variety evaluation codes with the flag variety being a Schubert variety.", "_type": "ecc", "_page_id": "c_flag_variety", "_href": "c/flag_variety"}, "c_hermitian_hypersurface": {"notes": "", "logical": "q-ary_digits", "code_id": "hermitian_hypersurface", "physical": "q-ary_digits", "protection": "", "introduced": "[I. M. Chakravarti, \u201cFamilies of Codes with Few Distinct Weights from Singular and Non-Singular Hermitian Varieties and Quadrics in Projective Geometries and Hadamard Difference Sets and Designs Associated with Two-Weight Codes\u201d, Coding Theory and Design Theory 35 (1990). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Hermitian hypersurface. ", "name": "Hermitian-hypersurface code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "flag_variety", "parents_detail": "Hermitian-hypersurface codes are flag-variety evaluation codes with the flag variety being a Hermitian hypersurface.", "cousins_code_id": "hermitian", "cousins_detail": "Hermitian-hypersurface codes reduce to Hermitian codes of polynomials when the hypersurface is a curve.", "_type": "ecc", "_page_id": "c_hermitian_hypersurface", "_href": "c/hermitian_hypersurface"}, "c_residue": {"notes": "", "logical": "q-ary_digits", "code_id": "residue", "physical": "q-ary_digits", "protection": "Riemann-Roch theorem yields code length \\(n\\), dimension \\(k\\), and a lower bound on distance in terms of features of \\(L\\) and genus of the curve \\(\\cal X\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Corr. 15.3.13). Distance bounds can also be derived from how an algebraic curve \\(\\cal X\\) is embedded in the ambient projective space [A. Couvreur, \u201cThe dual minimum distance of arbitrary-dimensional algebraic\u2013geometric codes\u201d, Journal of Algebra 350, 84 (2012). DOI; 0905.2345].", "introduced": "", "description": "Also called a differential code. Linear \\(q\\)-ary code defined using a set of points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) in \\(GF(q)\\) lying on an algebraic curve \\(\\cal X\\) and a linear space \\(\\Omega\\) of certain rational differential forms \\(\\omega\\). Codewords are evaluations of residues of the differential forms in the specified points, \\begin{align}\n  \\left(\\text{Res}_{P_{1}}(\\omega),\\text{Res}_{P_{2}}(\\omega),\\cdots,\\text{Res}_{P_{n}}(\\omega)\\right)\\quad\\quad\\forall\\omega\\in\\Omega~.\n\\end{align} The code is denoted as \\(C_{\\Omega}({\\cal X},{\\cal P},D)\\), where the divisor \\(D\\) determines which rational rational differential forms to use. ", "name": "Residue AG code", "realizations": "Improvements over the McEliece public-key cryptosystem to linear AG codes on curves of arbitrary genus [H. Janwa and O. Moreno, \u201c[]\u201d, Designs, Codes and Cryptography 8, 293 (1996). DOI]. Only the subfield subcode proposal remains resilient to attacks ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 15.7.5.3).\nAlgebraic secret-sharing schemes [H. Chen and R. Cramer, \u201cAlgebraic Geometric Secret Sharing Schemes and Secure Multi-Party Computations over Small Fields\u201d, Lecture Notes in Computer Science 521 (2006). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ag\nevaluation", "parents_detail": "\nAny residue AG code of differential forms can be equivalently stated as an evaluation AG code of functions ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Lemma 15.3.10; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.72). In addition, evaluation and residue AG codes are dual to each other ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 313; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).", "parent_of_code_id": "cartier\nshimura", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_residue", "_href": "c/residue"}, "c_goppa": {"notes": "GAP function GoppaCode(G,L) takes in a polynomial \\(G\\) that satisfies the necessary conditions for a Goppa code and a list \\(L\\) that contains elements in \\(GF(q)\\) that are not roots of \\(G\\). It returns a Goppa code.", "logical": "q-ary_digits", "code_id": "goppa", "physical": "q-ary_digits", "protection": "The length \\( n = |L| \\) , dimension \\( k \\geq n-mr \\) where \\( r = \\text{deg} G(x) \\), and the minimum distance \\( d \\geq r +1 \\).", "introduced": "[V. D. Goppa, \"A new class of linear error-correcting codes\", Probl. Peredach. Inform., vol. 6, no. 3, pp. 24-30, Sept. 1970.][V. D. Goppa, \"Rational representation of codes and (Lg) codes\", Probl. Peredach. Inform., vol. 7, no. 3, pp. 41-49, Sept. 1971.][E. Berlekamp, \u201cGoppa codes\u201d, IEEE Transactions on Information Theory 19, 590 (1973). DOI]", "description": "Let \\( G(x) \\) be a polynomial describing a projective-plane curve with coefficients from \\( GF(q^m) \\) for some fixed integer \\(m\\). Let \\( L \\) be a finite subset of the extension field \\( GF(q^m) \\) where \\(q\\) is prime, meaning \\( L  = \\{\\alpha_1, \\cdots, \\alpha_n\\} \\) is a subset of nonzero elements of \\( GF(q^m) \\). A Goppa code \\( \\Gamma(L,G) \\) is an \\([n,k,d]_q\\) linear code consisting of all vectors \\(a = a_1, \\cdots, a_n\\) such that \\( R_a(x) =0 \\) modulo \\(G(x)\\), where \\( R_a(x) = \\sum_{i=1}^n \\frac{a_i}{z - \\alpha_i} \\).\n\nGoppa codes are residue AG codes ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.28). Their duals are evaluation codes that are sometimes called geometric Reed Solomon codes ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.71). ", "name": "Classical Goppa code", "realizations": "Initial version of the McEliece public-key cryptosystem [R. J. McEliece, A public-key cryptosystem based on algebraic coding theory, Technical report, Jet Propulsion Lab. DSN Progress Report (1978).][H. Janwa and O. Moreno, \u201cMcEliece public key cryptosystems using algebraic-geometric codes\u201d, Designs, Codes and Cryptography 8, (1996). DOI] and its variation by Niederreiter [H. Niederreiter (1986). Knapsack-type cryptosystems and algebraic coding theory. Problems of Control and Information Theory. Problemy Upravlenija I Teorii Informacii. 15: 159\u2013166.] where the generator matrix is replaced by the parity check matrix. Some of these were proven to be insecure since the public key exposes algebraic structure of code [V. M. SIDELNIKOV and S. O. SHESTAKOV, \u201cOn insecurity of cryptosystems based on generalized Reed-Solomon codes\u201d, Discrete Mathematics and Applications 2, (1992). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Algebraic decoding algorithms [N. Patterson, \u201cThe algebraic decoding of Goppa codes\u201d, IEEE Transactions on Information Theory 21, 203 (1975). DOI]. If \\( \\text{deg} G(x) = 2t \\) , then there exists a \\(t\\)-correcting algebraic decoding algorithm for \\( \\Gamma(L,G) \\).\nSugiyama et al. modification of the extended Euclidean algorithm [Y. Sugiyama et al., \u201cA method for solving key equation for decoding goppa codes\u201d, Information and Control 27, 87 (1975). DOI][R. McEliece, The Theory of Information and Coding (Cambridge University Press, 2002). DOI].\nGuruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_reed_solomon\ncartier", "parents_detail": "Goppa codes are \\(GF(q)\\)-subfield subcode of the dual of the GRS code over \\(GF(q^m)\\) with evaluation points \\(\\alpha_i\\) and factors \\(v_i=G(\\alpha_i)^{-1}\\) ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], pg. 523; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nGoppa codes are Cartier codes from a curve of genus zero [Alain Couvreur, \u201cCodes and the Cartier Operator\u201d. 1206.4728].", "cousin_of_code_id": "binary_quantum_goppa\nq-ary_bch", "cousin_of_detail": "Classical Goppa codes are used to construct their quantum versions.\nNarrow-sense BCH codes are Goppa codes with \\(L=\\{1,\\alpha^{-1},\\cdots,\\alpha^{1-n}\\}\\) and \\(G(x)=x^{\\delta-1}\\) ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], pg. 522).", "_type": "ecc", "_page_id": "c_goppa", "_href": "c/goppa"}, "c_cartier": {"notes": "", "logical": "q-ary_digits", "code_id": "cartier", "physical": "q-ary_digits", "protection": "", "introduced": "[Alain Couvreur, \u201cCodes and the Cartier Operator\u201d. 1206.4728]", "description": "Subcode of a certain residue AG code that is constructed using the Cartier operator.", "name": "Cartier code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Cartier codes share similar asymptotic properties as subfield subcodes of residue AG codes, with both families admitting sequences of codes that achieve the Gilbert-Varshamov bound.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "residue", "parents_detail": "", "parent_of_code_id": "goppa", "parent_of_detail": "Goppa codes are Cartier codes from a curve of genus zero [Alain Couvreur, \u201cCodes and the Cartier Operator\u201d. 1206.4728].", "_type": "ecc", "_page_id": "c_cartier", "_href": "c/cartier"}, "c_shimura": {"notes": "", "logical": "q-ary_digits", "code_id": "shimura", "physical": "q-ary_digits", "protection": "", "introduced": "[M. A. Tsfasman, S. G. Vl\u0103dutx, and T. Zink, \u201cModular curves, Shimura curves, and Goppa codes, better than Varshamov-Gilbert bound\u201d, Mathematische Nachrichten 109, 21 (1982). DOI]", "description": "Member of a family of residue AG codes where \\(\\cal X\\) is either a reduction of a Shimura curve or an elliptic curve of varying genus.", "name": "Tsfasman-Vladut-Zink (TVZ) code", "realizations": "", "short_name": "TVZ", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "TVZ codes exceed the asymptotic Gilbert-Varshamov (GV) bound [M. A. Tsfasman, S. G. Vl\u0103dutx, and T. Zink, \u201cModular curves, Shimura curves, and Goppa codes, better than Varshamov-Gilbert bound\u201d, Mathematische Nachrichten 109, 21 (1982). DOI] (see also Ref. [Y. Ihara. \"Some remarks on the number of rational points of algebraic curves over finite fields.\" J. Fac. Sci. Univ. Tokyo Sect. IA Math., 28:721-724 (1982),1981.]). Roughly speaking, this breakthrough result implies that AG codes can outperform random codes. Such families of codes are optimal.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "residue", "parents_detail": "", "_type": "ecc", "_page_id": "c_shimura", "_href": "c/shimura"}, "c_plane_curve": {"notes": "", "logical": "q-ary_digits", "code_id": "plane_curve", "physical": "q-ary_digits", "protection": "Bezout's theorem yields parameters \\([n,k,d]\\), which depend on the polynomial used to define the plane curve as well as the maximum degree of the polynomials used for evaluation ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], pg. 883). Distance bounds can be derived from how the plane curve is embedded in the ambient projective space ([A. Couvreur, \u201cThe dual minimum distance of arbitrary-dimensional algebraic\u2013geometric codes\u201d, Journal of Algebra 350, 84 (2012). DOI; 0905.2345], Thm. 4.1).", "introduced": "[J. Justesen et al., \u201cConstruction and decoding of a class of algebraic geometry codes\u201d, IEEE Transactions on Information Theory 35, 811 (1989). DOI]", "description": "Evaluation AG code of bivariate polynomials of some finite maximum degree, evaluated at points lying on an affine plane curve. ", "name": "Plane-curve code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Generalization of the Peterson algorithm for BCH codes [J. Justesen et al., \u201cConstruction and decoding of a class of algebraic geometry codes\u201d, IEEE Transactions on Information Theory 35, 811 (1989). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation", "parents_detail": "Plane-curve codes are evaluation AG codes of bivariate polynomials with \\(\\cal X\\) being an affine plane curve ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.27).", "_type": "ecc", "_page_id": "c_plane_curve", "_href": "c/plane_curve"}, "c_elliptic": {"notes": "", "logical": "q-ary_digits", "code_id": "elliptic", "physical": "q-ary_digits", "protection": "", "introduced": "", "description": "Evaluation AG code of rational functions evaluated on points lying on an elliptic curve, i.e., a curve of genus one. ", "name": "Elliptic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation", "parents_detail": "Elliptic codes are evaluation AG codes with \\(\\cal X\\) being an elliptic curve, i.e., curve of genus one ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).", "cousins_code_id": "mds", "cousins_detail": "Elliptic codes can be MDS ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Ex. 15.5.3; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 310; [M. Tsfasman, S. Vl\u01cedu\u0163, and D. Nogin. Algebraic geometric codes: basic notions. Vol. 139. American Mathematical Society, 2022.], Sec. 4.4.2).", "_type": "ecc", "_page_id": "c_elliptic", "_href": "c/elliptic"}, "c_hermitian": {"notes": "", "logical": "q-ary_digits", "code_id": "hermitian", "physical": "q-ary_digits", "protection": "Distance determined by properties of the Hermitian curve, the underlying field, and the functions used [K. Yang and P. V. Kumar, \u201cOn the true minimum distance of Hermitian codes\u201d, Lecture Notes in Mathematics 99 (1992). DOI]; see Ref. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Sec. 5.3, for an example. For evaluations of polynomials up to degree \\(D\\), the Hermitian code protects against at least \\(n - (q+1)D\\) errors whenever \\(D < q + 1 \\). If \\(D \\geq q+1 \\), the Hermitian code protects against at least \\(n-k - \\frac{q(q-1)}{2} + 1\\) errors.", "introduced": "[H. Stichtenoth, \u201c\ufffdber die Automorphismengruppe eines algebraischen Funktionenk\ufffdrpers von Primzahlcharakteristik\u201d, Archiv der Mathematik 24, 527 (1973). DOI][H. Tiersma, \u201cRemarks on codes from Hermitian curves (Corresp.)\u201d, IEEE Transactions on Information Theory 33, 605 (1987). DOI]", "description": "Evaluation AG code of rational functions evaluated on points lying on a Hermitian curve \\(H(x,y) = x^{q+1}  + y^{q+1} - 1\\) over \\(\\mathbb{F}_q = GF(q)\\) in either affine or projective space. Hermitian codes directly improve over RS codes in the sense that RS codes have length at most \\(q\\) while Hermitian codes have length \\(q^3 + 1\\).\n\nHermitian codes of polynomials of total degree at most \\(D\\) can come in affine and epicyclic flavours, depending on whether the evaluations are over the affine plane or the bicyclic plane. The affine codes have length \\(q^3 - q\\) while epicyclic codes have length \\((q-2)(q+1)^2\\). More precisely, fix \\(r, D\\) and let \\begin{align}\n  M_D = \\left{f(x,y,z) = \\sum_{i+j \\leq D = D}a_{i,j}x^{i}y^{j}z^{D - (i+j)}\\right}\n\\end{align} be the message space of degree-\\(D\\) polynomials and \\begin{align}\n  \\(S = \\{(x:y:z) \\in PG(2,q) \\mid H(x:y:z) = 0 \\}\\)~,\n\\end{align} where \\(H(x:y:z) = x^{q+1} + y^{q+1} - z^{q+1}\\) is the homogenized Hermitian curve over the projective plane. The Hermitian code \\( C \\) over is \\begin{align}\nC = \\{(f(\\alpha_i))_{\\alpha_i \\in S}, \\: f \\in M_D \\}~.\n\\end{align}\n\nThe form \\(H(u,v,w) = u^{q+1} + v^{q+1} - w^{q+1}\\) is the Fermat version of the Hermitian curve. Substituting \\(u = x+z\\), \\(v = x+y\\), and \\(w = x+y+z \\) yields \\(H(x,y,z) = x^{q+1} - y^{q}z - yz^{q} \\), the Stichtenoth version of the curve. In affine coordinates, the Stichtenoth form of the curve is \\begin{align}\n  f(x,y) = x^{q+1} - y^{q} - y = N(x) - \\text{tr}(y)~,\n\\end{align} where \\(N(x) := x^{(q^{n}-1)/(q-1)}\\) and \\(\\text{tr} := 1 + x^{q} + \\ldots + x^{q^n}\\) are the field norm and trace of \\(GF(F_{q^n}\\), respectively. The Fermat version can be written as \\(H(u,v,w) = u\\overline{u} + v\\overline{v} - w\\overline{w}\\), where the conjugation map \\(\\overline{u} = u^{q}\\) is an isomorphism of \\(\\mathbb{F}_q \\). In fact, when the field of evaluations \\(\\mathbb{F}_{q^2}\\) is viewed as a quadratic extension of \\(\\mathbb{F}_q\\) then the conjugation map is an \\(\\mathbb{F}_q\\)-isomorphism that permutes the roots of the quadratic irreducible polynomial used to generate \\(\\mathbb{F}_{q^2}\\) from \\( \\mathbb{F}_q[x]\\).", "name": "Hermitian code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Unique decoding using syndromes and error locator ideals for polynomial evaluations. Note that Hermitian codes are linear codes so we can compute the syndrome of a received vector. Moreover, akin to the error-locator ideals found in decoding Reed-Solomon codes, for the multivariate case we must define an error locator ideal \\(\\Lambda \\) such that the variety of this ideal over \\(\\mathbb{F}^{2}_{q}\\) is exactly the set of errors. The Sakata algorithm uses these two ingredients to get a unique decoding procedure [S. Sakata, \u201cFinding a minimal set of linear recurring relations capable of generating a given finite two-dimensional array\u201d, Journal of Symbolic Computation 5, 321 (1988). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "For polynomial evaluations up to degree \\(D\\): if \\(D < q + 1 \\), \\(k = \\frac{(D+1)(D+2)}{2}\\), and if \\(D \\geq q + 1 \\), \\(k = (q+1)D - \\frac{q(q-1)}{2} + 1 \\). ", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_reed_solomon\nevaluation", "parents_detail": "Hermitian codes are concatenated GRS codes [T. Yaghoobian and I. F. Blake, \u201cHermitian codes as generalized Reed-Solomon codes\u201d, Designs, Codes and Cryptography 2, 5 (1992). DOI].\nHermitian codes are evaluation AG codes with \\(\\cal X\\) being a Hermitian curve ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.74). This curve is maximal, meaning that Hermitian codes are evaluation AG codes with maximum possible length given a fixed genus.", "cousin_of_code_id": "hermitian_hypersurface", "cousin_of_detail": "Hermitian-hypersurface codes reduce to Hermitian codes of polynomials when the hypersurface is a curve.", "_type": "ecc", "_page_id": "c_hermitian", "_href": "c/hermitian"}, "c_evaluation": {"notes": "See Refs. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.][T. Hoholdt and R. Pellikaan, \u201cOn the decoding of algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 41, 1589 (1995). DOI][P. Beelen and T. H\u00f8holdt, \u201cThe Decoding of Algebraic Geometry Codes\u201d, Series on Coding Theory and Cryptology 49 (2008). DOI][W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI][R. E. Blahut, Algebraic Codes on Lines, Planes, and Curves (Cambridge University Press, 2001). DOI] for surveys and overviews of decoders.", "logical": "q-ary_digits", "code_id": "evaluation", "physical": "q-ary_digits", "protection": "Riemann-Roch theorem yields code length \\(n\\), dimension \\(k\\), and a lower bound on distance in terms of features of \\(L\\) and genus of the curve \\(\\cal X\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.12). The order or Feng-Rao bound, a generalization of the shift bound for cyclic codes, gives a lower bound on the distance of evaluation AG codes [G.-L. Feng and T. R. N. Rao, \u201cDecoding algebraic-geometric codes up to the designed minimum distance\u201d, IEEE Transactions on Information Theory 39, 37 (1993). DOI][R. Pellikaan, \u201cThe shift bound for cyclic, Reed-Muller and geometric Goppa codes\u201d, Arithmetic, Geometry, and Coding Theory. DOI][P. Beelen, \u201cThe order bound for general algebraic geometric codes\u201d, Finite Fields and Their Applications 13, 665 (2007). DOI]. Connection to semigroups yields another bound [T. Johnsen, S. Manshadi, and N. Monzavi, \u201cA determination of the parameters of a large class of Goppa codes\u201d, IEEE Transactions on Information Theory 40, 1678 (1994). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.].", "introduced": "", "description": "Also called a function code. Evaluation code over \\(GF(q)\\) on a set of points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) in \\(GF(q)\\) lying on an algebraic curve \\(\\cal X\\) whose corresponding vector space \\(L\\) of functions \\(f\\) consists of certain polynomials or rational functions. Codewords are evaluations of all functions at the specified points, \\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right) \\quad\\quad\\forall f\\in L~.\n\\end{align} The code is denoted as \\(C_L({\\cal X},{\\cal P},D)\\), where the divisor \\(D\\) (of degree less than \\(n\\)) determines which rational functions to use by prescribing features associated with their zeroes and poles. The original motivation for evaluation codes, which are generalizations of RS codes that expand both the types of functions used as well as the available evaluation points, was to increase code length while maintaining good distance and size.\n\nThe algebraic curve \\(\\cal X\\) used for this construction is the set of zeroes of a nontrivial polynomial that is both smooth and irreducible over any field extension of \\(GF(q)\\). The curve can be defined over affine space or projective space, which contains the affine coordinates as a subset and which can yield an increase in length. If evaluations are made over projective coordinates, then the codewords are evaluations of homogeneous polynomials, and there are relations between such polynomials with polynomials over affine space. See Refs. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.][M. Tomlinson et al., Error-correction Coding and Decoding (Springer International Publishing, 2017). DOI] for more details.\n\nIn the case of polynomial functions \\(f\\), evaluation AG codes reduce to polynomial evaluation codes on algebraic curves. In the general case of rational functions, which are ratios of two polynomials, one can select such features for both the numerator and denominator polynomials. Zeroes of the denominator polynomial are called poles of the rational function, and their multiplicities correspond to orders of the poles. A bookkeeping device for this data is the divisor \\(D\\), and the corresponding vector space of functions defined using the curve \\(\\cal X\\) and the divisor is the Riemann-Roch space \\(L=L(D)\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 313).", "name": "Evaluation AG code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Generalization of plane-curve decoder [A. N. Skorobogatov and S. G. Vladut, \u201cOn the decoding of algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 36, 1051 (1990). DOI][V. Yu. Krachkovskii, \"Decoding of codes on algebraic curves,\" (in Russian), Conference Odessa, 1988.]. Another decoder [S. C. Porter, B.-Z. Shen, and R. Pellikaan, \u201cDecoding geometric Goppa codes using an extra place\u201d, IEEE Transactions on Information Theory 38, 1663 (1992). DOI] was later showed to be equivalent in Ref. [D. Ehrhard, \u201cDecoding Algebraic-Geometric Codes by solving a key equation\u201d, Lecture Notes in Mathematics 18 (1992). DOI]. Application of several algorthims in parallel can be used to decode up to half the minimum distance [R. Pellikaan, \u201cOn a decoding algorithm for codes on maximal curves\u201d, IEEE Transactions on Information Theory 35, 1228 (1989). DOI][S. Vladut, \u201cOn the decoding of algebraic-geometric codes over F/sub q/ for q&amp;lt;or=16\u201d, IEEE Transactions on Information Theory 36, 1461 (1990). DOI]. Computational procedure implementing these decoders is based on an extension of the Berlekamp-Massey algorithm by Sakata [S. Sakata, \u201cFinding a minimal set of linear recurring relations capable of generating a given finite two-dimensional array\u201d, Journal of Symbolic Computation 5, 321 (1988). DOI][S. Sakata, \u201cExtension of the Berlekamp-Massey algorithm to N dimensions\u201d, Information and Computation 84, 207 (1990). DOI][S. Sakata, \u201cDecoding binary 2-D cyclic codes by the 2-D Berlekamp-Massey algorithm\u201d, IEEE Transactions on Information Theory 37, 1200 (1991). DOI].\nDecoder based on majority voting of unknown syndromes [G.-L. Feng and T. R. N. Rao, \u201cDecoding algebraic-geometric codes up to the designed minimum distance\u201d, IEEE Transactions on Information Theory 39, 37 (1993). DOI] decodes up to half of the minimum distance [D. Ehrhard, \u201cAchieving the designed error capacity in decoding algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 39, 743 (1993). DOI].\nList decoders generalizing Sudan's RS decoder by Shokrollahi-Wasserman [M. A. Shokrollahi and H. Wasserman, \u201cList decoding of algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 45, 432 (1999). DOI] and Guruswami-Sudan [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_linear\nag\nevaluation_varieties", "parents_detail": "The degree of the divisor for evaluation AG codes is restricted to be less than \\(n\\). When there is no restriction, any \\(q\\)-ary linear code can be formulated as an evaluation AG code [R. Pellikan, B.-Z. Shen, and G. J. M. van Wee, \u201cWhich linear codes are algebraic-geometric?\u201d, IEEE Transactions on Information Theory 37, 583 (1991). DOI].\n\nEvaluation AG codes are evaluation codes of rational functions \\(f\\) for which \\(\\cal X\\) is an algebraic curve, i.e., an algebraic variety of dimension one [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.].", "parent_of_code_id": "elliptic\ngeneralized_reed_solomon\nhermitian\nhexacode\nklein_quartic\nplane_curve\nresidue", "parent_of_detail": "Elliptic codes are evaluation AG codes with \\(\\cal X\\) being an elliptic curve, i.e., curve of genus one ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nGRS (RS) codes are in one-to-one correspondence with evaluation AG codes of univariate polynomials \\(f\\) with \\(\\cal X\\) being the projective (affine) line ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.24; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nHermitian codes are evaluation AG codes with \\(\\cal X\\) being a Hermitian curve ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.74). This curve is maximal, meaning that Hermitian codes are evaluation AG codes with maximum possible length given a fixed genus.\nThe hexacode is an evaluation AG code over \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\) with \\(\\cal X\\) defined by \\(x^2 y + \\omega y^2 z + \\bar{\\omega} z^2 x = 0\\) ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.77).\nKlein-quartic codes are evaluation AG codes with \\(\\cal X\\) being the Klein quartic ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.75).\nPlane-curve codes are evaluation AG codes of bivariate polynomials with \\(\\cal X\\) being an affine plane curve ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.27).\nAny residue AG code of differential forms can be equivalently stated as an evaluation AG code of functions ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Lemma 15.3.10; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.72). In addition, evaluation and residue AG codes are dual to each other ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 313; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).", "cousin_of_code_id": "evaluation_polynomial", "cousin_of_detail": "Evaluation AG codes are evaluation codes on algebraic curves. Polynomial evaluation codes are evaluation codes of polynomials. Evaluation AG codes of polynomials are equivalent to polynomial evaluation codes on algebraic curves.", "_type": "ecc", "_page_id": "c_evaluation", "_href": "c/evaluation"}, "c_klein_quartic": {"notes": "", "logical": "q-ary_digits", "code_id": "klein_quartic", "physical": "q-ary_digits", "protection": "Dimension \\(k=8\\) and distance \\(d \\geq 13\\). Concatenation with the \\([4,3,2]\\) single parity check code, conversion to a binary code by expressing \\(GF(8)\\) elements as vectors over \\(GF(2)\\), and puncturing yields a \\([91,24,25]\\) binary code that held the world record for codes of length 91 [A. M. Barg, G. L. Katsman, M. A. Tsfasman, \u201cAlgebraic-Geometric Codes from Curves of Small Genus\u201d, Probl. Peredachi Inf., 23:1 (1987), 42\u201346; Problems Inform. Transmission, 23:1 (1987), 34\u201338].", "introduced": "[J. Hansen, \u201cCodes on the Klein quartic, ideals, and decoding (Corresp.)\u201d, IEEE Transactions on Information Theory 33, 923 (1987). DOI]", "description": "Evaluation AG code over \\(GF(8)\\) of rational functions evaluated on points lying in the Klein quartic, which is defined by the equation \\(x^3 y + y^3 z + z^3 x = 0\\) ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.75). ", "name": "Klein-quartic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation", "parents_detail": "Klein-quartic codes are evaluation AG codes with \\(\\cal X\\) being the Klein quartic ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.75).", "_type": "ecc", "_page_id": "c_klein_quartic", "_href": "c/klein_quartic"}, "c_q-ary_quad_residue": {"notes": "Introduction of quadratic-residue codes in Refs. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI].", "logical": "q-ary_digits", "code_id": "q-ary_quad_residue", "physical": "q-ary_digits", "protection": "", "introduced": "", "description": "Member of a quadruple of cyclic \\(q\\)-ary codes of prime length \\(n\\) where \\(q\\) is prime and a quadratic residue modulo \\(n\\). The codes are constructed using quadratic residues and nonresidues of \\(n\\).\n\nThe roots of the generator polynomial \\(r(x)\\) of the first code (see Cyclic-to-polynomial correspondence) are all of the inequivalent quadratic residues of \\(n\\), and the second code's generator polynomial is \\((x-1)r(x)\\). The roots of the generator polynomial \\(a(x)\\) of the third code are all inequivalent nonresidues of \\(n\\), and the fourth code's generator polynomial is \\((x-1)a(x)\\). The codes corresponding to polynomials \\(r,a\\) are often called augmented quadratic-residue codes, while the remaining codes are called expurgated. ", "name": "\\(q\\)-ary quadratic-residue (QR) code", "realizations": "", "short_name": "\\(q\\)-ary QR", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_duadic", "parents_detail": "QR codes are duadic codes of prime length satisfying certain relations [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].", "parent_of_code_id": "hexacode\nternary_golay", "parent_of_detail": "The hexacode is the smallest example of an extended quadratic residue code of Type \\(4^H\\) ([Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI], Sec. 2.4.6).\nThe ternary Golay code is a quadratic residue code over \\(GF(3)\\) with residue set \\(Q = \\{1, 3, 4, 5, 9\\} \\) and generator polynomial \\(x^5 + x^4 - x^3 + x^2 - 1\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 16).", "cousin_of_code_id": "binary_quad_residue", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_q-ary_quad_residue", "_href": "c/q-ary_quad_residue"}, "c_q-ary_duadic": {"notes": "Reviews of duadic codes [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI].", "logical": "q-ary_digits", "code_id": "q-ary_duadic", "physical": "q-ary_digits", "protection": "", "introduced": "[V. Pless, \u201cQ-codes\u201d, Journal of Combinatorial Theory, Series A 43, 258 (1986). DOI][V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI][J. J. Rushanan, Topics in Integral Matrices and Abelian Group Codes, California Institute of Technology, 1986. DOI][M. Smid, \u201cDuadic codes (Corresp.)\u201d, IEEE Transactions on Information Theory 33, 432 (1987). DOI]", "description": "Member of a pair of cyclic linear binary codes that satisfy certain relations, depending on whether the pair is even-like or odd-like duadic. Duadic codes exist only when \\(q\\) is a square modulo \\(n\\) [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].\n\nDuadic codes come in two pairs, an even-like duadic pair and an odd-like duadic pair. All codewords in the respective pairs are even-like, i.e., \\(\\sum_i c_i = 0\\), or odd-like, i.e., \\(\\sum_i c_i \\neq 0\\). A code with all even-like (odd-like) codewords is called even-like (odd-like).\n\nDuadic code pairs can be defined in terms of their idempotent generators (see Cyclic-to-polynomial correspondence). A pair of even-like codes \\(C_1\\) and \\(C_2\\) with respective idempotents \\(e_1\\) and \\(e_2\\) is an even-like duadic pair if (1) \\(e_1(x)+e_2(x)=1-\\frac{1}{n}(1+x+x^2+\\cdots+x^{n-1})\\) and (2) there exists a multiplier \\(\\mu\\) such that \\(C_1 \\mu=C_2\\) and \\(C_2 \\mu=C_1\\).\n\nThere is an odd-like duadic pair \\(\\{D_1,D_2\\}\\) associated with the even-like pair \\(\\{C_1, C_2\\}\\), where \\(1-e_2(x)\\) generates \\(D_1\\) and \\(1-e_1(x)\\) generates \\(D_2\\). The even-pair codes are \\([n,\\frac{n-1}{2}]_q\\) codes while the odd-pair codes are \\([n,\\frac{n+1}{2}]_q\\) codes.", "name": "\\(q\\)-ary duadic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_cyclic", "parents_detail": "", "parent_of_code_id": "q-ary_quad_residue", "parent_of_detail": "QR codes are duadic codes of prime length satisfying certain relations [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].", "cousin_of_code_id": "binary_duadic", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_q-ary_duadic", "_href": "c/q-ary_duadic"}, "c_q-ary_bch": {"notes": "See books [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.][S. Lin and D. J. Costello, Error Control Coding, 2nd ed. Englewood Cliffs, NJ: Prentice-Hall, 2004.][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI] for expositions on BCH codes and code tables.\nSee database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.\nSee corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cCyclic Codes (BCH-Bound).\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CCyclic-BCHBound.html].", "logical": "q-ary_digits", "code_id": "q-ary_bch", "physical": "q-ary_digits", "protection": "By the BCH bound, BCH code with designed distance \\(\\delta\\) has true minimum distance \\(d\\geq\\delta\\). BCH codes with different designed distances may coincide, and the largest possible designed distance for a given code is the Bose distance; the true distance may still be larger than that. ", "introduced": "[D. Gorenstein and N. Zierler, \u201cA Class of Error-Correcting Codes in $p^m $ Symbols\u201d, Journal of the Society for Industrial and Applied Mathematics 9, 207 (1961). DOI]", "description": "Cyclic \\(q\\)-ary code, with \\(n\\) and \\(q\\) relatively coprime, whose zeroes are consecutive powers of a primitive \\(n\\)th root of unity \\(\\alpha\\). More precisely, the generator polynomial of a BCH code of designed distance \\(\\delta\\geq 1\\) is the lowest-degree monic polynomial with zeroes \\(\\{\\alpha^b,\\alpha^{b+1},\\cdots,\\alpha^{b+\\delta-2}\\}\\) for some \\(b\\geq 0\\). BCH codes are called narrow-sense when \\(b=1\\), and are called primitive when \\(n=q^r-1\\) for some \\(r\\geq 2\\).\n\nThe code dimension is related to the multiplicative order of \\(q\\) modulo \\(n\\), i.e., the smallest integer \\(m\\) such that \\(n\\) divides \\(q^m-1\\). The dimension of a BCH code is at least \\(n-m(\\delta-1)\\). The field \\(GF(q^m)\\) is the smallest field containing the above root of unity \\(\\alpha\\), and is the splitting field of the polynomial \\(x^n-1\\) (see Cyclic-to-polynomial correspondence). ", "name": "Bose\u2013Chaudhuri\u2013Hocquenghem (BCH) code", "realizations": "DVDs, disk drives, and two-dimensional bar codes [S. Zhu, Z. Sun, and X. Kai, \u201cA Class of Narrow-Sense BCH Codes\u201d, IEEE Transactions on Information Theory 65, 4699 (2019). DOI].", "short_name": "BCH", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) [E. Berlekamp, \u201cNonbinary BCH decoding (Abstr.)\u201d, IEEE Transactions on Information Theory 14, 242 (1968). DOI][J. Massey, \u201cShift-register synthesis and BCH decoding\u201d, IEEE Transactions on Information Theory 15, 122 (1969). DOI][E. R. Berlekamp, Algebraic Coding Theory, McGraw-Hill, 1968] and modification by Burton [H. Burton, \u201cInversionless decoding of binary BCH codes\u201d, IEEE Transactions on Information Theory 17, 464 (1971). DOI]; see also [W. W. Peterson and E. J. Weldon, Error-correcting codes. MIT press 1972.][R. Gallager, Information Theory and Reliable Communication (Springer Vienna, 1972). DOI].\nGorenstein-Peterson-Zierler decoder with runtime of order \\(O(n^3)\\) [W. Peterson, \u201cEncoding and error-correction procedures for the Bose-Chaudhuri codes\u201d, IEEE Transactions on Information Theory 6, 459 (1960). DOI][D. Gorenstein and N. Zierler, \u201cA Class of Error-Correcting Codes in $p^m $ Symbols\u201d, Journal of the Society for Industrial and Applied Mathematics 9, 207 (1961). DOI] (see exposition in Ref. [R.E. Blahut, Theory and practice of error-control codes, Addison-Wesley 1983.]).\nSugiyama et al. modification of the extended Euclidean algorithm [Y. Sugiyama et al., \u201cA method for solving key equation for decoding goppa codes\u201d, Information and Control 27, 87 (1975). DOI][R. McEliece, The Theory of Information and Coding (Cambridge University Press, 2002). DOI].\nGuruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI] and modification by Koetter-Vardy for soft-decision decoding [R. Koetter and A. Vardy, \u201cAlgebraic soft-decision decoding of reed-solomon codes\u201d, IEEE Transactions on Information Theory 49, 2809 (2003). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Primitive BCH codes are asymptotically bad ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 269).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_reed_solomon\nq-ary_cyclic", "parents_detail": "BCH codes are subfield subcodes of GRS codes.\n", "cousins_code_id": "goppa", "cousins_detail": "Narrow-sense BCH codes are Goppa codes with \\(L=\\{1,\\alpha^{-1},\\cdots,\\alpha^{1-n}\\}\\) and \\(G(x)=x^{\\delta-1}\\) ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], pg. 522).", "cousin_of_code_id": "bch\ngalois_bch\nquantum_bch\nreed_solomon", "cousin_of_detail": "\n\nBCH codes are used to construct qubit BCH codes via the CSS and stabilizer-over-\\(GF(4)\\) constructions.\nNarrow-sense RS codes are BCH codes ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Remark 15.3.21; [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thms. 5.2.1 and 5.2.3). Moreover, an RS code can be represented as a union of cosets, with each coset being an interleaver of several binary BCH codes [A. Vardy and Y. Be'ery, \u201cBit-level soft-decision decoding of Reed-Solomon codes\u201d, IEEE Transactions on Communications 39, 440 (1991). DOI].", "_type": "ecc", "_page_id": "c_q-ary_bch", "_href": "c/q-ary_bch"}, "c_q-ary_cyclic": {"notes": "See Ch. 7 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for an exposition on cyclic codes.", "logical": "q-ary_digits", "code_id": "q-ary_cyclic", "physical": "q-ary_digits", "protection": "Shift bound [J. van Lint and R. Wilson, \u201cOn the minimum distance of cyclic codes\u201d, IEEE Transactions on Information Theory 32, 23 (1986). DOI] gives a lower bound on the distance of cyclic \\(q\\)-ary codes.", "introduced": "", "description": "A \\(q\\)-ary code of length \\(n\\) is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword. A cyclic code is called primitive when \\(n=q^r-1\\) for some \\(r\\geq 2\\). A shortened cyclic code is obtained from a cyclic code by taking only codewords with the first \\(j\\) zero entries, and deleting those zeroes. ", "name": "Cyclic linear \\(q\\)-ary code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Meggitt decoder [J. Meggitt, \u201cError correcting codes and their implementation for data transmission systems\u201d, IEEE Transactions on Information Theory 7, 234 (1961). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "cyclic\nq-ary_linear\ngroup", "parents_detail": "\n\nA length-\\(n\\) cyclic \\(q\\)-ary linear code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).", "parent_of_code_id": "q-ary_bch\ndodecacode\nq-ary_duadic\nq-ary_parity_check", "parent_of_detail": "\n\n\nSince permutations preserve coordinate sums, the cyclic permutation of a parity-check codeword is another codeword.", "cousin_of_code_id": "galois_css\ngeneralized_reed_muller\nquantum_mds\nreed_solomon\nq-ary_hamming", "cousin_of_detail": "Galois CSS codes can be constructed using self-orthogonal \\(q\\)-ary cyclic codes [Yongsheng Tang et al., \u201cNew quantum codes from dual-containing cyclic codes over finite rings\u201d. 1608.06674].\nGRM codes with nonzero evaluation points are cyclic ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 52).\nQuantum MDS codes can be constructed from \\(q\\)-ary cyclic codes using the Hermitian construction [G. G. La Guardia, \u201cNew Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 57, 5551 (2011). DOI].\nIf the length divides \\(q-1\\), then it is possible to construct a cyclic RS code.\nHamming codes are equivalent to cyclic codes when \\(q\\) and \\(r\\) are relatively prime ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 194).", "_type": "ecc", "_page_id": "c_q-ary_cyclic", "_href": "c/q-ary_cyclic"}, "c_interleaved_reed_solomon": {"notes": "", "logical": "q-ary_digits", "code_id": "interleaved_reed_solomon", "physical": "q-ary_digits", "protection": "", "introduced": "", "description": "A modification of RS codes where multiple polynomials are used to define each codeword. Each codeword \\(\\mu\\) of a \\(t\\)-interleaved RS code is a string of values of the corresponding set \\(\\{f_\\mu^{(1)},f_\\mu^{(2)},\\cdots,f_\\mu^{(t)}\\}\\) of \\(t\\) polynomials at the points \\(\\alpha_i\\). The vector codewords can be arranged in an array whose rows are ordinary RS codes for each polynomial \\(f^{j}\\), yielding the encoding \\begin{align}\n\\mu\\to\\left(\n\\begin{split}\n  f_{\\mu}^{(1)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(1)}\\left(\\alpha_{2}\\right) & \\cdots & f_{\\mu}^{(1)}\\left(\\alpha_{n}\\right)\\\\\n  f_{\\mu}^{(2)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(2)}\\left(\\alpha_{2}\\right) &  & f_{\\mu}^{(2)}\\left(\\alpha_{n}\\right)\\\\\n  \\vdots &  & \\ddots & \\vdots\\\\\n  f_{\\mu}^{(t)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(t)}\\left(\\alpha_{2}\\right) & \\cdots & f_{\\mu}^{(t)}\\left(\\alpha_{n}\\right)\n\\end{split}\\right)~.\n\\end{align} ", "name": "Interleaved RS (IRS) code", "realizations": "The cross-interleaved RS (CIRC), an IRS code using two shortened RS codes and two forms of interleaving, was used for compact discs (CDs) [Odaka K., Sako Y., Iwamoto I., Doi T.; Vries L.B.; SONY: Error correctable data transmission method (Patent US4413340) filing date May 21, 1980.] (see Ref. [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Sec. 5.6 and Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 4).", "short_name": "IRS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoder that corrects up to \\(1-\\frac{2k+n}{3n}\\) fraction of random errors [D. Bleichenbacher, A. Kiayias, and M. Yung, \u201cDecoding interleaved Reed\u2013Solomon codes over noisy channels\u201d, Theoretical Computer Science 379, 348 (2007). DOI].\nDecoder that corrects up to \\(1-(\\frac{k}{n})^{2/3}\\) fraction of random errors [D. Coppersmith and M. Sudan, \u201cReconstructing curves in three (and higher) dimensional space from noisy data\u201d, Proceedings of the thirty-fifth ACM symposium on Theory of computing - STOC '03 (2003). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_linear", "parents_detail": "IRS codes are linear over \\(GF(q)\\) but not necessarily over \\(GF(q^t)\\).", "parent_of_code_id": "parvaresh_vardy\nreed_solomon", "parent_of_detail": "PV codes are IRS codes with specific algebraic relations between the codeword polynomials that allow for efficient list decoding.\nAn IRS code utilizing one polynomial \\(f\\) reduces to an RS code.", "_type": "ecc", "_page_id": "c_interleaved_reed_solomon", "_href": "c/interleaved_reed_solomon"}, "c_extended_reed_solomon": {"notes": "See corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cExtended Reed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html].", "logical": "q-ary_digits", "code_id": "extended_reed_solomon", "physical": "q-ary_digits", "protection": "", "introduced": "", "description": "A GRS code with an additional parity-check coordinate with corresponding evaluation point of zero. In other words, an \\([n+1,k,n-k+2]_q\\) GRS code whose polynomials are evaluated at the points \\((\\alpha_1,\\cdots,\\alpha_n,0)\\). The case when \\(n=q-1\\), multipliers \\(v_i=1\\), and \\(\\alpha_i\\) are \\(i-1\\)st powers of a primitive \\(n\\)th root of unity is an extended narrow-sense RS code.\n\nAn \\([q-1,k,q-k]_q\\) narrow-sense RS code can be extended twice by adding two evaluation points (of which one can be zero) to yield a \\([q+1,k,q-k+2]_q\\) doubly extended narrow-sense RS code. ", "name": "Extended GRS code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_reed_solomon", "parents_detail": "Extended GRS codes can be thought of as GRS codes that include an evaluation point of zero.", "cousins_code_id": "mds", "cousins_detail": "An MDS GRS code can be extended to an MDS code ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thm. 5.3.4). Extended and doubly extended narrow-sense RS codes are MDS ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thms. 5.3.2 and 5.3.4), and there is an equivalence between the two for odd prime \\(q\\) [S. Ball, \u201cOn sets of vectors of a finite vector space in which every subset of basis size is a basis\u201d, Journal of the European Mathematical Society 733 (2012). DOI].", "cousin_of_code_id": "generalized_reed_muller\nprojective\nsimplex", "cousin_of_detail": "GRM codes for univariate polynomials (\\(m=1\\)) reduce to extended RS codes [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].\nColumns of parity-check matrices of doubly extended narrow-sense RS codes consist of points of a normal rational curve ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Def. 14.2.6).\n\\(S(2,k)\\) is an extended RS code [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cSimplex Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html].", "_type": "ecc", "_page_id": "c_extended_reed_solomon", "_href": "c/extended_reed_solomon"}, "c_folded_reed_solomon": {"notes": "See the book [V. Guruswami, A. Rudra, and M. Sudan. Essential coding theory. Draft available at this URL (2012).] for an introduction to FRS codes.", "logical": "q-ary_digits", "code_id": "folded_reed_solomon", "physical": "q-ary_digits", "protection": "", "introduced": "[V. Y. Krachkovsky, \u201cReed-solomon codes for correcting phased error bursts\u201d, IEEE Transactions on Information Theory 49, 2975 (2003). DOI]", "description": "A linear \\([n/m,k]_{q^m}\\) code that is a modification of an \\([n,k]_q\\) RS code such that evaluations are grouped to yield a code with smaller length. In this case, the evaluation points are all powers of a generating field element \\(\\gamma\\), \\(\\alpha_i=\\gamma^i\\). Each codeword \\(\\mu\\) of an \\(m\\)-folded RS code is a string of \\(n/m\\) symbols, with each symbol being a string of values of a polynomial \\(f_\\mu\\) at consecutive powers of \\(\\gamma\\), \\begin{align}\n\\begin{split}\n  \\mu\\to&\\Big(\\left(f_{\\mu}(\\alpha^{0}),\\cdots,f_{\\mu}(\\alpha^{m-1})\\right),\\left(f_{\\mu}(\\alpha^{m}),\\cdots,f_{\\mu}(\\alpha^{2m-1})\\right)\\cdots\\\\&\\cdots,\\left(f_{\\mu}(\\alpha^{n-m}),\\cdots,f_{\\mu}(\\alpha^{n-1})\\right)\\Big)~.\n\\end{split}\n\\end{align} ", "name": "Folded RS (FRS) code", "realizations": "", "short_name": "FRS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Guruswami and Rudra [Venkatesan Guruswami and Atri Rudra, \u201cExplicit Codes Achieving List Decoding Capacity: Error-correction with Optimal Redundancy\u201d. cs/0511072] achieved list-decoding up to \\(1-\\frac{k}{n}-\\epsilon\\) fraction of errors using the Parvaresh-Vardy algorithm [F. Parvaresh and A. Vardy, \u201cCorrecting Errors Beyond the Guruswami-Sudan Radius in Polynomial Time\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI]; see Ref. [V. Guruswami, \u201cLinear-Algebraic List Decoding of Folded Reed-Solomon Codes\u201d, 2011 IEEE 26th Annual Conference on Computational Complexity (2011). DOI; 1106.0436] for a randomized construction.\nFolded RS codes, concatenated with suitable inner codes, can be efficiently list-decoded up to the Blokh-Zyablov bound [Venkatesan Guruswami and Atri Rudra, \u201cExplicit Codes Achieving List Decoding Capacity: Error-correction with Optimal Redundancy\u201d. cs/0511072][V. Guruswami and A. Rudra, \u201cBetter Binary List Decodable Codes Via Multilevel Concatenation\u201d, IEEE Transactions on Information Theory 55, 19 (2009). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "q-ary_linear", "parents_detail": "", "parent_of_code_id": "reed_solomon", "parent_of_detail": "An FRS code with no extra grouping (\\(m=1\\)) reduces to an RS code.", "cousin_of_code_id": "parvaresh_vardy", "cousin_of_detail": "The specific relations imposed on the polynomials of PV codes allow for them to be expressed in a similar way as FRS codes, but with more redundancy. Folded RS codes can be list-decoded up to a higher fraction of errors.", "_type": "ecc", "_page_id": "c_folded_reed_solomon", "_href": "c/folded_reed_solomon"}, "c_parvaresh_vardy": {"notes": "", "logical": "q-ary_digits", "code_id": "parvaresh_vardy", "physical": "q-ary_digits", "protection": "", "introduced": "[F. Parvaresh and A. Vardy, \u201cCorrecting Errors Beyond the Guruswami-Sudan Radius in Polynomial Time\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI]", "description": "Also called a correlated RS code. An IRS code with additional algebraic relations (a.k.a. correlations) between the codeword polynomials \\(\\{f^{(j)}\\}_{j=1}^{t}\\). These relations yielded a list decoder that achieves list-decoding capacity. ", "name": "Parvaresh-Vardy (PV) code", "realizations": "", "short_name": "PV", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "PV codes can be list-decoded up to \\(1-(t k/n)^{1/(t+1)}\\) fraction of errors. This result improves over the Guruswami-Sudan algorithm for ordinary RS codes, which list-decodes up to \\(1-\\sqrt{k/n}\\) fraction of errors.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "interleaved_reed_solomon", "parents_detail": "PV codes are IRS codes with specific algebraic relations between the codeword polynomials that allow for efficient list decoding.", "cousins_code_id": "folded_reed_solomon", "cousins_detail": "The specific relations imposed on the polynomials of PV codes allow for them to be expressed in a similar way as FRS codes, but with more redundancy. Folded RS codes can be list-decoded up to a higher fraction of errors.", "_type": "ecc", "_page_id": "c_parvaresh_vardy", "_href": "c/parvaresh_vardy"}, "c_generalized_reed_solomon": {"notes": "", "logical": "q-ary_digits", "code_id": "generalized_reed_solomon", "physical": "q-ary_digits", "protection": "The code can detect \\(n-k\\) errors, and can correct errors \\( \\left\\lfloor (n-k)/2\\right\\rfloor  \\) errors.", "introduced": "", "description": "An \\([n,k,n-k+1]_q\\) linear code that is a modification of the RS code where codeword polynomials are multiplied by additional prefactors. Each message \\(\\mu\\) is encoded into a string of values of the corresponding polynomial \\(f_\\mu\\) at the points \\(\\alpha_i\\), multiplied by a corresponding nonzero factor \\(v_i \\in GF(q)\\), \\begin{align}\n  \\mu\\to\\left( v_{1}f_{\\mu}\\left(\\alpha_{1}\\right),v_{2}f_{\\mu}\\left(\\alpha_{2}\\right),\\cdots,v_{n}f_{\\mu}\\left(\\alpha_{n}\\right)\\right)~.\n\\end{align} ", "name": "Generalized RS (GRS) code", "realizations": "Commonly used in mass storage systems such as CDs, DVDs, QR codes etc.\nVarious cloud storage systems [H. Dau et al., \u201cRepairing Reed-Solomon Codes With Multiple Erasures\u201d, IEEE Transactions on Information Theory 64, 6567 (2018). DOI; 1612.01361].\nPublic-key cryptosystems generalizing those that used Goppa codes [R. J. McEliece, A public-key cryptosystem based on algebraic coding theory, Technical report, Jet Propulsion Lab. DSN Progress Report (1978).][H. Janwa and O. Moreno, \u201cMcEliece public key cryptosystems using algebraic-geometric codes\u201d, Designs, Codes and Cryptography 8, (1996). DOI][H. Niederreiter (1986). Knapsack-type cryptosystems and algebraic coding theory. Problems of Control and Information Theory. Problemy Upravlenija I Teorii Informacii. 15: 159\u2013166.], some of which were proven to be insecure [V. M. SIDELNIKOV and S. O. SHESTAKOV, \u201cOn insecurity of cryptosystems based on generalized Reed-Solomon codes\u201d, Discrete Mathematics and Applications 2, (1992). DOI]. More recent works focus on methods to mask the algebraic structure using subcodes of GRS codes [T. P. Berger and P. Loidreau, \u201cHow to Mask the Structure of Codes for a Cryptographic Use\u201d, Designs, Codes and Cryptography 35, 63 (2005). DOI]. For example, a key-recovery attack was developed in Ref. [Alain Couvreur et al., \u201cDistinguisher-Based Attacks on Public-Key Cryptosystems Using Reed-Solomon Codes\u201d. 1307.6458] for a variant of masking method proposed in Ref. [Marco Baldi et al., \u201cEnhanced public key security for the McEliece cryptosystem\u201d. 1108.2462].", "short_name": "GRS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The decoding process of GRS codes reduces to the solution of a polynomial congruence equation, usually referred to as the key equation. Decoding schemes are based on applications of the Euclid algorithm to solve the key equation.\nBerlekamp-Massey decoder with runtime of order \\(O(n^2)\\) [E. Berlekamp, \u201cNonbinary BCH decoding (Abstr.)\u201d, IEEE Transactions on Information Theory 14, 242 (1968). DOI][J. Massey, \u201cShift-register synthesis and BCH decoding\u201d, IEEE Transactions on Information Theory 15, 122 (1969). DOI][E. R. Berlekamp, Algebraic Coding Theory, McGraw-Hill, 1968].\nGuruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI] and modification by Koetter-Vardy for soft-decision decoding [R. Koetter and A. Vardy, \u201cAlgebraic soft-decision decoding of reed-solomon codes\u201d, IEEE Transactions on Information Theory 49, 2809 (2003). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation\nevaluation_polynomial", "parents_detail": "GRS (RS) codes are in one-to-one correspondence with evaluation AG codes of univariate polynomials \\(f\\) with \\(\\cal X\\) being the projective (affine) line ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.24; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nGRS (RS) codes are in one-to-one correspondence with univariate polynomial evaluation codes with \\(\\cal X\\) being the projective (affine) line ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.24; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).", "parent_of_code_id": "alternant\nq-ary_bch\ngoppa\nextended_reed_solomon\nhermitian\nreed_solomon", "parent_of_detail": "Alternant codes are subfield subcodes of GRS codes.\nBCH codes are subfield subcodes of GRS codes.\nGoppa codes are \\(GF(q)\\)-subfield subcode of the dual of the GRS code over \\(GF(q^m)\\) with evaluation points \\(\\alpha_i\\) and factors \\(v_i=G(\\alpha_i)^{-1}\\) ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], pg. 523; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nExtended GRS codes can be thought of as GRS codes that include an evaluation point of zero.\nHermitian codes are concatenated GRS codes [T. Yaghoobian and I. F. Blake, \u201cHermitian codes as generalized Reed-Solomon codes\u201d, Designs, Codes and Cryptography 2, 5 (1992). DOI].\nA GRS code for which all multipliers \\(v_i\\) are unity reduces to an RS code.", "cousins_code_id": "mds\ndistributed_storage", "cousins_detail": "GRS codes have distance \\(n-k+1\\), saturating the Singleton bound.\nGRS codes are used in various cloud storage systems [H. Dau et al., \u201cRepairing Reed-Solomon Codes With Multiple Erasures\u201d, IEEE Transactions on Information Theory 64, 6567 (2018). DOI; 1612.01361].", "cousin_of_code_id": "bch\ngalois_grs", "cousin_of_detail": "Binary BCH codes are subfield subcodes of GRS codes.\nHermitian self-orthogonal GRS codes are used to construct Galois-qudit GRS codes in the Hermitian construction.", "_type": "ecc", "_page_id": "c_generalized_reed_solomon", "_href": "c/generalized_reed_solomon"}, "c_reed_solomon": {"notes": "See database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.\nSee corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cReed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon.html].", "logical": "q-ary_digits", "code_id": "reed_solomon", "physical": "q-ary_digits", "protection": "Since each polynomial \\(f_{\\mu}\\) is of degree less than \\(k\\), it can be determined from its values at \\(k\\) points. This means that RS codes can correct erasures on up to \\(n-k\\) registers. The resulting distance, \\(d=n-k+1\\), saturates the Singleton bound.", "introduced": "[K. A. Bush, \u201cOrthogonal Arrays of Index Unity\u201d, The Annals of Mathematical Statistics 23, 426 (1952). DOI][I. S. Reed and G. Solomon, \u201cPolynomial Codes Over Certain Finite Fields\u201d, Journal of the Society for Industrial and Applied Mathematics 8, 300 (1960). DOI]", "description": "An \\([n,k,n-k+1]_q\\) linear code based on polynomials over \\(GF(q)\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct points in \\(GF(q)\\). An RS code encodes a message \\(\\mu=\\{\\mu_0,\\cdots,\\mu_{k-1}\\}\\) into \\(\\{f_\\mu(\\alpha_1),\\cdots,f_\\mu(\\alpha_n)\\}\\) using a message-dependent polynomial \\begin{align}\nf_\\mu(x)=\\mu_0+\\mu_1 x + \\cdots + \\mu_{k-1}x^{k-1}.\n\\end{align} In other words, each message \\(\\mu\\) is encoded into a string of values of the corresponding polynomial \\(f_\\mu\\) at the points \\(\\alpha_i\\), \\begin{align}\n  \\mu\\to\\left( f_{\\mu}\\left(\\alpha_{1}\\right),f_{\\mu}\\left(\\alpha_{2}\\right),\\cdots,f_{\\mu}\\left(\\alpha_{n}\\right)\\right) \\,.\n\\end{align}\n\nAn RS code with length \\(n=q-1\\) whose points \\(\\alpha_i\\) are \\(i-1\\)st powers of a primitive \\(n\\)th root of unity is a narrow-sense RS code. In an alternative convention (not used here), the primitive-root case is called an RS code, and the general-root case is a generalized RS code. ", "name": "Reed-Solomon (RS) code", "realizations": "RS Product Code (RSPC) was used in DVDs (see Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 4).\nDSL technologies and their variants against impluse noise [D. Zhang, K. Ho-Van, and T. Le-Ngoc, \u201cImpulse noise detection techniques for retransmission to reduce delay in DSL systems\u201d, 2012 IEEE International Conference on Communications (ICC) (2012). DOI].\nCryptographic primitives based on the hardness of decoding RS codes for more than \\(1-\\sqrt{k/n}+\\epsilon\\) errors. This is equivalent to the polynomial reconstruction problem [A. Kiayias and M. Yung, \u201cCryptographic Hardness Based on the Decoding of Reed-Solomon Codes\u201d, Automata, Languages and Programming 232 (2002). DOI].\nRS codes as outer codes concatenated with convolutional codes are used indirectly in space exploration programs such as Voyager and Galileo. RS codes were part of a temetry channel coding standard issued by the Consultative Committee for Space Data Systems (see Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 3).\nThe ubiquity of RS codes has yielded off-the-shelf VLSI intergrated-circuit decoding hardware [D. V. Sarwate and N. R. Shanbhag, \u201cHigh-speed architectures for Reed-Solomon decoders\u201d, IEEE Transactions on Very Large Scale Integration (VLSI) Systems 9, 641 (2001). DOI] (see also Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 5 and 10).\nAutomatic repeat request (ARQ) data transmission protocols (see Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 7).\nSlow-frequency-hop spread-spectrum transmission (see Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Chs. 8-9).\nCoded sharding designs in blockchains to increase efficiency [Songze Li et al., \u201cPolyShard: Coded Sharding Achieves Linearly Scaling Efficiency and Security Simultaneously\u201d. 1809.10361].\nPrivate Information Retrieval [B. Sasidharan and E. Viterbo, \u201cPrivate Data Access in Blockchain Systems Employing Coded Sharding\u201d, 2021 IEEE International Symposium on Information Theory (ISIT) (2021). DOI].\nUsed in QR-Codes to retrieve damaged barcodes [International Organization for Standardization, Information Technology: Automatic Identification and Data Capture Techniques-QR Code 2005 Bar Code Symbology Specification, 2nd ed., IEC18004 (ISO, 2006).].\nWireless communication systems such as 3G, DVB, and WiMAX [I. Shakeel et al., \u201cReed-Solomon coding for cooperative wireless communication\u201d, 21st Annual IEEE International Symposium on Personal, Indoor and Mobile Radio Communications (2010). DOI].\nCorrecting pooled testing results for SARS-CoV-2 [N. Shental et al., \u201cEfficient high-throughput SARS-CoV-2 testing to detect asymptomatic carriers\u201d, Science Advances 6, (2020). DOI].", "short_name": "RS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Although using iFFT has its counterpart iNNT for finite fields, the decoding is usually standard polynomial interpolation in \\(k=\\mathcal{O}(n\\log^2 n)\\). However, in erasure decoding, encoded values are only erased in \\(r\\) points, which is a specific case of polynomial interpolation and can be done in \\(\\mathcal{O}(n\\log n)\\) by computing product of the received polynomial and an erasure locator polynomial and using long division to find an original polynomial. The long division step can be omitted to increase speed further by only dividing the derivative of the product polynomial, and derivative of erasure locator polynomial evaluated at erasure locations.\nBerlekamp-Massey decoder with runtime of order \\(O(n^2)\\) [J. Massey, \u201cShift-register synthesis and BCH decoding\u201d, IEEE Transactions on Information Theory 15, 122 (1969). DOI][E. R. Berlekamp, Algebraic Coding Theory, McGraw-Hill, 1968].\nGorenstein-Peterson-Zierler decoder with runtime of order \\(O(n^3)\\) [W. Peterson, \u201cEncoding and error-correction procedures for the Bose-Chaudhuri codes\u201d, IEEE Transactions on Information Theory 6, 459 (1960). DOI][D. Gorenstein and N. Zierler, \u201cA Class of Error-Correcting Codes in $p^m $ Symbols\u201d, Journal of the Society for Industrial and Applied Mathematics 9, 207 (1961). DOI] (see exposition in Ref. [R.E. Blahut, Theory and practice of error-control codes, Addison-Wesley 1983.]).\nBerlekamp-Welch decoder with runtime of order \\(O(n^3)\\) [E. R. Berlekamp and L. Welch, Error Correction of Algebraic Block Codes. U.S. Patent, Number 4,633,470 1986.] (see exposition in Ref. [P. Gemmell and M. Sudan, \u201cHighly resilient correctors for polynomials\u201d, Information Processing Letters 43, 169 (1992). DOI]), assuming that \\(t \\geq (n+k)/2\\).\nGao decoder using extended Euclidean algorithm [S. Gao, \u201cA New Algorithm for Decoding Reed-Solomon Codes\u201d, Communications, Information and Network Security 55 (2003). DOI].\nFast-Fourier-transform decoder with runtime of order \\(O(n \\text{polylog}n)\\) [I. Reed et al., \u201cThe fast decoding of Reed-Solomon codes using Fermat theoretic transforms and continued fractions\u201d, IEEE Transactions on Information Theory 24, 100 (1978). DOI].\nList decoders try to find a low-degree bivariate polynomial \\(Q(x,y)\\) such that evaluation of \\(Q\\) at \\((\\alpha_i,y_i)\\) is zero. By choosing proper degrees, it can be shown such polynomial exists by drawing an analogy between evaluation of \\(Q(\\alpha_i,y_i)\\) and solving a homogenous linear equation (interpolation). Once this is done, one lists roots of \\(y\\) that agree at \\(\\geq t\\) points. The breakthrough Sudan list-decoding algorithm corrects up to \\(1-\\sqrt{2R}\\) fraction of errors [M. Sudan, \u201cDecoding of Reed Solomon Codes beyond the Error-Correction Bound\u201d, Journal of Complexity 13, 180 (1997). DOI]. Roth and Ruckenstein proposed a modified key equation that allows for correction of more than \\(\\left\\lfloor (n-k)/2 \\right\\rfloor\\) errors [R. M. Roth and G. Ruckenstein, \u201cEfficient decoding of Reed-Solomon codes beyond half the minimum distance\u201d, IEEE Transactions on Information Theory 46, 246 (2000). DOI]. The Guruswami-Sudan algorithm improved the Sudan algorithm to \\(1-\\sqrt{R}\\) [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI]; see Ref. [V. Guruswami and A. Rudra, \u201cLimits to List Decoding Reed\u2013Solomon Codes\u201d, IEEE Transactions on Information Theory 52, 3642 (2006). DOI] for bounds. A further modification by Koetter and Vardy is used for soft-decision decoding [R. Koetter and A. Vardy, \u201cAlgebraic soft-decision decoding of reed-solomon codes\u201d, IEEE Transactions on Information Theory 49, 2809 (2003). DOI] (see also Ref. [A. Vardy and Y. Be'ery, \u201cBit-level soft-decision decoding of Reed-Solomon codes\u201d, IEEE Transactions on Communications 39, 440 (1991). DOI]).", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Bit-serial encoder [E. Berlekamp, \u201cBit-serial Reed - Solomon encoders\u201d, IEEE Transactions on Information Theory 28, 869 (1982). DOI].\n\\([n,k,n-k+1]\\) RS code requires an order \\(O(n^2)\\) operations while encoding if a straightforward matrix multiplication is employed and \\(k=\\mathcal{O}(n)\\). Using the FFT algorithm, complexity of evaluating a polynomial at \\(n\\) roots of unity becomes \\(O(n\\log n)\\). The FFT can be generalized to finite fields and rings, which is referred as Number-theoretic Transform (NTT). However, for some values of \\(n\\), which can not be factorized into small primes or do not have \\(n\\) roots of unity, the FFT algorithm fails. Independently developed by [Y. Wang and X. Zhu, \u201cA fast algorithm for the Fourier transform over finite fields and its VLSI implementation\u201d, IEEE Journal on Selected Areas in Communications 6, 572 (1988). DOI][D. G. Cantor, \u201cOn arithmetical algorithms over finite fields\u201d, Journal of Combinatorial Theory, Series A 50, 285 (1989). DOI] and generalized in Ref. [J. von zur Gathen and J. Gerhard, Modern Computer Algebra (Cambridge University Press, 2009). DOI], the additive FFT solves this problem by evaluating the polynomial at \\(n-1\\) roots of unity when \\(n\\) is power of 2.", "features_rate": "Generic Reed-Solomon codes achieve list-decoding capacity [Joshua Brakensiek, Sivakanth Gopi, and Visu Makam, \u201cGeneric Reed-Solomon codes achieve list-decoding capacity\u201d. 2206.05256].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_reed_solomon\ninterleaved_reed_solomon\nfolded_reed_solomon", "parents_detail": "A GRS code for which all multipliers \\(v_i\\) are unity reduces to an RS code.\nAn IRS code utilizing one polynomial \\(f\\) reduces to an RS code.\nAn FRS code with no extra grouping (\\(m=1\\)) reduces to an RS code.", "parent_of_code_id": "q-ary_parity_check", "parent_of_detail": "RS codes for \\(k=n-1\\) are parity-check codes [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cExtended Reed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html].", "cousins_code_id": "mds\nq-ary_bch\nq-ary_cyclic", "cousins_detail": "RS codes have distance \\(n-k+1\\), saturating the Singleton bound. If \\(k \\leq p\\), then all linear MDS codes \\( [n,k,n-k+1]_{p^m} \\) are RS codes [S. Ball, \u201cOn sets of vectors of a finite vector space in which every subset of basis size is a basis\u201d, Journal of the European Mathematical Society 733 (2012). DOI].\nNarrow-sense RS codes are BCH codes ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Remark 15.3.21; [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thms. 5.2.1 and 5.2.3). Moreover, an RS code can be represented as a union of cosets, with each coset being an interleaver of several binary BCH codes [A. Vardy and Y. Be'ery, \u201cBit-level soft-decision decoding of Reed-Solomon codes\u201d, IEEE Transactions on Communications 39, 440 (1991). DOI].\nIf the length divides \\(q-1\\), then it is possible to construct a cyclic RS code.", "cousin_of_code_id": "quantum_secret_sharing\nconvolutional\ngalois_polynomial\njustesen\nmaximum_rank_distance\npolynomial\nrank_modulation", "cousin_of_detail": "The classical information in this code is encoded using a Reed-Solomon code.\nConvolutional codes are often used in concatenation with Reed-Solomon codes for communication [T. Halonen, J. Romero, and J. Melero, editors , GSM, GPRS and EDGE Performance (Wiley, 2003). DOI].\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.\nAn RS code is the outer code of Justesen codes.\nMRD rank-metric codes can be thought of as matrix analogues of MDS Reed-Solomon codes as both constructions utilize a Vandermonde matrix [R. Koetter and F. R. Kschischang, \u201cCoding for Errors and Erasures in Random Network Coding\u201d, IEEE Transactions on Information Theory 54, 3579 (2008). DOI].\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.\nRS codes can be used to design rank modulation codes [A. Mazumdar, A. Barg, and G. Zemor, \u201cConstructions of rank modulation codes\u201d, 2011 IEEE International Symposium on Information Theory Proceedings (2011). DOI].", "_type": "ecc", "_page_id": "c_reed_solomon", "_href": "c/reed_solomon"}, "c_binary_permutation": {"notes": "", "logical": "points", "code_id": "binary_permutation", "physical": "groups", "protection": "", "introduced": "[I. F. Blake, G. Cohen, and M. Deza, \u201cCoding with permutations\u201d, Information and Control 43, 1 (1979). DOI][P. J. Cameron, \u201cPermutation codes\u201d, European Journal of Combinatorics 31, 482 (2010). DOI]", "description": "Stub.", "name": "Binary permutation-based code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "group_classical", "parents_detail": "", "cousin_of_code_id": "rank_modulation", "cousin_of_detail": "Binary permutation-based codes also encode messages into permutations but protect against errors with the Hamming distance.", "_type": "ecc", "_page_id": "c_binary_permutation", "_href": "c/binary_permutation"}, "c_group_classical": {"notes": "", "logical": "points", "code_id": "group_classical", "physical": "groups", "protection": "", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates labeled by elements of a finite group \\(G\\).", "name": "Group-based code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "binary_permutation\nrank_modulation", "parent_of_detail": "\nGroup-based codes whose alphabet is based on the permutation group \\(S_n\\) are rank-modulation codes.", "cousins_code_id": "bits_into_bits\npoints_into_lattices\ngroup_quantum", "cousins_detail": "Group-based codes whose alphabet is based on the group \\(\\mathbb{Z}_2\\) are binary codes.\nGroup-based codes whose alphabet is based on the group \\(\\mathbb{R}\\) are lattice-based codes.\n", "_type": "ecc", "_page_id": "c_group_classical", "_href": "c/group_classical"}, "c_rank_modulation": {"notes": "", "logical": "points", "code_id": "rank_modulation", "physical": "groups", "protection": "Protects against errors in the Kendall tau distance on the space of permutations. The Kendall distance between permutations \\(\\sigma\\) and \\(\\pi\\) is defined as the minimum number of adjacent transpositions required to change \\(\\sigma\\) into \\(\\pi\\). ", "introduced": "[H. Chadwick and L. Kurz, \u201cRank permutation group codes based on Kendall's correlation statistic\u201d, IEEE Transactions on Information Theory 15, 306 (1969). DOI][Anxiao Jiang, M. Schwartz, and J. Bruck, \u201cError-correcting codes for rank modulation\u201d, 2008 IEEE International Symposium on Information Theory (2008). DOI]", "description": "Also known as a code in permutations. A family of codes that encode a finite set of size \\(M\\) into a set \\(S_n\\) of permutations of \\([n]=(1,2,...,n)\\). They can be derived from Lee-metric codes, Reed-Solomon codes [A. Mazumdar, A. Barg, and G. Zemor, \u201cConstructions of rank modulation codes\u201d, 2011 IEEE International Symposium on Information Theory Proceedings (2011). DOI], quadratic residue codes and most binary codes. ", "name": "Rank-modulation code", "realizations": "Electronic devices where charges can either increase in an individual cell or decrease in a block of adjacent cells, e.g., flash memories [Anxiao Jiang et al., \u201cRank Modulation for Flash Memories\u201d, IEEE Transactions on Information Theory 55, 2659 (2009). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Rank modulation codes with code distance \\(d=\\Theta(n^{1+\\epsilon})\\) for \\(\\epsilon\\in[0,1]\\) achieve a rate of \\(1-\\epsilon\\) [A. Barg and A. Mazumdar, \u201cCodes in permutations and error correction for rank modulation\u201d, 2010 IEEE International Symposium on Information Theory (2010). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "group_classical", "parents_detail": "Group-based codes whose alphabet is based on the permutation group \\(S_n\\) are rank-modulation codes.", "cousins_code_id": "reed_solomon\nbinary_permutation", "cousins_detail": "RS codes can be used to design rank modulation codes [A. Mazumdar, A. Barg, and G. Zemor, \u201cConstructions of rank modulation codes\u201d, 2011 IEEE International Symposium on Information Theory Proceedings (2011). DOI].\nBinary permutation-based codes also encode messages into permutations but protect against errors with the Hamming distance.", "_type": "ecc", "_page_id": "c_rank_modulation", "_href": "c/rank_modulation"}, "c_points_into_spheres": {"notes": "", "logical": "spheres", "code_id": "points_into_spheres", "physical": "points", "protection": "", "introduced": "", "description": "Encodes states (codewords) into points on an \\(n\\)-dimensional sphere \\(S^n\\).", "name": "Spherical code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "_type": "ecc", "_page_id": "c_points_into_spheres", "_href": "c/points_into_spheres"}, "c_linear": {"notes": "", "description": "A code whose set of codewords is closed under addition and multiplication by elements of its alphabet, which can be either a field or a ring. In other words, for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any alphabet elements \\(\\alpha,\\beta\\). This extra structure yields much information about their properties, making them a large and well-studied subset of codes. ", "name": "Linear code", "code_id": "linear", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "divisible\ndual\nevaluation_varieties\ngroup\nq-ary_linear\nbinary_linear\nldpc\nrings_linear", "parent_of_detail": "\n\n\n\n\n\n\n", "cousins_code_id": "stabilizer", "cousins_detail": "Linear (stabilizer) codes form a large and well-studied subset of all classical (quantum) codes because features such as decoding and level of protection are typically easier to determine than those of nonlinear (non-stabilizer) codes.", "cousin_of_code_id": "points_into_lattices", "cousin_of_detail": "Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.", "_type": "ecc", "_page_id": "c_linear", "_href": "c/linear"}, "c_evaluation_polynomial": {"notes": "See Refs. [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349][Delio Jaramillo, Maria Vaz Pinto, and Rafael H. Villarreal, \u201cEvaluation codes and their basic parameters\u201d. 1907.13217] for reviews.", "logical": "", "code_id": "evaluation_polynomial", "physical": "", "protection": "", "introduced": "", "description": "Evaluation code of polynomials at points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) on an algebraic variety \\(\\cal X\\). Codewords \\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right)\n\\end{align} are evaluations of a linear space \\(L\\) of polynomials \\(f\\). If the space is taken to be all polynomials up to some degree, the code is called a Reed-Muller-type code or RM-type code of that degree.\n\nOne can specify the space \\(L\\) by the number of variables input into the polynomials as well as the polynomials' maximum degree. One can additionally select only polynomials that have zeroes at certain points with certain multiplicities. A bookkeeping device for this data is the divisor \\(D\\), and the corresponding vector space of polynomials defined using the variety \\(\\cal X\\) and the divisor is the Riemann-Roch space \\(L=L(D)\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 313). ", "name": "Polynomial evaluation code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation_varieties", "parents_detail": "Polynomial evaluation codes are evaluation codes of polynomials \\(f\\) for which \\(\\cal X\\) is an algebraic variety.", "parent_of_code_id": "complete_intersections\ndeligne_lusztig\nflag_variety\ngeneralized_reed_muller\ngeneralized_reed_solomon\ntoric_classical\nreed_muller\nruled_surface\nserge", "parent_of_detail": "Complete-intersection RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a complete intersection.\nDeligne-Lusztig codes are polynomial evaluation codes with \\(\\cal X\\) a Deligne-Lusztig variety.\nFlag-variety codes are polynomial evaluation codes with \\(\\cal X\\) being a flag variety.\nGRM (PRM) codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine (projective) space over \\(GF(q)\\) ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pgs. 44-46; [S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nGRS (RS) codes are in one-to-one correspondence with univariate polynomial evaluation codes with \\(\\cal X\\) being the projective (affine) line ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.24; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nHansen toric codes are polynomial evaluation codes with \\(\\cal X\\) being a toric variety.\nRM codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine binary space ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pgs. 44-46; [S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nRuled-surface codes are polynomial evaluation codes with \\(\\cal X\\) being a ruled surface.\nSerge-variety RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a Serge variety.", "cousins_code_id": "evaluation", "cousins_detail": "Evaluation AG codes are evaluation codes on algebraic curves. Polynomial evaluation codes are evaluation codes of polynomials. Evaluation AG codes of polynomials are equivalent to polynomial evaluation codes on algebraic curves.", "_type": "ecc", "_page_id": "c_evaluation_polynomial", "_href": "c/evaluation_polynomial"}, "c_dual": {"notes": "See books [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI] for more on self-dual codes.\nSee Refs. [S. Bouyuklieva, \u201cSome optimal self-orthogonal and self-dual codes\u201d, Discrete Mathematics 287, 1 (2004). DOI][M. Harada, \u201cBinary extremal self-dual codes of length 60 and related codes\u201d, Designs, Codes and Cryptography 86, 1085 (2017). DOI; 1706.01694] for constructions of binary self-dual codes.\nSee Tables of Self-Dual Codes for a database of self-dual codes over \\(GF(2)\\), \\(GF(3)\\), \\(GF(4)\\) (Euclidean or Hermitian), \\(GF(5)\\), and \\(GF(7)\\). See also Ref. [P. Gaborit and A. Otmani, \u201cExperimental constructions of self-dual codes\u201d, Finite Fields and Their Applications 9, 372 (2003). DOI].", "logical": "", "code_id": "dual", "physical": "", "protection": "The dual of an \\([n,k,d] \\) code is an \\([n,n-k,d']\\) code, where \\(d'\\) is not always related to \\(d\\). The generator matrix of \\(C^\\perp\\) is the parity check matrix of \\(C\\), and visa versa.", "introduced": "[W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI]", "description": "For any \\([n,k]\\) binary or \\(q\\)-ary linear code \\(C\\), the dual (or orthogonal) code, \\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{n} ~|~ x\\cdot y=0 \\forall x\\in C\\},\n\\end{align} where the ordinary, standard, or Euclidean inner product is \\(x\\cdot y = \\sum_{i=1}^n x_i y_i\\) for coordinates \\(x_i,y_i\\).\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called self-orthogonal or weakly self-dual. A code that contains its dual, \\(C^\\perp \\subseteq C\\), is called dual-containing. A code that is equal to its dual, \\(C^\\perp = C\\), is called self-dual. The dual of a dual code is the original code. A code is dual-containing iff its dual is self-orthogonal.\n\nThe dual code \\(C^\\perp\\) is the row space of the parity check matrix of \\(C\\). The dual code is the kernel of the encoding map for \\(C\\), and \\(\\dim C^\\perp = n-k\\).\n\nFor cases when \\(q\\) is a square, an alternative definition of dual substitutes the Euclidean inner product for the Hermitian inner product, \\(x\\cdot y \\to \\sum_{i=1}^n x_i y^{\\sqrt{q}}_i\\). More general inner products can also be considered [Y. Fan and L. Zhang, \u201cGalois self-dual constacyclic codes\u201d, Designs, Codes and Cryptography 84, 473 (2016). DOI]. Self-dual codes with respect to the Hermitian inner product are called Hermitian self-dual; similar definitions hold for self-orthogonal and dual-containing as well as other inner products.", "name": "Dual linear code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "linear", "parents_detail": "", "cousins_code_id": "divisible", "cousins_detail": "Binary self-dual codes are singly-even.", "cousin_of_code_id": "css\ndodecacode\ndual_additive\ngolay\nhadamard\nhexacode\nmajorana_stab\nmds\nqubit_stabilizer\nreed_muller\nstabilizer_over_gf4\nternary_golay\ntetracode\ngalois_true_stabilizer", "cousin_of_detail": "CSS codes for which \\(C_X=C_Z \\equiv C\\) are called self-orthogonal since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\).\nThe dodecacode is self-dual.\nThe difference between the definitions of dual linear and dual additive codes is in the trace used in the inner product. Self-dual linear codes are also self-dual additive codes.\nThe extended Golay code is self-dual.\nThe Hadamard code is the dual of the extended Hamming Code.\nThe hexacode is Euclidean and Hermitian self-dual.\nClassical self-orthogonal codes can be used to construct Majorana stabilizer codes [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a self-orthogonal classical code. A self-orthogonal classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\).\nA linear binary or \\(q\\)-ary \\([n,k,n-k+1]\\) code is MDS if and only if its dual \\([n,n-k,k+1]\\) is MDS ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 1.9.13).\nSymplectic representations of stabilizer group elements form a linear code over \\(GF(2)\\) that is self-orthogonal with respect to the symplectic inner product ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.6).\nThe codes RM\\((r,m)\\) and RM\\((m-r-1,m)\\) are dual to each other.\nIf the classical additive code of quaternary vectors corresponding a stabilizer code over \\(GF(4)\\) is linear, then the code is self-orthogonal with respect to both the trace-Hermitian and Hermitian inner products ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.4.1). In other words, the extra trace operation can be removed from the definition of inner product.\nThe extended ternary Golay code is self-dual.\nThe tetracode is self-dual.\nHermitian self-orthogonal linear codes over \\(GF(q^2)\\) yield true stabilizer codes via either the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI], Corr. 1) or the stabilizer-over-\\(GF(q^2)\\) construction (showing self-orthogonality under the trace-alternating inner product; see Ref. [Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19 or Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.8).", "_type": "ecc", "_page_id": "c_dual", "_href": "c/dual"}, "c_ldpc": {"notes": "See database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit representatives of several classes of LDPC codes, including \\(q\\)-ary, WiMAX, multi-edge, and spatially-coupled.\nSee Ref. [A. Shokrollahi, \u201cLDPC Codes: An Introduction\u201d, Coding, Cryptography and Combinatorics 85 (2004). DOI] for a review of LDPC codes circa 2005.\nCodes have been benchmarked using AFF3CT toolbox [A. Cassagne et al., \u201cAFF3CT: A Fast Forward Error Correction Toolbox!\u201d, SoftwareX 10, 100345 (2019). DOI].", "logical": "", "code_id": "ldpc", "physical": "", "protection": "", "introduced": "[R. Gallager, \u201cLow-density parity-check codes\u201d, IEEE Transactions on Information Theory 8, 21 (1962). DOI]", "description": "Also known as Gallager codes. Binary or \\(q\\)-ary linear code with a sparse parity-check matrix. More precisely, a member of an infinite family of \\([n,k,d]\\) codes for which the number of nonzero entries in each row and column of the parity-check matrix are both bounded by a constant as \\(n\\to\\infty\\). An LDPC code is \\((j,k)\\)-regular if the parity-check matrix has a fixed number of \\(j\\) nonzero entries in each row and \\(k\\) entries in each column; otherwise, the LDPC code is irregular.\n\nA parity check is performed by taking the inner product of a row of the parity-check matrix with a codeword that has been affected by a noise channel. A parity check yields either zero (no error) or one (error) for binary codes, while yielding zero (no error) or a nonzero field element (error) for \\(q\\)-ary codes. Despite the fact that there is more than one nonzero outcome, \\(q\\)-ary linear codes with sparse parity-check matrices are also called LDPC codes. ", "name": "Low-density parity-check (LDPC) code", "realizations": "5G NR cellular communication for the traffic channel [M. V. Patil, S. Pawar, and Z. Saquib, \u201cCoding Techniques for 5G Networks: A Review\u201d, 2020 3rd International Conference on Communication System, Computing and IT Applications (CSCITA) (2020). DOI].\nWiMAX (IEEE 802.16e) [LDPC coding for OFDMA PHY. 802.16REVe Sponsor Ballot Recirculation comment, July 2004. IEEE C802.16e04/141r2].\nSatellite transmission of digital television [R. Purnamasari, H. Wijanto, and I. Hidayat, \u201cDesign and implementation of LDPC(Low Density Parity Check) coding technique on FPGA (Field Programmable Gate Array) for DVB-S2 (Digital Video Broadcasting-Satellite)\u201d, 2014 IEEE International Conference on Aerospace Electronics and Remote Sensing Technology (2014). DOI].", "short_name": "LDPC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Belief propagation using min-sum algorithm [S. Lin and D. J. Costello, Error Control Coding, 2nd ed. Englewood Cliffs, NJ: Prentice-Hall, 2004.].\nLinear programming [J. Feldman, \u201cLP Decoding\u201d, Encyclopedia of Algorithms 1177 (2016). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Achieve capacity on the binary symmetric channel under maximum-likelihood decoding [R. Gallager, \u201cLow-density parity-check codes\u201d, IEEE Transactions on Information Theory 8, 21 (1962). DOI][Venkatesan Guruswami, \u201cIterative Decoding of Low-Density Parity Check Codes (A Survey)\u201d. cs/0610022]. Some LDPC codes achieve capacity for smaller block lengths under belief-propagation decoding [Shrinivas Kudekar, Tom Richardson, and Ruediger Urbanke, \u201cSpatially Coupled Ensembles Universally Achieve Capacity under Belief Propagation\u201d. 1201.2999]. Random LDPC codes achieve list-decoding capacity [Jonathan Mosheiff et al., \u201cLDPC Codes Achieve List Decoding Capacity\u201d. 1909.06430].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "fountain\ntornado", "parent_of_detail": "\n", "cousin_of_code_id": "qldpc\ntornado", "cousin_of_detail": "\nTornado codes are similar to LDPC codes, but they use a highly irregular weight distribution for the underlying graphs [A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI].", "_type": "ecc", "_page_id": "c_ldpc", "_href": "c/ldpc"}, "c_group": {"notes": "See Ch. 16 of Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI] and pg. 58 of Ref. [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI] for introductions to group codes.\nNot all abelian group codes are for cyclic groups (cyclic codes) or for elementary abelian \\( p \\) groups (e.g. Reed Muller codes [S. D. Berman, \u201cSemisimple cyclic and Abelian codes. II\u201d, Cybernetics 3, 17 (1970). DOI]). For example, there is a binary code with parameters \\( [45,13,16] \\) which is an abelian group code for the group \\( G = \\mathbb{Z}_3 \\times \\mathbb{Z}_{15} \\). ", "logical": "", "code_id": "group", "physical": "", "protection": "", "introduced": "", "description": "An \\( [n,k] \\) binary or \\(q\\)-ary code based on a finite group \\( G \\) of size \\(n \\). A group code for an abelian group is called an abelian group code.\n\nThe code is a \\( k \\)-dimensional linear subspace of the group algebra of \\( G\\) with coefficients in the field \\(GF(q) = \\mathbb{F}_q\\) with \\(q\\) elements. To be precise, the code must be closed under permutations corresponding to the elements of the group \\( G \\); therefore, \\( G \\) must be a subgroup of the permutation automorphism group of the code, which is defined as the group of permutations of the physical bits that preserve the code space. This leads us to the formal definition of a group code: a group code is an ideal in the group algebra \\( \\mathbb{F}_q G \\).", "name": "Group code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "q-ary_cyclic\nbinary_cyclic\nreed_muller", "parent_of_detail": "A length-\\(n\\) cyclic \\(q\\)-ary linear code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).\nA length-\\(n\\) cyclic binary linear code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).\nConsider a binary vector space of dimension \\( m \\). Under addition, this forms a finite group with \\( 2^m \\) elements known as an elementary abelian 2-group -- the direct product of \\( m \\) two-element cyclic groups \\( \\mathbb{Z}_2 \\times \\dots \\times \\mathbb{Z}_2 \\). Denote this group by \\( G_m \\). Let \\( J \\) be the Jacobson radical of the group algebra \\( \\mathbb{F}_2 G_m \\), where \\(\\mathbb{F}_2=GF(2)\\). RM\\((r,m)\\) codes correspond to the ideal \\( J^{m-r} \\). The length of the code is \\( |G_m| = 2^m \\), the distance is \\( 2^{m-r} \\), and the dimension is \\( \\sum_{i=0}^r {m \\choose i} \\). A similar construction exists for choices of a prime \\( p\\neq 2 \\).", "_type": "ecc", "_page_id": "c_group", "_href": "c/group"}, "c_random": {"notes": "Shannon's pioneering work [C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI] analyzes the distance distribution of the code given a rate. Given \\(N\\) and the rate \\(R\\), the minimum distance of a TRC is given by the GV bound \\(d=N\\delta_{GV}(2R)\\), where \\(\\delta_{GV} = h^{-1}(1-R)\\), \\(0\\le R \\le 1\\), and \\(\\delta_{GV}(x)=0\\) for all other \\(R\\). For a TLC, the minimum distance is given by \\(d=N\\delta_{GV}(R)\\).", "logical": "", "code_id": "random", "physical": "", "protection": "", "introduced": "[C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI]", "description": "Code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes, to codes whose multi-step construction is deterministic with the exception of a single step.\n\nTypically, random codes are selected with uniform distribution from some ensemble of codes. For example, a random binary code is a set of \\(2^{K}\\) codewords with length \\(N\\) chosen uniformly from the ensemble of all \\(2^N\\) bit-strings. Each bit in the codeword is randomly chosen between 0 and 1 with equal probability. For another example, a random binary linear code is generated from a random chosen \\(K\\) generators of length \\(N\\), where each bit of the generators is randomly chosen between 0 and 1 with equal probability. Equivalently, a random binary linear code is defined by a randomly generated \\(K\\) by \\(N\\) generator matrix, where each entry is randomly chosen between 0 and 1 with equal probability.\n\nIn both of the above random code constructions, the ensemble size scales exponentially with \\(N\\). A common convention is to think of the resulting code constructions as effectively explicit (as opposed to random) in cases where the ensemble size is independent of \\(N\\) or even when the size scales polynomially with \\(N\\).", "name": "Random code", "realizations": "Distributed storage systems [Yunfeng Lin, Ben Liang, and Baochun Li, \u201cPriority Random Linear Codes in Distributed Storage Systems\u201d, IEEE Transactions on Parallel and Distributed Systems 20, 1653 (2009). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Ball-collision decoding [D. J. Bernstein, T. Lange, and C. Peters, \u201cSmaller Decoding Exponents: Ball-Collision Decoding\u201d, Advances in Cryptology \u2013 CRYPTO 2011 743 (2011). DOI].\nFiniasz and Sendrier (FS-ISD) decoding [M. Finiasz and N. Sendrier, \u201cSecurity Bounds for the Design of Code-Based Cryptosystems\u201d, Advances in Cryptology \u2013 ASIACRYPT 2009 88 (2009). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Typical random codes (TRC) or typical random linear codes (TLC) refer to codes in the respective ensemble that satisfy a certain minimum distance. The relative fraction of typical codes in the ensemble approaches one as \\(N\\) goes to infinity [C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI] (see also Ref. [A. Barg and G. D. Forney, \u201cRandom codes: minimum distances and error exponents\u201d, IEEE Transactions on Information Theory 48, 2568 (2002). DOI]). Asymptotically, given distance \\(d\\), the maximum rate for a TRC is given by \\(R=\\frac{1}{2}R_{GV}(\\delta)\\) where \\(R_{GV}\\) is the Gilbert\u2013Varshamov (GV) bound \\(R_{GV}=1-h(\\delta)\\), and \\(h(\\delta)=h(\\frac{d}{n})\\) is the binary entropy function. The maximum rate for a TLC is given by \\(R=R_{GV}(d)\\), meaning that TLCs achieve the asymoptic GV bound.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "cousin_of_code_id": "expander_lifted_product\nfountain\njustesen\nquantum_random", "cousin_of_detail": "Expander lifted-product codes are quantum CSS codes that utilize short classical codes in their construction which need to satisfy some properties (Ref. [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654], Lemma 10). It is shown that such codes exist, but they are not explicitly constructed. Such codes can be obtained by repeated random sampling or by performing a search of all codes of desired length. Nevertheless, since the length of the desired short codes does not scale with \\(n\\), this construction is effectively explicit.\n\nThe required inner codes are obtained by random sampling from the Wozencraft ensemble, whose length scales logarithmically with \\(n\\).\n", "_type": "ecc", "_page_id": "c_random", "_href": "c/random"}, "c_evaluation_varieties": {"notes": "", "logical": "", "code_id": "evaluation_varieties", "physical": "", "protection": "Properties of \\(\\cal X\\) can be used to bound the code dimension \\(k\\) and distance \\(d\\). The order or Feng-Rao bound gives a lower bound on the distance of evaluation codes [O. Geil, \u201cEvaluation Codes from an Affine Variety Code Perspective\u201d, Series on Coding Theory and Cryptology 153 (2008). DOI][Gui-Liang Feng et al., \u201cSimplified understanding and efficient decoding of a class of algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 40, 981 (1994). DOI][G.-L. Feng and T. R. N. Rao, \u201cDecoding algebraic-geometric codes up to the designed minimum distance\u201d, IEEE Transactions on Information Theory 39, 37 (1993). DOI][J. Fitzgerald and R. F. Lax, \u201c[]\u201d, Designs, Codes and Cryptography 13, 147 (1998). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]; see Ref. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ch. 4 and Ref. [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349] for more discussion.", "introduced": "[S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI]", "description": "Code whose codewords are evaluations of functions at certain fixed points. Code properties can be inferred from the structure of the functions and the underlying geometric object containing the points, often using results from algebraic geometry.\n\nLet \\(\\cal{X}\\) be a geometric object that contains a subset \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right) \\) consisting of \\(n\\) points \\(P_j\\). Let \\(L\\) be a vector space over \\(GF(q)\\) of functions \\(f\\) that take values in \\(GF(q)\\). Each \\(f\\in L\\) yields a codeword of an evaluation code \\(C_L({\\cal X},{\\cal P})\\) of the form \\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right) \\quad\\quad\\forall f\\in L~.\n\\end{align} This is a linear binary or \\(q\\)-ary code since the functions \\(f\\) take values in \\(GF(q)\\) and form a vector space.\n\nExamples of geometric objects \\(\\cal X\\) include affine or projective spaces over \\(GF(q)\\) as well as subsets of those spaces determined by some constraints. Prominent subsets are algebraic varieties, i.e., sets of solutions of systems of polynomial equations in either affine or projective space. The functions \\(f\\) are typically polynomials or rational functions.", "name": "Evaluation code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "evaluation\nevaluation_polynomial", "parent_of_detail": "Evaluation AG codes are evaluation codes of rational functions \\(f\\) for which \\(\\cal X\\) is an algebraic curve, i.e., an algebraic variety of dimension one [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.].\nPolynomial evaluation codes are evaluation codes of polynomials \\(f\\) for which \\(\\cal X\\) is an algebraic variety.", "cousins_code_id": "q-ary_linear", "cousins_detail": "Evaluation codes are defined using polynomial or rational functions evaluated on a subset of affine or projective space. Given access to more general structures (i.e., morphisms of algebras), any \\(q\\)-ary linear code can be formulated as an evaluation code ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Sec. 4.1; [M. Tsfasman, S. Vl\u01cedu\u0163, and D. Nogin. Algebraic geometric codes: basic notions. Vol. 139. American Mathematical Society, 2022.], Prop. 1.1.4).", "cousin_of_code_id": "projective", "cousin_of_detail": "Codewords of an evaluation code of multivariate polynomials up to degree one evaluated at points in projective space yields a projective code.", "_type": "ecc", "_page_id": "c_evaluation_varieties", "_href": "c/evaluation_varieties"}, "c_mds": {"notes": "", "logical": "", "code_id": "mds", "physical": "", "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error-correction properties.", "introduced": "[R. Singleton, \u201cMaximum distance&amp;lt;tex&amp;gt;q&amp;lt;/tex&amp;gt;-nary codes\u201d, IEEE Transactions on Information Theory 10, 116 (1964). DOI]", "description": "A \\([n,k,d]_q\\) \\(q\\)-ary linear code is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Singleton bound \\begin{align}\nd \\leq n-k+1\n\\end{align} becomes an equality. A code is called almost MDS (AMDS) when \\(d=n-k\\). A bound for general \\(q\\)-ary codes can also be formulated; see Thm. 1.9.10 in Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI]. A code is near MDS (NMDS) if the code and its dual are mode AMDS.\n\nThe codes \\( [n,1,n]_q, [n,n-1,2]_q, [n,n,1]_q \\) for any \\(q\\) are MDS codes. These are called the trivial MDS codes. The only binary MDS codes are the trivial ones. ", "name": "Maximum distance separable (MDS) code", "realizations": "The McEliece Public Key Cryptosystem [McEliece, R.J.: A public-key cryptosystem based on algebraic coding theory. DSN Progress Report pp. 114\u2013116 (1978).] uses algebraic coding theory to secure communications against eavesdropping attack, in which private keys are generator matrices of linear codes, i.e., \\(G\\). Public Keys shared to outside world are scrambled and permutated versions of \\(G\\), i.e., \\(G^\\prime=SGP\\). Data to be encrypted, \\(u\\), is multiplied by public key and added intentional errors \\(e\\), i.e., \\(x=uG^\\prime+e\\). Upon receiving encrypted data, private key owner can apply inverse permutation \\(P^{-1}\\) to \\(x\\), decode the scrambled message given the presence of \\(e\\) errors, and finally unscramble to obtain \\(u\\). Security parameters of the system are \\(n\\) and \\(e\\), hence MDS codes, such as GRS codes may provide the same security level for shorter key sizes, and the private key owner can decode arguably fast enough using known decoding algorithms.\nAutomatic repeat request (ARQ) data transmission protocols ([S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 7).", "short_name": "MDS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "locally_recoverable", "parents_detail": "MDS codes are most efficient in terms of minimizing storage overhead for handling erasures. They are locally recoverable with locality \\(k\\).", "parent_of_code_id": "griesmer\nhexacode\nparity_check\ntetracode\nq-ary_parity_check", "parent_of_detail": "Singleton bound implies the Griesmer bound.\n\n\n\n", "cousins_code_id": "dual\nprojective", "cousins_detail": "A linear binary or \\(q\\)-ary \\([n,k,n-k+1]\\) code is MDS if and only if its dual \\([n,n-k,k+1]\\) is MDS ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 1.9.13).\nA linear code is MDS (almost MDS) if and only if columns of its parity-check matrix form an \\(n\\)-arc (\\(n\\)-track) in projective space [S. M. Dodunekov and I. N. Landgev, \u201cOn near-MDS codes\u201d, Proceedings of 1994 IEEE International Symposium on Information Theory. DOI][J. W. P. Hirschfeld and L. Storme, \u201cThe Packing Problem in Statistics, Coding Theory and Finite Projective Spaces: Update 2001\u201d, Developments in Mathematics 201 (2001). DOI]. The dual of a MDS code is an MDS code, so MDS codes are projective.", "cousin_of_code_id": "ag\nelliptic\nextended_reed_solomon\ngeneralized_reed_solomon\nmatrix_computation\nmaximum_rank_distance\nquantum_mds\nreed_solomon", "cousin_of_detail": "Near MDS \\([n,k,d]_{GF(p^m)}\\) AG codes exist when \\(n,p,m\\) satisfy certain relations according to the Tsfasman-Vladut bound [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI].\nElliptic codes can be MDS ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Ex. 15.5.3; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 310; [M. Tsfasman, S. Vl\u01cedu\u0163, and D. Nogin. Algebraic geometric codes: basic notions. Vol. 139. American Mathematical Society, 2022.], Sec. 4.4.2).\nAn MDS GRS code can be extended to an MDS code ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thm. 5.3.4). Extended and doubly extended narrow-sense RS codes are MDS ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thms. 5.3.2 and 5.3.4), and there is an equivalence between the two for odd prime \\(q\\) [S. Ball, \u201cOn sets of vectors of a finite vector space in which every subset of basis size is a basis\u201d, Journal of the European Mathematical Society 733 (2012). DOI].\nGRS codes have distance \\(n-k+1\\), saturating the Singleton bound.\nThe first matrix multiplication code encoded each entry of the matrices to be multiplied into an MDS code [K. Lee et al., \u201cSpeeding Up Distributed Machine Learning Using Codes\u201d, IEEE Transactions on Information Theory 64, 1514 (2018). DOI; 1512.02673].\nMRD codes are matrix-code analogues of MDS codes.\n\nRS codes have distance \\(n-k+1\\), saturating the Singleton bound. If \\(k \\leq p\\), then all linear MDS codes \\( [n,k,n-k+1]_{p^m} \\) are RS codes [S. Ball, \u201cOn sets of vectors of a finite vector space in which every subset of basis size is a basis\u201d, Journal of the European Mathematical Society 733 (2012). DOI].", "_type": "ecc", "_page_id": "c_mds", "_href": "c/mds"}, "c_covering": {"notes": "See book [G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, \"Covering codes\". Elsevier, 1997.] for an expositions on covering codes.", "logical": "", "code_id": "covering", "physical": "", "protection": "", "introduced": "", "description": "A code \\(C\\) in a metric space is covering if the union of balls of some radius centered at the codewords covers the entire space. For example, a \\(q\\)-ary code \\(C\\) is \\(\\rho\\)-covering if \\(\\forall v \\in GF(q)^{n}\\), there is a codeword \\(c \\in C\\) such that the Hamming distance \\(D(c,v)\\leq \\rho\\).\n\nThe covering radius \\(\\rho(C)\\) is the smallest non-negative integer \\(\\rho\\) such that \\(C\\) is \\(\\rho\\)-covering, i.e. \\begin{align}\n  \\rho(C)=\\max_{{v\\in GF(q)^{n}}}\\min_{{c\\in C}}d(v,c)~.\n\\end{align} For a linear code \\([n,k]_q\\), the covering radius is the minimum number of columns of the code's parity check matrix which cover \\(GF(q)^{n-k}\\).\n\nThe covering radius satisfies various inequalities. A code \\(C\\) with distance \\(d\\) satisfies the relation \\begin{align}\n  \\rho(C)\\geq \\frac{|d-1|}{2}~. \\label{eq:perfect-ref}\n\\end{align} Linear \\([n,k]_q\\) codes also satisfy the redundancy bound \\begin{align}\n  \\rho(C)\\leq n-k\n\\end{align} and the sphere covering bound \\begin{align}\n  \\rho(C)\\leq \\min{\\left(p~\\bigg\\rvert \\sum_{i=0}^{p} {n \\choose i}(q-1)^{i}|C| \\geq q^{n}\\right)}~. \\label{eq:spherepacking-perfect-label}\n\\end{align} A code is perfect iff it satisfies Eqs. \\(\\eqref{eq:perfect-ref}\\) and \\(\\eqref{eq:spherepacking-perfect-label}\\) with equality.\n\nIn general, finding the covering radius of a given code is difficult. Complexity analysis as well as an extensive study on bounds can be found in Ref. [G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering Codes, Elsevier (1997).].", "name": "Covering code", "realizations": "Data compression both with or without compression [G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering Codes, Elsevier (1997).].\nFootball-pool problem: finding the smallest number of bets on a set of matches needed to guarantee at least one bet has at most \\(\\rho\\) errors [H. Hamalainen et al., \u201cFootball Pools--A Game for Mathematicians\u201d, The American Mathematical Monthly 102, 579 (1995). DOI][A. Barg, \u201cAt the Dawn of the Theory of Codes\u201d, The Mathematical Intelligencer 15, 20 (1993). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "weighed_covering", "parents_detail": "An \\(m\\)-weighed covering code for \\(m_j=1\\) is a covering code of covering radius at most \\(r\\) ([G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.], Ch. 13).", "parent_of_code_id": "perfect", "parent_of_detail": "Perfect codes are covering codes with minimum number of codewords", "_type": "ecc", "_page_id": "c_covering", "_href": "c/covering"}, "c_quasi_perfect": {"notes": "", "logical": "", "code_id": "quasi_perfect", "physical": "", "protection": "Correct errors of weight \\(t\\) as well as some errors of weight \\(t+1\\).", "introduced": "", "description": "Perfect codes \\((n,K,d)_q\\) are those for which balls of Hamming radius \\(t=\\left\\lfloor (d-1)/2\\right\\rfloor\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings. Quasi-perfect codes are those for which balls of Hamming radius \\(t\\) are disjoint, while balls of radius \\(t+1\\) cover the space with possible overlaps. In other words, any \\(q\\)-ary string is at most \\(t+1\\) bit flips away from a codeword of a quasi-perfect code. ", "name": "Quasi-perfect code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "weighed_covering", "parents_detail": "A quasi-perfect code is an \\(m\\)-weighed covering code for \\(r=t+1\\), \\(m_0=m_1=\\cdots=m_{t+1}=1\\), and \\(m_t=m_{t+1}=1/\\left\\lfloor (n+1)(t+1) \\right\\rfloor\\) ([G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.], Ch. 13).", "parent_of_code_id": "nearly_perfect\nzetterberg", "parent_of_detail": "Nearly perfect codes are quasi-perfect ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 533).\nZetterberg codes are quasi-perfect, with each \\(n\\)-bit string at most three bit-flips away from a codeword [S. M. Dodunekov and J. E. M. Nilsson, \u201cAlgebraic decoding of the Zetterberg codes\u201d, IEEE Transactions on Information Theory 38, 1570 (1992). DOI].", "cousin_of_code_id": "bch", "cousin_of_detail": "Only double error-correcting BCH codes \\([2^m-1,n-2m,5]\\) are quasi-perfect [D. Gorenstein, W. W. Peterson, and N. Zierler, \u201cTwo-error correcting Bose-Chaudhuri codes are quasi-perfect\u201d, Information and Control 3, 291 (1960). DOI][T. Helleseth, \u201cNo primitive binary&amp;lt;tex&amp;gt;t&amp;lt;/tex&amp;gt;-error-correcting BCH code with&amp;lt;tex&amp;gt;t &amp;gt; 2&amp;lt;/tex&amp;gt;is quasi-perfect (Corresp.)\u201d, IEEE Transactions on Information Theory 25, 361 (1979). DOI] (see also Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 9).", "_type": "ecc", "_page_id": "c_quasi_perfect", "_href": "c/quasi_perfect"}, "c_perfect": {"notes": "", "description": "An \\((n,K,2t+1)_q\\) binary or \\(q\\)-ary code is perfect if parameters \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the Hamming (a.k.a. sphere-packing) bound \\begin{align}\n\\sum_{j=0}^{t}(q-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align} becomes an equality. For example, for a binary \\(q=2\\) code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\). Perfect codes are those for which balls of Hamming radius \\(t\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings.\n\nAny perfect linear code is either a repetition code, a Hamming code, or a binary or ternary Golay code [K. Lindstr\u00f6m, \u201cAll nearly perfect codes are known\u201d, Information and Control 35, 40 (1977). DOI]. If \\(q\\) is a prime power, any distance-three code is either a Hamming code or a nonlinear code with the same parameters; see Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 100, for more details.\n\nFor binary codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit, \\begin{align}\n\\frac{k}{n}\\leq 1-h(t/n),\n\\end{align} where \\(h\\) is the binary entropy function.", "name": "Perfect code", "code_id": "perfect", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "covering\nnearly_perfect", "parents_detail": "Perfect codes are covering codes with minimum number of codewords\nPerfect codes are nearly perfect codes, and \\(t+1\\) divides \\(n-t\\) for such codes. In addition, any perfect code can be extended to a nearly perfect code.", "parent_of_code_id": "golay\nhamming\nternary_golay\nq-ary_hamming", "parent_of_detail": "The Golay code is perfect.\n\nThe ternary Golay code is perfect.\n", "cousin_of_code_id": "homological_classical\nquantum_perfect\nrepetition", "cousin_of_detail": "A family of homology codes saturate the asymptotic Hamming bound [H. Bombin and M. A. Martin-Delgado, \u201cHomological error correction: Classical and quantum codes\u201d, Journal of Mathematical Physics 48, 052105 (2007). DOI; quant-ph/0605094].\nA classical (quantum) perfect code saturates the classical (quantum) Hamming bound.\nRepetition codes are perfect for odd \\(n\\).", "_type": "ecc", "_page_id": "c_perfect", "_href": "c/perfect"}, "c_weighed_covering": {"notes": "See book [G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.] for an expositions on weighed covering codes and generalized sphere-packing bounds.\nSee book [J. H. van Lint, Introduction to Coding Theory (Springer Berlin Heidelberg, 1992). DOI], Table 7.5.18 for tables of codes with particular weighed coverings.", "logical": "", "code_id": "weighed_covering", "physical": "", "protection": "", "introduced": "", "description": "A binary or \\(q\\)-ary code for which balls of some radius centered at its codewords provide a weighted covering of the Hamming space.\n\nLet the outer or weight distribution of a \\(q\\)-ary string \\(x\\) with respect to a \\(q\\)-ary code \\(C\\) be \\(A(x) = \\left( A_0(x),A_1(x),\\cdots,A_n(x) \\right)\\), where \\begin{align}\n  A_j(x) = \\left|\\{ c \\in C~\\text{such that}~ D(c,x)=j \\}\\right|~,\n\\end{align} and \\(D\\) is the Hamming distance. Given a tuple \\(m=(m_1,m_2,\\cdots,m_n)\\) of rational numbers, the \\(m\\)-density of the code at \\(x\\) is \\begin{align}\n  \\theta(x) = \\sum_{j=0}^n m_j A_j(x)~.\n\\end{align}\n\nA code is an \\(m\\)-weighed covering if \\(\\theta(x)\\geq1\\) for all strings \\(x\\in GF(q)^n\\). The \\(m\\)-covering radius \\(r\\) is the largest \\(j\\) for which \\(m_j\\) is nonzero.", "name": "Weighed-covering code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "covering\nquasi_perfect", "parent_of_detail": "An \\(m\\)-weighed covering code for \\(m_j=1\\) is a covering code of covering radius at most \\(r\\) ([G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.], Ch. 13).\nA quasi-perfect code is an \\(m\\)-weighed covering code for \\(r=t+1\\), \\(m_0=m_1=\\cdots=m_{t+1}=1\\), and \\(m_t=m_{t+1}=1/\\left\\lfloor (n+1)(t+1) \\right\\rfloor\\) ([G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.], Ch. 13).", "_type": "ecc", "_page_id": "c_weighed_covering", "_href": "c/weighed_covering"}, "c_nearly_perfect": {"notes": "", "logical": "", "code_id": "nearly_perfect", "physical": "", "protection": "", "introduced": "[J. M. Goethals and S. L. Snover, \u201cNearly perfect binary codes\u201d, Discrete Mathematics 3, 65 (1972). DOI][N. V. Semakov, V. A. Zinov'ev, G. V. Zaitsev, \u201cUniformly Packed Codes\u201d, Probl. Peredachi Inf., 7:1 (1971), 38\u201350; Problems Inform. Transmission, 7:1 (1971), 30\u201339]", "description": "An \\((n,K,2t+1)\\) binary code is nearly perfect if parameters \\(n\\), \\(K\\), and \\(t\\) are such that the Johnson bound \\begin{align}\n  \\frac{{n \\choose t}\\left(\\frac{n-t}{t+1}-\\left\\lfloor \\frac{n-t}{t+1}\\right\\rfloor \\right)}{\\left\\lfloor \\frac{n}{t+1}\\right\\rfloor }+\\sum_{j=0}^{t}{n \\choose j}\\leq2^{n}/K\n\\end{align} becomes an equality ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Sec. 2.3.5; see also Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 17). All nearly perfect binary codes are either perfect, or correspond to either punctured Preparata codes or one of the \\(2^r-2,2^{2^r-2-r},3)\\) codes for \\(r\\geq 3\\) [Kauko Lindstr\u00f6m. \"The nonexistence of unknown nearly perfect binary codes.\" PhD diss., Turun yliopisto, 1975.].\n\nSimilar definitions can be made for \\(q\\)-ary codes, but all nearly perfect \\(q\\)-ary codes must be perfect [K. Lindstrom and M. J. Aaltonen, \"The nonexistence of nearly perfect nonbinary codes for 1 =< e =< 10\", Ann. Univ. Turku, Ser. A I, No. 172, 1976.][K. Lindstr\u00f6m, \u201cAll nearly perfect codes are known\u201d, Information and Control 35, 40 (1977). DOI].", "name": "Nearly perfect code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "quasi_perfect", "parents_detail": "Nearly perfect codes are quasi-perfect ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 533).", "parent_of_code_id": "parity_check\nperfect\nrepetition", "parent_of_detail": "\nPerfect codes are nearly perfect codes, and \\(t+1\\) divides \\(n-t\\) for such codes. In addition, any perfect code can be extended to a nearly perfect code.\n", "cousin_of_code_id": "golay\nhamming", "cousin_of_detail": "The extended Golay code is nearly perfect.\nShortened Hamming codes \\([2^r-2,2^r-r-2,3]\\) are nearly perfect ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 533).", "_type": "ecc", "_page_id": "c_nearly_perfect", "_href": "c/nearly_perfect"}, "c_cyclic": {"notes": "", "logical": "", "code_id": "cyclic", "physical": "", "protection": "", "introduced": "[E. Prange, Cyclic Error-Correcting Codes in Two Symbols, TN-57-/03, (September 1957)][E. Prange, Some cyclic error-correcting codes with simple decoding algorithms, TN-58-156, (April 1958)][E. Prange, The use of coset equivalence in the analysis and decoding of group codes, TN-59-/64, (1959)][E. Prange, An algorithm for factoring xn - I over a finite field. TN-59-/75, (October 1959)][W. W. Peterson and E. J. Weldon, Error-correcting codes. MIT press 1972.]", "description": "A code of length \\(n\\) over an alphabet is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword.\n\nCyclic-to-polynomial correspondence\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCyclic-to-polynomial correspondence: Binary and \\(q\\)-ary cyclic codes and their properties can be naturally formulated using the theory of polynomials. Cyclic codes correspond to ideals in a particular polynomial ring. Codewords \\(c_1 c_2 \\cdots c_n\\) of a \\(q\\)-ary Galois-field code can be thought of as coefficients in a polynomial \\(c_1+c_2 x+\\cdots+c_n x^{n-1}\\) in the set of polynomials with \\(q\\)-ary coefficients, \\(\\mathbb{F}_q[x]\\) with \\(\\mathbb{F}_q=GF(q)\\). Polynomials corresponding to codewords of a linear cyclic code form an ideal (i.e., are closed under multiplication and addition) in the ring \\(\\mathbb{F}_q[x]/(x^n-1)\\) (i.e., the set of equivalence classes of polynomials congruent modulo \\(x^n-1\\)). Multiplication of a codeword polynomial \\(c(x)\\) by \\(x\\) in such a ring corresponds to a cyclic shift of the corresponding codeword string.\n\nCodeword polynomials of a cyclic code can be generated, via multiplication, by a generator polynomial \\(g(x)\\). A particular generator polynomial \\(e(x)\\) has the additional property of being idempotent, i.e., \\(e(x)^2=e(x)\\). Given a generator polynomial, the corresponding check polynomial \\(h(x)=(x^n-1)/g(x)\\) yields zero when multiplying a codeword polynomial. Its coefficients correspond to the code's parity check matrix.\n\nSince the generator polynomial \\(g(x)\\) is a polynomial over \\(GF(q)\\), it can be factorized over some potentially larger splitting field (just like \\(x^2+1\\) can be factorized over the complex numbers but not the reals). Whenever \\(q\\) and \\(n\\) are relatively prime, cyclic codes can also be defined in terms of roots of \\(g(x)\\). Such roots are called zeroes of the code, and they are all powers of a primitive \\(n\\)th root of unity because \\(g(x)\\) is a divisor of \\(x^n-1\\). Since the generator polynomial generates all codeword polynomials \\(c(x)\\) by multiplication by \\(x\\), its zeroes are also zeroes of those polynomials.", "name": "Cyclic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "quasi_cyclic", "parents_detail": "Quasi-cyclic codes with \\(\\ell=1\\) are cyclic.", "parent_of_code_id": "q-ary_cyclic\nbinary_cyclic", "parent_of_detail": "\n", "cousin_of_code_id": "octacode\nquantum_cyclic", "cousin_of_detail": "The octacode is a cyclic code over \\(\\mathbb{Z}_4\\) with generator polynomial \\(x^2+3x^2+2x+3\\) extended by a parity check [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI].\n", "_type": "ecc", "_page_id": "c_cyclic", "_href": "c/cyclic"}, "c_skew_cyclic": {"notes": "Computer algebra software is used to find most codes of this type. Ref. [Delphine Boucher, Willi Geiselmann, and F\u00e9lix Ulmer, \u201cSkew-cyclic codes\u201d. math/0604603] gives several examples of codes, which have slightly improved minimum distance for some \\((n,k)\\) codes.", "logical": "", "code_id": "skew_cyclic", "physical": "", "protection": "", "introduced": "[Delphine Boucher, Willi Geiselmann, and F\u00e9lix Ulmer, \u201cSkew-cyclic codes\u201d. math/0604603]", "description": "A classical code \\(C\\) of length \\(n\\) over an alphabet \\(R\\) is skew-cyclic if there exists an automorphism, \\(\\theta\\), of \\(R\\), such that for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the skew-cyclically shifted string \\(\\theta(c_n) \\theta(c_1) \\cdots \\theta(c_{n-1})\\in C\\). We say that \\(C\\) is a \\(\\theta\\)-cyclic code over \\(R\\).", "name": "Skew-cyclic code", "realizations": "Not directly implemented, but BCH codes form a subclass, and are used in DVD, solid state drive storage, etc.", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Only given for skew-BCH codes, adapted froom standard BCH codes.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "quasi_cyclic", "parents_detail": "Under certain conditions, there is an equivalent quasi-cyclic code for every skew-cyclic code [I. Siap et al., \u201cSkew cyclic codes of arbitrary length\u201d, International Journal of Information and Coding Theory 2, 10 (2011). DOI].", "cousin_of_code_id": "skew-cyclic_galois_css", "cousin_of_detail": "Skew-cyclic CSS codes are constructed from classical skew-cylic codes.", "_type": "ecc", "_page_id": "c_skew_cyclic", "_href": "c/skew_cyclic"}, "c_quasi_cyclic": {"notes": "A database of quasi-cyclic codes with searchable parameters such as block length and dimension is constructed and displayed here.", "logical": "", "code_id": "quasi_cyclic", "physical": "", "protection": "", "introduced": "[R. Townsend and E. Weldon, \u201cSelf-orthogonal quasi-cyclic codes\u201d, IEEE Transactions on Information Theory 13, 183 (1967). DOI]", "description": "A code \\(C\\) of length \\(n\\) over an alphabet is quasi-cyclic if, for each codeword \\(c_1 \\cdots c_{\\ell} c_{\\ell+1} \\cdots c_n\\), the string \\(c_{n-\\ell+1} \\cdots c_n c_1 \\cdots c_{n-\\ell}\\) where each entry is cyclically shifted by \\(\\ell\\) increments is also a codeword.\n\nThe generator of an \\([mn_0,mk_0]\\) quasi-cyclic linear code is representable as a block matrix of \\(m \\times m\\) circulant matrices [Thomas A. Gulliver, Construction of quasi-cyclic codes, Thesis, University of New Brunswick, 1989.].", "name": "Quasi-cyclic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "cyclic\nskew_cyclic", "parent_of_detail": "Quasi-cyclic codes with \\(\\ell=1\\) are cyclic.\nUnder certain conditions, there is an equivalent quasi-cyclic code for every skew-cyclic code [I. Siap et al., \u201cSkew cyclic codes of arbitrary length\u201d, International Journal of Information and Coding Theory 2, 10 (2011). DOI].", "_type": "ecc", "_page_id": "c_quasi_cyclic", "_href": "c/quasi_cyclic"}, "c_parallel_concatenated": {"notes": "", "logical": "", "code_id": "parallel_concatenated", "physical": "", "protection": "", "introduced": "", "description": "Stub.", "name": "Parallel concatenated code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "tanner", "parent_of_detail": "", "cousins_code_id": "concatenated", "cousins_detail": "", "_type": "ecc", "_page_id": "c_parallel_concatenated", "_href": "c/parallel_concatenated"}, "c_generalized_concatenated": {"notes": "", "logical": "", "code_id": "generalized_concatenated", "physical": "", "protection": "", "introduced": "", "description": "Stub.", "name": "Generalized concatenated code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "concatenated\njustesen\npolar\ntensor", "parent_of_detail": "\nJustesen codes can be considered as a generalized concatenation of a Reed-Solomon outer code with \\(N\\) distinct binary inner codes.\nPolar codes can be represented as generalized concatenations of their kernels.\n", "_type": "ecc", "_page_id": "c_generalized_concatenated", "_href": "c/generalized_concatenated"}, "c_concatenated": {"notes": "", "logical": "", "code_id": "concatenated", "physical": "", "protection": "", "introduced": "[G. D. Forney, Jr (1966). Concatenated Codes. MIT Press, Cambridge, MA.]", "description": "Also called a serially concatenated code [A. Barg and G. Zemor, \u201cConcatenated Codes: Serial and Parallel\u201d, IEEE Transactions on Information Theory 51, 1625 (2005). DOI]. Stub.", "name": "Concatenated code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Generalized minimum-distance decoding [G. Forney, \u201cGeneralized minimum distance decoding\u201d, IEEE Transactions on Information Theory 12, 125 (1966). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_concatenated", "parents_detail": "", "cousins_code_id": "quantum_concatenated", "cousins_detail": "", "cousin_of_code_id": "parallel_concatenated", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_concatenated", "_href": "c/concatenated"}, "c_codes_with_availability": {"notes": "", "description": "Stub.", "name": "Availability code", "code_id": "codes_with_availability", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "parallel_recovery", "parents_detail": "", "_type": "ecc", "_page_id": "c_codes_with_availability", "_href": "c/codes_with_availability"}, "c_parallel_recovery": {"notes": "", "description": "Stub.", "name": "Parallel-recovery code", "code_id": "parallel_recovery", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "sequential_recovery", "parents_detail": "", "parent_of_code_id": "codes_with_availability", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_parallel_recovery", "_href": "c/parallel_recovery"}, "c_distributed_storage": {"notes": "", "logical": "", "code_id": "distributed_storage", "physical": "", "protection": "", "introduced": "", "description": "Designed to encode information into spatial nodes such that it is possible to recover said information after failure of some nodes by accessing the remaining nodes with minimal bandwidth. Stub.", "name": "Distributed-storage code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "locally_recoverable\nregenerating", "parent_of_detail": "\n", "cousin_of_code_id": "fountain\ngeneralized_reed_solomon", "cousin_of_detail": "There are proposals [Megasthenis Asteris and Alexandros G. Dimakis, \u201cRepairable Fountain Codes\u201d. 1401.0734][Michael G. Luby et al., \u201cLiquid Cloud Storage\u201d. 1705.07983] adapting fountain codes to distributed storage systems.\nGRS codes are used in various cloud storage systems [H. Dau et al., \u201cRepairing Reed-Solomon Codes With Multiple Erasures\u201d, IEEE Transactions on Information Theory 64, 6567 (2018). DOI; 1612.01361].", "_type": "ecc", "_page_id": "c_distributed_storage", "_href": "c/distributed_storage"}, "c_sequential_recovery": {"notes": "", "description": "Stub.", "name": "Sequential-recovery code", "code_id": "sequential_recovery", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "locally_recoverable", "parents_detail": "", "parent_of_code_id": "parallel_recovery", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_sequential_recovery", "_href": "c/sequential_recovery"}, "c_locally_recoverable": {"notes": "", "logical": "", "code_id": "locally_recoverable", "physical": "", "protection": "The distance, \\(d\\), of an \\((n,k,r)\\) LRC code satisfies \\begin{align} d\\leq n-k-\\left \\lceil\\frac{k}{r}\\right \\rceil+2~,\\label{eq:gen-singleton} \\end{align} where \\(r\\leq k\\). When \\(k=r\\), the bound on the distance gives the Singleton bound. The generalized Singleton bound \\(\\eqref{eq:gen-singleton}\\) does not account for \\(q\\)-ary alphabet size. A more generalized bound (including the non-linear case) is given in Ref. [V. R. Cadambe and A. Mazumdar, \u201cBounds on the Size of Locally Recoverable Codes\u201d, IEEE Transactions on Information Theory 61, 5787 (2015). DOI].", "introduced": "", "description": "Any code for which, given a codeword \\(x\\) and coordinate \\(i\\), \\(x_i\\) can be recovered from (at most \\(r\\)) other coordinates of \\(x\\). An \\(r\\)-locally recoverable code of length \\(n\\) and dimension \\(k\\) is denoted as an \\((n,k,r)\\) LRC code.\n\nMore technically, a \\(q\\)-ary code \\(C\\) with length \\(n\\) is \\(r\\)-locally recoverable, or has locality \\(r\\), if \\(\\forall i \\in [n]\\), there exists \\(I_i \\subset [n]\\setminus i\\) such that \\(|I_i|\\leq r\\), and the projection of the set \\(\\mathcal{C}(i,a)=\\{x\\in C : x_i=a\\}\\) on to the coordinates in \\(I_i\\), i.e., \\(\\mathcal{C}_{I_i}(i,a)\\) is disjoint from \\(\\mathcal{C}_{I_i}(i,a^\\prime)\\) where \\(a\\neq a^\\prime\\).\n\nThe definition can be generalized to \\(t\\)-LRC code, if every coordinate is recoverable from \\(t\\) disjoint subsets of coordinates. A study on the parameters of \\(t\\)-LRC codes, together with known bounds, can be found in Ref. [I. Tamo, A. Barg, and A. Frolov, \u201cBounds on the Parameters of Locally Recoverable Codes\u201d, IEEE Transactions on Information Theory 62, 3070 (2016). DOI].", "name": "Locally recoverable code (LRC)", "realizations": "An \\((18,14,7)\\) LRC code has beed used in the Windows Azure cloud storage system [C. Huang, H. Simitci, Y. Xu, A. Ogus, B. Calder, P. Gopalan, J. Li, and S. Yekhanin. Erasure coding in Windows Azure Storage. In Proc. USENIX Annual Technical Conference (ATC), pgs. 15-26, Boston, Massachusetts, June 2012.]; see also Sec. 31.3.1.2 in Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI].", "short_name": "LRC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The rate \\(r\\) of an \\((n,k,r)\\) LRC code satisfies \\begin{align} \\frac{k}{n}\\leq\\frac{r}{r+1}~. \\end{align}", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "distributed_storage", "parents_detail": "", "parent_of_code_id": "batch\nmds\nsequential_recovery", "parent_of_detail": "A systematic batch code with restricted size of reconstruction sets can recover any query of \\(t\\) information symbols with recovery sets of size \\(r\\) [V. Skachek, \u201cBatch and PIR Codes and Their Connections to Locally Repairable Codes\u201d, Network Coding and Subspace Designs 427 (2018). DOI][A.-E. Riet, V. Skachek, and E. K. Thomas, \u201cBatch Codes for Asynchronous Recovery of Data\u201d, IEEE Transactions on Information Theory 68, 1545 (2022). DOI].\nMDS codes are most efficient in terms of minimizing storage overhead for handling erasures. They are locally recoverable with locality \\(k\\).\n", "_type": "ecc", "_page_id": "c_locally_recoverable", "_href": "c/locally_recoverable"}, "c_balanced": {"notes": "", "logical": "", "code_id": "balanced", "physical": "", "protection": "Can detect unidirectional errors, such as a zero going to a one.", "introduced": "[D. Knuth, \u201cEfficient balanced codes\u201d, IEEE Transactions on Information Theory 32, 51 (1986). DOI]", "description": "An even-length-\\(n\\) binary or \\(q\\)-ary code whose codewords all have a Hamming weight of \\(n/2\\). ", "name": "Balanced code", "realizations": "Balanced length-eight code, known as a 6b/8b encoding, used for balancing direct current in a communications system [K. A. S. Immink. Codes for mass data storage systems. Shannon Foundation Publisher, 2004.]", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Efficient decoder [D. Knuth, \u201cEfficient balanced codes\u201d, IEEE Transactions on Information Theory 32, 51 (1986). DOI][S. Al-Bassam and B. Bose, \u201cOn balanced codes\u201d, IEEE Transactions on Information Theory 36, 406 (1990). DOI][K. A. Schouhamer Immink and J. H. Weber, \u201cVery Efficient Balanced Codes\u201d, IEEE Journal on Selected Areas in Communications 28, 188 (2010). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Efficient encoder [D. Knuth, \u201cEfficient balanced codes\u201d, IEEE Transactions on Information Theory 32, 51 (1986). DOI].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "constant_weight", "parents_detail": "", "parent_of_code_id": "hadamard", "parent_of_detail": "Each Hadamard codeword has length \\(2^m\\) and Hamming weight of \\(2^{m-1}\\), making this code balanced.", "_type": "ecc", "_page_id": "c_balanced", "_href": "c/balanced"}, "c_divisible": {"notes": "See Ref. [K. Betsumiya and A. Munemasa, \u201cOn triply even binary codes\u201d, Journal of the London Mathematical Society 86, 1 (2012). DOI; 1012.4134] for an introduction to triply even binary linear codes and their construction from doubly even codes.", "logical": "", "code_id": "divisible", "physical": "", "protection": "", "introduced": "[H. N. Ward, \u201cDivisible codes\u201d, Archiv der Mathematik 36, 485 (1981). DOI]", "description": "A linear binary or \\(q\\)-ary code is \\(\\Delta\\)-divisible if the Hamming weight of each of its codewords is divisible by divisor \\(\\Delta\\). A \\(2\\)-divisible (\\(4\\)-divisible) code is called even (doubly even) [Sascha Kurz, \u201cDivisible Codes\u201d. 2112.11763]. A code is called singly even if all codewords are even and at least one has weight equal to 2 modulo 4.", "name": "Divisible code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "constant_weight\nparity_check\nreed_muller", "parent_of_detail": "Codes whose codewords have a constant weight of \\(m\\) are automatically \\(m\\)-divisible.\nBinary parity-check codes are two-divisible.\nAn RM\\((r,m)\\) code is \\(2^{\\left\\lceil m/r\\right\\rceil-1}\\)-divisible, according to McEliece's theorem [R. J. McEliece, \u201cOn periodic sequences from GF(q)\u201d, Journal of Combinatorial Theory, Series A 10, 80 (1971). DOI][R. J. McEliece, \u201cWeight congruences for p-ary cyclic codes\u201d, Discrete Mathematics 3, 177 (1972). DOI].", "cousin_of_code_id": "dual\ngriesmer\nquantum_divisible\nternary_golay", "cousin_of_detail": "Binary self-dual codes are singly-even.\nGriesmer codes over prime fields are divisible [H. N. Ward, \u201cDivisibility of Codes Meeting the Griesmer Bound\u201d, Journal of Combinatorial Theory, Series A 83, 79 (1998). DOI].\nQuantum divisible codes are constructed via the CSS construction using a divisible linear binary code.\nExtended ternary Golay code is 3-divisible ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 296).", "_type": "ecc", "_page_id": "c_divisible", "_href": "c/divisible"}, "c_constant_weight": {"notes": "Tables of binary constant-weight codes for \\(n \\leq 28\\) [A. E. Brouwer et al., \u201cA new table of constant weight codes\u201d, IEEE Transactions on Information Theory 36, 1334 (1990). DOI] and \\(n > 28\\) [D. H. Smith, L. A. Hughes, and S. Perkins, \u201cA New Table of Constant Weight Codes of Length Greater than 28\u201d, The Electronic Journal of Combinatorics 13, (2006). DOI].\nSee book [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for (Johnson) bounds on the size of constant-weight codes.", "logical": "", "code_id": "constant_weight", "physical": "", "protection": "", "introduced": "", "description": "Also known as an \\(m\\)-in-\\(n\\) or \\({n \\choose m}\\) code. A linear binary or \\(q\\)-ary code whose codewords all have the same Hamming weight. ", "name": "Constant-weight code", "realizations": "Radio-network frequency hopping [D. H. Smith, L. A. Hughes, and S. Perkins, \u201cA New Table of Constant Weight Codes of Length Greater than 28\u201d, The Electronic Journal of Combinatorics 13, (2006). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "divisible", "parents_detail": "Codes whose codewords have a constant weight of \\(m\\) are automatically \\(m\\)-divisible.", "parent_of_code_id": "balanced\none_hot\nsimplex\nweight_two", "parent_of_detail": "\n\nAll non-zero simplex codewords have a constant weight of \\(q^{k-1}\\).\n", "cousins_code_id": "constant_excitation", "cousins_detail": "Constant-weight codes are classical analogues of qubit constant-excitation codes.", "_type": "ecc", "_page_id": "c_constant_weight", "_href": "c/constant_weight"}, "c_rings_into_rings": {"notes": "", "logical": "rings", "code_id": "rings_into_rings", "physical": "rings", "protection": "", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates over a ring \\(R\\).", "name": "Ring code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "rings_linear", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_rings_into_rings", "_href": "c/rings_into_rings"}, "c_quaternary_over_z4": {"notes": "", "logical": "rings", "code_id": "quaternary_over_z4", "physical": "rings", "protection": "", "introduced": "", "description": "A linear code encoding \\(K\\) states (codewords) in \\(n\\) coordinates over the ring \\(\\mathbb{Z}_4\\) of integers modulo 4.", "name": "Quaternary code over \\(\\mathbb{Z}_4\\)", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "rings_linear", "parents_detail": "", "parent_of_code_id": "octacode\nreed_muller", "parent_of_detail": "\nRM codes are images of ring-linear quaternary codes under the Gray map ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 6.3).", "_type": "ecc", "_page_id": "c_quaternary_over_z4", "_href": "c/quaternary_over_z4"}, "c_octacode": {"notes": "", "logical": "rings", "code_id": "octacode", "physical": "rings", "protection": "", "introduced": "[J. H. Conway and N. J. A. Sloane, \u201cSelf-dual codes over the integers modulo 4\u201d, Journal of Combinatorial Theory, Series A 62, 30 (1993). DOI][J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI][E. M. Rains and N. J. A. Sloane, \u201cSelf-Dual Codes\u201d. math/0208001]", "description": "The unique self-dual linear code of length 8 over \\(\\mathbb{Z}_4\\) with generator matrix \\begin{align}\n  \\begin{pmatrix}\n  3 & 3 & 2 & 3 & 1 & 0 & 0 & 0\\\\\n  3 & 0 & 3 & 2 & 3 & 1 & 0 & 0\\\\\n  3 & 0 & 0 & 3 & 2 & 3 & 1 & 0\\\\\n  3 & 0 & 0 & 0 & 3 & 2 & 3 & 1\n  \\end{pmatrix}\\,.\n\\end{align} ", "name": "Octacode", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "quaternary_over_z4", "parents_detail": "", "cousins_code_id": "cyclic\nhamming\ndual_additive", "cousins_detail": "The octacode is a cyclic code over \\(\\mathbb{Z}_4\\) with generator polynomial \\(x^2+3x^2+2x+3\\) extended by a parity check [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI].\nThe octacode reduces modulo-two to the \\([8,4,4]\\) Hamming code [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI].\nThe octacode is self-dual with respect to the Euclidean inner product.", "_type": "ecc", "_page_id": "c_octacode", "_href": "c/octacode"}, "c_rings_linear": {"notes": "", "logical": "rings", "code_id": "rings_linear", "physical": "rings", "protection": "", "introduced": "", "description": "A code of length \\(n\\) over a ring \\(R\\) is \\(R\\)-linear if it is a submodule of \\(R^n\\).", "name": "\\(R\\)-linear code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "rings_into_rings\nlinear", "parents_detail": "\n", "parent_of_code_id": "quaternary_over_z4", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_rings_linear", "_href": "c/rings_linear"}, "c_points_into_lattices": {"notes": "", "logical": "points", "code_id": "points_into_lattices", "physical": "", "protection": "", "introduced": "", "description": "Encodes states (codewords) in coordinates of a lattice in the \\(n\\)-dimensional real coordinate space \\(\\mathbb{R}^n\\). The number of codewords may be infinite because the coordinate space is infinite-dimensional, so various restricted versions have to be constructed in practice. Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.", "name": "Lattice-based code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "Error-correcting codes are defined for a finite alphabet, so only finite lattice-based codes are children.", "parent_of_code_id": "niset_andersen_cerf", "parent_of_detail": "The Niset-Andersen-Cerf code encodes two coherent states at a time with arbitrary complex values, making it analogous to a lattice-based (classical) code encoding two points in \\(\\mathbb{R}^2\\). The code does not encode any quantum information since superpositions of the coherent states are not stored.", "cousins_code_id": "linear", "cousins_detail": "Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.", "cousin_of_code_id": "group_classical\nmultimodegkp", "cousin_of_detail": "Group-based codes whose alphabet is based on the group \\(\\mathbb{R}\\) are lattice-based codes.\nMultimode GKP codes are quantum analogues of lattice-based codes.", "_type": "ecc", "_page_id": "c_points_into_lattices", "_href": "c/points_into_lattices"}, "c_convolutional": {"notes": "", "logical": "bits", "code_id": "convolutional", "physical": "bits", "protection": "", "introduced": "[Peter Elias. Coding for noisy channels. IRE Convention Records, 3(4):37\u201346, 1955.]", "description": "Classical codes that are formed using generator polynomials over the finite field with two elements. The encoder slides across contiguous subsets of the input bit-string (like a convolutional neural network) evaluating the polynomials on that window to obtain a number of parity bits. These parity bits are the encoded information. There are many ways to formulate these codes", "name": "Convolutional code", "realizations": "A type of convolutional code used in Real-time Application networks [S. I. Mrutu, A. Sam, and N. H. Mvungi, \u201cForward Error Correction Convolutional Codes for RTAs' Networks: An Overview\u201d, International Journal of Computer Network and Information Security 6, 19 (2014). DOI].\nMobile and radio communications (3G networks) use convolutional codes concatenated with Reed-Solomon codes to obtain suitable performance [T. Halonen, J. Romero, and J. Melero, editors , GSM, GPRS and EDGE Performance (Wiley, 2003). DOI].\nA convolutional code with rate 1/2 was used for deep-space and satellite communication [Butman, Deutsch, and Miller. Performance of concatenated codes for deep space missions. 1981.]", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoders based on the Viterbi algorithm (trellis decoding) were developed first, which result in the most-likely codeword for the encoded bits [A. Viterbi, \u201cError bounds for convolutional codes and an asymptotically optimum decoding algorithm\u201d, IEEE Transactions on Information Theory 13, 260 (1967). DOI]. Following, other trellis decoders such as the BCJR decoding algorithm [L. Bahl et al., \u201cOptimal decoding of linear codes for minimizing symbol error rate (Corresp.)\u201d, IEEE Transactions on Information Theory 20, 284 (1974). DOI] were developed later.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Evaluation on the generator polynomials. Can be implemented with a small number of XOR gates", "features_rate": "Depends on the polynomials used. Using puncturing removal [L. Sari, \u201cEffects of Puncturing Patterns on Punctured Convolutional Codes\u201d, TELKOMNIKA (Telecommunication, Computing, Electronics and Control) 10, (2012). DOI] the rate for the code can be increased from \\(\\frac{1}{t}\\) to \\(\\frac{s}{t}\\), where \\(t\\) is the number of output bits, and \\(s\\) depends on the puncturing done. This is done by deleting some pieces of the encoder output such that the most-likely decoders remain effective", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "bits_into_bits", "parents_detail": "", "cousins_code_id": "quantum_convolutional\nreed_solomon", "cousins_detail": "Quantum analogue of convolutional codes\nConvolutional codes are often used in concatenation with Reed-Solomon codes for communication [T. Halonen, J. Romero, and J. Melero, editors , GSM, GPRS and EDGE Performance (Wiley, 2003). DOI].", "_type": "ecc", "_page_id": "c_convolutional", "_href": "c/convolutional"}, "c_tanner": {"notes": "", "logical": "bits", "code_id": "tanner", "physical": "bits", "protection": "Tanner Codes protect against noise on classical bit strings. If \\(C_0\\) is an \\([d, d-t,d'> d(\\gamma_0 +\\frac{\\lambda}{d})]_2\\) code and G is an \\((N, M, 2, d, \\rho,\\alpha)\\)- expander where \\(\\rho = \\gamma_0 (\\gamma_0 +\\frac{\\lambda}{d})\\), then the Tanner Code \\(T(G, C_0)\\) has rate \\(1-\\frac{M}{N}t\\) and relative distance \\(\\geq \\gamma_0(\\gamma_0+\\frac{\\lambda}{d})\\).", "introduced": "[R. Tanner, \u201cA recursive approach to low complexity codes\u201d, IEEE Transactions on Information Theory 27, 533 (1981). DOI]", "description": "Binary linear code defined on edges on a regular graph \\(G\\) such that each subsequence of bits corresponding to edges in the neighborhood any vertex belong to some short binary linear code \\(C_0\\). Expansion properties of the underlying graph can yield efficient decoding algorithms.\n\nMore technically, let \\(G(V,E)\\) be a \\(\\Delta\\)-regular (not necessarily bipartite) graph with number of vertices \\(|V| = n \\) and number of edges \\(|E| = N = n\\Delta/2\\). Let \\(C_0\\) be a linear binary code of length \\(\\Delta\\) and rate \\(R_0\\). The Tanner code \\(T(G,C_0)\\), whose bits are placed on edges of the graph, consists of the following codewords: \\begin{align}\n\\left\\{ c \\in GF(2)^{n}\\,\\text{s.t. }\\forall v\\in V,\\left.c\\right|_{N(v)}\\in C_{0}\\right\\} ~,\n\\end{align} where \\(\\left.c\\right|_{N(v)}\\) is the subsequence formed by the \\(\\Delta\\) bits located on the neighbors \\(N(v)\\) of the vertex \\(v\\). The dimension of \\(T\\) is at least \\(N -n(\\Delta -\\Delta R_0) = N(2R_0-1)\\geq 0\\) whenever \\(R_0 \\geq \\frac{1}{2}\\). ", "name": "Tanner code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Parallel decoding algorithm corrects a fraction \\(\\delta_0^2/48\\) of errors for Tanner codes [M. Sipser and D. A. Spielman, \u201cExpander codes\u201d, IEEE Transactions on Information Theory 42, 1710 (1996). DOI]. A modification of said algorithm improves the fraction to \\(\\delta_0^2/4\\) with no extra cost to complexity [G. Zemor, \u201cOn expander codes\u201d, IEEE Transactions on Information Theory 47, 835 (2001). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Quadratic algorithm: This technique works for all linear block codes and encodes using matrix multiplication [J. D. Lafferty and D. N. Rockmore, \u201cSpectral techniques for expander codes\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI].\nUsing the non-Abelian Fast Fourier Transform and exploiting the symmetry of the underlying graph, an encoding algorithm that requires \\(O(n^{4/3})\\) has been devised in [J. D. Lafferty and D. N. Rockmore, \u201cSpectral techniques for expander codes\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI].\nA modified construction yields codes that may be encoded in linear time yet maintain similar performance [D. A. Spielman, \u201cLinear-time encodable and decodable error-correcting codes\u201d, IEEE Transactions on Information Theory 42, 1723 (1996). DOI].", "features_rate": "For a short code \\(C_0\\) with rate \\(R_0\\), the Tanner code has rate \\(R \\geq 2R_0-1\\). If \\(C_0\\) satisfies the Gilbert-Varshamov bound, the rate \\(R \\geq \\delta = 1-2h(\\delta_0)\\), where \\(\\delta\\) (\\(\\delta_0\\)) is the relative distance of the Tanner code (\\(C_0\\)), and \\(h\\) is the binary entropy function.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_linear\nparallel_concatenated", "parents_detail": "\n", "parent_of_code_id": "expander", "parent_of_detail": "", "cousin_of_code_id": "dhlv\nexpander_lifted_product\nquantum_tanner", "cousin_of_detail": "Tanner codes are used in constructing quantum DHLV codes.\nExpander lifted-product codes are products of \\(q\\)-ary Tanner codes defined on expander graphs.\nTanner codes are used in constructing quantum Tanner codes.", "_type": "ecc", "_page_id": "c_tanner", "_href": "c/tanner"}, "c_levenshtein": {"notes": "", "logical": "bits", "code_id": "levenshtein", "physical": "bits", "protection": "Levenshtein codes meet the Plotkin bound \\(K\\leq 2\\left\\lfloor\\frac{d}{2d-n}\\right\\rfloor\\), where \\(K\\) is the number of codewords, \\(d\\) is the distance, and \\(n\\) is the length, and with the assumption that the Hadamard matrices for such parameters exist. The general proof depends on the correctness of Hadamard's conjecture [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.].", "introduced": "[V.I. Levenshtein, Application of Hadamard matrices to a problem in coding theory, Problems of Cybernetics, vol. 5, GIFML, Moscow, 1961, 125\u2013136.]", "description": "Binary codes constructed from combining two codes \\(A'\\) constructed out of Hadamard matrices.\n\nLet \\(H_n\\) be a normalized Hadamard matrix. The generator matrix for an \\((n-1,n,n/2)\\) code \\(A_n\\) is obtained by taking \\(H_n\\), replacing the +1's by 0's and the -1's by 1's, and deleting the first column. Taking only the codewords of \\(A_n\\) which begin with 0 and deleting the leading 0 yields the generator matrix of an \\((n-2,n/2,n/2)\\) code \\(A_n'\\).\n\nNext, apply the following way of combining codes. Suppose we have an \\((n_1,M_1,d_1)\\) code \\(C_1\\) and an \\((n_2,M_2,d_2)\\) code \\(C_2\\). The combined \\((an_1+bn_2,\\min(M_1,M_2),ad_1+bd_2)\\) code \\(a C_1\\bigoplus b C_2\\) may be constructed by pasting \\(a\\) copies of \\(C_1\\) and \\(b\\) copies of \\(C_2\\) together and omitting the last \\(|M_1-M_2|\\) rows. Applying this to construct a Levenshtein code with length \\(n\\) and distance \\(d\\), define \\(k=\\lfloor d/(2d-n)\\rfloor\\), \\(a=d(2k+1)-n(k+1)\\), and \\(b=kn-d(2k-1)\\). If \\(n\\) is even, construct \\(\\frac{a}{2}A_{4k}'\\bigoplus\\frac{b}{2}A_{4k+4}'\\). If \\(n\\) is odd and \\(k\\) is even, construct \\(aA_{2k}\\bigoplus\\frac{b}{2}A_{4k+4}'\\). If \\(n\\) is odd and \\(k\\) is odd, construct \\(\\frac{a}{2}A_{4k}'\\bigoplus b A_{2k+2}\\).", "name": "Levenshtein code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "bits_into_bits", "parents_detail": "", "_type": "ecc", "_page_id": "c_levenshtein", "_href": "c/levenshtein"}, "c_polar": {"notes": "For more details, see Ch. 32 of Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI].\nSee database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.\nCodes have been benchmarked using AFF3CT toolbox [A. Cassagne et al., \u201cAFF3CT: A Fast Forward Error Correction Toolbox!\u201d, SoftwareX 10, 100345 (2019). DOI].", "logical": "bits", "code_id": "polar", "physical": "bits", "protection": "Protects against various types of noise in the communication channel, for instance, errors, erasures, or other types of noise. Distance plays no role in the analysis of its properties, and is much lower than the largest possible value given \\(K,N\\).", "introduced": "[E. Arikan, \u201cChannel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels\u201d, IEEE Transactions on Information Theory 55, 3051 (2009). DOI]", "description": "In its basic version, a binary linear polar code encodes \\(K\\) message bits into \\(N=2^n\\) bits. The linear transformation that defines the code is given by the matrix \\(G^{(n)}=B_N G^{\\otimes n}\\), where \\(B_N\\) is a certain \\(N\\times N\\) permutation matrix, and \\(G^{\\otimes n}\\) is the \\(n\\)th Kronecker power of the \\(2\\times 2\\) kernel matrix \\(G=\\left[\\begin{smallmatrix}1 & 0\\\\ 1 & 1 \\end{smallmatrix}\\right]\\). To encode \\(K\\) message bits, one forms an \\(N\\)-vector \\(u\\) in which \\(K\\) coordinates represent the message bits. The remaining \\(N-K\\) coordinates are set to some fixed values and are said to be frozen. The codeword \\(x \\in \\{0,1\\}^N\\) is obtained as \\(x=u G^{\\otimes n}\\).\n\nThe choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.\n\nThere are multiple variants of the above basic construction, in particular relying on other kernel matrices. The codes can be defined for nonbinary alphabets, and they can be adjusted to support tasks such as lossless and lossy compression, successive refinement, communication over the mulitple access channel, communication over the wiretap channel, and many others.", "name": "Polar code", "realizations": "Code control channels for the 5G NR (New Radio) interfaces [3rd Generation Partnership Project (3GPP), Technical specification group radio access network, 3GPP TS 38.212 V.15.0.0, 2017.].", "short_name": "", "features_threshold": "Achieves Shannon capacity of the binary-input memoryless channel under successive cancellation decoder [E. Arikan, \u201cChannel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels\u201d, IEEE Transactions on Information Theory 55, 3051 (2009). DOI].", "features_code_capacity_threshold": "", "features_decoders": "Successive cancellation (SC) decoder [E. Arikan, \u201cChannel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels\u201d, IEEE Transactions on Information Theory 55, 3051 (2009). DOI].\nSuccessive cancellation list (SCL) decoder [I. Tal and A. Vardy, \u201cList Decoding of Polar Codes\u201d, IEEE Transactions on Information Theory 61, 2213 (2015). DOI] and a modification utilizing sequence repetition (SR-List) [Yuqing Ren et al., \u201cA Sequence Repetition Node-Based Successive Cancellation List Decoder for 5G Polar Codes: Algorithm and Implementation\u201d. 2205.08857].\nSoft cancellation (SCAN) decoder [U. U. Fayyaz and J. R. Barry, \u201cLow-Complexity Soft-Output Decoding of Polar Codes\u201d, IEEE Journal on Selected Areas in Communications 32, 958 (2014). DOI][U. U. Fayyaz and J. R. Barry, \u201cPolar codes for partial response channels\u201d, 2013 IEEE International Conference on Communications (ICC) (2013). DOI].\nBelief propagation (BP) decoder [E. Arkan, \u201cA performance comparison of polar codes and Reed-Muller codes\u201d, IEEE Communications Letters 12, 447 (2008). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Supports reliable transmission at rates \\(K/N\\) approaching the Shannon capacity of the channel.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_linear\ngeneralized_concatenated", "parents_detail": "\nPolar codes can be represented as generalized concatenations of their kernels.", "cousins_code_id": "reed_muller", "cousins_detail": "RM codes rely on the same generator matrix, but place message bits in different coordinates.", "cousin_of_code_id": "quantum_polar", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_polar", "_href": "c/polar"}, "c_justesen": {"notes": "", "logical": "bits", "code_id": "justesen", "physical": "bits", "protection": "", "introduced": "[J. Justesen, \u201cClass of constructive asymptotically good algebraic codes\u201d, IEEE Transactions on Information Theory 18, 652 (1972). DOI]", "description": "Binary linear code resulting from generalized concatenation of a Reed-Solomon (RS) outer code with multiple inner codes sampled from the Wozencraft ensemble, i.e., \\(N\\) distinct binary inner codes of dimension \\(m\\) and length \\(2m\\). Justesen codes are parameterized by \\(m\\), with length \\(n=2mN\\) and dimension \\(k=mK\\), where \\((N=2^m-1,K)\\) is the RS outer code over \\(GF(2^m)\\).", "name": "Justesen code", "realizations": "Generating small-bias sample spaces, i.e., probability distributions that parity functions cannot typically distinguish from the uniform distribution [J. Naor and M. Naor, \u201cSmall-bias probability spaces: efficient constructions and applications\u201d, Proceedings of the twenty-second annual ACM symposium on Theory of computing - STOC '90 (1990). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Generalized minimum distance decoding [J. Justesen, \u201cClass of constructive asymptotically good algebraic codes\u201d, IEEE Transactions on Information Theory 18, 652 (1972). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The first asymptotically good codes. Rate is \\(R_m=k/n=K/2N\\geq R\\) and the relative minumum distance satisfy \\(\\delta_m=d_m/n\\geq 0.11(1-2R)\\), where \\(K=\\left\\lceil 2NR\\right\\rceil\\) for asymptotic rate \\(0<R<1/2\\); see pg. 311 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.].\n\nThe code can be improved and extend the range of \\(R\\) from 0 to 1 by puncturing, i.e., by erasing \\(s\\) digits from each inner codeword. This yields a code of length \\(n=(2m-s)N\\) and rate \\(R=mk/(2m-s)N\\). The lower bound of the distance of the punctured code approaches \\(d_m/n=(1-R/r)H^{-1}(1-r)\\) as \\(m\\) goes to infinity, where \\(r\\) is the maximum of 1/2 and the solution to \\(R=r^2/(1+\\log(1-h^{-1}(1-r)))\\), and \\(h\\) is the binary entropy function.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_linear\ngeneralized_concatenated", "parents_detail": "\nJustesen codes can be considered as a generalized concatenation of a Reed-Solomon outer code with \\(N\\) distinct binary inner codes.", "cousins_code_id": "reed_solomon\nwozencraft\nrandom", "cousins_detail": "An RS code is the outer code of Justesen codes.\nWozencraft ensemble forms the inner codes of Justesen codes.\nThe required inner codes are obtained by random sampling from the Wozencraft ensemble, whose length scales logarithmically with \\(n\\).", "_type": "ecc", "_page_id": "c_justesen", "_href": "c/justesen"}, "c_tornado": {"notes": "", "logical": "bits", "code_id": "tornado", "physical": "bits", "protection": "", "introduced": "[J. W. Byers et al., \u201cA digital fountain approach to reliable distribution of bulk data\u201d, ACM SIGCOMM Computer Communication Review 28, 56 (1998). DOI][M. G. Luby et al., \u201cPractical loss-resilient codes\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI][M. G. Luby et al., \u201cEfficient erasure correcting codes\u201d, IEEE Transactions on Information Theory 47, 569 (2001). DOI]", "description": "Stub.", "name": "Tornado code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Linear-time decoder.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Linear-time encoder.", "features_rate": "Come arbitrarily close to the capacity of the binary erasure channel.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_linear\nldpc", "parents_detail": "\n", "cousins_code_id": "fountain\nldpc", "cousins_detail": "Tornado codes, the precursor to fountain codes, are much slower to encode and decode in the low-rate regime applicable to scalable data transmission [Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7\u201312). IEEE.][A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI].\nTornado codes are similar to LDPC codes, but they use a highly irregular weight distribution for the underlying graphs [A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI].", "cousin_of_code_id": "raptor", "cousin_of_detail": "Tornado codes, which can be used as a pre-code for raptor codes, also use a multi-layer approach where redundant symbols are created by one code for another code to use as input.", "_type": "ecc", "_page_id": "c_tornado", "_href": "c/tornado"}, "c_vt_single_deletion": {"notes": "", "logical": "bits", "code_id": "vt_single_deletion", "physical": "bits", "protection": "Corrects a single asymmetric error (a \\(0\\) mapped to a \\(1\\)), a single deletion, or a single insertion of an arbitrary bit in an arbitrary position for any choice of \\(a\\).", "introduced": "[R. R. Varshamov and G. M. Tenengolts, Codes which correct single asymmetric errors (translated to English), Autom. Remote Control, 26(2), 286-290 (1965)][V. I. Levenshtein, Binary codes capable of correcting deletions, insertions and reversals (translated to English), Soviet Physics Dokl., 10(8), 707-710 (1966).]", "description": "Nearly optimal binary deletion-correcting code. Given integers \\(n\\geq 1\\) and \\(a\\in\\{0,1,\\dots,n\\}\\), the associated binary Varshamov-Tenengolts code \\(C_{n,a}\\) corresponds to the set\n\n\\begin{align}\nC_{n,a}=\\left\\{x\\in\\{0,1\\}^n: \\sum_{i=1}^n i~x_i = a\\mod (n+1) \\right\\}.\n\\end{align}", "name": "Binary Varshamov-Tenengolts (VT) code", "realizations": "", "short_name": "Binary VT", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoder based on checksums \\(\\sum_{i=1}^n i~x_i^{\\prime}\\) of corrupted codewords \\(x_i^{\\prime}\\) [V. I. Levenshtein, Binary codes capable of correcting deletions, insertions and reversals (translated to English), Soviet Physics Dokl., 10(8), 707-710 (1966).][V. I. Levenshtein, Binary codes capable of correcting spurious insertions and deletions of one (translated to English), Prob. Inf. Transmission, 1(1), 8-17 (1965).].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Rate-\\(1\\) code, with \\(\\log n+1\\) bits of redundancy when \\(a=0\\). Nearly optimal.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "bits_into_bits", "parents_detail": "", "cousins_code_id": "binary_linear", "cousins_detail": "By adapting a construction of Tenengolts [G. M. Tenengolts, Class of codes correcting bit loss and errors in the preceding bit (translated to English), Automation and Remote Control, 37(5), 797\u2013802 (1976).], binary VT codes can be modified to yield slightly longer linear codes [N. J. A. Sloane, \u201cOn Single-Deletion-Correcting Codes\u201d. math/0207197].", "_type": "ecc", "_page_id": "c_vt_single_deletion", "_href": "c/vt_single_deletion"}, "c_binary_linear": {"notes": "Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by A. E. Brouwer [Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.], are maintained by M. Grassl at this website.", "logical": "bits", "code_id": "binary_linear", "physical": "bits", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set for which no two elements of the set add up to a codeword.\n\nLinear codes admit a parity check matrix \\(H\\), whose columns make up a set of parity checks, i.e., a maximal linearly independent set of vectors that are in the kernel of \\(G\\). It follows that \\begin{align}\n  G H^{\\text{T}} = 0 \\mod 2~.\n\\end{align} ", "introduced": "", "description": "An \\((n,2^k,d)\\) linear code is denoted as \\([n,k]\\) or \\([n,k,d]\\), where \\(d\\) is the code's distance. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword. A code that is not linear is called nonlinear.\n\nLinear codes can be defined in terms of a generator matrix \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a message \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its standard or systematic form \\(G = [I_k~A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) binary matrix. ", "name": "Linear binary code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoding an arbitary linear binary code is NP-hard [E. Berlekamp, R. McEliece, and H. van Tilborg, \u201cOn the inherent intractability of certain coding problems (Corresp.)\u201d, IEEE Transactions on Information Theory 24, 384 (1978). DOI].\nSlepian's standard-array decoding [D. Slepian, \u201cSome Further Theory of Group Codes\u201d, Bell System Technical Journal 39, 1219 (1960). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "A family of linear codes \\(C_i = [n_i,k_i,d_i]\\) is asymptotically good if the asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "bits_into_bits\nlinear", "parents_detail": "\n", "parent_of_code_id": "binary_cyclic\nfibonacci_model\nfountain\nhomological_classical\nhadamard\njustesen\npolar\nreed_muller\ntanner\ntornado\nweight_two", "parent_of_detail": "\n\n\n\n\n\n\n\n\n\n", "cousin_of_code_id": "vt_single_deletion\ncss\neaqecc\neastab\nparity_check\nqubit_stabilizer", "cousin_of_detail": "By adapting a construction of Tenengolts [G. M. Tenengolts, Class of codes correcting bit loss and errors in the preceding bit (translated to English), Automation and Remote Control, 37(5), 797\u2013802 (1976).], binary VT codes can be modified to yield slightly longer linear codes [N. J. A. Sloane, \u201cOn Single-Deletion-Correcting Codes\u201d. math/0207197].\nConstruction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\).\nAny linear binary code can be used to construct an EAQECC.\nAny linear binary code can be used to construct an EA stabilizer code.\nAny \\([n,k,d]\\) code with odd distance can be extended to an \\([n+1,k,d+1]\\) code by adding a bit storing the sum of codeword coordinates.\nQubit stabilizer codes are quantum analogues of binary linear codes.", "_type": "ecc", "_page_id": "c_binary_linear", "_href": "c/binary_linear"}, "c_luby_transform": {"notes": "", "logical": "bits", "code_id": "luby_transform", "physical": "bits", "protection": "", "introduced": "[M. Luby, \u201cLT codes\u201d, The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. Proceedings.. DOI]", "description": "Erasure codes based on fountain codes. They improve on random linear fountain codes by having a much more efficient encoding and decoding algorithm.\n\nLT codes can be constructed as follows. First, randomly choose a degree \\(d_n\\) from a degree distribution depending on total size \\(K\\). Then, randomly choose \\(d_n\\) distinct source packets and let the packet to be transmitted \\(\\hat{p}_n\\) be the bitwise sum of the chosen input packets. This forms a graph connecting encoded packets to source packets. ", "name": "Luby transform (LT) code", "realizations": "", "short_name": "LT", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Sum-product algorithm, often called a peeling decoder [T. Richardson and R. Urbanke, Modern Coding Theory (Cambridge University Press, 2008). DOI][David J. C. MacKay. 2002. Information Theory, Inference & Learning Algorithms. Cambridge University Press, USA], similar to belief propagation [J. Pearl, \u201cReverend Bayes on Inference Engines: A Distributed Hierarchical Approach\u201d, Probabilistic and Causal Inference 129 (2022). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "raptor", "parents_detail": "Raptor codes using a trivial pre-code are LT codes. Typically, Raptor codes have constant-sized more overhead but are faster to decode.", "_type": "ecc", "_page_id": "c_luby_transform", "_href": "c/luby_transform"}, "c_anticode": {"notes": "", "logical": "bits", "code_id": "anticode", "physical": "bits", "protection": "", "introduced": "[P. G. Farrell, \u201cLinear binary anticodes\u201d, Electronics Letters 6, 419 (1970). DOI][P. G. Farrell and A. Farrag, \u201cFurther properties of linear binary anticodes\u201d, Electronics Letters 10, 340 (1974). DOI]", "description": "Code for which the distance between any two codewords is less than or equal to some value \\(\\delta\\) called the maximum distance. Anticodes can be used to construct codes that saturate the Griesmer bound; see Refs. [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI][F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for more details.", "name": "Anticode", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "bits_into_bits", "parents_detail": "", "cousins_code_id": "griesmer", "cousins_detail": "Several anticode (e.g., [B. I. Belov, V. N. Logachev, V. P. Sandimirov, \u201cConstruction of a Class of Linear Binary Codes Achieving the Varshamov-Griesmer Bound\u201d, Probl. Peredachi Inf., 10:3 (1974), 36\u201344; Problems Inform. Transmission, 10:3 (1974), 211\u2013217][R. Hill, \"Optimal Linear Codes in: C. Mitchell (Ed.) Crytography and Coding.\" (1992): 75-104.]) and related [B. I. Belov, \"A conjecture on the Griesmer bound.\" Optimization Methods and Their Applications,(Russian), Sibirsk. Energet. Inst. Sibirsk. Otdel. Akad. Nauk SSSR, Irkutsk 182 (1974): 100-106.] constructions saturate the Griesmer bound; see Refs. [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI][F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for more details.", "cousin_of_code_id": "projective", "cousin_of_detail": "There is a relation between anticodes and minihypers ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 295).", "_type": "ecc", "_page_id": "c_anticode", "_href": "c/anticode"}, "c_fountain": {"notes": "Review on fountain codes can be found in Refs. [D. J. C. MacKay, \u201cFountain codes\u201d, IEE Proceedings - Communications 152, 1062 (2005). DOI][Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7\u201312). IEEE.].", "logical": "bits", "code_id": "fountain", "physical": "bits", "protection": "Designed to protect against erasures during broadcasting of information by a sender to multiple receivers.", "introduced": "[J. W. Byers et al., \u201cA digital fountain approach to reliable distribution of bulk data\u201d, ACM SIGCOMM Computer Communication Review 28, 56 (1998). DOI]", "description": "Code based on the idea of generating an endless stream of custom encoded packets for the receiver. The code is designed so that the receiver can recover the original transmission of size \\(Kl\\) bits after receiving at least \\(K\\) packets each of \\(l\\) bits.\n\nThe simplest example of a fountain code is the random linear fountain code. Take some message of size \\(Kl\\) and split into \\(K\\) packets, \\(p_0, p_1, ..., p_K\\). For each packet \\(\\hat{p}_n\\) to be transmitted do the following: Generate \\(K\\) random bits \\(G_{nk}\\) and let \\(\\hat{p}_n\\) be the bitwise sum of the source packets when \\(G_{nk}\\) is 1, \\begin{align}\n\\hat{p}_n = \\sum_{k=1}^K p_k G_{kn}~.\n\\end{align} Error correction can then be applied to each packet. ", "name": "Fountain code", "realizations": "Designed for servers sending data to many recipients, such as during broadcasting or file distribution [A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI][E. Baik, A. Pande, and P. Mohapatra, \u201cCross-layer coordination for efficient contents delivery in LTE eMBMS traffic\u201d, 2012 IEEE 9th International Conference on Mobile Ad-Hoc and Sensor Systems (MASS 2012) (2012). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Invert the fragment generator matrix resulting from the continuous encoding process. If exactly \\(K\\) packets are received, then the probability of decoding correctly is \\(0.289\\). Extra packets increase this probability exponentially. The decoding runtime is dominated by the matrix inversion step, which takes order \\(O(n^3)\\) time.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Random linear fountain codes approach the Shannon limit as the file size \\(K\\) increases. However, they do not have a fixed encoding rate.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_linear\nldpc", "parents_detail": "\n", "parent_of_code_id": "raptor", "parent_of_detail": "", "cousins_code_id": "random\ndistributed_storage", "cousins_detail": "\nThere are proposals [Megasthenis Asteris and Alexandros G. Dimakis, \u201cRepairable Fountain Codes\u201d. 1401.0734][Michael G. Luby et al., \u201cLiquid Cloud Storage\u201d. 1705.07983] adapting fountain codes to distributed storage systems.", "cousin_of_code_id": "tornado", "cousin_of_detail": "Tornado codes, the precursor to fountain codes, are much slower to encode and decode in the low-rate regime applicable to scalable data transmission [Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7\u201312). IEEE.][A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI].", "_type": "ecc", "_page_id": "c_fountain", "_href": "c/fountain"}, "c_batch": {"notes": "", "logical": "bits", "code_id": "batch", "physical": "bits", "protection": "", "introduced": "[Y. Ishai et al., \u201cBatch codes and their applications\u201d, Proceedings of the thirty-sixth annual ACM symposium on Theory of computing - STOC '04 (2004). DOI]", "description": "Binary code designed for minimizing the total amount of storage and the worst-case maximal load on any devices in a distributed system.\n\nAn \\((n,N,k,m,t)\\) batch code encodes a length-\\(n\\) string \\(x_1,\\cdots,x_n\\) into an \\(m\\)-tuple of strings of total length \\(N\\) (are also called buckets), such that for each \\(k\\)-tuple of distinct indices \\(i_1,i_2,...,i_k\\), the entries \\(x_{i_1},...,x_{i_k}\\) can be decoded by reading at most \\(t\\)-symbols from each bucket. If each bucket of a batch code contains a single symbol, then the \\((n,N,k,m)\\) batch code is primitive.\n\nA multi-user generalization of batch code is named multiset batch code. If, for any multiset \\(i_1, i_2, ..., i_k \\in [n]\\), there is a partition of buckets into subsets \\(S_1, ..., S_k \\subset [m]\\) such that each \\(x_{i_j}\\) can be recovered by reading at most one symbol from each bucket in \\(S_j\\), then the \\((n, N, k, m)\\) code is a multiset batch code.\n\nCombining two batch codes \\(C_1\\) and \\(C_2\\), which are \\((n_1,N_1,k_1,m_1)\\) and \\((n_2,N_2,k_2,m_2)\\) batch codes respectively, yields a composite batch code \\(C_1\\otimes C_2\\), which is an \\((n_1, m_1N_2, k_1 k_2, m_1 m_2)\\) batch code.", "name": "Batch code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "bits_into_bits\nlocally_recoverable", "parents_detail": "\nA systematic batch code with restricted size of reconstruction sets can recover any query of \\(t\\) information symbols with recovery sets of size \\(r\\) [V. Skachek, \u201cBatch and PIR Codes and Their Connections to Locally Repairable Codes\u201d, Network Coding and Subspace Designs 427 (2018). DOI][A.-E. Riet, V. Skachek, and E. K. Thomas, \u201cBatch Codes for Asynchronous Recovery of Data\u201d, IEEE Transactions on Information Theory 68, 1545 (2022). DOI].", "_type": "ecc", "_page_id": "c_batch", "_href": "c/batch"}, "c_homological_classical": {"notes": "", "logical": "bits", "code_id": "homological_classical", "physical": "bits", "protection": "", "introduced": "[H. Bombin and M. A. Martin-Delgado, \u201cHomological error correction: Classical and quantum codes\u201d, Journal of Mathematical Physics 48, 052105 (2007). DOI; quant-ph/0605094]", "description": "This code's properties are derived from the size two chain complex associated with a particular graph. Given a connected simplicial (no self loops or muliedges) graph \\(G = (V, E)\\), which is not a tree, with incidence matrix \\(\\Gamma\\) we can construct a code by choosing a parity check matrix which consists of all the linearly independent rows of \\(\\Gamma\\). This is a \\([n,k,d]\\) code with \\(n = |E|\\), \\(k = 1 - \\mathcal{X}(G) = 1-|V|+|E|\\), where \\( \\mathcal{X}(G)\\) is the euler characteristic of the graph. The code distance is equal to the shortest size of a cycle, guaranteed to exist since \\(G\\) is not a tree. ", "name": "Graph homology code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_linear", "parents_detail": "", "cousins_code_id": "perfect\ncss", "cousins_detail": "A family of homology codes saturate the asymptotic Hamming bound [H. Bombin and M. A. Martin-Delgado, \u201cHomological error correction: Classical and quantum codes\u201d, Journal of Mathematical Physics 48, 052105 (2007). DOI; quant-ph/0605094].\nCSS codes can also be constructed using homology techniques but for manifolds of dimension two or greater.", "_type": "ecc", "_page_id": "c_homological_classical", "_href": "c/homological_classical"}, "c_raptor": {"notes": "There is an open source RaptorQ implementation in Java and Rust.", "logical": "bits", "code_id": "raptor", "physical": "bits", "protection": "As a type of fountain code, a Raptor code is designed to correct erasures. The error probability of Raptor codes is measured in terms of its overhead, which is how many additional symbols are received above the dimension of the input \\(k\\). This relationship can vary widely depending on the input pre-code and degree distribution. For a well-designed degree distribution, the error probability of a Raptor code is directly related to the error probability of the pre-code's decoder. In other words, if there is a linear time decoder for the pre-code that has subexponentially small error probability, then the Raptor code's error probability will decrease exponentially with increasing overhead (past the \\(n-k\\) overhead symbols necessary for the pre-code).", "introduced": "[A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI][Petar Maymounkov, Online codes, Technical report, New York University, 2002.]", "description": "Raptor codes are concatenated erasure codes with two layers: an outer pre-code and a Luby-Transform (LT) inner code. The pre-code is a linear binary erasure code, which is applied first to the input to create some redundant data. The LT code is then applied to the intermediate symbols from the pre-code to generate final output symbols to be transmitted.\n\nThe parameters for a Raptor code are \\( (k, C, \\Omega(x)) \\), with \\(C\\) being the pre-code with dimension \\( k \\), and \\( \\Omega(x) \\) being the degree distribution for the LT code.\n\nThe times to encode and decode source blocks are both linear. The space requirement is \\(1/R \\), where \\(R\\) is the rate of the pre-code. Raptor codes with the simplest output distribution (LT code) are called pre-code-only (PCO).", "name": "Raptor (RAPid TORnado) code", "realizations": "Two versions of Raptor codes have been standardized by IETF: R10 and the more recent RaptorQ. RaptorQ is used in mobile multimedia broadcasts as specified in ETSI technical specifications. It is also used in the mobile Next Gen TV standard.\nRaptor codes are useful in scenarios where erasure (i.e. weak signal or noisy channel) is common, such as in military or disaster scenarios.", "short_name": "Raptor", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Raptor codes can be decoded using inactivation decoding [F. Lazaro, G. Liva, and G. Bauch, \u201cInactivation Decoding of LT and Raptor Codes: Analysis and Code Design\u201d, IEEE Transactions on Communications 1 (2017). DOI; 1706.05814], a combination of belief-propogation and Gaussian elimination decoding.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "fountain", "parents_detail": "", "parent_of_code_id": "luby_transform", "parent_of_detail": "Raptor codes using a trivial pre-code are LT codes. Typically, Raptor codes have constant-sized more overhead but are faster to decode.", "cousins_code_id": "tornado", "cousins_detail": "Tornado codes, which can be used as a pre-code for raptor codes, also use a multi-layer approach where redundant symbols are created by one code for another code to use as input.", "_type": "ecc", "_page_id": "c_raptor", "_href": "c/raptor"}, "c_reed_muller": {"notes": "See Chs. 13-15 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for details of RM codes and their variants.\nSee Ref. [E. Berlekamp and L. Welch, \u201cWeight distributions of the cosets of the (32,6) Reed-Muller code\u201d, IEEE Transactions on Information Theory 18, 203 (1972). DOI] for the weight distribution of the \\(2^{26}\\) cosets of the \\((32,6)\\) first-order RM code, obtained in part by hand computation.", "logical": "bits", "code_id": "reed_muller", "physical": "bits", "protection": "", "introduced": "[D. E. Muller, \u201cApplication of Boolean algebra to switching circuit design and to error detection\u201d, Transactions of the I.R.E. Professional Group on Electronic Computers EC-3, 6 (1954). DOI][I. Reed, \u201cA class of multiple-error-correcting codes and the decoding scheme\u201d, Transactions of the IRE Professional Group on Information Theory 4, 38 (1954). DOI][N. Mitani, On the transmission of numbers in a sequential computer, delivered at the National Convention of the Inst. of Elect. Engineers of Japan, November 1951.]", "description": "Member of the RM\\((r,m)\\) family of linear binary codes derived from multivariate polynomials. The code parameters are \\([2^m,\\sum_{j=0}^{r} {m \\choose j},2^{m-r}]\\), where \\(r\\) is the order of the code satisfying \\(0\\leq r\\leq m\\). Punctured RM codes RM\\(^*(r,m)\\) are obtained from RM codes by deleting one or more coordinates from each codeword.\n\nGenerator matrices of RM codes are constructed using the \\((u|u+v)\\) construction by starting from the \\(2^m\\)-dimensional matrix \\(F^{(m)}=\\left(\\begin{smallmatrix}1 & 0\\\\\n1 & 1\n\\end{smallmatrix}\\right)^{\\otimes m}\\), labeling its rows top-to-bottom from \\(0\\) to \\(2^m-1\\), converting the labels to binary strings of length \\(m\\), and deleting all rows whose labels have a Hamming weight less than \\(m-r\\). The recursive nature of the tensor product in the matrix \\(F^{(m)}\\) implies that RM\\((r,m)\\) is a subcode of RM\\((r+1,m)\\).\n\nAnother way to generate RM codewords is to list all outcomes of all polynomials of \\(m\\) binary variables of degree at most \\(r\\) [Emmanuel Abbe, Amir Shpilka, and Min Ye, \u201cReed-Muller Codes: Theory and Algorithms\u201d. 2002.03317] (see also Ch. 13 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.]).", "name": "Reed-Muller (RM) code", "realizations": "Deep-space communication, including the Mariner 9 spacecraft [J. L. Massey, \u201cDeep-space communications and coding: A marriage made in heaven\u201d, Advanced Methods for Satellite and Deep Space Communications 1. DOI][E.C. Posner, Combinatorial Structures in Planetary Reconnaissance in Error Correcting Codes, ed. H.B. Mann, Wiley, NY 1968.].", "short_name": "RM", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Reed decoder with \\(r+1\\)-step majority decoding corrects \\(\\frac{1}{2}(2^{m-r}-1)\\) errors [D. E. Muller, \u201cApplication of Boolean algebra to switching circuit design and to error detection\u201d, Transactions of the I.R.E. Professional Group on Electronic Computers EC-3, 6 (1954). DOI] (see also Ch. 13 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.]).\nSequential code-reduction decoding [L. Rudolph and C. Hartmann, \u201cDecoding by sequential code reduction\u201d, IEEE Transactions on Information Theory 19, 549 (1973). DOI].\nFirst-order (\\(r=1\\)) RM codes admit specialized decoders [E.C. Posner, Combinatorial Structures in Planetary Reconnaissance in Error Correcting Codes, ed. H.B. Mann, Wiley, NY 1968.].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Achieves capacity of the binary erasure channel [S. Kudekar et al., \u201cReed\u2013Muller Codes Achieve Capacity on Erasure Channels\u201d, IEEE Transactions on Information Theory 63, 4298 (2017). DOI] and of the binary memoryless symmetric (BMS) channel under bitwise maximum-a-posteriori decoding [Galen Reeves and Henry D. Pfister, \u201cReed-Muller Codes Achieve Capacity on BMS Channels\u201d. 2110.14631].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "evaluation_polynomial\nbinary_linear\nquaternary_over_z4\ndivisible\ngroup", "parents_detail": "RM codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine binary space ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pgs. 44-46; [S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\n\nRM codes are images of ring-linear quaternary codes under the Gray map ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 6.3).\nAn RM\\((r,m)\\) code is \\(2^{\\left\\lceil m/r\\right\\rceil-1}\\)-divisible, according to McEliece's theorem [R. J. McEliece, \u201cOn periodic sequences from GF(q)\u201d, Journal of Combinatorial Theory, Series A 10, 80 (1971). DOI][R. J. McEliece, \u201cWeight congruences for p-ary cyclic codes\u201d, Discrete Mathematics 3, 177 (1972). DOI].\nConsider a binary vector space of dimension \\( m \\). Under addition, this forms a finite group with \\( 2^m \\) elements known as an elementary abelian 2-group -- the direct product of \\( m \\) two-element cyclic groups \\( \\mathbb{Z}_2 \\times \\dots \\times \\mathbb{Z}_2 \\). Denote this group by \\( G_m \\). Let \\( J \\) be the Jacobson radical of the group algebra \\( \\mathbb{F}_2 G_m \\), where \\(\\mathbb{F}_2=GF(2)\\). RM\\((r,m)\\) codes correspond to the ideal \\( J^{m-r} \\). The length of the code is \\( |G_m| = 2^m \\), the distance is \\( 2^{m-r} \\), and the dimension is \\( \\sum_{i=0}^r {m \\choose i} \\). A similar construction exists for choices of a prime \\( p\\neq 2 \\).", "parent_of_code_id": "hamming", "parent_of_detail": "Hamming codes are equivalent to RM\\(^*(m-2,m)\\).", "cousins_code_id": "bch\ndual\nbinary_duadic\nbinary_cyclic\nparity_check", "cousins_detail": "RM\\((r,m)\\) codes are subcodes of BCH codes of designed distance \\(2^{m-r}-1\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 13).\nThe codes RM\\((r,m)\\) and RM\\((m-r-1,m)\\) are dual to each other.\nCertain punctured RM codes such as RM\\(^*(2,5)\\) are duadic; see Ref. [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Table 6.2.\nPunctured RM codes are cyclic ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 13, Thm. 11), making RM codes extended cyclic codes. RM codes with nonzero evaluation points are cyclic ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 52).\nRM\\((m-1,m)\\) are parity-check codes.", "cousin_of_code_id": "generalized_reed_muller\nhadamard\nmajorana_stab\npolar\nquantum_reed_muller\nquantum_divisible\nsimplex", "cousin_of_detail": "\nFor any Hamming code \\([2^m,2^m-m-1,3]\\), the dual Hadamard code, when augmented with a bit that is always 0, gives the RM\\((1,m)\\) code. In general, RM\\((1,m)\\) is related to the duals of the Hamming code, and when RM\\((1,m)\\) is self-dual, it is directly related to the Hamming code.\nMajorana stabilizer codes can be constructed by self-orthogonal RM codes [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code.\nRM codes rely on the same generator matrix, but place message bits in different coordinates.\n\nQuantum divisible codes can be constructed out of first-order RM codes.\nBinary simplex codes can be constructed from the generator matrix of RM\\((1,k)\\) by removing first the all-ones row, and then the all-zero column. Punctured RM codes and simplex codes are interconvertible via expurgation and augmentation ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 31).", "_type": "ecc", "_page_id": "c_reed_muller", "_href": "c/reed_muller"}, "c_expander": {"notes": "", "logical": "bits", "code_id": "expander", "physical": "bits", "protection": "Bit flip errors of weight at most \\((d-1)/2\\) where \\(d\\) is the distance of the code and is linear in \\(n\\), the number of physical bits.", "introduced": "[M. Sipser and D. A. Spielman, \u201cExpander codes\u201d, IEEE Transactions on Information Theory 42, 1710 (1996). DOI]", "description": "Expander codes are binary linear codes whose parity check matrices are derived from the adjacency matrix of bipartite expander graphs. In particular, the rows of the parity check matrix correspond to the right nodes of the bipartite graph and the columns correspond to the left nodes. The codespace is equivalent to all subsets of the left nodes in the graph that have an even number of edges going into every right node of the graph. Since the expander graph is only left regular, these codes do not qualify as LDPC codes.\n\nExpander codes are important because they admit efficient encoding and decoding algorithms and are asymptotically good (i.e., their rate and normalized distance are constant). The rate and distance of the expander code depend on specific parameters of the corresponding graph. A (\\(n, m, D, \\gamma, \\alpha\\)) bipartite expander graph is defined as a \\(D\\)-left-regular graph with \\(n\\) left nodes, and \\(m\\) right nodes such that for any subset of left nodes \\(S\\) of size at most \\(\\gamma n\\) the neighborhood \\(N(S)\\) is at least of size \\(\\alpha|S|\\). Given a (\\(n, m, D, \\gamma, (1-\\epsilon)D\\)) expander graph, the corresponding expander code has rate of \\(1 - m/n\\) and a distance of at least \\(2(1-\\epsilon)\\gamma n\\) for any \\(\\epsilon < 1/2\\). Explicit constructions for expander graphs with any ratio \\(n/m\\) are known where \\(D = \\text{polylog}(n/m)\\), \\(\\gamma = \\Omega(1/D)\\) and arbitrary \\(\\epsilon\\) [M. Capalbo et al., \u201cRandomness conductors and constant-degree lossless expanders\u201d, Proceedings of the thiry-fourth annual ACM symposium on Theory of computing - STOC '02 (2002). DOI]. ", "name": "Expander code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoding can be done in \\(O(n)\\) runtime using a greedy flip algorithm. The algorithm consists of flipping a bit of the received word if it will result in a greater number of satisfied parity checks. This is repeated until a codeword is reached.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Multiplication by generator matrix with runtime \\(O(n^2)\\)", "features_rate": "The rate is \\(1 - m/n\\) where \\(n\\) is the number of left nodes and \\(m\\) is the number of right nodes in the bipartite expander graph.", "features_transversal_gates": "", "features_fault_tolerance": "The flip decoding algorithm is fault tolerant against parity check errors [D. A. Spielman, \u201cLinear-time encodable and decodable error-correcting codes\u201d, IEEE Transactions on Information Theory 42, 1723 (1996). DOI]; see also course notes by M. Sudan.", "parents_code_id": "tanner", "parents_detail": "", "cousin_of_code_id": "quantum_expander", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_expander", "_href": "c/expander"}, "c_fibonacci_model": {"notes": "", "logical": "bits", "code_id": "fibonacci_model", "physical": "bits", "protection": "Protects against small weight errors and string-like errors. The code distance is more than \\(L\\), but the exact value is unknown. ", "introduced": "[G. M. Nixon and B. J. Brown, \u201cCorrecting Spanning Errors With a Fractal Code\u201d, IEEE Transactions on Information Theory 67, 4504 (2021). DOI; 2002.11738]", "description": "The code is defined on an \\(L\\times L/2\\) lattice with one bit on each site, where \\(L=2^N\\) for an integer \\(N\\geq 2\\). The codewords are defined to satisfy the condition that, for each lattice site \\((x,y)\\), the bits on \\((x,y)\\), \\((x+1,y)\\), \\((x-1,y)\\) and \\((x,y+1)\\) (where the lattice is taken to be periodic in both directions) contain an even numbers of \\(1\\)'s. The codewords can be generated using a one-dimensional cellular automaton of length \\(L\\) (periodic). The \\(2^L\\) possible initial states correspond to the \\(2^L\\) codewords. For each generation, the state of each cell is the xor sum of that cell and its two neighbors in the previous generation. After \\(L/2-1\\) generations, the entire history generated by the automaton corresponds to a codeword, where the initial state is the first row of the lattice, the first generation is the second row, etc. ", "name": "Fibonacci code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "An efficient algorithm base on minimum-weight perfect matching [G. M. Nixon and B. J. Brown, \u201cCorrecting Spanning Errors With a Fractal Code\u201d, IEEE Transactions on Information Theory 67, 4504 (2021). DOI; 2002.11738], which can correct high-weight errors that span the lattice, with failure rate decaying super-exponentially with \\(L\\).", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_linear", "parents_detail": "", "cousins_code_id": "haah_cubic", "cousins_detail": "The Fibonacci code is designed to mimic the fractal properties of (quantum) Haah cubic code so that studying the former can help us toward the development of an efficient algorithm for the latter.", "_type": "ecc", "_page_id": "c_fibonacci_model", "_href": "c/fibonacci_model"}, "c_bits_into_bits": {"notes": "", "logical": "bits", "code_id": "bits_into_bits", "physical": "bits", "protection": "A binary code \\(C\\) corrects \\(t\\) errors in the Hamming distance if \\begin{align}\n  \\forall x \\in C~,~D(x,x+y) < D(x' , x+y)\n\\end{align} for all codewords \\(x' \\neq x\\) and all \\(y\\) such that \\(|y|=t\\), where \\(D\\) is the Hamming distance and \\(|y| = D(y,0) \\). A code corrects \\(t\\) errors if and only if \\(d \\geq 2t+1\\), i.e., a code corrects errors on \\(t \\leq \\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates. In addition, a code detects errors on up to \\(d-1\\) coordinates, and corrects erasure errors on up to \\(d-1\\) coordinates.\n\nPerformance of binary codes can also be measured with respect to deletions and insertions of bits into the codewords. In this case, the metric measuring distance of an error word to the nearest codeword is the deletion distance: given vectors \\(u,v\\), this distance is one-half the smallest number of deletions and insertions needed to change \\(u\\) to \\(v\\). A code \\(C\\) corrects \\(e\\) delections if all codewords are separated by at least \\(e+1\\) in the deletion distance [N. J. A. Sloane, \u201cOn Single-Deletion-Correcting Codes\u201d. math/0207197]. ", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) binary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)\\). The distance is the minimum Hamming distance between a pair of distinct codewords.", "name": "Binary code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "For few-bit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.\nGiven a received string \\(x\\) and an error bound \\(e\\), a list decoder returns a list of all codewords that are at most \\(e\\) from \\(x\\) in Hamming distance. The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\).", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "anticode\nbatch\nvt_single_deletion\nconvolutional\nlevenshtein\nbinary_linear", "parent_of_detail": "\n\n\n\n\n", "cousin_of_code_id": "fock_state\ngroup_classical\nmovassagh_ouyang", "cousin_of_detail": "Fock-state code distance is a natural extension of Hamming distance between binary strings.\nGroup-based codes whose alphabet is based on the group \\(\\mathbb{Z}_2\\) are binary codes.\nMovassagh-Ouyang codes are constructed from classical binary codes.", "_type": "ecc", "_page_id": "c_bits_into_bits", "_href": "c/bits_into_bits"}, "c_binary_duadic": {"notes": "Reviews of duadic codes [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI].", "logical": "bits", "code_id": "binary_duadic", "physical": "bits", "protection": "Since duadic codes are cyclic, the BCH bound can be used to determine their minimum distance.", "introduced": "[J. Leon, J. Masley, and V. Pless, \u201cDuadic Codes\u201d, IEEE Transactions on Information Theory 30, 709 (1984). DOI]", "description": "Member of a pair of cyclic linear binary codes that satisfy certain relations, depending on whether the pair is even-like or odd-like duadic. Duadic codes exist for lengths \\(n\\) that are products of powers of primes, with each prime being \\(\\pm 1\\) modulo \\(8\\) [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].\n\nDuadic codes come in two pairs, an even-like duadic pair and an odd-like duadic pair. All codewords in the respective pairs are even-like, i.e., \\(\\sum_i c_i = 0\\), or odd-like, i.e., \\(\\sum_i c_i = 1\\). A code with all even-like (odd-like) codewords is called even-like (odd-like).\n\nDuadic code pairs can be defined in terms of their idempotent generators (see Cyclic-to-polynomial correspondence). A pair of even-like codes \\(C_1\\) and \\(C_2\\) with respective idempotents \\(e_1\\) and \\(e_2\\) is an even-like duadic pair if (1) \\(e_1(x)+e_2(x)=1-\\frac{1}{n}(1+x+x^2+\\cdots+x^{n-1})\\) and (2) there exists a multiplier \\(\\mu\\) such that \\(C_1 \\mu=C_2\\) and \\(C_2 \\mu=C_1\\).\n\nThere is an odd-like duadic pair \\(\\{D_1,D_2\\}\\) associated with the even-like pair \\(\\{C_1, C_2\\}\\), where \\(1-e_2(x)\\) generates \\(D_1\\) and \\(1-e_1(x)\\) generates \\(D_2\\). The even-pair codes are \\([n,\\frac{n-1}{2}]\\) codes while the odd-pair codes are \\([n,\\frac{n+1}{2}]\\) codes.", "name": "Binary duadic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_cyclic", "parents_detail": "", "parent_of_code_id": "binary_quad_residue", "parent_of_detail": "QR codes are duadic codes of prime length satisfying certain relations [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].", "cousins_code_id": "q-ary_duadic", "cousins_detail": "", "cousin_of_code_id": "reed_muller", "cousin_of_detail": "Certain punctured RM codes such as RM\\(^*(2,5)\\) are duadic; see Ref. [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Table 6.2.", "_type": "ecc", "_page_id": "c_binary_duadic", "_href": "c/binary_duadic"}, "c_binary_quad_residue": {"notes": "Introduction of quadratic-residue codes in Refs. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI].", "logical": "bits", "code_id": "binary_quad_residue", "physical": "bits", "protection": "", "introduced": "", "description": "Member of a quadruple of cyclic binary codes of prime length \\(n=8m\\pm 1\\) for \\(m\\geq 1\\) constructed using quadratic residues and nonresidues of \\(n\\).\n\nThe roots of the generator polynomial \\(r(x)\\) of the first code (see Cyclic-to-polynomial correspondence) are all of the inequivalent quadratic residues of \\(n\\), and the second code's generator polynomial is \\((x-1)r(x)\\). The roots of the generator polynomial \\(a(x)\\) of the third code are all inequivalent nonresidues of \\(n\\), and the fourth code's generator polynomial is \\((x-1)a(x)\\). The codes corresponding to polynomials \\(r,a\\) are often called augmented quadratic-residue codes, while the remaining codes are called expurgated. ", "name": "Binary quadratic-residue (QR) code", "realizations": "", "short_name": "Binary QR", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_duadic", "parents_detail": "QR codes are duadic codes of prime length satisfying certain relations [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].", "parent_of_code_id": "golay", "parent_of_detail": "The Golay code is a binary quadratic residue code with generator polynomial \\(r(x)\\) over \\(GF(2)\\) with length \\(n=23\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 16).", "cousins_code_id": "q-ary_quad_residue", "cousins_detail": "", "cousin_of_code_id": "hamming", "cousin_of_detail": "\\([7,4,3]\\) Hamming code is a quadratic-residue code [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.].", "_type": "ecc", "_page_id": "c_binary_quad_residue", "_href": "c/binary_quad_residue"}, "c_bch": {"notes": "See books [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.][S. Lin and D. J. Costello, Error Control Coding, 2nd ed. Englewood Cliffs, NJ: Prentice-Hall, 2004.][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI] for expositions on BCH codes and code tables.\nSee database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.\nSee corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cCyclic Codes (BCH-Bound).\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CCyclic-BCHBound.html].", "logical": "bits", "code_id": "bch", "physical": "bits", "protection": "By the BCH bound, BCH code with designed distance \\(\\delta\\) has true distance \\(d\\geq\\delta\\). BCH codes with different designed distances may coincide, and the largest possible designed distance for a given code is the Bose distance; the true distance may still be larger than that. ", "introduced": "[R. C. Bose and D. K. Ray-Chaudhuri, \u201cOn a class of error correcting binary group codes\u201d, Information and Control 3, 68 (1960). DOI][R. C. Bose and D. K. Ray-Chaudhuri, \u201cFurther results on error correcting binary group codes\u201d, Information and Control 3, 279 (1960). DOI][A. Hocquenghem, Codes correcteurs d'Erreurs, Chiffres (Paris), vol.2, pp.147-156, 1959.]", "description": "Cyclic binary code of odd length \\(n\\) whose zeroes are consecutive powers of a primitive \\(n\\)th root of unity \\(\\alpha\\) (see Cyclic-to-polynomial correspondence). More precisely, the generator polynomial of a BCH code of designed distance \\(\\delta\\geq 1\\) is the lowest-degree monic polynomial with zeroes \\(\\{\\alpha^b,\\alpha^{b+1},\\cdots,\\alpha^{b+\\delta-2}\\}\\) for some \\(b\\geq 0\\). BCH codes are called narrow-sense when \\(b=1\\), and are called primitive when \\(n=2^r-1\\) for some \\(r\\geq 2\\).\n\nThe code dimension is related to the multiplicative order of \\(2\\) modulo \\(n\\), i.e., the smallest integer \\(m\\) such that \\(n\\) divides \\(2^m-1\\). The dimension of a BCH code with \\(\\delta=2t+1\\) is at least \\(n-mt\\). The field \\(GF(2^m)\\) is the smallest field containing the above root of unity \\(\\alpha\\), and is the splitting field of the polynomial \\(x^n-1\\) (see Cyclic-to-polynomial correspondence). ", "name": "Binary BCH code", "realizations": "Satellite communication [Cheung, K-M., and F. Pollara. \"Phobos lander coding system: Software and analysis.\" The Telecommunications and Data Acquisition Report (1988).]", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Peterson decoder with runtime of order \\(O(n^3)\\) [W. Peterson, \u201cEncoding and error-correction procedures for the Bose-Chaudhuri codes\u201d, IEEE Transactions on Information Theory 6, 459 (1960). DOI][S. Arimoto, \"Encoding and decoding of p-ary group codes and the correction system,\" Information Processing in Japan (in Japanese), vol. 2, pp. 320-325, Nov. 1961.] (see exposition in Ref. [R.E. Blahut, Theory and practice of error-control codes, Addison-Wesley 1983.]).\nBerlekamp-Massey decoder with runtime of order \\(O(n^2)\\) [J. Massey, \u201cShift-register synthesis and BCH decoding\u201d, IEEE Transactions on Information Theory 15, 122 (1969). DOI][E. R. Berlekamp, Algebraic Coding Theory, McGraw-Hill, 1968] and modification by Burton [H. Burton, \u201cInversionless decoding of binary BCH codes\u201d, IEEE Transactions on Information Theory 17, 464 (1971). DOI]; see also [W. W. Peterson and E. J. Weldon, Error-correcting codes. MIT press 1972.][R. Gallager, Information Theory and Reliable Communication (Springer Vienna, 1972). DOI].\nSugiyama et al. modification of the extended Euclidean algorithm [Y. Sugiyama et al., \u201cA method for solving key equation for decoding goppa codes\u201d, Information and Control 27, 87 (1975). DOI][R. McEliece, The Theory of Information and Coding (Cambridge University Press, 2002). DOI].\nGuruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_cyclic", "parents_detail": "", "parent_of_code_id": "golay\nhamming", "parent_of_detail": "The Golay code is equivalent to a BCH code with Bose distance 5 ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 20).\nBinary Hamming codes are binary primitive narrow-sense BCH codes ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Corr. 5.1.5). Binary Hamming codes are cyclic ([R. Hill. A First Course In Coding Theory. Oxford University Press, 1988.], Thm. 12.22).", "cousins_code_id": "quasi_perfect\nq-ary_bch\ngeneralized_reed_solomon\ngriesmer", "cousins_detail": "Only double error-correcting BCH codes \\([2^m-1,n-2m,5]\\) are quasi-perfect [D. Gorenstein, W. W. Peterson, and N. Zierler, \u201cTwo-error correcting Bose-Chaudhuri codes are quasi-perfect\u201d, Information and Control 3, 291 (1960). DOI][T. Helleseth, \u201cNo primitive binary&amp;lt;tex&amp;gt;t&amp;lt;/tex&amp;gt;-error-correcting BCH code with&amp;lt;tex&amp;gt;t &amp;gt; 2&amp;lt;/tex&amp;gt;is quasi-perfect (Corresp.)\u201d, IEEE Transactions on Information Theory 25, 361 (1979). DOI] (see also Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 9).\n\nBinary BCH codes are subfield subcodes of GRS codes.\nThe \\([15,5,7]\\) BCH code extended with a parity check saturates the Griesmer bound ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 157).", "cousin_of_code_id": "quantum_bch\nreed_muller\nq-ary_hamming", "cousin_of_detail": "Binary BCH codes are used to construct a subset of qubit BCH codes via the CSS construction.\nRM\\((r,m)\\) codes are subcodes of BCH codes of designed distance \\(2^{m-r}-1\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 13).\nSome narrow sense BCH codes of length \\(n=(q^r-1)/(q-1)\\) such that \\(\\text{gcd}(r,q-1)=1\\) are \\(q\\)-ary Hamming codes ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thm. 5.1.4).", "_type": "ecc", "_page_id": "c_bch", "_href": "c/bch"}, "c_zetterberg": {"notes": "", "logical": "bits", "code_id": "zetterberg", "physical": "bits", "protection": "Correct at least all weight-2 errors.", "introduced": "[L.-H. Zetterberg, \u201cCyclic codes from irreducible polynomials for correction of multiple errors\u201d, IEEE Transactions on Information Theory 8, 13 (1962). DOI]", "description": "Family of binary cyclic \\([2^{2s}+1,2^{2s}-4s+1]\\) codes with distance \\(d>5\\) generated by the minimal polynomial \\(g_s(x)\\) of \\(\\alpha\\) over \\(GF(2)\\), where \\(\\alpha\\) is a primitive \\(n\\)th root of unity in the field \\(GF(2^{4s})\\). They are quasi-perfect codes and are one of the best known families of double-error correcting binary linear codes", "name": "Zetterberg code", "realizations": "Code used to provide better protection of data transmission with its double error correcting capacity [J. Meggitt, \u201cError correcting codes and their implementation for data transmission systems\u201d, IEEE Transactions on Information Theory 7, 234 (1961). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Kallquist first described an algebraic decoding theorem [P. Kallquist, \"Decoding of Zetterberg codes,\" in Proc. Fourth Joint Swedish-Soviet Workshop on Inform. Theory, Gotland, Sweden, Aug. 27-Sept. 1, 1989, p. 305-300]. A faster version was later provided in Ref. [S. M. Dodunekov and J. E. M. Nilsson, \u201cAlgebraic decoding of the Zetterberg codes\u201d, IEEE Transactions on Information Theory 38, 1570 (1992). DOI] and further modified in Ref. [M.-H. Jing et al., \u201cA Result on Zetterberg Codes\u201d, IEEE Communications Letters 14, 662 (2010). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The rate is given by \\(1-\\frac{4s}{n}\\), which is asymptotically good, with a minimum distance of 5.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_cyclic\nquasi_perfect", "parents_detail": "\nZetterberg codes are quasi-perfect, with each \\(n\\)-bit string at most three bit-flips away from a codeword [S. M. Dodunekov and J. E. M. Nilsson, \u201cAlgebraic decoding of the Zetterberg codes\u201d, IEEE Transactions on Information Theory 38, 1570 (1992). DOI].", "_type": "ecc", "_page_id": "c_zetterberg", "_href": "c/zetterberg"}, "c_binary_cyclic": {"notes": "See Ch. 7 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for an exposition on cyclic codes.", "logical": "bits", "code_id": "binary_cyclic", "physical": "bits", "protection": "Shift bound [J. van Lint and R. Wilson, \u201cOn the minimum distance of cyclic codes\u201d, IEEE Transactions on Information Theory 32, 23 (1986). DOI] gives a lower bound on the distance of cyclic binary codes.", "introduced": "", "description": "A binary code of length \\(n\\) is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword. A cyclic code is called primitive when \\(n=2^r-1\\) for some \\(r\\geq 2\\). A shortened cyclic code is obtained from a cyclic code by taking only codewords with the first \\(j\\) zero entries, and deleting those zeroes. ", "name": "Cyclic linear binary code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Meggitt decoder [J. Meggitt, \u201cError correcting codes and their implementation for data transmission systems\u201d, IEEE Transactions on Information Theory 7, 234 (1961). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "cyclic\nbinary_linear\ngroup", "parents_detail": "\n\nA length-\\(n\\) cyclic binary linear code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).", "parent_of_code_id": "bch\nbinary_duadic\none_hot\nparity_check\nrepetition\nzetterberg", "parent_of_detail": "\n\n\nSince permutations preserve parity, the cyclic permutation of a parity-check codeword is another codeword.\n\n", "cousin_of_code_id": "majorana_stab\nreed_muller", "cousin_of_detail": "Cyclic binary linear codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also self-orthogonal [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459].\nPunctured RM codes are cyclic ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 13, Thm. 11), making RM codes extended cyclic codes. RM codes with nonzero evaluation points are cyclic ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 52).", "_type": "ecc", "_page_id": "c_binary_cyclic", "_href": "c/binary_cyclic"}, "c_golay": {"notes": "The automorphism group of the Golay code is the Mathieu group \\(\\mathcal{M}_{23}\\), and the automorphism group of the extended Golay code is the Mathieu group \\(\\mathcal{M}_{24}\\), two of the sporadic simple groups.", "logical": "bits", "code_id": "golay", "physical": "bits", "protection": "", "introduced": "[M. J. E. Golay, Notes on digital coding, Proc. IEEE, 37 (1949) 657.]", "description": "A \\([23, 12, 7]\\) perfect binary linear code with connections to various areas of mathematics, e.g., lattices [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI] and sporadic simple groups [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.]. Adding a parity bit to the code results in the \\([24, 12, 8]\\) extended Golay code. Up to equivalence, both codes are unique for their respective parameters.\n\nTo construct the Golay code, one can use the great dodecahedron to generate codewords by placing message bits on the faces and calculating the parity bits that live on the 12 vertices of the inner icosahedron. ", "name": "Golay code", "realizations": "Used in the Voyager 1 and 2 spacecraft [E. C. Stone, \u201cThe Voyager 2 encounter with Uranus\u201d, Journal of Geophysical Research: Space Physics 92, 14873 (1987). DOI].\nRadio communications [E. E. Johnson. An Efficient Golay Codec For MIL-STD-188-141A and FED-STD-1045. Department of Electrical and Computer Engineering, New Mexico State University, 1991.].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Majority decoding for the extended Golay code [J.-M. Goethals, \u201cOn the Golay perfect binary code\u201d, Journal of Combinatorial Theory, Series A 11, 178 (1971). DOI].\nDecoder for the extended Golay code using the hexacode [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI].\nBoth Golay codes have a trellis representation and can thus be decoded using trellis decoding [A. J. VITERBI, \u201cError Bounds for Convolutional Codes and an Asymptotically Optimum Decoding Algorithm\u201d, The Foundations of the Digital Wireless World 41 (2009). DOI][B. Honary and G. Markarian, \u201cNew simple encoder and trellis decoder for Golay codes\u201d, Electronics Letters 29, 2170 (1993). DOI].\nBounded-distance decoder requiring at most 121 real operations [A. Vardy, \u201cEven more efficient bounded-distance decoding of the hexacode, the Golay code, and the Leech lattice\u201d, IEEE Transactions on Information Theory 41, 1495 (1995). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "perfect\nbinary_quad_residue\nbch", "parents_detail": "The Golay code is perfect.\nThe Golay code is a binary quadratic residue code with generator polynomial \\(r(x)\\) over \\(GF(2)\\) with length \\(n=23\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 16).\nThe Golay code is equivalent to a BCH code with Bose distance 5 ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 20).", "cousins_code_id": "nearly_perfect\ndual", "cousins_detail": "The extended Golay code is nearly perfect.\nThe extended Golay code is self-dual.", "cousin_of_code_id": "hexacode\nternary_golay", "cousin_of_detail": "Extended Golay codewords can be obtained from hexacodewords [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. The hexacode can be used to decode the extended Golay code [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI]. There is also a connection between automoprhisms of the even Golay code and the holomorph of the hexacode [J. A. Harvey and G. W. Moore, \u201cMoonshine, superconformal symmetry, and quantum error correction\u201d, Journal of High Energy Physics 2020, (2020). DOI; 2003.13700].\n", "_type": "ecc", "_page_id": "c_golay", "_href": "c/golay"}, "c_hadamard": {"notes": "", "logical": "bits", "code_id": "hadamard", "physical": "bits", "protection": "", "introduced": "", "description": "An \\([2^k,k,2^{k-1}]\\) balanced binary code dual to an extended Hamming Code.", "name": "Hadamard code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_linear\nbalanced", "parents_detail": "\nEach Hadamard codeword has length \\(2^m\\) and Hamming weight of \\(2^{m-1}\\), making this code balanced.", "cousins_code_id": "dual\nhamming\nreed_muller", "cousins_detail": "The Hadamard code is the dual of the extended Hamming Code.\nThe Hadamard code is the dual of the extended Hamming Code. Conversely, the shortened Hadamard code is the dual of the Hamming Code.\nFor any Hamming code \\([2^m,2^m-m-1,3]\\), the dual Hadamard code, when augmented with a bit that is always 0, gives the RM\\((1,m)\\) code. In general, RM\\((1,m)\\) is related to the duals of the Hamming code, and when RM\\((1,m)\\) is self-dual, it is directly related to the Hamming code.", "_type": "ecc", "_page_id": "c_hadamard", "_href": "c/hadamard"}, "c_repetition": {"notes": "", "logical": "bits", "code_id": "repetition", "physical": "bits", "protection": "Detects errors on up to \\(\\frac{n-1}{2}\\) coordinates, corrects erasure errors on up to \\(\\frac{n-1}{2}\\) coordinates. The generator matrix is \\(G=\\left[\\begin{smallmatrix}1 & 1&\\cdots& 1 & 1 \\end{smallmatrix}\\right]\\).", "introduced": "", "description": "\\([n,1,n]\\) binary linear code encoding one bit of information into an \\(n\\)-bit string. The length \\(n\\) needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a \\((n,1)\\)-Hamming code.", "name": "Repetition code", "realizations": "Repetition codes, in conjunction with other codes, were used in magnetic disks [T. Klove and M. Miller, \u201cThe Detection of Errors After Error-Correction Decoding\u201d, IEEE Transactions on Communications 32, 511 (1984). DOI].", "short_name": "", "features_threshold": "Suppose each bit has probability \\(p\\) of being received correctly, independent for each bit. The probability that a repetition code is received correctly is \\(\\sum_{k=0}^{(n-1)/2}\\frac{n!}{k!(n-k)!}p^{n-k}(1-p)^{k}\\). If \\(\\frac{1}{2}\\leq p\\), then people can always increase the probability of success by increasing the number of physical bit \\(n\\).", "features_code_capacity_threshold": "", "features_decoders": "Calculate the Hamming weight \\(d_H\\) of the code. If \\(d_H\\leq \\frac{n-1}{2}\\), decode the code as 0. If \\(d_H\\geq \\frac{n+1}{2}\\), decode the code as 1.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Code rate is \\(\\frac{1}{n}\\), code distance is \\(n\\).", "features_transversal_gates": "", "features_fault_tolerance": "Triple modular redundancy (TMR) error-correction protocol [R. E. Lyons and W. Vanderkulk, \u201cThe Use of Triple-Modular Redundancy to Improve Computer Reliability\u201d, IBM Journal of Research and Development 6, 200 (1962). DOI]; see Ref. [Steven M. Girvin, \u201cIntroduction to Quantum Error Correction and Fault Tolerance\u201d. 2111.08894] for a pedagogical explanation.", "parents_code_id": "binary_cyclic\nnearly_perfect", "parents_detail": "\n", "cousins_code_id": "perfect\nquantum_repetition\nhamming", "cousins_detail": "Repetition codes are perfect for odd \\(n\\).\n\nThe triple repetition code \\([3,1,3]\\) is the smallest Hamming code.", "cousin_of_code_id": "parity_check\nsimplex", "cousin_of_detail": "Binary parity-check codes and repetition codes are dual to each other.\n\\(S(2,1)\\) reduces to the repetition code.", "_type": "ecc", "_page_id": "c_repetition", "_href": "c/repetition"}, "c_parity_check": {"notes": "", "logical": "bits", "code_id": "parity_check", "physical": "bits", "protection": "This code cannot protect information, it can only detect 1-bit error.", "introduced": "", "description": "Also known as a sum-zero or even-weight code. An \\([n,n-1,2]\\) linear binary code whose codewords consist of the message string appended with a parity-check bit such that the parity (i.e., sum over all coordinates of each codeword) is zero. If the Hamming weight of a message is odd (even), then the parity bit is one (zero). This code requires only one extra bit of overhead and is therefore inexpensive.", "name": "Parity-check code", "realizations": "Can be realized on almost every communication device. Parity-check codes are some of the earlier error-correcting codes ([Encyclopedia of Computer Science and Technology, Second Edition Volume I (CRC Press, 2017). DOI], Ch. 27).", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "If the receiver finds that the parity information of a codeword disagrees with the parity bit, then the receiver will discard the information and request a resend.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The code rate is \\(\\frac{n}{n+1}\\to 1\\) as \\(n\\to\\infty\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "binary_cyclic\nnearly_perfect\nmds\ndivisible", "parents_detail": "Since permutations preserve parity, the cyclic permutation of a parity-check codeword is another codeword.\n\n\nBinary parity-check codes are two-divisible.", "cousins_code_id": "repetition\nq-ary_parity_check\nbinary_linear", "cousins_detail": "Binary parity-check codes and repetition codes are dual to each other.\n\nAny \\([n,k,d]\\) code with odd distance can be extended to an \\([n+1,k,d+1]\\) code by adding a bit storing the sum of codeword coordinates.", "cousin_of_code_id": "reed_muller", "cousin_of_detail": "RM\\((m-1,m)\\) are parity-check codes.", "_type": "ecc", "_page_id": "c_parity_check", "_href": "c/parity_check"}, "c_hamming": {"notes": "See database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.", "logical": "bits", "code_id": "hamming", "physical": "bits", "protection": "Can detect 1-bit and 2-bit errors, and can correct 1-bit errors.", "introduced": "[C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI][R. W. Hamming, \u201cError Detecting and Error Correcting Codes\u201d, Bell System Technical Journal 29, 147 (1950). DOI][M. J. E. Golay, Notes on digital coding, Proc. IEEE, 37 (1949) 657.]", "description": "An infinite family of perfect linear codes with parameters \\((2^r-1,2^r-r-1, 3)\\) for \\(r \\geq 2\\). Their \\(r \\times (2^r-1) \\) parity check matrix \\(H\\) has all possible non-zero \\(r\\)-bit strings as its columns.\n\nA generator matrix for the \\([7,4,3]\\) Hamming code is \\begin{align}\n\\left(\\begin{array}{ccccccccccc}\n  1 & 0 & 0 & 0 & 1 & 1 & 0\\\\\n  0 & 1 & 0 & 0 & 1 & 0 & 1\\\\\n  0 & 0 & 1 & 0 & 0 & 1 & 1\\\\\n  0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\\right)~.\n\\end{align} ", "name": "Hamming code", "realizations": "Commonly used when error rates are very low, for example, computer RAM or integrated circuits [R. Hentschke et al., \u201cAnalyzing area and performance penalty of protecting different digital modules with Hamming code and triple modular redundancy\u201d, Proceedings. 15th Symposium on Integrated Circuits and Systems Design. DOI].\nHamming-code based matrix embedding used in steganography [Crandall, Ron. \"Some notes on steganography.\" Posted on steganography mailing list 1998 (1998): 1-6.][A. Westfeld, \u201cF5\u2014A Steganographic Algorithm\u201d, Information Hiding 289 (2001). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Asymptotic rate \\(k/n = 1-\\frac{\\log n}{n} \\to 1\\) and normalized distance \\(d/n \\to 0\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "perfect\nreed_muller\nbch", "parents_detail": "\nHamming codes are equivalent to RM\\(^*(m-2,m)\\).\nBinary Hamming codes are binary primitive narrow-sense BCH codes ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Corr. 5.1.5). Binary Hamming codes are cyclic ([R. Hill. A First Course In Coding Theory. Oxford University Press, 1988.], Thm. 12.22).", "parent_of_code_id": "tetracode", "parent_of_detail": "The tetracode is equivalent to the \\(r=2\\) Hamming code.", "cousins_code_id": "projective\nbinary_quad_residue\nquantum_hamming\nq-ary_hamming\nnearly_perfect", "cousins_detail": "Columns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(2)^n\\).\n\\([7,4,3]\\) Hamming code is a quadratic-residue code [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.].\n\n\nShortened Hamming codes \\([2^r-2,2^r-r-2,3]\\) are nearly perfect ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 533).", "cousin_of_code_id": "hadamard\noctacode\nrepetition\nsteane\nquantum_hamming_css", "cousin_of_detail": "The Hadamard code is the dual of the extended Hamming Code. Conversely, the shortened Hadamard code is the dual of the Hamming Code.\nThe octacode reduces modulo-two to the \\([8,4,4]\\) Hamming code [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI].\nThe triple repetition code \\([3,1,3]\\) is the smallest Hamming code.\nThe Steane code is constructed from a classical Hamming code.\nQuantum Hamming codes result from applying the CSS construction to Hamming codes.", "_type": "ecc", "_page_id": "c_hamming", "_href": "c/hamming"}, "c_weight_two": {"notes": "See Ch. 19 of book [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI] on weight-two codes.", "logical": "bits", "code_id": "weight_two", "physical": "bits", "protection": "", "introduced": "", "description": "A length-\\(n\\) binary code whose codewords all have Hamming weight two. Such codes provide slightly extra redundancy for storage of small-scale information such as ZIP codes or decimal digits.\n\nFor example, the two-in-five code has a size 10, thereby providing an encoding for the decimal digits 0 through 9. Such a code detects some single bit-flips as well as unidirectional errors using the fact that each codeword is weight-two. The code fails for any sequence of flips that maintains the constant weight. ", "name": "Weight-two code", "realizations": "Two-in-five, also known as the two-out-of-five code, was used in the United States Postal Service's POSTNET barcode system as well as the Postal Alpha-numeric Encoding Technique (PLANET).\nTwo-in-five code forms the numerical part of the Code 39 barcode encoding.\nTwo-in-five code was used on early IBM computers [J. Svigals, \u201cIBM 7070 data processing system\u201d, Papers presented at the the March 3-5, 1959, western joint computer conference on XX - IRE-AIEE-ACM '59 (Western) (1959). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "constant_weight\nbinary_linear", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_weight_two", "_href": "c/weight_two"}, "c_one_hot": {"notes": "", "logical": "bits", "code_id": "one_hot", "physical": "bits", "protection": "", "introduced": "", "description": "Also known as an \\(1\\)-in-\\(n\\) code. A length-\\(n\\) binary code whose codewords are those with Hamming weight one. The reverse of this code, where all codewords have Hamming weight \\(n-1\\) is called a one-cold code. ", "name": "One-hot code", "realizations": "The bi-quinary code, a combination of one-hot 1-in-2 and 1-in-5 one-hot codes to encode decimal digits, was used in several early computers ([Encyclopedia of Computer Science and Technology, Second Edition Volume I (CRC Press, 2017). DOI], Ch. 27).\nMarking the state of a finite automaton [S. Devadas and A. R. Newton, \u201cDecomposition and factorization of sequential finite state machines\u201d, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems 8, 1206 (1989). DOI].\nUsed in machine-learning based classification tasks because one-hot encodings, as opposed to integer encodings, do not presume an order [K. Potdar, T. S., and C. D., \u201cA Comparative Study of Categorical Variable Encoding Techniques for Neural Network Classifiers\u201d, International Journal of Computer Applications 175, 7 (2017). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "constant_weight\nbinary_cyclic", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_one_hot", "_href": "c/one_hot"}, "c_metrological": {"notes": "", "logical": "", "code_id": "metrological", "physical": "", "protection": "Physical noise can cause logical errors along one of the three axes, i.e., either logical-\\(X\\), \\(Y\\), or \\(Z\\), depending on what basis is used. Codes protect against logical errors along the remaining two axes.\n\nA metrological code defined in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits) has distance \\(d\\) if the above conditions are satisfied for an error set \\(\\cal E\\) consisting of errors supported on \\(d-1\\) subsystems of less.", "introduced": "[Philippe Faist et al., \u201cTime-energy uncertainty relation for noisy quantum metrology\u201d. 2207.13707]", "description": "Linear subspace of a Hilbert space whose basis states satisfy only a part of the Knill-Laflamme conditions. The satisfied part of the conditions ensures that the code can be used for local parameter estimation.\n\nLetting \\(\\Pi = U U^\\dagger\\) be the codespace projector for encoding isometry \\(U\\) and projecting a pair of errors \\(E_i,E_j\\) from an error set \\(\\cal E\\) into the two-dimensional codespace yields \\begin{align}\n  \\Pi E_{i}^{^{\\dagger}}E_{j}\\Pi=c_{ij}\\,\\Pi+x_{ij}\\overline{X}+y_{ij}\\overline{Y}+z_{ij}\\overline{Z}\n\\end{align} with error-matrix element \\(c_{ij}\\) and logical-error coefficients \\begin{align}\n  \\left\\{ x,y,z\\right\\} _{ij}={\\textstyle \\frac{1}{2}}\\text{Tr}\\left(\\left\\{ \\overline{X},\\overline{Y},\\overline{Z}\\right\\} E_{i}^{^{\\dagger}}E_{j}\\right)~.\n\\end{align} If all three logical-error coefficients are zero, then the Knill-Laflamme conditions are satisfied, and the code is a QECC. If only one of the three coefficients is zero, then the code is the more general metrological code.", "name": "Metrological code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parent_of_code_id": "qecc", "parent_of_detail": "Metrological codes satisfy the Knill-Laflamme conditions conditions only partially, and codes that satisfy them fully are QECCs.", "cousins_code_id": "metopt\ncovariant\nqubit_stabilizer", "cousins_detail": "Error-corrected sensing codes are required to satisfy the Knill-Laflamme conditions, while metrological codes need only satisfy the conditions partially.\nAny time-covariant QECC, i.e., a code admitting a continuous-parameter \\(U(1)\\) family of gates, is automatically a metrological code.\nA joint \\(+1\\) and \\(-1\\) eigenstate of a set of stabilizer can form a metrological stabilizer code [Philippe Faist et al., \u201cTime-energy uncertainty relation for noisy quantum metrology\u201d. 2207.13707].", "_type": "ecc", "_page_id": "c_metrological", "_href": "c/metrological"}, "c_oecc": {"notes": "", "logical": "", "code_id": "oecc", "physical": "", "protection": "Necessary and sufficient [M. A. Nielsen and D. Poulin, \u201cAlgebraic and information-theoretic conditions for operator quantum error correction\u201d, Physical Review A 75, (2007). DOI; quant-ph/0506069] error-correction conditions are, for all errors \\(E_a,E_b\\) in an error set \\(\\cal{E}\\), \\begin{align}\nP E^{\\dagger}_a E_b P = I_{\\mathsf{A}} \\otimes g_{ab}^{\\mathsf{B}}\n\\end{align} where \\(P\\) is a projector onto the codespace \\(\\mathsf{C}\\), and \\(g_{ab}^{\\mathsf{B}}\\) is an arbitrary operator on the gauge subsystem. ", "introduced": "[D. Kribs, R. Laflamme, and D. Poulin, \u201cUnified and Generalized Approach to Quantum Error Correction\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0412076][David W. Kribs et al., \u201cOperator quantum error correction\u201d. quant-ph/0504189]", "description": "A subsystem code, also known as an operator QECC or gauge QECC, encodes information in a subsystem \\(\\mathsf{A}\\) of the code space \\(\\mathsf{C}\\), which is part of the system Hilbert space \\(\\mathsf{H}\\), as \\begin{align}\n\\mathsf{H}=\\mathsf{C} \\oplus \\mathsf{C}^{\\perp} = \\mathsf{A} \\otimes \\mathsf{B} \\oplus \\mathsf{C}^{\\perp}~.\n\\end{align} Following an error, it is sufficient to revert back to the original state modulo a transformation on the auxiliary or gauge subsystem \\(\\mathsf{B}\\). The subsystem \\(\\mathsf{B}\\) therefore gives additional freedom to the error correction process, and is said to encode gauge qubits when its dimension is a power of two. While strictly speaking all operator QECCs are also ordinary QECCs, the attachment of a subsystem to a code allows for a wider variety of encoding procedures, fault-tolerant logical operations, and efficient error-correction protocols. ", "name": "Subsystem quantum error-correcting code", "realizations": "", "short_name": "Subsystem QECC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oaecc", "parents_detail": "", "parent_of_code_id": "subsystem_stabilizer", "parent_of_detail": "", "cousins_code_id": "qecc", "cousins_detail": "A subsystem code reduces to an ordinary error-correcting code when the gauge subsystem is trivial, \\(\\mathsf{B} = \\mathbb{C}\\). Conversely, any QECC with a tensor-product logical subspace can be turned into a subsystem code by treating a logical tensor factor as a gauge subsystem.", "cousin_of_code_id": "eaoecc", "cousin_of_detail": "Entanglement-assisted operator QECCs are subsystem QECCs utilizing pre-shared entanglement.", "_type": "ecc", "_page_id": "c_oecc", "_href": "c/oecc"}, "c_qecc": {"notes": "", "logical": "", "code_id": "qecc", "physical": "", "protection": "Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{\\text{logical}}\\to\\mathsf{H}_{\\text{physical}}\\) with a set of correctable errors \\(\\cal{E}\\) with the following property: there exists a quantum operation \\(\\cal{D}\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{\\text{logical}}\\), \\begin{align}\n  {\\cal D} (EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})\n  = c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\n\\end{align} for some constant \\(c\\).\n\nEquivalently, correction capability is determined by the Knill-Laflamme conditions, which may admit infinite terms due to non-normalizability of ideal code states in the case of codes with infinite-dimenional physical spaces. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an approximate code. These conditions can also be formulated in terms of a dual Heisenberg picture, where correctability is checked for some algebra of observables [C. B\u00e9ny, A. Kempf, and D. W. Kribs, \u201cQuantum error correction on infinite-dimensional Hilbert spaces\u201d, Journal of Mathematical Physics 50, 062108 (2009). DOI; 0811.0421].", "introduced": "", "description": "Encodes quantum information in a (logical) subspace of a (physical) Hilbert space such that it is possible to recover said information from errors that act as linear maps on the physical space. The logical subspace is spanned by a basis comprised of code basis states or codewords. Codewords may not be normalizable if the physical Hilbert space in infinite, so approximate versions have to be constructed in practice. ", "name": "Quantum error-correcting code (QECC)", "realizations": "", "short_name": "QECC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oaecc\nmetrological", "parents_detail": "\nMetrological codes satisfy the Knill-Laflamme conditions conditions only partially, and codes that satisfy them fully are QECCs.", "parent_of_code_id": "approximate_qecc\noscillators\ncovariant\ndynamic_gen\nqecc_finite\ngroup_quantum\nhamiltonian\nquantum_lego\nquantum_cyclic\nquantum_random\nstabilizer", "parent_of_detail": "\n\n\n\n\n\n\n\n\n\n", "cousin_of_code_id": "eaqecc\noecc", "cousin_of_detail": "EA-QECCs are QECCs utilizing pre-shared entanglement.\nA subsystem code reduces to an ordinary error-correcting code when the gauge subsystem is trivial, \\(\\mathsf{B} = \\mathbb{C}\\). Conversely, any QECC with a tensor-product logical subspace can be turned into a subsystem code by treating a logical tensor factor as a gauge subsystem.", "_type": "ecc", "_page_id": "c_qecc", "_href": "c/qecc"}, "c_eaqecc": {"notes": "", "logical": "", "code_id": "eaqecc", "physical": "", "protection": "", "introduced": "[T. A. Brun, I. Devetak, and M.-H. Hsieh, \u201cCatalytic Quantum Error Correction\u201d, IEEE Transactions on Information Theory 60, 3073 (2014). DOI; quant-ph/0608027][T. Brun, I. Devetak, and M.-H. Hsieh, \u201cCorrecting Quantum Errors with Entanglement\u201d, Science 314, 436 (2006). DOI; quant-ph/0610092]", "description": "QECC whose encoding and decoding utilizes pre-shared entanglement between sender and receiver.", "name": "Entanglement-assisted (EA) QECC", "realizations": "", "short_name": "EAQECC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "eacq", "parents_detail": "", "parent_of_code_id": "eastab", "parent_of_detail": "", "cousins_code_id": "qecc\nqudits_into_qudits\nbinary_linear\nq-ary_linear", "cousins_detail": "EA-QECCs are QECCs utilizing pre-shared entanglement.\nPure modular-qudit codes can be used to make EA-QECCs with the same distance and dimension; see Thm. 10 of Ref. [M. Grassl, F. Huber, and A. Winter, \u201cEntropic Proofs of Singleton Bounds for Quantum Error-Correcting Codes\u201d, IEEE Transactions on Information Theory 68, 3942 (2022). DOI; 2010.07902].\nAny linear binary code can be used to construct an EAQECC.\nAny linear \\(q\\)-ary code can be used to construct an EAQECC.", "cousin_of_code_id": "metopt", "cousin_of_detail": "Metrologically optimal codes can be thought of as being entanglement-assisted because they require error-free ancillas for optimal local parameter estimation, and the estimation procedure uses an entangling gate.", "_type": "ecc", "_page_id": "c_eaqecc", "_href": "c/eaqecc"}, "c_eaoecc": {"notes": "", "logical": "", "code_id": "eaoecc", "physical": "", "protection": "", "introduced": "[M.-H. Hsieh, I. Devetak, and T. Brun, \u201cGeneral entanglement-assisted quantum error-correcting codes\u201d, Physical Review A 76, (2007). DOI; 0708.2142][T. A. Brun, I. Devetak, and M.-H. Hsieh, \u201cGeneral entanglement-assisted quantum error-correcting codes\u201d, 2007 IEEE International Symposium on Information Theory (2007). DOI]", "description": "Subsystem QECC whose encoding and decoding utilizes pre-shared entanglement between sender and receiver.", "name": "Entanglement-assisted (EA) operator QECC", "realizations": "", "short_name": "EAOQECC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "eacq", "parents_detail": "", "cousins_code_id": "oecc", "cousins_detail": "Entanglement-assisted operator QECCs are subsystem QECCs utilizing pre-shared entanglement.", "_type": "ecc", "_page_id": "c_eaoecc", "_href": "c/eaoecc"}, "c_quantum_convolutional": {"notes": "", "logical": "qubits", "code_id": "quantum_convolutional", "physical": "qubits", "protection": "", "introduced": "[G. D. Forney, M. Grassl, and S. Guha, \u201cConvolutional and Tail-Biting Quantum Error-Correcting Codes\u201d, IEEE Transactions on Information Theory 53, 865 (2007). DOI; quant-ph/0511016]", "description": "Stub.", "name": "Quantum convolutional code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "cousin_of_code_id": "convolutional\nquantum_reed_muller", "cousin_of_detail": "Quantum analogue of convolutional codes\nQuantum convolutional codes can be derived from Quantum Reed-Muller codes [Salah A. Aly, Andreas Klappenecker, and Pradeep Kiran Sarvepalli, \u201cQuantum Convolutional Codes Derived From Reed-Solomon and Reed-Muller Codes\u201d. quant-ph/0701037].", "_type": "ecc", "_page_id": "c_quantum_convolutional", "_href": "c/quantum_convolutional"}, "c_quantum_divisible": {"notes": "", "logical": "qubits", "code_id": "quantum_divisible", "physical": "qubits", "protection": "Distance \\(d\\) is upper bounded by the two classical codes that determine the CSS code.", "introduced": "[Jingzhen Hu, Qingzhong Liang, and Robert Calderbank, \u201cDivisible Codes for Quantum Computation\u201d. 2204.13176]", "description": "Consider a CSS code whose \\(Z\\)-stabilizers are determined by the dual of a classical \\([n, k_1]\\) linear binary code \\(C_1\\), and whose \\(X\\)-stabilizers are determined by a classical \\([n, k_2]\\) binary code \\(C_2 \\subset C_1\\). This code is quantum divisible if all weights in \\(C_2\\) share a common divisor \\(\\Delta > 1\\), and all weights in each coset of \\(C_2\\) in \\(C_1\\) are congruent to \\(\\Delta\\).\n\nFor example, if \\(C_2\\) is the first-order Reed-Muller code, and \\(C_1/ C_2\\) consists of quadratic forms with a bounded rank, then \\([[n = 2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), d = 3]]\\) is a family of quantum divisible codes. ", "name": "Quantum divisible code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "The \\([[2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), 3]]\\) quantum divisible code family can serve as outer codes of either the five-qubit \\([[5,1,3]]\\) or Steane \\([[7,1,3]]\\) code to realize a \\(T\\) gate on the inner code. For example, when \\(m=5\\) (\\(m=6\\)), the resulting \\([[31,5,3]]\\) (\\([[63,7,3]]\\)) code yields the \\(T\\) gate on the inner five-qubit (Steane) code.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "The \\(T\\) gate realized by concatenating members of the \\([[2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), 3]]\\) quantum divisible code family with either the five-qubit \\([[5,1,3]]\\) or Steane \\([[7,1,3]]\\) code is fault-tolerant and does not require magic-state distillation. The gate is performed on the inner five-qubit/Steane code and does require encoding and decoding algorithms to pass between the inner and outer codes.", "parents_code_id": "css", "parents_detail": "", "cousins_code_id": "divisible\nreed_muller\nquantum_reed_muller\nquantum_triorthogonal\nquantum_concatenated\nstab_5_1_3\nsteane", "cousins_detail": "Quantum divisible codes are constructed via the CSS construction using a divisible linear binary code.\nQuantum divisible codes can be constructed out of first-order RM codes.\nQuantum RM codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions.\nTriorthogonal codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions.\nA fault-tolerant \\(T\\) gate on the five-qubit or Steane code can be obtained by concatenating with particular quantum divisible codes.\nA fault-tolerant \\(T\\) gate on the five-qubit code can be obtained by concatenating with particular quantum divisible codes.\nA fault-tolerant \\(T\\) gate on the Steane code can be obtained by concatenating with particular quantum divisible codes.", "_type": "ecc", "_page_id": "c_quantum_divisible", "_href": "c/quantum_divisible"}, "c_haar_random": {"notes": "", "logical": "qubits", "code_id": "haar_random", "physical": "qubits", "protection": "Random code achieve the capacity of any noisy quantum channel.", "introduced": "[Peter W. Shor, The quantum channel capacity and coherent information, 2002 (obtained from the MSRI Workshop on Quantum Computation website).][P. Hayden et al., \u201cA Decoupling Approach to the Quantum Capacity\u201d, Open Systems &amp; Information Dynamics 15, 7 (2008). DOI; quant-ph/0702005][I. Devetak, \u201cThe private classical capacity and quantum capacity of a quantum channel\u201d. quant-ph/0304127][Rochus Klesse, \u201cA random-coding based proof for the quantum coding theorem\u201d. 0712.2558]", "description": "Haar-random codewords are generated in a process involving averaging over unitary operations distributed accoding to the Haar measure. Haar-random codes are used to prove statements about the capacity of a quantum channel to transmit quantum information [M. M. Wilde, \u201cPreface to the Second Edition\u201d, Quantum Information Theory xi. DOI; 1106.1445], but encoding and decoding in such \\(n\\)-qubit codes quickly becomes impractical as \\(n\\to\\infty\\).\n\nThere are different approaches to create Haar-random codewords. In the construction of Ref. [P. Hayden et al., \u201cA Decoupling Approach to the Quantum Capacity\u201d, Open Systems &amp; Information Dynamics 15, 7 (2008). DOI; quant-ph/0702005], codewords are produced by performing a unitarily covariant projective measurement on a typical subspace of a tensor-power state. Reference [P. Hayden et al., \u201cA Decoupling Approach to the Quantum Capacity\u201d, Open Systems &amp; Information Dynamics 15, 7 (2008). DOI; quant-ph/0702005] showed that the capacity of a noisy quantum channel can be achieved by encoding in such Haar-random codes. In particular, Haar-random codes achieve perfect transmission in the \\(n\\to\\infty\\)) limit by proving that the encoded information becomes decoupled from the environment. This is a necessary and sufficient condition for successful decoding since measurements of the environment should never reveal the encoded information [B. Schumacher and M. A. Nielsen, \u201cQuantum data processing and error correction\u201d, Physical Review A 54, 2629 (1996). DOI; quant-ph/9604022].\n\nIntuitively, coupling with the environment can be decreased by projecting the system onto a random codespace. The more qubits that are randomly discarded, the more the codespace is decoupled from the environment. One may ask what is the least amount of qubits that can be discarded, i.e. the largest remaining codespace, that still achieves decoupling. It can be shown through the decoupling inequality [M. Horodecki, J. Oppenheim, and A. Winter, \u201cQuantum State Merging and Negative Information\u201d, Communications in Mathematical Physics 269, 107 (2006). DOI; quant-ph/0512247] that the largest possible dimension of the random codespace that achieves arbitrarily large decoupling is exponential in the coherent information of the channel. Therefore, there exist codes that can transmit information with rate equal to the coherent information. Furthermore, these codes can be constructed with high probability by performing a Haar-random isometry embedding a \\(k\\)-dimensional logical subspace into an \\(n\\)-dimensional physical space, where \\(k/n\\) is equal to the coherent information. Such an isometry can be produced by QR decomposition of a Gaussian random matrix [G. W. Stewart, \u201cThe Efficient Generation of Random Orthogonal Matrices with an Application to Condition Estimators\u201d, SIAM Journal on Numerical Analysis 17, 403 (1980). DOI].", "name": "Haar-random code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The rate of the code is equal to the coherent information of the channel (i.e. the quantum channel capacity).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "random_circuit", "parents_detail": "", "cousins_code_id": "t-designs", "cousins_detail": "Approximating the random projections through \\(t\\)-designs is necessary in order to make the protocol practical. Replacing with random Clifford gates is especially convenient since the Clifford group forms a unitary 2-design and produces stabilizer codes.", "_type": "ecc", "_page_id": "c_haar_random", "_href": "c/haar_random"}, "c_eastab": {"notes": "See Ref. [Gaojun Luo et al., \u201cHow Much Entanglement Does a Quantum Code Need?\u201d. 2207.05647] for code tables and bounds on performance.", "logical": "", "code_id": "eastab", "physical": "", "protection": "", "introduced": "[T. A. Brun, I. Devetak, and M.-H. Hsieh, \u201cCatalytic Quantum Error Correction\u201d, IEEE Transactions on Information Theory 60, 3073 (2014). DOI; quant-ph/0608027][T. Brun, I. Devetak, and M.-H. Hsieh, \u201cCorrecting Quantum Errors with Entanglement\u201d, Science 314, 436 (2006). DOI; quant-ph/0610092]", "description": "Constructed using a variation of the stabilizer formalism designed to utilize pre-shared entanglement between sender and receiver. An EA stabilizer code is denoted as \\([[n,k;c]]\\) or \\([[n,k,d;c]]\\), where \\(d\\) is the code's distance, and \\(c\\) is the number of required pre-shared maximally entangled Bell states.' ", "name": "Entanglement-assisted (EA) stabilizer code", "realizations": "", "short_name": "EA stabilizer", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "eaqecc\nqubit_stabilizer", "parents_detail": "\nEntanglement-assisted stabilizer codes are stabilizer codes utilizing pre-shared entanglement.", "parent_of_code_id": "quantum_polar", "parent_of_detail": "Quantum polar codes are CSS codes used in an entanglement generation scheme that generally requires entanglement assistance.", "cousins_code_id": "binary_linear\nq-ary_linear\ncss", "cousins_detail": "Any linear binary code can be used to construct an EA stabilizer code.\nAny linear quaternary (\\(q=4\\)) code can be used to construct an EA stabilizer code.\nAs opposed to CSS codes, EA stabilizer codes can be constructed from any linear binary code.", "_type": "ecc", "_page_id": "c_eastab", "_href": "c/eastab"}, "c_xs_stabilizer": {"notes": "", "logical": "qubits", "code_id": "xs_stabilizer", "physical": "qubits", "protection": "", "introduced": "[X. Ni, O. Buerschaper, and M. Van den Nest, \u201cA non-commuting stabilizer formalism\u201d, Journal of Mathematical Physics 56, 052201 (2015). DOI; 1404.5327]", "description": "A type of stabilizer code where stabilizer generators are elements of the group \\( \\{\\alpha I, X, \\sqrt{Z}]\\}^{\\otimes n} \\), with \\( \\sqrt{Z} = \\text{diag} (1, i)\\). The codespace is a joint \\(+1\\) eigenspace of a set of stabilizer generators, which need not commute to define a valid codespace. ", "name": "XS stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "xp_stabilizer", "parents_detail": "The XP stabilizer formalism reduces to the XS formalism at \\(N=4\\).", "cousins_code_id": "topological_abelian", "cousins_detail": "Twisted quantum double models for the groups \\(\\mathbb{Z}_2^k\\) can be realized as XS stabilizer codes.", "_type": "ecc", "_page_id": "c_xs_stabilizer", "_href": "c/xs_stabilizer"}, "c_eth": {"notes": "", "logical": "qubits", "code_id": "eth", "physical": "qubits", "protection": "Approximately protects against erasure errors at known locations. Translation invariance alone is sufficient for good approximate error-correcting properties in a many-body spectrum, including in integrable models [F. G. S. L. Brand\u00e3o et al., \u201cQuantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains\u201d, Physical Review Letters 123, (2019). DOI; 1710.04631]. The ETH code generated from the spectrum of the translation-invariant 1D Heisenberg spin chain [F. G. S. L. Brand\u00e3o et al., \u201cQuantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains\u201d, Physical Review Letters 123, (2019). DOI; 1710.04631] has recovery infidelity (against the erasure of a constant number of sites) scale as \\(\\epsilon_\\text{worst}=O(1/n)\\) [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].", "introduced": "[F. G. S. L. Brand\u00e3o et al., \u201cQuantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains\u201d, Physical Review Letters 123, (2019). DOI; 1710.04631]", "description": "Also called a thermodynamic code [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]. An \\(n\\)-qubit approximate code whose codespace is formed by eigenstates of a translationally-invariant quantum many-body system which satisfies the Eigenstate Thermalization Hypothesis (ETH). ETH ensures that codewords cannot be locally distinguished in the thermodynamic limit. Relevant many-body systems include 1D non-interacting spin chains, Motzkin chains, or Heisenberg models.\n\nETH requires that for ordered energy eigenstates \\(|E_l\\rangle\\) and any local observable \\(O\\), \\begin{align}\n|\\langle E_l|O|E_l\\rangle-\\langle E_{l+1}|O|E_{l+1}\\rangle|\\leq\\exp(-cn)\n\\end{align} for a constant \\(c\\). This implies that energy eigenstates around some energy \\(\\bar E\\) are approximately locally indistinguishable from one another, as their reduced density matrices on any subsystem are both approximately thermal at energy \\(\\bar E\\). In this way, global information is protected from local measurements by the environment as \\(n\\to\\infty\\). ", "name": "Eigenstate thermalization hypothesis (ETH) code", "realizations": "", "short_name": "ETH", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "An explicit universal recovery channel for the ETH code is given in [N. Bao and N. Cheng, \u201cEigenstate thermalization hypothesis and approximate quantum error correction\u201d, Journal of High Energy Physics 2019, (2019). DOI; 1906.03669].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hamiltonian\napproximate_qecc", "parents_detail": "ETH codewords are eigenstates of a local Hamiltonian whose eigenstates satisfy ETH.\nETH codes approximately protect against erasures in the thermodynamic limit.", "cousins_code_id": "topological", "cousins_detail": "ETH codewords, like topological codewords, are locally indistinguishable.", "cousin_of_code_id": "covariant", "cousin_of_detail": "ETH codes consisting of Dicke states are approximately \\(U(1)\\)-covariant and nearly saturate certain covariance-performance bounds [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360].", "_type": "ecc", "_page_id": "c_eth", "_href": "c/eth"}, "c_t-designs": {"notes": "", "logical": "qubits", "code_id": "t-designs", "physical": "qubits", "protection": "In a 1D geometry, the code approximately detects any error with support on a segment of length \\(\\leq n/4\\), with deviations exponentially suppressed in \\(n\\).", "introduced": "[F. G. S. L. Brand\u00e3o, A. W. Harrow, and M. Horodecki, \u201cLocal Random Quantum Circuits are Approximate Polynomial-Designs\u201d, Communications in Mathematical Physics 346, 397 (2016). DOI]", "description": "An \\(n\\)-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal \\(n\\)-qubit states and acting with a random unitary circuit of depth polynomial in \\(n\\). Two states are locally indistinguishable if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about \\(n/2\\) two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries. The above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (\\(D=1\\), while codes for higher-dimensional geometries require \\(O(n^{1/D})\\)-depth circuits [F. G. S. L. Brand\u00e3o, A. W. Harrow, and M. Horodecki, \u201cLocal Random Quantum Circuits are Approximate Polynomial-Designs\u201d, Communications in Mathematical Physics 346, 397 (2016). DOI]. Follow-up work [M. J. Gullans et al., \u201cQuantum Coding with Low-Depth Random Circuits\u201d, Physical Review X 11, (2021). DOI; 2010.09775] revealed that optimal code properties require only \\(O(\\sqrt{n})\\)-depth circuits for that case, and \\(O(\\sqrt{n})\\)-depth circuits for a two-dimensional square-lattice geometry.", "name": "Local Haar-random circuit code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Random local circuit of depth proportional to \\(n^{\\alpha}\\), with \\(\\alpha\\) depending on system geometry.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "random_circuit", "parents_detail": "", "cousins_code_id": "topological\napproximate_qecc", "cousins_detail": "Local Haar-random codewords, like topological codewords, are locally indistinguishable [F. G. S. L. Brand\u00e3o, A. W. Harrow, and M. Horodecki, \u201cLocal Random Quantum Circuits are Approximate Polynomial-Designs\u201d, Communications in Mathematical Physics 346, 397 (2016). DOI].\n", "cousin_of_code_id": "haar_random", "cousin_of_detail": "Approximating the random projections through \\(t\\)-designs is necessary in order to make the protocol practical. Replacing with random Clifford gates is especially convenient since the Clifford group forms a unitary 2-design and produces stabilizer codes.", "_type": "ecc", "_page_id": "c_t-designs", "_href": "c/t-designs"}, "c_qubits_into_qubits": {"notes": "There is a relation between one-way entanglement distillation protocols and QECCs [C. H. Bennett et al., \u201cMixed-state entanglement and quantum error correction\u201d, Physical Review A 54, 3824 (1996). DOI; quant-ph/9604024].", "logical": "qubits", "code_id": "qubits_into_qubits", "physical": "qubits", "protection": "A convenient and often considered error set is the Pauli error or Pauli string basis. For a single qubit, this set consists of products of powers of the Pauli matrices \\begin{align}\n  X=\\begin{pmatrix}0 & 1\\\\\n  1 & 0\n  \\end{pmatrix}\\,\\,\\text{ and }\\,\\,Z=\\begin{pmatrix}1 & 0\\\\\n  0 & -1\n  \\end{pmatrix}~.\n\\end{align} For multiple qubits, error set elements are tensor products of elements of the single-qubit error set.\n\nThe Pauli error set is a unitary and Hermitian basis for linear operators on the multi-qubit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a prototypical nice error basis [E. Knill, \u201cNon-binary Unitary Error Bases and Quantum Codes\u201d. quant-ph/9608048]. The distance associated with this set is often the minimum weight of a Pauli string that implements a nontrivial logical operation in the code. The minimum weight of a Pauli error that has a non-zero expectation value for some code basis state is called the diagonal distance [Upendra S. Kapshikar, \u201cThe Diagonal Distance of CWS Codes\u201d. 2107.11286]. Codes whose distance is greater than the diagonal distance are degenerate. ", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2^n\\)-dimensional (i.e., \\(n\\)-qubit) Hilbert space. Usually denoted as \\(((n,K))\\) or \\(((n,K,d))\\), where \\(d\\) is the code's distance. ", "name": "Qubit code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder. For few-qubit codes (\\(n\\) is small), maximum-likelihood decoding can be based by creating a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "cws\nmovassagh_ouyang\nxp_stabilizer", "parent_of_detail": "\n\n", "cousin_of_code_id": "fermions\nfock_state\ngroup_quantum\nspins_into_spins", "cousin_of_detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation [A. Y. Kitaev, \u201cUnpaired Majorana fermions in quantum wires\u201d, Physics-Uspekhi 44, 131 (2001). DOI; cond-mat/0010440], codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations.\nFock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators [Victor V. Albert, private communication, 2016]. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations [Steven M. Girvin, \u201cIntroduction to Quantum Error Correction and Fault Tolerance\u201d. 2111.08894].\nGroup quantum codes whose physical spaces are constructed using the group \\(\\mathbb{Z}_2\\) are qubit codes.\nSpin codes with spin \\(\\ell=1/2\\) correspond to qubit codes.", "_type": "ecc", "_page_id": "c_qubits_into_qubits", "_href": "c/qubits_into_qubits"}, "c_qubit_stabilizer": {"notes": "Tables of bounds and examples of stabilizer codes for various \\(n\\) and \\(k\\), based on algorithms developed in Ref. [M. Grassl, \u201cSearching for linear codes with large minimum distance\u201d, Discovering Mathematics with Magma 287. DOI], are maintained by M. Grassl at this website.\nStabilizer error-recovery circuits can be simulated efficiently using dedicated software (e.g., STIM [C. Gidney, \u201cStim: a fast stabilizer circuit simulator\u201d, Quantum 5, 497 (2021). DOI; 2103.02202]).", "logical": "qubits", "code_id": "qubit_stabilizer", "physical": "qubits", "protection": "Detects errors on up to \\(d-1\\) qubits, and corrects erasure errors on up to \\(d-1\\) qubits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).\n\nA stabilizer code is geometrically local if the support of the stabilizer generators is bounded by a ball of size independent of \\(n\\). There is an upper bound of \\(d \\leq O(L^{D-1})\\) on the distance [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983] of geometrically local stabilizer codes arranged in a \\(D\\)-dimensional lattice of length \\(L\\) with \\(n=L^D\\). ", "introduced": "[A. R. Calderbank et al., \u201cQuantum Error Correction and Orthogonal Geometry\u201d, Physical Review Letters 78, 405 (1997). DOI; quant-ph/9605005][Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052]", "description": "Also called a Pauli stabilizer code. An \\(((n,2^k,d))\\) qubit stabilizer code is denoted as \\([[n,k]]\\) or \\([[n,k,d]]\\), where \\(d\\) is the code's distance. Logical subspace is the joint eigenspace of commuting Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace of a set of \\(2^{n-k}\\) commuting Pauli operators which do not contain \\(-I\\). The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation in the code.\n\nEach stabilizer code can be represented by a \\((n-k) \\times 2n\\) check matrix (a.k.a. stabilizer generator matrix) \\(H=(A|B)\\), where each row \\((a|b)\\) is the binary symplectic representation of an element from a set of generating elements of the stabilizer group. The check matrix can be brought into standard form via Gaussian elimination [M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum Information (Cambridge University Press, 2009). DOI].\n\nThe stabilizer commutation condition can equivalently be stated in the symplectic representation. A pair of \\(n\\)-qubit stabilizers with symplectic representations \\((a|b)\\) and \\((a^{\\prime}|b^{\\prime})\\) commute iff their symplectic inner product is zero, \\begin{align}\n  a \\cdot b^{\\prime} + a^{\\prime}\\cdot b = \\sum_{j=1}^{n} a_j b^{\\prime}_j + a^{\\prime}_i b_i = 0~.\n\\end{align} Symplectic representations of stabilizer group elements thus form a self-orthogonal subspace of \\(GF(2)^{2n}\\) with respect to the symplectic inner product.", "name": "Qubit stabilizer code", "realizations": "", "short_name": "", "features_threshold": "Computational thresholds against stochastic local noise can be achieved through repeated use of concatenatenation, and can rely on the same small code in every level [E. Knill, R. Laflamme, and W. H. Zurek, \u201cResilient quantum computation: error models and thresholds\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 454, 365 (1998). DOI; quant-ph/9702058][Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129][J. Preskill, \u201cReliable quantum computers\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 454, 385 (1998). DOI; quant-ph/9705031][Panos Aliferis, Daniel Gottesman, and John Preskill, \u201cQuantum accuracy threshold for concatenated distance-3 codes\u201d. quant-ph/0504218]. The resulting code is highly degenerate, with all but an exponentially small fraction of generators having small weights. Circuit and measurement designs have to take case of the few stabilizer generators with large weights in order to be fault tolerant.", "features_code_capacity_threshold": "Bounds on code capacity thresholds using maximum-likelihood (ML) decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][A. A. Kovalev and L. P. Pryadko, \u201cFault tolerance of quantum low-density parity check codes with sublinear distance scaling\u201d, Physical Review A 87, (2013). DOI; 1208.2317][Alexey A. Kovalev and Leonid P. Pryadko, \u201cSpin glass reflection of the decoding transition for quantum error correcting codes\u201d. 1311.7688][C. T. Chubb and S. T. Flammia, \u201cStatistical mechanical models for quantum codes with correlated noise\u201d, Annales de l\u2019Institut Henri Poincar\u00e9 D 8, 269 (2021). DOI; 1809.10704].", "features_decoders": "The structure of stabilizer codes allows for syndrome-based decoding, where errors are corrected based on the results of stabilizer measurements (syndromes). Finding an optimal decoder is \\(\\#P\\)-hard [Pavithran Iyer and David Poulin, \u201cHardness of decoding quantum stabilizer codes\u201d. 1310.3235].\nTrellis decoder, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) [H. Ollivier and J.-P. Tillich, \u201cTrellises for stabilizer codes: Definition and uses\u201d, Physical Review A 74, (2006). DOI; quant-ph/0512041].\nQuantum extension of GRAND decoder [Diogo Cruz, Francisco A. Monteiro, and Bruno C. Coutinho, \u201cQuantum Error Correction via Noise Guessing Decoding\u201d. 2208.02744].", "features_general_gates": "Logical gates implemented via constant-depth quantum circuits of \\(D\\)-dimensional geometrically local stabilizer codes lie in the \\(D\\)th level of the Clifford hierarchy [S. Bravyi and R. K\u00f6nig, \u201cClassification of Topologically Protected Gates for Local Stabilizer Codes\u201d, Physical Review Letters 110, (2013). DOI; 1206.1609].\nWith pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].", "features_magic_scaling_exponent": "", "features_encoders": "Circuits consisting of CNOT, Hadamard, and phase gates using algorithm based on the Gottesman-Knill theorem [S. Aaronson and D. Gottesman, \u201cImproved simulation of stabilizer circuits\u201d, Physical Review A 70, (2004). DOI; quant-ph/0406196].\nCircuits obtained by first constructing the CWS form of the code [I. Chuang et al., \u201cCodeword stabilized quantum codes: Algorithm and structure\u201d, Journal of Mathematical Physics 50, 042109 (2009). DOI; 0803.3232][A. Cross et al., \u201cCodeword Stabilized Quantum Codes\u201d, IEEE Transactions on Information Theory 55, 433 (2009). DOI; 0708.1021]. These consist of \\(n\\) Hadamard gates, a classical encoder which takes at most \\(n\\) CX gates for a single-qubit encoding code, and at most \\(n(n-1)/2\\) CZ gates to create the needed graph state.\nDissipative preparation, for which codespace is steady-state space of a Lindbladian [J. Dengis, R. K\u00f6nig, and F. Pastawski, \u201cAn optimal dissipative encoder for the toric code\u201d, New Journal of Physics 16, 013023 (2014). DOI; 1310.1036].\nLindbladian-based dissipative encoding [Juan Pablo Paz and Wojciech Hubert Zurek, \u201cContinuous Error Correction\u201d. quant-ph/9707049][J. Dengis, R. K\u00f6nig, and F. Pastawski, \u201cAn optimal dissipative encoder for the toric code\u201d, New Journal of Physics 16, 013023 (2014). DOI; 1310.1036] that does not give a speedup, in terms of scaling with \\(n\\), over circuit-based encoders [R. K\u00f6nig and F. Pastawski, \u201cGenerating topological order: No speedup by dissipation\u201d, Physical Review B 90, (2014). DOI; 1310.1037].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "With pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].\nFault-tolerant error correction scheme by Shor [Peter W. Shor, \u201cFault-tolerant quantum computation\u201d. quant-ph/9605011], which is based on repeated measurements. A modification uses adaptive measurements [Theerapat Tansuwannont and Kenneth R. Brown, \u201cAdaptive syndrome measurements for Shor-style error correction\u201d. 2208.05601].\nFault-tolerant error correction scheme by Knill (a.k.a. telecorrection [C. M. Dawson, H. L. Haselgrove, and M. A. Nielsen, \u201cNoise thresholds for optical cluster-state quantum computation\u201d, Physical Review A 73, (2006). DOI; quant-ph/0601066]), which is based on teleportation [E. Knill, \u201cQuantum computing with realistically noisy devices\u201d, Nature 434, 39 (2005). DOI; quant-ph/0410199][E. Knill, \u201cScalable Quantum Computation in the Presence of Large Detected-Error Rates\u201d. quant-ph/0312190].", "parents_code_id": "stabilizer\ncws\nxp_stabilizer\nquantum_lego", "parents_detail": "\nIf the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code.\nThe XP stabilizer formalism reduces to the Pauli formalism at \\(N=2\\).\nQubit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qubit repetition code, single-qubit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state.", "parent_of_code_id": "css\nclifford-deformed_surface\neastab\nfloquet\nfusion\nhaah_cubic\nmajorana_stab\nmatching\nhappy\nquantum_convolutional\nquantum_bch\nrbh\nstabilizer_over_gf4\ntfim\nxyz_product\nquantum_hamming", "parent_of_detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) self-orthogonal CSS code, with the mapping preserving geometric locality of a code up to a constant factor [S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791].\n\nEntanglement-assisted stabilizer codes are stabilizer codes utilizing pre-shared entanglement.\nParticular sequences of measurements on this code yield an instantaneous stabilizer group.\nThe resource states in FBQC are small stabilizer states, and after fusion measurements, the outputs are stabilizers (conditioned on measurement outcomes.\n\nThe Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438][S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791]. However, Pauli- and Majorana-based stabilizer codes have different notions of locality [A. Y. Kitaev, \u201cUnpaired Majorana fermions in quantum wires\u201d, Physics-Uspekhi 44, 131 (2001). DOI; cond-mat/0010440] and are thus useful for different physical platforms.\n\nThe HaPPY code is a stabilizer code because it is defined by a contracted network of stabilizer tensors; see Thm. 6 in Ref. [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\n\nqubit BCH codes constructed via the CSS construction are CSS codes, and the rest are stabilizer codes over \\(GF(4)\\).\n\n\n\n\n", "cousins_code_id": "binary_linear\ndual\nhamiltonian\nqudit_stabilizer", "cousins_detail": "Qubit stabilizer codes are quantum analogues of binary linear codes.\nSymplectic representations of stabilizer group elements form a linear code over \\(GF(2)\\) that is self-orthogonal with respect to the symplectic inner product ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.6).\nCodespace is the ground-state space of the code Hamiltonian, which consists of an equal linear combination of stabilizer generators and which can be made into a commuting projector Hamiltonian.\nModular-qudit stabilizer codes for prime-dimensional qudits \\(q=p\\) inherit most of the features of qubit stabilizer codes, including encoding an integer number of qudits and a Pauli group with a unique number of generators. Conversely, qubit codes can be extended to modular-qudit codes by decorating appropriate generators with powers. For example, \\([[4,2,2]]\\) qubit code generators can be adjusted to \\(ZZZZ\\) and \\(XX^{-1} XX^{-1}\\). A systematic procedure extending a qubit code to prime-qudit codes involves putting its generator matrix into local-dimension-invariant (LDI) form [L. G. Gunderman, \u201cLocal-dimension-invariant qudit stabilizer codes\u201d, Physical Review A 101, (2020). DOI; 1910.08122]. Various bounds exist on the distance of the resulting codes [Arun J. Moorthy and Lane G. Gunderman, \u201cLocal-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise\u201d. 2110.11510][L. G. Gunderman, \u201cDegenerate local-dimension-invariant stabilizer codes and an alternative bound for the distance preservation condition\u201d, Physical Review A 105, (2022). DOI; 2110.15274].", "cousin_of_code_id": "galois_stabilizer\nmetrological\nmovassagh_ouyang\nsubsystem_stabilizer\ntranslationally_invariant_stabilizer", "cousin_of_detail": "Galois-qudit stabilizer codes reduce to qubit stabilizer codes for \\(q=2\\).\nA joint \\(+1\\) and \\(-1\\) eigenstate of a set of stabilizer can form a metrological stabilizer code [Philippe Faist et al., \u201cTime-energy uncertainty relation for noisy quantum metrology\u201d. 2207.13707].\nMany, but not all, Movassagh-Ouyang codes are stabilizer codes.\nGauge stabilizer codes reduce to stabilizer codes when there are no gauge qubits.\nQubit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site.", "_type": "ecc", "_page_id": "c_qubit_stabilizer", "_href": "c/qubit_stabilizer"}, "c_quantum_reed_muller": {"notes": "", "logical": "qubits", "code_id": "quantum_reed_muller", "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "introduced": "[Andrew Steane, \u201cQuantum Reed-Muller Codes\u201d. quant-ph/9608026]", "description": "A CSS code formed from a classical Reed-Muller code in which polynomials over finite fields encode data. This is done by transforming these polynomials into the stabilizer generator matrices.", "name": "Quantum Reed-Muller code", "realizations": "", "short_name": "", "features_threshold": "Between \\(10^{-3}\\) and \\(10^{-6}\\) for depolarizing noise (assuming ideal decoders), see [L. Luo et al., \u201cFault-tolerance thresholds for code conversion schemes with quantum Reed\u2013Muller codes\u201d, Quantum Science and Technology 5, 045022 (2020). DOI]", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "Magic state distillation in all prime dimensions [E. T. Campbell, H. Anwar, and D. E. Browne, \u201cMagic-State Distillation in All Prime Dimensions Using Quantum Reed-Muller Codes\u201d, Physical Review X 2, (2012). DOI]", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "\\(\\frac{k}{n}\\), where \\(k = 2^r - {r \\choose t} + 2 \\sum_{i=0}^{t-1} {r \\choose i}\\). Additionally, CSS codes formed from binary Reed-Muller codes achieve channel capacity on erasure channels [Shrinivas Kudekar et al., \u201cReed-Muller Codes Achieve Capacity on Erasure Channels\u201d. 1601.04689].", "features_transversal_gates": "", "features_fault_tolerance": "Gate switching protocol for universal computation [J. T. Anderson, G. Duclos-Cianci, and D. Poulin, \u201cFault-Tolerant Conversion between the Steane and Reed-Muller Quantum Codes\u201d, Physical Review Letters 113, (2014). DOI; 1403.2734].", "parents_code_id": "css", "parents_detail": "", "parent_of_code_id": "stab_15_1_3", "parent_of_detail": "The \\([[15,1,3]]\\) code is often noted as the 15-qubit quantum Reed-Muller code in the literature.", "cousins_code_id": "reed_muller\nquantum_convolutional", "cousins_detail": "\nQuantum convolutional codes can be derived from Quantum Reed-Muller codes [Salah A. Aly, Andreas Klappenecker, and Pradeep Kiran Sarvepalli, \u201cQuantum Convolutional Codes Derived From Reed-Solomon and Reed-Muller Codes\u201d. quant-ph/0701037].", "cousin_of_code_id": "covariant\nquantum_divisible\nquantum_triorthogonal", "cousin_of_detail": "Quantum RM codes are approximately covariant and nearly saturate certain covariance-performance bounds [Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360].\nQuantum RM codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions.\nClassification of triorthongonal codes yields a connection to Reed-Muller polynomials [Sepehr Nezami and Jeongwan Haah, \u201cClassification of Small Triorthogonal Codes\u201d. 2107.09684].", "_type": "ecc", "_page_id": "c_quantum_reed_muller", "_href": "c/quantum_reed_muller"}, "c_movassagh_ouyang": {"notes": "", "logical": "qubits", "code_id": "movassagh_ouyang", "physical": "qubits", "protection": "Let \\(C \\subset \\{0,1,\\dots,q-1\\}^n\\) be a classical code with distance \\(d_x\\). Let \\(d_z\\) satisfy \\(q^n > 2 V_q(d_z-1) -1\\), where \\(V_q(r)\\) is the volume of the \\(q\\)-ary Hamming ball of radius \\(r\\). Then the algorithm produces a quantum code with distance \\(d = \\text{min}(d_x,d_z)\\). Asymptotically, the distance scales linearly with \\(n\\).", "introduced": "[Ramis Movassagh and Yingkai Ouyang, \u201cConstructing quantum codes from any classical code and their embedding in ground space of local Hamiltonians\u201d. 2012.01453]", "description": "This is a family of codes derived via an algorithm that takes as input any binary classical code and outputs a quantum code (note that this framework can be extended to \\(q\\)-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.\n\nThis family strictly generalizes CSS codes (because CSS codes come only from linear or self orthogonal classical codes). These codes can be shown to be realized as a subspace of the ground space of a (geometrically) local Hamiltonian. ", "name": "Movassagh-Ouyang Hamiltonian code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The rate depends on the classical code, but distance can scale linearly with \\(n\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubits_into_qubits\nhamiltonian", "parents_detail": "\nMovassagh-Ouyang codes reside in the ground space of a Hamiltonian.", "parent_of_code_id": "css", "parent_of_detail": "Movassagh-Ouyang codes stem from a prescription that converts an arbitrary classical code into a quantum code.", "cousins_code_id": "qubit_stabilizer\nbits_into_bits", "cousins_detail": "Many, but not all, Movassagh-Ouyang codes are stabilizer codes.\nMovassagh-Ouyang codes are constructed from classical binary codes.", "cousin_of_code_id": "cws", "cousin_of_detail": "The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other.", "_type": "ecc", "_page_id": "c_movassagh_ouyang", "_href": "c/movassagh_ouyang"}, "c_floquet": {"notes": "", "logical": "qubits", "code_id": "floquet", "physical": "qubits", "protection": "Protects against single-qubit Pauli noise and check operator measurement errors.", "introduced": "[M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194]", "description": "Dynamically-generated stabilizer-based code whose logical qubits are generated through a particular sequence of check-operator measurements such that the number of logical qubits is larger than when the code is viewed as a static subsystem stabilizer code. After each measurement in the sequence, the codespace is a joint \\(+1\\) eigenspace of an instantaneous stabilizer group (ISG), i.e., a particular stabilizer group corresponding to the measurement. The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured in the next step in the sequence. As opposed to subsystem codes, only specific measurement sequences maintain the codespace. ", "name": "Floquet code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "dynamic_gen\nqubit_stabilizer", "parents_detail": "\nParticular sequences of measurements on this code yield an instantaneous stabilizer group.", "parent_of_code_id": "honeycomb", "parent_of_detail": "The honeycomb code is the first 2D Floquet code.", "cousins_code_id": "subsystem_stabilizer\nmonitored_random_circuits\nmajorana_stab", "cousins_detail": "This code can be viewed as a subsystem stabilizer code, albeit one with less logical qubits.\nBoth Floquet and monitored random circuit codes can have an instantaneous stabilizer group which evolves through unitary evolution and measurements. However, Floquet codewords are generated via a specific sequence of measurements, while random-circuit codes maintain a stabilizer group after any measurement. Floquet codes have the additional capability of detecting errors induced during the measurement process; see Appx. A of Ref. [M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].\nFloquet codes are viable candidates for storage in Majorana-qubit devices [Adam Paetznick et al., \u201cPerformance of planar Floquet codes with Majorana-based qubits\u201d. 2202.11829].", "_type": "ecc", "_page_id": "c_floquet", "_href": "c/floquet"}, "c_quantum_hamming": {"notes": "", "logical": "qubits", "code_id": "quantum_hamming", "physical": "qubits", "protection": "Protects against any single qubit error.", "introduced": "[D. Gottesman, \u201cClass of quantum error-correcting codes saturating the quantum Hamming bound\u201d, Physical Review A 54, 1862 (1996). DOI; quant-ph/9604038]", "description": "A family of stabilizer codes of distance \\(3\\) that asymptotically saturate quantum Hamming bound.", "name": "\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming code", "realizations": "", "short_name": "\\([[2^r, 2^r-r-2, 3]]\\)", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Concatenations of Hamming codes yield fault-tolerant quantum computation with constant space and quasi-polylogarithmic time overheads [Hayata Yamasaki and Masato Koashi, \u201cTime-Efficient Constant-Space-Overhead Fault-Tolerant Quantum Computation\u201d. 2207.08826].", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "cousins_code_id": "quantum_perfect", "cousins_detail": "Quantum Hamming codes saturate the asymptotic Hamming bound.", "cousin_of_code_id": "hamming", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_quantum_hamming", "_href": "c/quantum_hamming"}, "c_nonlocal_lowdepth": {"notes": "", "logical": "qubits", "code_id": "nonlocal_lowdepth", "physical": "qubits", "protection": "Creates a random \\([[n,k,d]]\\) stabilizer code that detects errors on \\(d-1\\) qubits, and corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "introduced": "[W. Brown and O. Fawzi, \u201cShort random circuits define good quantum error correcting codes\u201d, 2013 IEEE International Symposium on Information Theory (2013). DOI; 1312.7646]", "description": "An encoder for an \\([[n,k]]\\) quantum error correcting code, is an \\(n\\)-qubit unitary transformation that takes a \\(k\\)-qubit state as input (with \\(k\\leq n\\), and the remaining \\(n-k\\) qubits initialized to \\(|0\\rangle^{\\otimes n-k}\\) ) to give a corresponding state in the codespace as the output. An n-qubit quantum circuit with random 2-qubit Clifford gates can act as an encoder into a code with distance \\(d\\) with high probability, with a size (i.e. number of gates in the circuit) at most \\(O(n^2 log n)\\)). Noting that two gates acting on disjoint qubits could in fact be executed simultaneously, this is equivalent to the depth (number of time steps in the circuit) being at most \\(O(log^3 n)\\).", "name": "Low-depth random Clifford-circuit code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "random_circuit", "parents_detail": "", "_type": "ecc", "_page_id": "c_nonlocal_lowdepth", "_href": "c/nonlocal_lowdepth"}, "c_quantum_bch": {"notes": "", "logical": "qubits", "code_id": "quantum_bch", "physical": "qubits", "protection": "", "introduced": "[M. Grassl, T. Beth, and T. Pellizzari, \u201cCodes for the quantum erasure channel\u201d, Physical Review A 56, 33 (1997). DOI; quant-ph/9610042][A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006][Andrew M. Steane, \u201cEnlargement of Calderbank Shor Steane quantum codes\u201d. quant-ph/9802061][Markus Grassl and Thomas Beth, \u201cQuantum BCH Codes\u201d. quant-ph/9910060]", "description": "Qubit stabilizer code constructed from a self-orthogonal binary BCH code via the CSS construction, from a Hermitian self-orthogonal quaternary BCH code via the stabilizer-over-\\(GF(4)\\) construction, or by taking a Euclidean self-orthogonal BCH code over \\(GF(2^m)\\), converting it to a binary code, and applying the CSS construction. ", "name": "Qubit BCH code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubit_stabilizer", "parents_detail": "qubit BCH codes constructed via the CSS construction are CSS codes, and the rest are stabilizer codes over \\(GF(4)\\).", "cousins_code_id": "bch\nq-ary_bch\ncss\nstabilizer_over_gf4", "cousins_detail": "Binary BCH codes are used to construct a subset of qubit BCH codes via the CSS construction.\nBCH codes are used to construct qubit BCH codes via the CSS and stabilizer-over-\\(GF(4)\\) constructions.\nSome qubit BCH codes are CSS.\nHermitian self-orthogonal quaternary BCH codes are used to construct a subset of qubit BCH codes via the stabilizer-over-\\(GF(4)\\) construction.", "cousin_of_code_id": "galois_bch", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_quantum_bch", "_href": "c/quantum_bch"}, "c_gnu_permutation_invariant": {"notes": "", "logical": "qubits", "code_id": "gnu_permutation_invariant", "physical": "qubits", "protection": "Depends on the family. One family which is completely symmetrized versions of Bacon-Shor codes (parameterized by \\(t\\)) protects against arbitrary weight-\\(t\\) qubit errors. Additionally, codes with large enough length \\((t+1)(3t+1)+t\\) can approximately correct \\(t\\) spontaneous decay errors.", "introduced": "[Y. Ouyang, \u201cPermutation-invariant quantum codes\u201d, Physical Review A 90, (2014). DOI; 1302.3247]", "description": "Can be expressed in terms of Dicke states where the logical states are \\begin{align}\n|\\overline{\\pm}\\rangle = \\sum_{\\ell=0}^{n} \\frac{(\\pm 1)^\\ell}{\\sqrt{2^n}} \\sqrt{n \\choose \\ell} |D^m_{g \\ell}\\rangle~.\n\\end{align} Here, \\(m\\) is the number of particles used for encoding \\(1\\) qubit, and \\(g, n \\leq m\\) are arbitrary positive integers. The state \\(|D^m_w\\rangle\\) is a Dicke state -- a normalized permutation-invariant state on \\(m\\) qubits with \\(w\\) excitations, i.e., a normalized sum over all basis elements with \\(w\\) ones and \\(m - w\\) zeroes.\n\nA qudit extension of such codes, based on a correspondence with binomial codes, exists [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]. ", "name": "GNU permutation-invariant code", "realizations": "", "short_name": "GNU", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "permutation_invariant", "parents_detail": "", "cousins_code_id": "bacon_shor\nhamiltonian\napproximate_qecc\nbinomial\nquantum_repetition", "cousins_detail": "Symmetrized versions of the Bacon-Shor codes are GNU codes\nGNU codes lie within the ground state of ferromagnetic Heisenberg models without an external magnetic field [Y. Ouyang, \u201cQuantum storage in quantum ferromagnets\u201d, Physical Review B 103, (2021). DOI; 1904.01458].\nGNU codes protect approximately against amplitude damping errors.\nBinomial codes and GNU codes are both related to spin-coherent states, and a qudit generalization can be obtained from qudit binomial codes ([V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010], Appx. C).\nGNU codewords for \\(g=1\\) reduce to the phase-flip code.", "_type": "ecc", "_page_id": "c_gnu_permutation_invariant", "_href": "c/gnu_permutation_invariant"}, "c_quantum_hamming_css": {"notes": "", "logical": "qubits", "code_id": "quantum_hamming_css", "physical": "qubits", "protection": "Protects against any single qubit error.", "introduced": "", "description": "A Hamming-based CSS code is a CCS code constructed with a classical Hamming code \\([2^r-1,2^r-1-r,3]=C_X=C_Z\\).", "name": "\\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Syndrome measurement can be done with two ancillary flag qubits [R. Chao and B. W. Reichardt, \u201cQuantum Error Correction with Only Two Extra Qubits\u201d, Physical Review Letters 121, (2018). DOI; 1705.02329].", "parents_code_id": "css", "parents_detail": "", "parent_of_code_id": "steane", "parent_of_detail": "Steane code is the smallest member of a family of Hamming-based CSS codes.", "cousins_code_id": "hamming", "cousins_detail": "Quantum Hamming codes result from applying the CSS construction to Hamming codes.", "cousin_of_code_id": "qudit_hamming_css", "cousin_of_detail": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) codes are prime-qudit extensions of \\([[2^r-1, 2^r-2r-1, 3]]\\) codes.", "_type": "ecc", "_page_id": "c_quantum_hamming_css", "_href": "c/quantum_hamming_css"}, "c_tfim": {"notes": "", "logical": "qubits", "code_id": "tfim", "physical": "qubits", "protection": "Code distance is 1 for open boundary conditions similar to a repetition code, and 3 for periodic boundary conditions with an encoding circuit depth of 4.", "introduced": "[Yifan Hong et al., \u201cQuantum error correction in a time-dependent transverse field Ising model\u201d. 2205.12998]", "description": "A 1D translationally invariant stabilizer code whose encoding is a constant-depth circuit of nearest-neighbor gates on alternating even and odd bonds that consist of transverse-field Ising Hamiltonian interactions. The code allows for perfect state transfer of arbitrary distance using local operations and classical communications (LOCC).", "name": "Transverse-field Ising model (TFIM) code", "realizations": "", "short_name": "TFIM", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "1D geometrically local constant-depth brickwork circuit of nearest-neighbor gates on alternating even and odd bonds. Gates are generated by interaction terms of the transverse-field Ising Hamiltonian.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubit_stabilizer\ntranslationally_invariant_stabilizer", "parents_detail": "\n", "cousins_code_id": "majorana_stab\nquantum_repetition", "cousins_detail": "The TFIM code stabilizers can be expressed in terms of Majorana operators.\nWhen written in the computational basis, the phase-flip and TFIM codewords are superpositions of qubit states of fixed total parity. The superposition is equal for the phase-flip code, whereas some states appear with a \\(-1\\) coefficient for TFIM code. However, the TFIM code can be encoded in constant depth.", "_type": "ecc", "_page_id": "c_tfim", "_href": "c/tfim"}, "c_quantum_h": {"notes": "", "logical": "qubits", "code_id": "quantum_h", "physical": "qubits", "protection": "Detects weight-1 Pauli errors. The \\(r\\)-level contatenated H code detects weight Pauli errors up to weight \\(2^r-1\\).", "introduced": "[C. Jones, \u201cMultilevel distillation of magic states for quantum computing\u201d, Physical Review A 87, (2013). DOI; 1210.3388]", "description": "Family of \\([[k+4,k,2]]\\) CSS codes with transversal Hadmard gates; relevant to magic state distillation. Four stablizer generators are \\(X_1X_2X_3X_4\\), \\(Z_1Z_2Z_3Z_4\\), \\(X_1X_2X_5X_6...X_{k+4}\\), and \\(Z_1Z_2Z_5Z_6...Z_{k+4}\\).", "name": "H code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "The H codes can be used for high-quality and high-efficiency magic-state distillation [C. Jones, \u201cMultilevel distillation of magic states for quantum computing\u201d, Physical Review A 87, (2013). DOI; 1210.3388]. Their associated multi-level magic states protocols have an efficency advantage over the 10-to-2 and 15-to-1 protocals for output error below \\(10^{-7}\\).", "features_magic_scaling_exponent": "A total of \\(r\\) rounds of magic-state distillation yields a magic-state scaling exponent \\(\\gamma\\to 1\\) as \\(k,r\\rightarrow \\infty\\). This matches a conjectured bound for \\(\\gamma\\) [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426].", "features_encoders": "", "features_rate": "The H codes are dense, i.e., the rate \\(\\frac{k}{k+4}\\rightarrow 1\\) as \\(k \\rightarrow \\infty\\). The distance is 2. However an \\(r\\)-level concatenation of H codes gives a distance of \\(2^r\\).", "features_transversal_gates": "Hadamard and \\(TXT^{\\dagger}\\) gates, with the latter Clifford-equivalent to Hadamard, and where \\(T=\\exp(i\\pi(I-Z)/8)\\) is the \\(\\pi/8\\)-rotation gate.", "features_fault_tolerance": "", "parents_code_id": "css", "parents_detail": "", "_type": "ecc", "_page_id": "c_quantum_h", "_href": "c/quantum_h"}, "c_cws": {"notes": "", "logical": "qubits", "code_id": "cws", "physical": "qubits", "protection": "Code distance \\(\\mathcal{Q} = ( \\mathcal{G},\\mathcal{C}) \\) is upper bounded by the distance of the classical code \\(\\mathcal{C} \\). The diagonal distance is upper bounded by \\(\\delta + 1\\), where \\(\\delta\\) is the minimum degree of \\(\\mathcal{G}\\). Computing the distance is generally NP-complete, and is NP-hard for non-degenerate codes [Upendra Kapshikar and Srijita Kundu, \u201cDiagonal distance of quantum codes and hardness of the minimum distance problem\u201d. 2203.04262].", "introduced": "[A. Cross et al., \u201cCodeword Stabilized Quantum Codes\u201d, IEEE Transactions on Information Theory 55, 433 (2009). DOI; 0708.1021]", "description": "This family of codes strictly generalizes stabilizer codes. They are usually denoted by \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\) where \\(\\mathcal{G}\\) is a graph and \\(\\mathcal{C}\\) is a \\( (n,K,d) \\) binary classical code. From the graph we form the unique graph state (stabilizer state) \\( |G \\rangle \\). From the classical code we form Pauli \\(Z\\)-type operators \\( W_i = Z^{c_{i,1}} \\otimes \\cdots \\otimes Z^{c_{i,n}} \\), where \\(c_{i,j} \\) is the \\(j\\)-th bit of the \\(i\\)-th classical codeword. The CWS codewords are then \\( | i \\rangle =  W_i | G \\rangle \\).\n\nThere is an alternative description to the one above that is locally Clifford-equivalent. In particular, we can describe CWS codes as \\( \\mathcal{Q} = (S,\\mathcal{W})\\) where \\(S\\) is a stabilizer group and \\( \\mathcal{W} = \\{ w_\\ell \\}_{\\ell = 1}^K \\) is a family of \\(K\\) \\(n\\)-qubit Pauli strings. We then form CWS codeswords as \\( | i \\rangle = w_i | S \\rangle \\), where \\( | S \\rangle \\) is the (unique) stabilizer state of \\(S\\). ", "name": "Codeword stabilized (CWS) code", "realizations": "", "short_name": "CWS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "There is no known efficient algorithm to decode non-additive (non-stabilizer) CWS codes.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "If \\( \\mathcal{C} \\) has an efficient classical encoder, then so does the CWS code \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\).", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubits_into_qubits", "parents_detail": "", "parent_of_code_id": "qubit_stabilizer", "parent_of_detail": "If the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code.", "cousins_code_id": "movassagh_ouyang\nspacetime", "cousins_detail": "The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other.\nCWS codes have been considered in the context of spacetime replication of quantum data [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913][P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544], while STCs are designed to replicate classical data.", "cousin_of_code_id": "xp_stabilizer", "cousin_of_detail": "The orbit representatives of XP codes play a similar role to the word operators of CWS codes.", "_type": "ecc", "_page_id": "c_cws", "_href": "c/cws"}, "c_css": {"notes": "Introduction to CSS-to-homology correspondence by M. Hastings.\nEntanglement purification protocols related to quantum key distribution (QKD) utilize CSS error correction [P. W. Shor and J. Preskill, \u201cSimple Proof of Security of the BB84 Quantum Key Distribution Protocol\u201d, Physical Review Letters 85, 441 (2000). DOI; quant-ph/0003004].\nUsing linear programming to solve a set of equations and inequalities on weight distribution of a classical self-orthogonal code \\(C=(n, 2^n-k)\\) and its dual, one can find a \\(C\\) such that the \\([[n,k,d]]\\) CSS code constructed using \\(C\\) and its dual would have rate and distance close to the Singleton bound [A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006].", "logical": "qubits", "code_id": "css", "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.\n\nUsing the relation to chain complexes, the number of encoded logical qubits is equal to the dimension of the first \\(\\mathbb{Z}_2\\)-homology of the chain complex, \\(H_1(\\partial, \\mathbb{Z}_2) = \\frac{\\text{Ker}(\\partial_1)}{\\text{Im}(\\partial_2)}\\). The distance of the CSS code is equal to the minimum of the combinatorial (\\(d-1\\))-systole of the cellulated \\(d\\)-dimensional manifold and its dual. ", "introduced": "[A. R. Calderbank and P. W. Shor, \u201cGood quantum error-correcting codes exist\u201d, Physical Review A 54, 1098 (1996). DOI; quant-ph/9512032][A. M. Steane, \u201cError Correcting Codes in Quantum Theory\u201d, Physical Review Letters 77, 793 (1996). DOI][\u201cMultiple-particle interference and quantum error correction\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 452, 2551 (1996). DOI; quant-ph/9601029]", "description": "An \\([[n,k,d]]\\) stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The stabilizer generator matrix is of the form \\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parity}\n\\end{align} such that the rows of the two blocks must be orthogonal \\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:comm}\n\\end{align} The above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related binary linear codes, an \\([n,k_X,d^\\prime_X]\\) code \\(C_X\\) and \\([n,k_Z,d^\\prime_Z]\\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d^\\prime_X,d^\\prime_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\(\\eqref{eq:parity}\\) is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\(\\eqref{eq:comm}\\). Basis states for the code are, for \\(\\gamma \\in C_X\\), \\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n\nA CSS code has stabilizer weight \\(w\\) if the highest weight of any stabilizer generator is \\(w\\), i.e., any row of \\(H_X\\) and \\(H_Z\\) has weight at most \\(w\\). In the context of comparing weight as well as of determining distances for noise models biased toward \\(X\\)- or \\(Z\\)-type errors, an extended notation for asymmetric CSS codes is \\([[n,k,(d_X,d_Z),w]]\\) or \\([[n,k,d_X/d_Z,w]]\\). The quantity \\(\\min\\{d_X,d_Z\\}\\) is often called the worst-case minimum distance.\n\nCSS-to-homology correspondence\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCSS-to-homology correspondence: CSS codes and their properties can be formulated in terms of homology theory, yielding a powerful correspondence between codes and chain complexes, the primary homological structures. There exists a many-to-one mapping from size three chain complexes to CSS codes [A. Y. Kitaev, \u201cQuantum computations: algorithms and error correction\u201d, Russian Mathematical Surveys 52, 1191 (1997). DOI][H. Bombin and M. A. Martin-Delgado, \u201cHomological error correction: Classical and quantum codes\u201d, Journal of Mathematical Physics 48, 052105 (2007). DOI; quant-ph/0605094][Sergey Bravyi and Matthew B. Hastings, \u201cHomological Product Codes\u201d. 1311.0885][Nikolas P. Breuckmann, \u201cPhD thesis: Homological Quantum Codes Beyond the Toric Code\u201d. 1802.01520] that allows one to extract code properties from topological features of the complexes. Codes constructed in this manner are sometimes called homological CSS codes, but they are equivalent to CSS codes. This mapping of codes to manifolds allows the application of structures from topology to error correction, yielding various QLDPC codes with favorable properties.\n\nA chain complex of size three is given by binary vector spaces \\(A_2\\), \\(A_1\\), \\(A_0\\) and binary matrices \\(\\partial_{i=1,2}\\) (called boundary operators) \\(A_i\\) to \\(A_{i-1}\\) that satisfy \\(\\partial_1 \\partial_2 = 0\\). Such a complex is typically denoted as \\begin{align}\nA_2 \\xrightarrow{\\partial_2} A_1 \\xrightarrow{\\partial_1} A_0~.\n\\label{eq:chain}\n\\end{align} One constructs a CSS code by associating a physical qubit to every basis element of \\(A_1\\), and defining parity-check matrices \\(H_X=\\partial_1^T\\) and \\(H_Z=\\partial_2\\)). That way, the spaces \\(A_0\\) and \\(A_2\\) can be associated with \\(X\\)-type and \\(Z\\)-type Pauli operators, respectively, and boundary operators determine the Paulis making up the stabilizer generators. The requirement \\(\\partial_1 \\partial_2 = 0\\) guarantees that the \\(X\\)-stabilizer generators associated with \\(H_X\\) commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nUsually, the chain complex \\(\\eqref{eq:chain}\\) used in the construction comes from the chain complex associated with a cellulation of a manifold. When the manifold is a two-dimensional surface, its entire chain is used. Higher-dimensional manifolds allow for longer chain complexes, and one can use the three largest non-trivial vector spaces in its chain.", "name": "Calderbank-Shor-Steane (CSS) stabilizer code", "realizations": "", "short_name": "CSS", "features_threshold": "", "features_code_capacity_threshold": "Bounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights [A. A. Kovalev and L. P. Pryadko, \u201cFault tolerance of quantum low-density parity check codes with sublinear distance scaling\u201d, Physical Review A 87, (2013). DOI; 1208.2317][I. Dumer, A. A. Kovalev, and L. P. Pryadko, \u201cThresholds for Correcting Errors, Erasures, and Faulty Syndrome Measurements in Degenerate Quantum Codes\u201d, Physical Review Letters 115, (2015). DOI; 1412.6172].", "features_decoders": "Coherent decoders allow for measurement-free error correction [Toshiaki Inada et al., \u201cMeasurement-Free Ultrafast Quantum Error Correction by Using Multi-Controlled Gates in Higher-Dimensional State Space\u201d. 2109.00086]. One method is table/multi-control decoding [G. A. Paz-Silva, G. K. Brennen, and J. Twamley, \u201cFault Tolerance with Noisy and Slow Measurements and Preparation\u201d, Physical Review Letters 105, (2010). DOI; 1002.1536], which scales exponentially with the number of ancillas used in syndrome measurement. Another method, the Ising-based decoder, utilizes the mapping of the effect of the noise to a statistical mechanical model [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][Albert T. Schmitz, \u201cThermal Stability of Dynamical Phase Transitions in Higher Dimensional Stabilizer Codes\u201d. 2002.11733] such that the decoding problem maps to preparation of the ground state of an Ising model.", "features_general_gates": "LDPC CSS code symmetries called \\(XZ\\)-dualities allow for fold-transversal gates, i.e., transversal gates followed by qubit permutations [Nikolas P. Breuckmann and Simon Burton, \u201cFold-Transversal Clifford Gates for Quantum Codes\u201d. 2202.06647].", "features_magic_scaling_exponent": "", "features_encoders": "Stabilizer measurement [J. \u0141odyga et al., \u201cSimple scheme for encoding and decoding a qubit in unknown state for various topological codes\u201d, Scientific Reports 5, (2015). DOI; 1404.2495].", "features_rate": "For a depolarizing channel with probability \\(p\\), CSS codes allowing for arbitrarily accurate recovery exist with asymptotic rate \\(1-2h(p)\\), where \\(h\\) is the binary entropy function [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143].", "features_transversal_gates": "CNOT gates. Self-dual CSS codes admit transversal Clifford gates.", "features_fault_tolerance": "Steane error correction [A. M. Steane, \u201cActive Stabilization, Quantum Computation, and Quantum State Synthesis\u201d, Physical Review Letters 78, 2252 (1997). DOI; quant-ph/9611027].\nParallel syndrome extraction for distance-three codes can be done fault-tolerantly using one flag qubit [Pei-Hao Liou and Ching-Yi Lai, \u201cParallel syndrome extraction with shared flag qubits for CSS codes of distance three\u201d. 2208.00581].", "parents_code_id": "qubit_stabilizer\nmovassagh_ouyang", "parents_detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) self-orthogonal CSS code, with the mapping preserving geometric locality of a code up to a constant factor [S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791].\nMovassagh-Ouyang codes stem from a prescription that converts an arbitrary classical code into a quantum code.", "parent_of_code_id": "balanced_product\ncolor\ndhlv\ndistance_balanced\nquantum_h\nsurface\nquantum_reed_muller\nquantum_tanner\nquantum_divisible\nquantum_parity\nquantum_triorthogonal\nquantum_hamming_css", "parent_of_detail": "\n\n\n\n\n\n\n\n\n\n\n", "cousins_code_id": "binary_linear\ndual", "cousins_detail": "Construction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\).\nCSS codes for which \\(C_X=C_Z \\equiv C\\) are called self-orthogonal since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\).", "cousin_of_code_id": "eastab\ngalois_css\ngeneralized_homological_product\nhomological_classical\ngroup_gkp\nhomological_cv\nmajorana_stab\nqudit_css\nquantum_bch\nxp_stabilizer", "cousin_of_detail": "As opposed to CSS codes, EA stabilizer codes can be constructed from any linear binary code.\nExtension of qubit CSS codes to Galois qudits.\nThe notion of homological products arose from interpreting CSS codes in terms of chain complexes over manifolds, but some generalized products no longer yield CSS codes.\nCSS codes can also be constructed using homology techniques but for manifolds of dimension two or greater.\nAn \\(n\\)-qubit CSS code corresponds to the \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{n}\\) group construction.\nCSS and homological CV codes utilize chain complexes in code construction, with the latter complexes having trivial homology.\nWhen constructing a Majorana stabilizer code from a self-orthogonal classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space [S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791][Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different self-orthogonal classical codes with an odd number of bits, as is often done in the CSS construction.\nExtension of CSS codes to modular-integer qudits.\nSome qubit BCH codes are CSS.\nEach XP-regular code can be mapped to a CSS code with a similar logical operator structure [Mark A. Webster, Benjamin J. Brown, and Stephen D. Bartlett, \u201cThe XP Stabiliser Formalism: a Generalisation of the Pauli Stabiliser Formalism with Arbitrary Phases\u201d. 2203.00103].", "_type": "ecc", "_page_id": "c_css", "_href": "c/css"}, "c_xp_stabilizer": {"notes": "", "logical": "qubits", "code_id": "xp_stabilizer", "physical": "qubits", "protection": "", "introduced": "[Mark A. Webster, Benjamin J. Brown, and Stephen D. Bartlett, \u201cThe XP Stabiliser Formalism: a Generalisation of the Pauli Stabiliser Formalism with Arbitrary Phases\u201d. 2203.00103]", "description": "The XP Stabilizer formalism is a generalization of the XS and Pauli stabilizer formalisms, with stabilizer generators taken from the group \\( \\{\\omega I, X, P\\}^{\\otimes n} \\). Here, \\( \\omega \\) is a \\( 2N \\) root of unity, and \\( P = \\text{diag} ( 1, \\omega^2) \\). The codespace is a \\(+1\\) eigenspace of a set of XP stabilizer generators, which need not commute to define a valid codespace.\n\nXP stabilizer codes are classified into XP-regular and XP-non-regular, where the former can be mapped to a CSS code with similar logical operator structure. ", "name": "XP stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubits_into_qubits", "parents_detail": "", "parent_of_code_id": "qubit_stabilizer\nxs_stabilizer", "parent_of_detail": "The XP stabilizer formalism reduces to the Pauli formalism at \\(N=2\\).\nThe XP stabilizer formalism reduces to the XS formalism at \\(N=4\\).", "cousins_code_id": "css\ncws", "cousins_detail": "Each XP-regular code can be mapped to a CSS code with a similar logical operator structure [Mark A. Webster, Benjamin J. Brown, and Stephen D. Bartlett, \u201cThe XP Stabiliser Formalism: a Generalisation of the Pauli Stabiliser Formalism with Arbitrary Phases\u201d. 2203.00103].\nThe orbit representatives of XP codes play a similar role to the word operators of CWS codes.", "_type": "ecc", "_page_id": "c_xp_stabilizer", "_href": "c/xp_stabilizer"}, "c_quantum_parity": {"notes": "", "logical": "qubits", "code_id": "quantum_parity", "physical": "qubits", "protection": "Has distance \\(d=\\min(m_1,m_2)\\).", "introduced": "[T. C. Ralph, A. J. F. Hayes, and A. Gilchrist, \u201cLoss-Tolerant Optical Qubits\u201d, Physical Review Letters 95, (2005). DOI; quant-ph/0501184][E. Knill, R. Laflamme, and G. J. Milburn, \u201cA scheme for efficient quantum computation with linear optics\u201d, Nature 409, 46 (2001). DOI][E. Knill, R. Laflamme, and G. Milburn, \u201cEfficient Linear Optics Quantum Computation\u201d. quant-ph/0006088]", "description": "Also called a generalized Shor code [Dave Bacon and Andrea Casaccino, \u201cQuantum Error Correcting Subsystem Codes From Two Classical Linear Codes\u201d. quant-ph/0610088]. A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) CSS code family obtained from concatenating an \\(m_1\\)-qubit phase-flip repetition code with an \\(m_2\\)-qubit bit-flip repetition code. Logical codewords are \\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}+|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}-|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}~.\n\\end{split}\n\\end{align} ", "name": "Quantum parity code (QPC)", "realizations": "The \\([[m^2,1,m]]\\) codes for \\(m\\leq 7\\) have been realized in trapped-ion quantum devices [N. H. Nguyen et al., \u201cDemonstration of Shor Encoding on a Trapped-Ion Quantum Computer\u201d, Physical Review Applied 16, (2021). DOI; 2104.01205].\nNon-determinisitic linear-optical encoding [T. C. Ralph, A. J. F. Hayes, and A. Gilchrist, \u201cLoss-Tolerant Optical Qubits\u201d, Physical Review Letters 95, (2005). DOI; quant-ph/0501184] whose success probability \\(P_{E}\\) is determined by the efficiency \\(\\eta\\) of the photonic encoding circuit. A threshold \\(\\eta > 0.82 \\) exists for the efficiency, above which \\(P_{E}\\to 1\\) as \\(m_1\\to\\infty\\) given particular \\(m_2\\).\nStudied in the context of error-corrected quantum repeaters [S. Muralidharan et al., \u201cUltrafast and Fault-Tolerant Quantum Communication across Long Distances\u201d, Physical Review Letters 112, (2014). DOI; 1310.5291].", "short_name": "QPC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "css\ntranslationally_invariant_stabilizer", "parents_detail": "\n", "parent_of_code_id": "quantum_repetition\nshor_nine", "parent_of_detail": "A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) QPC is a concatenation of a \\(m_1\\) bit-flip and a \\(m_2\\) phase-flip repetition codes, reducing to a repetition code when \\(m_1\\) or \\(m_2\\) is one.\nShor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "cousins_code_id": "quantum_concatenated\nbacon_shor", "cousins_detail": "A QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code.\nBacon-Shor codes reduce to QPCs for a particular gauge configuration.", "cousin_of_code_id": "stab_4_2_2", "cousin_of_detail": "\\([[4,1,2]]\\) subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "_type": "ecc", "_page_id": "c_quantum_parity", "_href": "c/quantum_parity"}, "c_quantum_repetition": {"notes": "Repetition codes can be used to benchmark device performance [Teague Tomesh et al., \u201cSupermarQ: A Scalable Quantum Benchmark Suite\u201d. 2202.11045].", "logical": "qubits", "code_id": "quantum_repetition", "physical": "qubits", "protection": "Bit-flip code detects bit-flip errors \\(X\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any phase-flip errors \\(Z\\). Phase-flip code detects phase-flip errors \\(Z\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any bit-flip errors \\(X\\). Because they protect against only one type of noise, both codes can be thought of as a classical \\([n,1,d]\\) repetition code with classical distance \\(d=\\left\\lfloor (n-1)/2\\right\\rfloor\\) embedded in a quantum system.", "introduced": "[A. Peres, \u201cReversible logic and quantum computers\u201d, Physical Review A 32, 3266 (1985). DOI]", "description": "Encodes \\(1\\) qubit into \\(n\\) qubits according to \\(|0\\rangle\\to|\\phi_0\\rangle^{\\otimes n}\\) and \\(|1\\rangle\\to|\\phi_1\\rangle^{\\otimes n}\\). Also known as a bit-flip code when \\(|\\phi_i\\rangle = |i\\rangle\\), and a phase-flip code when \\(|\\phi_0\\rangle = |+\\rangle\\) and \\(|\\phi_1\\rangle = |-\\rangle\\).\n\nThe \\(\\pm\\)-basis codewords for the bit-flip code are GHz (a.k.a. cat) states \\(|0\\rangle^{\\otimes n}\\pm|1\\rangle^{\\otimes n}\\). These are ground states of the one-dimensional classical Ising model Hamiltonian \\(H=\\sum_{i} Z_{i}Z_{i+1}\\).\n\nThe \\(\\pm\\)-basis codewords for the phase-flip code are expanded in the computational basis as \\begin{align}\n  \\begin{split}\n    |\\overline{+}\\rangle =\\frac{1}{\\sqrt{2^{n-1}}}\\sum_{\\sum_{i}v_{i}=0}|v_{1},\\cdots,v_{n}\\rangle~{\\phantom{,}}\\\\\n    |\\overline{-}\\rangle =\\frac{1}{\\sqrt{2^{n-1}}}\\sum_{\\sum_{i}v_{i}=1}|v_{1},\\cdots,v_{n}\\rangle~,\n  \\end{split}\n\\end{align} showing that the phase-flip code stores information in the total parity of the qubits.", "name": "Quantum repetition code", "realizations": "NMR: 3-qubit phase-flip code [D. G. Cory et al., \u201cExperimental Quantum Error Correction\u201d, Physical Review Letters 81, 2152 (1998). DOI; quant-ph/9802018][O. Moussa et al., \u201cDemonstration of Sufficient Control for Two Rounds of Quantum Error Correction in a Solid State Ensemble Quantum Information Processor\u201d, Physical Review Letters 107, (2011). DOI; 1108.4842], with up to two rounds of error correction in liquid-state NMR [J. Zhang et al., \u201cExperimental quantum error correction with high fidelity\u201d, Physical Review A 84, (2011). DOI; 1109.4821].\nSuperconducting circuits: 3-qubit phase-flip and bit-flip code by Schoelkopf group [M. D. Reed et al., \u201cRealization of three-qubit quantum error correction with superconducting circuits\u201d, Nature 482, 382 (2012). DOI; 1109.4948], another 3-qubit bit-flip code [D. Rist\u00e8 et al., \u201cDetecting bit-flip errors in a logical qubit using stabilizer measurements\u201d, Nature Communications 6, (2015). DOI; 1411.5542], 3-qubit phase-flip code up to 3 cycles of error correction [J. Cramer et al., \u201cRepeated quantum error correction on a continuously encoded qubit by real-time feedback\u201d, Nature Communications 7, (2016). DOI; 1508.01388], IBM 15-qubit device [J. R. Wootton and D. Loss, \u201cRepetition code of 15 qubits\u201d, Physical Review A 97, (2018). DOI; 1709.00990], IBM Rochester device using 43-qubit code [J. R. Wootton, \u201cBenchmarking near-term devices with quantum error correction\u201d, Quantum Science and Technology 5, 044004 (2020). DOI; 2004.11037], Google system performing up to 8 error-correction cycles on 5 and 9 qubits [J. Kelly et al., \u201cState preservation by repetitive error detection in a superconducting quantum circuit\u201d, Nature 519, 66 (2015). DOI; 1411.7403], and Google Quantum AI Sycamore utilizing from 5 to 21 qubits [Zijun Chen et al., \u201cExponential suppression of bit or phase flip errors with repetitive error correction\u201d. 2102.06132] and 25 qubits (for comparison with a quantum code) [Rajeev Acharya et al., \u201cSuppressing quantum errors by scaling a surface code logical qubit\u201d. 2207.06431]. Continuous error correction protocols have been implemented on a 3-qubit device [W. P. Livingston et al., \u201cExperimental demonstration of continuous quantum error correction\u201d, Nature Communications 13, (2022). DOI; 2107.11398].\nSemiconductor spin-qubit devices: 3-qubit devices at RIKEN [Kenta Takeda et al., \u201cQuantum error correction with silicon spin qubits\u201d. 2201.08581] and Delft [F. van Riggelen et al., \u201cPhase flip code with semiconductor spin qubits\u201d. 2202.11530].\nNitrogen-vacancy centers in diamond: 3-qubit phase-flip code [G. Waldherr et al., \u201cQuantum error correction in a solid-state hybrid spin register\u201d, Nature 506, 204 (2014). DOI; 1309.6424][T. Nakazato et al., \u201cQuantum error correction of spin quantum memories in diamond under a zero magnetic field\u201d, Communications Physics 5, (2022). DOI] (see also Ref. [T. H. Taminiau et al., \u201cUniversal control and error correction in multi-qubit spin registers in diamond\u201d, Nature Nanotechnology 9, 171 (2014). DOI; 1309.5452]).\nTrapped-ion device: 3-qubit phase-flip algorithm implemented in 3 cycles on high fidelity gate operations [P. Schindler et al., \u201cExperimental Repetitive Quantum Error Correction\u201d, Science 332, 1059 (2011). DOI].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Lindbladian-based dissipative encoding passively protecting against bit flips [C. Ahn, A. C. Doherty, and A. J. Landahl, \u201cContinuous quantum error correction via quantum feedback control\u201d, Physical Review A 65, (2002). DOI; quant-ph/0110111][F. Reiter et al., \u201cDissipative quantum error correction and application to quantum sensing with trapped ions\u201d, Nature Communications 8, (2017). DOI; 1702.08673].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "quantum_parity", "parents_detail": "A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) QPC is a concatenation of a \\(m_1\\) bit-flip and a \\(m_2\\) phase-flip repetition codes, reducing to a repetition code when \\(m_1\\) or \\(m_2\\) is one.", "cousins_code_id": "hamiltonian", "cousins_detail": "Bit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions.", "cousin_of_code_id": "gnu_permutation_invariant\nrepetition\nself_correct\nshor_nine\ntfim\nvery-small-logical-qubit", "cousin_of_detail": "GNU codewords for \\(g=1\\) reduce to the phase-flip code.\n\nThe bit-flip repetition code associated with the 2D classical Ising model is a self-correcting classical memory.\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\nWhen written in the computational basis, the phase-flip and TFIM codewords are superpositions of qubit states of fixed total parity. The superposition is equal for the phase-flip code, whereas some states appear with a \\(-1\\) coefficient for TFIM code. However, the TFIM code can be encoded in constant depth.\nParts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss.", "_type": "ecc", "_page_id": "c_quantum_repetition", "_href": "c/quantum_repetition"}, "c_honeycomb": {"notes": "", "logical": "qubits", "code_id": "honeycomb", "physical": "qubits", "protection": "Protective features similar to the surface code: on a torus geometry, the code protects two logical qubits with a code distance proportional to the linear size of the torus. Properties of the code with open boundaries are discussed in Refs. [J. Haah and M. B. Hastings, \u201cBoundaries for the Honeycomb Code\u201d, Quantum 6, 693 (2022). DOI; 2110.09545][Christophe Vuillot, \u201cPlanar Floquet Codes\u201d. 2110.05348], and various other generalizations have been proposed [David Aasen, Zhenghan Wang, and Matthew B. Hastings, \u201cAdiabatic paths of Hamiltonians, symmetries of topological order, and automorphism codes\u201d. 2203.11137].", "introduced": "[M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194]", "description": "Floquet code inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438] whose logical qubits are generated through a particular sequence of measurements.\n\nThe code is defined on a hexagonal (honeycomb) lattice with a physical qubit located at each vertex. Edges are labeled \\(x\\), \\(y\\), and \\(z\\), such that one edge of each label meet at every vertex. Check operators are defined as \\(XX\\) acting on any two qubits joined by an \\(x\\) edge, and similarly for \\(y\\) and \\(z\\). The hexagonal lattice is 3-colorable, so the hexagons may be labeled 0, 1, 2 such that no two neighboring hexagons have the same label.\n\nThe code-generating measurement pattern consists of measuring the check operators located on all of the \\(r\\)-labeled edges in round \\(r\\) mod 3. The code space is the \\(+1\\) eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured.", "name": "Honeycomb code", "realizations": "", "short_name": "", "features_threshold": "\\(0.2\\%-0.3\\%\\) in a controlled-not circuit model with a correlated minimum-weight perfect-matching decoder [C. Gidney et al., \u201cA Fault-Tolerant Honeycomb Memory\u201d, Quantum 5, 605 (2021). DOI; 2108.10457].\n\\(1.5\\%<p<2.0\\%\\) in a circuit model with native two-body measurements and a correlated minimum-weight perfect-matching decoder [C. Gidney et al., \u201cA Fault-Tolerant Honeycomb Memory\u201d, Quantum 5, 605 (2021). DOI; 2108.10457]. Here, \\(p\\) is the collective error rate of the two-body measurement gate, including both measurement and correlated data depolarization error processes.\nAgainst circuit-level noise: within \\(0.2\\% \u2212 0.3\\%\\) for SD6 (standard depolarizing 6-step cycle), \\(0.1\\% \u2212 0.15\\%\\) for SI1000 (superconducting-inspired 1000 ns cycle), and \\(1.5\\% \u2212 2.0\\%\\) for EM3 (entangling-measurement 3-step cycle) [Craig Gidney, Michael Newman, and Matt McEwen, \u201cBenchmarking the Planar Honeycomb Code\u201d. 2202.11845][Adam Paetznick et al., \u201cPerformance of planar Floquet codes with Majorana-based qubits\u201d. 2202.11829].", "features_code_capacity_threshold": "", "features_decoders": "The ISG has a static subgroup for all time steps \\(r\\geq 3\\) \u2013 that is, a subgroup which remains a subgroup of the ISG for all future times \u2013 given by so-called plaquette stabilizers. These are stabilizers consisting of products of check operators around homologically trivial paths. The syndrome bits correspond to the eigenvalues of the plaquette stabilizers. Because of the structure of the check operators, only one-third of all plaquettes are measured each round. The syndrome bits must therefore be represented by a lattice in spacetime, to reflect when and where the outcome was obtained.", "features_general_gates": "There are two types of logical operators, inner and outer. An inner logical operator is the product of check operators on a homologically nontrivial cycle. They belong to the stabilizer group as a subsystem code. Outer logical operators have an interpretation in terms of magnetic and electric operators of an embedded surface code, and they do not belong to the stabilizer group of the associated subsystem code.", "features_magic_scaling_exponent": "", "features_encoders": "Initialization can be performed by preparing each pair of qubits on an edge in some particular state independently specified by the effective-one-qubit operators (two-qubit Pauli strings centered on an edge) and then beginning the check measurement sequence. This is analogous to projecting a state into the code space by measuring stabilizers.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "One can run a fault-tolerant decoding algorithm by (1) bipartitioning the syndrome lattice into two graphs which are congruent to the Cayley graph of the free abelian group with three generators (up to boundary conditions) and (2) performing a matching algorithm to deduce errors.", "parents_code_id": "floquet", "parents_detail": "The honeycomb code is the first 2D Floquet code.", "cousins_code_id": "surface\nsubsystem_color\nmajorana_stab\nmatching\nqldpc", "cousins_detail": "Measurement of each check operator involves two qubits and projects the state of the two qubits to a two-dimensional subspace, which we regard as an effective qubit. These effective qubits form a surface code on a hexagonal superlattice. Electric and magnetic operators on the embedded surface code correspond to outer logical operators of the Floquet code. In fact, outer logical operators transition back and forth from magnetic to electric surface code operators under the measurement dynamics. Inspired by this code, stabilizer measurement circuits consisting of two-body measurements have been designed for the surface code [R. Chao et al., \u201cOptimization of the surface code design for Majorana-based qubits\u201d, Quantum 4, 352 (2020). DOI; 2007.00307][Craig Gidney, \u201cA Pair Measurement Surface Code on Pentagons\u201d. 2206.12780].\nBoth honeycomb and subsystem color codes are generated via periodic sequences of measurements. However, any measurement sequence can be performed on the color code without destroying the logical qubits, while honeycomb codes can be maintained only with specific sequences. Honeycomb codes require a shorter measurement cycle and use fewer qubits at the given code distance [M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].\nThe Honeycomb code admits a representation in terms of Majorana fermions. This leads to a possible physical realization of the code in terms of tetrons [T. Karzig et al., \u201cScalable designs for quasiparticle-poisoning-protected topological quantum computation with Majorana zero modes\u201d, Physical Review B 95, (2017). DOI; 1610.05289], where each physical qubit is composed of four Majorana modes.\nMatching and honeycomb codes are both inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438].\nThe Floquet check operators are weight-two, and each qubit participates in one check each round.", "_type": "ecc", "_page_id": "c_honeycomb", "_href": "c/honeycomb"}, "c_monitored_random_circuits": {"notes": "Connections to information scrambling in black hole physics, as introduced in Section 11 of [S. Choi et al., \u201cQuantum Error Correction in Scrambling Dynamics and Measurement-Induced Phase Transition\u201d, Physical Review Letters 125, (2020). DOI; 1903.05124]. In particular, monitored random circuits can be viewed as the Hayden-Preskill recovery problem [B. Yoshida, \u201cSoft mode and interior operator in the Hayden-Preskill thought experiment\u201d, Physical Review D 100, (2019). DOI] running backwards in time. In this setting, the volume-law entanglement phase of the monitored circuit describes the phase when information can be recovered from an old black hole (ie, a black hole that is maximally entangled with the early universe).\nMapping monitored random circuits to statistical mechanics models can help estimate thresholds and code distances for these systems [Y. Li and M. P. A. Fisher, \u201cStatistical mechanics of quantum error correcting codes\u201d, Physical Review B 103, (2021). DOI; 2007.03822].", "logical": "qubits", "code_id": "monitored_random_circuits", "physical": "groups", "protection": "When in the volume-law phase, protects against random projective measurements at a rate \\( p < p_c \\). While the true code distance is not known, it is conjectured to be proportional to the contiguous distance. As first described in Ref. [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195], the contiguous distance for these circuits is defined with respect to all partitions of the system.", "introduced": "[B. Skinner, J. Ruhman, and A. Nahum, \u201cMeasurement-Induced Phase Transitions in the Dynamics of Entanglement\u201d, Physical Review X 9, (2019). DOI][Y. Li, X. Chen, and M. P. A. Fisher, \u201cQuantum Zeno effect and the many-body entanglement transition\u201d, Physical Review B 98, (2018). DOI][A. Chan et al., \u201cUnitary-projective entanglement dynamics\u201d, Physical Review B 99, (2019). DOI; 1808.05949]", "description": "Error-correcting code arising from a monitored random circuit. Such a circuit is described by a series of intermittant random local projective Pauli measurements with random unitary time-evolution operators. An important sub-family consists of Clifford monitored random circuits, where unitaries are sampled from the Clifford group [Y. Li, X. Chen, and M. P. A. Fisher, \u201cMeasurement-driven entanglement transition in hybrid quantum circuits\u201d, Physical Review B 100, (2019). DOI; 1901.08092]. When the rate of projective measurements is independently controlled by a probability parameter \\(p\\), there can exist two stable phases, one described by volume-law entanglement entropy and the other by area-law entanglement entropy. The phases and their transition can be understood from the perspective of quantum error correction, information scrambling, and channel capacities [S. Choi et al., \u201cQuantum Error Correction in Scrambling Dynamics and Measurement-Induced Phase Transition\u201d, Physical Review Letters 125, (2020). DOI; 1903.05124][M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195].\n\nMonitored random circuits have a finite information capacity that decays exponentially with respect to system size [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]. When \\( p = 0 \\), the random circuit achieves channel capacity, meaning that it stores the most amount of information possible. This notion quantifies the recoverability of information and the reversability of the system under the monitored random dynamics. In the volume-law phase (\\( p < p_c \\) for some critical probability \\(p_c\\)), the channel capacity remains non-zero, and the monitored channel projects an initial state into a random error-correcting code [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]. With appropriately chosen evolution operators and measurements, the code is a stabilizer code whose parameters depend on time, \\( [[n,k(t),d(t)]] \\). A similar notion applies to Haar random circuits with measurements [A. Zabalo et al., \u201cCritical properties of the measurement-induced transition in random quantum circuits\u201d, Physical Review B 101, (2020). DOI; 1911.00008]. ", "name": "Monitored random-circuit code", "realizations": "Measurement induced quantum phases have been realized in a trapped-ion processor [Crystal Noel et al., \u201cObservation of measurement-induced quantum phases in a trapped-ion quantum computer\u201d. 2106.05881].", "short_name": "", "features_threshold": "Above the critical measurement rate \\( p_c\\), the natural error correction properties of the circuit can no longer protect the information. This can be interpreted as the code threshold.\nThese dynamically generated codes saturate the trade off between density of encoded information and the error rate threshold [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]", "features_code_capacity_threshold": "", "features_decoders": "The recovery operation is the reverse unitary transformation with access to the measurement record (for dynamically generated codes with a strong purification transition) [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "The dynamics of the monitored random circuit can be recast in the language of stabilizer codes [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]. The stabilizer group of the error-correcting code resulting from a monitored Clifford circuit either grows or shrinks with each time step, depending on which projective measurements were performed during the time step.\nOne can construct optimal single-copy encoding operations for strong purification transitions [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]", "features_rate": "Rate can be finite [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195], depending on the family of random codes generated by the circuit.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "random_circuit", "parents_detail": "Monitored random circuits are random circuits where projective measurements are interspersed throughout the circuit and measurement results are recorded.", "cousins_code_id": "topological", "cousins_detail": "Topological order can be generated in 2D monitored random circuits [A. Lavasani, Y. Alavirad, and M. Barkeshli, \u201cTopological Order and Criticality in <mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mo stretchy=\"false\">(</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy=\"false\">)</mml:mo><mml:mi mathvariant=\"normal\">D</mml:mi></mml:mrow></mml:math> Monitored Random Quantum Circuits\u201d, Physical Review Letters 127, (2021). DOI; 2011.06595].", "cousin_of_code_id": "floquet", "cousin_of_detail": "Both Floquet and monitored random circuit codes can have an instantaneous stabilizer group which evolves through unitary evolution and measurements. However, Floquet codewords are generated via a specific sequence of measurements, while random-circuit codes maintain a stabilizer group after any measurement. Floquet codes have the additional capability of detecting errors induced during the measurement process; see Appx. A of Ref. [M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].", "_type": "ecc", "_page_id": "c_monitored_random_circuits", "_href": "c/monitored_random_circuits"}, "c_quantum_polar": {"notes": "", "logical": "qubits", "code_id": "quantum_polar", "physical": "qubits", "protection": "Protects against Pauli noise and erasures.", "introduced": "[J. M. Renes, F. Dupuis, and R. Renner, \u201cEfficient Polar Coding of Quantum Information\u201d, Physical Review Letters 109, (2012). DOI; 1109.3195]", "description": "Entanglement-assisted CSS code utilized in a quantum polar coding scheme producing entangled pairs of qubits between sender and receiver. In such a scheme, the amplitude and phase information of a quantum state is handled in complementary fashion [J. M. Renes and J.-C. Boileau, \u201cPhysical underpinnings of privacy\u201d, Physical Review A 78, (2008). DOI; 0803.3096] using an encoding based on classical polar codes. Variants of the initial scheme have been developed for degradable channels [M. M. Wilde and J. M. Renes, \u201cQuantum polar codes for arbitrary channels\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1201.2906] and extended to arbitrary channels [M. M. Wilde and S. Guha, \u201cPolar Codes for Degradable Quantum Channels\u201d, IEEE Transactions on Information Theory 59, 4718 (2013). DOI; 1109.5346].\n\nThe scheme requires some a-priori quantum side information in the general case, making the associated code entanglement assisted [J. M. Renes, F. Dupuis, and R. Renner, \u201cEfficient Polar Coding of Quantum Information\u201d, Physical Review Letters 109, (2012). DOI; 1109.3195]. The requirement of having quantum side information vanishes when the sum of the amplitude channel fidelity and the phase channel fidelity is not greater than 1. It is shown to vanish for the case of degradable noise channels [M. M. Wilde and S. Guha, \u201cPolar Codes for Degradable Quantum Channels\u201d, IEEE Transactions on Information Theory 59, 4718 (2013). DOI; 1109.5346]. ", "name": "Quantum polar code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Constructed using classical polar decoders for the amplitude and phase channels.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The rate approaches the symmetric coherent information of the quantum noise channel [M. M. Wilde and J. M. Renes, \u201cQuantum polar codes for arbitrary channels\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1201.2906].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "eastab", "parents_detail": "Quantum polar codes are CSS codes used in an entanglement generation scheme that generally requires entanglement assistance.", "cousins_code_id": "polar", "cousins_detail": "", "cousin_of_code_id": "stab_4_2_2", "cousin_of_detail": "\\([[4,2,2]]\\) code is a small quantum polar code [Kyungjoo Noh, Leung code as quantum polar code, 2017.].", "_type": "ecc", "_page_id": "c_quantum_polar", "_href": "c/quantum_polar"}, "c_stabilizer_over_gf4": {"notes": "Tables of \\([[n,0,d]]\\) codes, corresponding to a self-dual \\(GF(4)\\) representation, at this website.", "logical": "qubits", "code_id": "stabilizer_over_gf4", "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "introduced": "[A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006]", "description": "An \\([[n,k,d]]\\) stabilizer code constructed from a quaternary classical code using the one-to-one correspondence between the four Pauli matrices \\(\\{I,X,Y,Z\\}\\) and the four elements \\(\\{0,1,\\alpha^2,\\alpha\\}\\) of the quaternary field \\(GF(4)\\).\n\nAn \\(n\\)-qubit Pauli stabilizer can be represented as a length-\\(n\\) quaternary vector. The stabilizer commutation condition corresponds to a zero trace-Hermitian inner product between the corresponding vectors. Stabilizer codes over \\(GF(4)\\) can thus be constructed from classical trace-Hermitian self-orthogonal additive quaternary codes and Hermitian self-orthogonal linear quaternary codes (since the latter are automatically trace-Hermitian self-orthogonal). The classical code corresponds to the stabilizer group \\(\\mathsf{S}\\) while its trace-Hermitian dual corresponds to the normalizer \\(\\mathsf{N(S)}\\).\n\nStabilizer codes over \\(GF(4)\\) can be constructed as follows. Let \\(\\phi\\) be a bijection from a linear binary subspace to \\(GF(4)^n\\). Let \\(C\\) be a trace-Hermitian self-orthogonal additive subcode over \\(GF(4)\\), containing \\(2^{n-k}\\) vectors, such that there are no vectors of weight less than \\(d\\) in \\(C^{\\perp}\\setminus C\\). Then, any eigenspace of the inverse map \\(\\phi^{-1}(C)\\) is an \\([[n, k, d]]\\) stabilizer code over \\(GF(4)\\).", "name": "Stabilizer code over \\(GF(4)\\)", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "parent_of_code_id": "stab_5_1_3", "parent_of_detail": "The \\([[5,1,3]]\\) code is derived from the \\([5,3,3]_4\\) Hamming code.", "cousins_code_id": "dual_additive\ndual", "cousins_detail": "The stabilizer commutation condition for stabilizer codes over \\(GF(4)\\) can equivalently be stated in the representation of stabilizers as quaternary vectors. A pair of \\(n\\)-qubit stabilizers commute iff the trace-Hermitian inner product of their corresponding vectors is zero. Stabilizer codes over \\(GF(4)\\) can thus be constructed from trace-Hermitian self-orthogonal additive quaternary codes.\nIf the classical additive code of quaternary vectors corresponding a stabilizer code over \\(GF(4)\\) is linear, then the code is self-orthogonal with respect to both the trace-Hermitian and Hermitian inner products ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.4.1). In other words, the extra trace operation can be removed from the definition of inner product.", "cousin_of_code_id": "quantum_bch\nstabilizer_over_gfqsq", "cousin_of_detail": "Hermitian self-orthogonal quaternary BCH codes are used to construct a subset of qubit BCH codes via the stabilizer-over-\\(GF(4)\\) construction.\nStabilizer codes over \\(GF(q^2)\\) are Galois-qudit extensions of those over \\(GF(4)\\).", "_type": "ecc", "_page_id": "c_stabilizer_over_gf4", "_href": "c/stabilizer_over_gf4"}, "c_happy": {"notes": "Ref. [Jordan Cotler and Andrew Strominger, \u201cThe Universe as a Quantum Encoder\u201d. 2201.11658] discusses the HaPPY code for an AdS_3 space and its relation to a dS_2 braneworld with a conformal boundary.", "logical": "qubits", "code_id": "happy", "physical": "qubits", "protection": "Protects against erasure errors and Pauli errors on the boundary qubits.", "introduced": "[F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237]", "description": "Also known as a hyperbolic pentagon code (HyPeC). Holographic code constructed out of a network of perfect tensors that tesselates hyperbolic space. Physical qubits are associated with uncontracted tensor legs at the boundary of the tesselation, while logical qubits are associated with uncontracted legs in the bulk. The code serves as a minimal model for several aspects of the AdS/CFT holographic duality. The construction below is described for qubits, but straightforward generalizations exist to modular qudits, oscillators, and rotors [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].\n\nEncoding is accomplished using a tensor network of \\([[5,1,3]]\\) encoding isometries, which are six-legged perfect tensors (with five legs corresponding to the physical qubits and one for the encoded logical qubit). A \\(2n\\)-legged perfect tensor is proportional to an isometry for any bipartition of its indices into a set \\(A\\) and a complementary set \\(A^{\\perp}\\) such that \\(|A|\\leq|A^{\\perp}|\\).\n\nTo construct the encoding, one first uniformly tiles the hyperbolic AdS/CFT disc using pentagons and hexagons. Then, one places a 6-legged \\([[5,1,3]]\\) encoding tensor at each hexagon and pentagon, contracting legs between neighboring shapes and leaving one leg uncontracted at each pentagon. This construction forms an encoding isometry from the uncontracted legs in the bulk to the uncontracted legs at the boundary.", "name": "Pastawski-Yoshida-Harlow-Preskill (HaPPY) code", "realizations": "", "short_name": "HaPPY", "features_threshold": "\\(26\\%\\) for boundary erasure errors on the the pentagon/hexagon HaPPY code, which has alternating layers of pentagons and hexagons in the tiling.\n\\(\\sim 50\\%\\) for boundary erasure errors on the single-qubit HaPPY code, which has a central pentagon encoding one bulk operator and hexagons tiling all other layers\n\\(16.3\\%\\) for boundary Pauli errors on the single-qubit HaPPY code with 3 layers [R. J. Harris et al., \u201cDecoding holographic codes with an integer optimization decoder\u201d, Physical Review A 102, (2020). DOI; 2008.10206].\nThere is no threshold for the pentagon HaPPY code as a constant number of errors (two) can make bulk recovery impossible.", "features_code_capacity_threshold": "", "features_decoders": "Greedy algorithm for decoding specified in Ref. [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Heisenberg-picture encoding is done through tensor pushing. Each bulk operator (logical) is pushed to an operator supported on a portion of the boundary region (physical). Pushing all the bulk operators through results in reconstruction of the boundary.", "features_rate": "The pentagon HaPPY code has an asymptotic rate \\(\\frac{1}{\\sqrt{5}} \\approx 0.447\\). The pentagon/hexagon HaPPY code, with alternating layers of pentagons and hexagons in the tiling, has a rate of \\(0.299\\) if the last layer is a pentagon layer and a rate of \\(0.088\\) if the last layer is a hexagon layer.", "features_transversal_gates": "For locality-preserving physical gates on the boundary, the set of transversally implementable logical operations in the bulk is strictly contained in the Clifford group [S. Cree et al., \u201cFault-Tolerant Logical Gates in Holographic Stabilizer Codes Are Severely Restricted\u201d, PRX Quantum 2, (2021). DOI; 2103.13404].", "features_fault_tolerance": "", "parents_code_id": "holographic\nqubit_stabilizer", "parents_detail": "\nThe HaPPY code is a stabilizer code because it is defined by a contracted network of stabilizer tensors; see Thm. 6 in Ref. [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].", "cousins_code_id": "stab_5_1_3\nmajorana_stab", "cousins_detail": "The \\([[5,1,3]]\\) encoding isometry tiles various holographic codes because its corresponding tensor is perfect [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nHaPPY code Hamiltonian can be expressed in terms of mutually commuting two-body Majorana operators [A. Jahn et al., \u201cMajorana dimers and holographic quantum error-correcting codes\u201d, Physical Review Research 1, (2019). DOI; 1905.03268].", "_type": "ecc", "_page_id": "c_happy", "_href": "c/happy"}, "c_quantum_triorthogonal": {"notes": "Reference [Sepehr Nezami and Jeongwan Haah, \u201cClassification of Small Triorthogonal Codes\u201d. 2107.09684] presents a classification of triorthogonal codes up to \\(n + k \\leq 38\\) by associating each triorthogonal code with a Reed-Muller polynomial.", "logical": "qubits", "code_id": "quantum_triorthogonal", "physical": "qubits", "protection": "Weight \\(t\\) Pauli errors, where \\(t\\) depends on the family. For example, Ref. [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426] provides a family of distance \\(2\\) codes. It also presents a \\([[49, 1, 5]]\\) code.", "introduced": "[S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426]", "description": "A triorthogonal \\(m \\times n\\) binary matrix is triorthogonal if its rows \\(r_1, \\ldots, r_m\\) satisfy \\(|r_i \\cdot r_j| = 0\\) and \\(|r_i \\cdot r_j \\cdot r_k| = 0\\), where addition and multiplication are done on \\(\\mathbb{Z}_2\\). The triorthogonal code associated with the matrix is constructed by mapping non-zero entries in even-weight rows to \\(X\\) operators, and \\(Z\\) operators for each row in the orthogonal complement.", "name": "Triorthogonal code", "realizations": "", "short_name": "", "features_threshold": "Approximately \\(\\frac{1}{3k + 1}\\) [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426].", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "Triorthogonal codes can be used for high-quality magic-state distillation [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426].", "features_magic_scaling_exponent": "Depends on the matrix. Reference [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426] gave a family of \\(\\frac{k}{3k+8}\\) codes with magic-state distillation scaling exponent \\(\\gamma = \\log_2 \\frac{3k+8}{k}\\).", "features_encoders": "Encoder for magic states for the code constructed in [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426].", "features_rate": "", "features_transversal_gates": "Admits transversal \\(T\\) gates [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426] and the controlled-controlled-\\(Z\\) gate.", "features_fault_tolerance": "", "parents_code_id": "css", "parents_detail": "", "parent_of_code_id": "stab_15_1_3", "parent_of_detail": "The \\([[15, 1, 3]]\\) code is a triorthogonal code [Sepehr Nezami and Jeongwan Haah, \u201cClassification of Small Triorthogonal Codes\u201d. 2107.09684]", "cousins_code_id": "quantum_reed_muller", "cousins_detail": "Classification of triorthongonal codes yields a connection to Reed-Muller polynomials [Sepehr Nezami and Jeongwan Haah, \u201cClassification of Small Triorthogonal Codes\u201d. 2107.09684].", "cousin_of_code_id": "color\nquantum_divisible", "cousin_of_detail": "The 3D color code is triorthogonal.\nTriorthogonal codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions.", "_type": "ecc", "_page_id": "c_quantum_triorthogonal", "_href": "c/quantum_triorthogonal"}, "c_stab_4_2_2": {"notes": "Concatenating \\([[4,2,2]]\\) code with surface code can generate 2D topological code with a reasonable circuit-based threshold [B. Criger and B. Terhal, \u201cNoise thresholds for the [4,2,2]-concatenated toric code\u201d, Quantum Information and Computation 16, 1261 (2016). DOI].", "logical": "qubits", "code_id": "stab_4_2_2", "physical": "qubits", "protection": "Detects a single-qubit error [L. Vaidman, L. Goldenberg, and S. Wiesner, \u201cError prevention scheme with four particles\u201d, Physical Review A 54, R1745 (1996). DOI; quant-ph/9603031] or single erasure [M. Grassl, T. Beth, and T. Pellizzari, \u201cCodes for the quantum erasure channel\u201d, Physical Review A 56, 33 (1997). DOI; quant-ph/9610042]. Not able to correct arbitrary single-qubit errors because \\( \\lfloor \\frac{d-1}{2} \\rfloor =0 \\). Approximately corrects a single amplitude damping error [D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002].", "introduced": "[L. Vaidman, L. Goldenberg, and S. Wiesner, \u201cError prevention scheme with four particles\u201d, Physical Review A 54, R1745 (1996). DOI; quant-ph/9603031]", "description": "Also known as the \\(C_4\\) code. Four-qubit CSS stabilizer code with generators \\(\\{XXXX, ZZZZ\\} \\) and codewords \\begin{align}\n  \\begin{split}\n    |\\overline{00}\\rangle = (|0000\\rangle + |1111\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{01}\\rangle = (|0011\\rangle + |1100\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{10}\\rangle = (|0101\\rangle + |1010\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{11}\\rangle = (|0110\\rangle + |1001\\rangle)/\\sqrt{2}~.\n  \\end{split}\n\\end{align} This code is the smallest single-qubit error-detecting code. It is also the smallest instance of the toric code, and its various single-qubit subcodes are small planar surface codes.\n\nThe subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is a \\([[4,1,2]]\\) code [D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002], whose \\(\\pm\\)-basis codewords can be written as \\begin{align}\n  |\\overline{\\pm}\\rangle = \\frac{1}{2}(|00\\rangle \\pm |11\\rangle)^{\\otimes 2}~.\\\\\n\\end{align} This code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code. The subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\) [G. Alber et al., \u201cStabilizing Distinguishable Qubits against Spontaneous Decay by Detected-Jump Correcting Quantum Codes\u201d, Physical Review Letters 86, 4402 (2001). DOI; quant-ph/0103042] has also been studied against amplitude-damping noise. This subcode [A. Erhard et al., \u201cEntangling logical qubits with lattice surgery\u201d, Nature 589, 220 (2021). DOI; 2006.03071] and the subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [C. K. Andersen et al., \u201cRepeated quantum error detection in a surface code\u201d, Nature Physics 16, 875 (2020). DOI; 1912.09410], \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) [Zijun Chen et al., \u201cExponential suppression of bit or phase flip errors with repetitive error correction\u201d. 2102.06132], and \\(\\{|\\overline{00}\\rangle,|\\overline{11}\\rangle\\}\\) [J. F. Marques et al., \u201cLogical-qubit operations in an error-detecting surface code\u201d, Nature Physics 18, 80 (2021). DOI; 2102.13071] are small planar surface codes. ", "name": "\\([[4,2,2]]\\) CSS code", "realizations": "\\([[4,1,2]]\\) subcode implemented using four-qubit graph state of photons [B. A. Bell et al., \u201cExperimental demonstration of a graph state quantum error-correction code\u201d, Nature Communications 5, (2014). DOI; 1404.5498]. \nTrapped-ion device by IonQ [N. M. Linke et al., \u201cFault-tolerant quantum error detection\u201d, Science Advances 3, (2017). DOI; 1611.06946].\nLogical state preparation and flag-qubit error correction realized in superconducting-circuit devices by IBM [M. Takita et al., \u201cExperimental Demonstration of Fault-Tolerant State Preparation with Superconducting Qubits\u201d, Physical Review Letters 119, (2017). DOI; 1705.09259][E. H. Chen et al., \u201cCalibrated Decoders for Experimental Quantum Error Correction\u201d, Physical Review Letters 128, (2022). DOI; 2110.04285].\nThe subcode \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [C. K. Andersen et al., \u201cRepeated quantum error detection in a surface code\u201d, Nature Physics 16, 875 (2020). DOI; 1912.09410] and \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) [Zijun Chen et al., \u201cExponential suppression of bit or phase flip errors with repetitive error correction\u201d. 2102.06132], treated as a planar surface code, has been realized in superconducting-circuit devices.\nLogical gates between two copies of the subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\), interpreted as lattice surgery between planar surface codes, realized in superconducting circuits [A. Erhard et al., \u201cEntangling logical qubits with lattice surgery\u201d, Nature 589, 220 (2021). DOI; 2006.03071].\nLogical gates for the \\(\\{|\\overline{00}\\rangle,|\\overline{11}\\rangle\\}\\) subcode, treated as a planar code, realized in superconducting circuits [J. F. Marques et al., \u201cLogical-qubit operations in an error-detecting surface code\u201d, Nature Physics 18, 80 (2021). DOI; 2102.13071].", "short_name": "\\([[4,2,2]]\\)", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "Transversal Pauli, Hadamard, and two-qubit \\(R\\) gates [Daniel Gottesman, \u201cQuantum fault tolerance in small experiments\u201d. 1610.03507].", "features_fault_tolerance": "Preparation of certain states along with transversal gates can be performed fault-tolerantly, but requires post-selection because the code cannot correct errors [Daniel Gottesman, \u201cQuantum fault tolerance in small experiments\u201d. 1610.03507].", "parents_code_id": "surface", "parents_detail": "\\([[4,2,2]]\\) code is the smallest toric code.", "cousins_code_id": "rotated_surface\nquantum_parity\nstab_5_1_3\nquantum_polar\napproximate_qecc\nbinomial", "cousins_detail": "Various \\([[4,1,2]]\\) subcodes are small rotated planar codes [A. Erhard et al., \u201cEntangling logical qubits with lattice surgery\u201d, Nature 589, 220 (2021). DOI; 2006.03071][C. K. Andersen et al., \u201cRepeated quantum error detection in a surface code\u201d, Nature Physics 16, 875 (2020). DOI; 1912.09410][Zijun Chen et al., \u201cExponential suppression of bit or phase flip errors with repetitive error correction\u201d. 2102.06132][J. F. Marques et al., \u201cLogical-qubit operations in an error-detecting surface code\u201d, Nature Physics 18, 80 (2021). DOI; 2102.13071].\n\\([[4,1,2]]\\) subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes.\n\\([[4,2,2]]\\) can be derived from \\([[5,1,3]]\\) code using a protocol that converts \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman [Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052].\n\\([[4,2,2]]\\) code is a small quantum polar code [Kyungjoo Noh, Leung code as quantum polar code, 2017.].\n\\([[4,1,2]]\\) subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002] and \\(\\{|\\overline{01}\\rangle,|\\overline{11}\\rangle\\}\\) [G. Alber et al., \u201cStabilizing Distinguishable Qubits against Spontaneous Decay by Detected-Jump Correcting Quantum Codes\u201d, Physical Review Letters 86, 4402 (2001). DOI; quant-ph/0103042] approximately correct a single amplitude damping error.\n\\([[4,1,2]]\\) subcode consisting of \\(\\{|\\overline{00}\\rangle\\) and any other codeword reduces to the \\(0,2,4\\) binomial code when the basis labels in each codeword are written as in base-ten. Such a mapping can be generalized [Linshu Li, private communication, 2018].", "cousin_of_code_id": "heavy_hex", "cousin_of_detail": "The \\(d=2\\) heavy-hexagonal code is closely related to the \\([[4,1,2]]\\) code.", "_type": "ecc", "_page_id": "c_stab_4_2_2", "_href": "c/stab_4_2_2"}, "c_steane": {"notes": "", "logical": "qubits", "code_id": "steane", "physical": "qubits", "protection": "The Steane code is a distance 3 code. It detects errors on 2 qubits, corrects errors on 1 qubit.", "introduced": "[\u201cMultiple-particle interference and quantum error correction\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 452, 2551 (1996). DOI; quant-ph/9601029]", "description": "A \\([[7,1,3]]\\) CSS code that uses the classical binary \\([7,4,3]\\) Hamming code for protecting against \\(X\\) errors and its dual \\([7,3,4]\\) for \\(Z\\) errors. The parity-check matrix for the \\([7,4,3]\\) Hamming code is \\begin{align}\n  H = \\left(\\begin{matrix}\n    1&0&0&1&0&1&1\\\\\n    0&1&0&1&1&0&1\\\\\n    0&0&1&0&1&1&1\n  \\end{matrix}\\right),\n\\end{align} and the check matrix for the Steane code is therefore \\begin{align}\n  \\left(\\begin{matrix}\n    0&H\\\\\n    H&0\n  \\end{matrix}\\right).\n\\end{align} The stabilizer group for the Steane code has six generators. ", "name": "Steane \\([[7,1,3]]\\) code", "realizations": "Trapped-ion qubits: seven-qubit device in Blatt group [D. Nigg et al., \u201cQuantum computations on a topologically encoded qubit\u201d, Science 345, 302 (2014). DOI; 1403.5426], ten-qubit QCCD device by Quantinuum [C. Ryan-Anderson et al., \u201cRealization of real-time fault-tolerant quantum error correction\u201d. 2107.07505] (see APS Physics Synopsys [P. Ball, \u201cReal-Time Error Correction for Quantum Computing\u201d, Physics 14, (2021). DOI]). Fault-tolerant universal two-qubit gate set by Monz group [Lukas Postler et al., \u201cDemonstration of fault-tolerant universal quantum gate operations\u201d. 2111.12654]. Logical CNOT gate between two logical qubits, including rounds of correction and fault-tolerant primitives such as flag qubits and pieceable fault tolerance, on a 20-qubit device by Quantinuum [C. Ryan-Anderson et al., \u201cImplementing Fault-tolerant Entangling Gates on the Five-qubit Code and the Color Code\u201d. 2208.01863]; logical fidelity interval of the combined preparation-CNOT-measurement procedure was higher than that of the unencoded physical qubits.\nRydberg atom arrays: Lukin group [D. Bluvstein et al., \u201cA quantum processor based on coherent transport of entangled atom arrays\u201d, Nature 604, 451 (2022). DOI; 2112.03923].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "Pieceable fault-tolerant CCZ gate [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].", "features_magic_scaling_exponent": "", "features_encoders": "Nine CNOT and four Hadamard gates ([M. Nakahara, \u201cQuantum Computing\u201d, [] (2008). DOI], Fig. 10.14).", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Pieceable fault-tolerant CCZ gate [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].\nSyndrome measurement can be done with ancillary flag qubits [T. J. Yoder and I. H. Kim, \u201cThe surface code with a twist\u201d, Quantum 1, 2 (2017). DOI; 1612.04795][R. Chao and B. W. Reichardt, \u201cQuantum Error Correction with Only Two Extra Qubits\u201d, Physical Review Letters 121, (2018). DOI; 1705.02329] or with no extra qubits [B. W. Reichardt, \u201cFault-tolerant quantum error correction for Steane\u2019s seven-qubit color code with few or no extra qubits\u201d, Quantum Science and Technology 6, 015007 (2020). DOI].", "parents_code_id": "quantum_hamming_css\ncolor", "parents_detail": "Steane code is the smallest member of a family of Hamming-based CSS codes.\nSteane code is the smallest 2D color code.", "cousins_code_id": "hamming", "cousins_detail": "The Steane code is constructed from a classical Hamming code.", "cousin_of_code_id": "quantum_divisible", "cousin_of_detail": "A fault-tolerant \\(T\\) gate on the Steane code can be obtained by concatenating with particular quantum divisible codes.", "_type": "ecc", "_page_id": "c_steane", "_href": "c/steane"}, "c_stab_5_1_3": {"notes": "", "logical": "qubits", "code_id": "stab_5_1_3", "physical": "qubits", "protection": "Smallest stabilizer code that protects against a single error on any one qubit. Detects two-qubit errors.", "introduced": "[Raymond Laflamme et al., \u201cPerfect Quantum Error Correction Code\u201d. quant-ph/9602019]", "description": "Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, \\begin{align} \\begin{split} S_1 &= IXZZX \\\\ S_2 &= XZZXI \\\\ S_3 &= ZZXIX \\\\ S_4 &= ZXIXZ~. \\end{split} \\end{align}", "name": "\\([[5,1,3]]\\) perfect code", "realizations": "NMR: Implementation of perfect error correcting code on 5 spin subsystem of labeled crotonic acid for quantum network benchmarking [E. Knill et al., \u201cBenchmarking Quantum Computers: The Five-Qubit Error Correcting Code\u201d, Physical Review Letters 86, 5811 (2001). DOI; quant-ph/0101034]. Implementation of identity, NOT, and Haddamard gates along with perfect error correcting code on single qubit errors in 5 qubit circuit [J. Zhang, R. Laflamme, and D. Suter, \u201cExperimental Implementation of Encoded Logical Qubit Operations in a Perfect Quantum Error Correcting Code\u201d, Physical Review Letters 109, (2012). DOI; 1208.4797].\nSuperconducting qubits [M. Gong et al., \u201cExperimental exploration of five-qubit quantum error-correcting code with superconducting qubits\u201d, National Science Review 9, (2021). DOI; 1907.04507].\nTrapped-ion qubits: non-transversal CNOT gate between two logical qubits, including rounds of correction and fault-tolerant primitives such as flag qubits and pieceable fault tolerance, on a 12-qubit device by Quantinuum [C. Ryan-Anderson et al., \u201cImplementing Fault-tolerant Entangling Gates on the Five-qubit Code and the Color Code\u201d. 2208.01863].", "short_name": "\\([[5,1,3]]\\)", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Combined dynamical decoupling and error correction protocol on individually-controlled qubits with always-on Ising couplings [A. De and L. P. Pryadko, \u201cUniversal set of dynamically protected gates for bipartite qubit networks: Soft pulse implementation of the [[5,1,3]] quantum error-correcting code\u201d, Physical Review A 93, (2016). DOI; 1509.01239].\nSymmetric decoder correcting all weight-one Pauli errors. The resulting logical error channel after coherent noise has been explicitly derived [Chaobin Liu, \u201cExact performance of the five-qubit code with coherent errors\u201d. 2203.01706].", "features_general_gates": "Pieceable fault-tolerant CZ, CNOT, and CCZ gates [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].", "features_magic_scaling_exponent": "", "features_encoders": "Four CCZ, four Hadamard, and one \\(Z\\) gate ([M. Nakahara, \u201cQuantum Computing\u201d, [] (2008). DOI], Fig. 10.16).\nFour CNOT and five CPHASE gates [A. De and L. P. Pryadko, \u201cUniversal set of dynamically protected gates for bipartite qubit networks: Soft pulse implementation of the [[5,1,3]] quantum error-correcting code\u201d, Physical Review A 93, (2016). DOI; 1509.01239].", "features_rate": "", "features_transversal_gates": "Pauli gates are transversal, along with the one non-Pauli Hadmard times phase gate.", "features_fault_tolerance": "Pieceable fault-tolerant CZ, CNOT, and CCZ gates [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].\nSyndrome measurement can be done with two ancillary flag qubits [R. Chao and B. W. Reichardt, \u201cQuantum Error Correction with Only Two Extra Qubits\u201d, Physical Review Letters 121, (2018). DOI; 1705.02329].", "parents_code_id": "stabilizer_over_gf4", "parents_detail": "The \\([[5,1,3]]\\) code is derived from the \\([5,3,3]_4\\) Hamming code.", "cousins_code_id": "quantum_perfect\nquantum_mds\nquantum_cyclic\nhamiltonian\nmajorana_stab", "cousins_detail": "The smallest perfect code.\nThe smallest quantum MDS code.\n\\([[5,1,3]]\\) code is the smallest known example of quantum cyclic code.\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].", "cousin_of_code_id": "braunstein\nhexacode\nhappy\nquantum_divisible\nstab_4_2_2\nrotor_5_1_3", "cousin_of_detail": "The Braunstein five-mode code is a bosonic analogue of the five-qubit code.\nApplying the stabilizer-over-\\(GF(4)\\) construction to the hexacode yields a \\([[6,0,4]]\\) quantum code [A. J. Scott, \u201cMultipartite entanglement, quantum-error-correcting codes, and entangling power of quantum evolutions\u201d, Physical Review A 69, (2004). DOI; quant-ph/0310137] corresponding to the six-qubit perfect state. The \\([[5,1,3]]\\) code can be obtained from this code by tracing out a qubit [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nThe \\([[5,1,3]]\\) encoding isometry tiles various holographic codes because its corresponding tensor is perfect [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nA fault-tolerant \\(T\\) gate on the five-qubit code can be obtained by concatenating with particular quantum divisible codes.\n\\([[4,2,2]]\\) can be derived from \\([[5,1,3]]\\) code using a protocol that converts \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman [Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052].\n", "_type": "ecc", "_page_id": "c_stab_5_1_3", "_href": "c/stab_5_1_3"}, "c_shor_nine": {"notes": "Shor's code is the first known quantum error correction code. ", "logical": "qubits", "code_id": "shor_nine", "physical": "qubits", "protection": "The code detects two-qubit errors or corrects an arbitrary single-qubit error.", "introduced": "[P. W. Shor, \u201cScheme for reducing decoherence in quantum computer memory\u201d, Physical Review A 52, R2493 (1995). DOI]", "description": "Nine-qubit CSS code that is the smallest such code to correct a single-qubit error. The logical state is encoded using \\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right)^{\\otimes3}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle-|111\\rangle\\right)^{\\otimes3}~.\n\\end{split}\n\\end{align} The code works by concatenating each qubit of a phase-flip with a bit-flip repetition code. Therefore, the code can correct both type of errors simultaneously.\n\nSpecifically, a state is phase-flip error-corrected by a three-qubit phase-flip repetition code, with stabilizer generators \\(X_0 X_1I_2\\) and \\(X_0I_1X_2\\) in \\(X\\) basis, where the subscript represents the qubit index. Each logical qubit is encoded using \\begin{align}\n\\label{eq:phase-flip}\n\\begin{split}\n  |\\overline{0}\\rangle &= |+_0+_1+_2\\rangle \\\\\n  |\\overline{1}\\rangle &= |-_0-_1-_2\\rangle .\n\\end{split}\n\\end{align} Then, each physical qubit used in \\(\\eqref{eq:phase-flip}\\) is further encoded in the three-qubit bit-flip repetition code, \\begin{align}\n  |\\pm _j \\rangle  = \\frac{1}{\\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\\rangle \\pm |1_{j0}1_{j1}1_{j2}\\rangle),\n\\end{align} each with bit-flip error stabilizer generators \\(Z_{j0}Z_{j1}I_{j2}\\) and \\(Z_{j0}I_{j1}Z_{j2} \\) with \\(j=0,1,2\\). Notice now the phase-flip error stabilizer generator is extended as \\(X_j = X_{j0}X_{j1}X_{j2}\\). As a result, the stabilizer generators with the qubit index flattened are \\begin{align}\n\\begin{split}\n  Z_{j0}Z_{j1}I_{j2} &\\rightarrow \\{Z_0Z_1, Z_3Z_4, Z_6Z_7\\} \\\\\n  Z_{j0}I_{j1}Z_{j2} &\\rightarrow \\{Z_0Z_2, Z_3Z_5, Z_6Z_8\\} \\\\\n  X_0 X_1I_2  &\\rightarrow  \\{X_0X_1X_2X_3X_4X_5\\}\\\\\n  X_0 I_1X_2  &\\rightarrow  \\{X_0X_1X_2X_6X_7X_8\\}.\n\\end{split}\n\\end{align} ", "name": "Shor \\([[9,1,3]]\\) code", "realizations": "Trapped-ion qubits: state preparation with 98.8(1)% and 98.5(1)% fidelity for state \\(|\\overline{0}\\rangle\\) and \\(|\\overline{1}\\rangle\\), respectively, by N. Linke group [N. H. Nguyen et al., \u201cDemonstration of Shor Encoding on a Trapped-Ion Quantum Computer\u201d, Physical Review Applied 16, (2021). DOI; 2104.01205]. Variants of the code to handle coherent noise studied and realized by K. Brown and C. Monroe groups [D. M. Debroy et al., \u201cOptimizing Stabilizer Parities for Improved Logical Qubit Memories\u201d, Physical Review Letters 127, (2021). DOI; 2105.05068].\nOptical systems: quantum teleportation of information implemented by J.-W. Pan group on maximally entangled pair of one physical and one logical qubit with fidelity rate of up to 78.6% [Y.-H. Luo et al., \u201cQuantum teleportation of physical qubits into logical code spaces\u201d, Proceedings of the National Academy of Sciences 118, (2021). DOI; 2009.06242]. All-photonic quantum repeater architecture tested on the same code [R. Zhang et al., \u201cLoss-tolerant all-photonic quantum repeater with generalized Shor code\u201d, Optica 9, 152 (2022). DOI; 2203.07979].", "short_name": "Shor", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Bit- and phase-flip circuits utilize CNOT and Hadamard gates ([M. Nakahara, \u201cQuantum Computing\u201d, [] (2008). DOI], Fig. 10.6).", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "quantum_parity", "parents_detail": "Shor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "cousins_code_id": "quantum_repetition\nquantum_concatenated\nreal_projective_plane", "cousins_detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\nShor's code is the smallest surface code defined on the projective plane [Michael H. Freedman and David A. Meyer, \u201cProjective plane and planar quantum codes\u201d. quant-ph/9810055].", "cousin_of_code_id": "lloyd_slotine", "cousin_of_detail": "The Lloyd-Slotine nine-mode code is a bosonic analogue of Shor's code.", "_type": "ecc", "_page_id": "c_shor_nine", "_href": "c/shor_nine"}, "c_stab_15_1_3": {"notes": "The \\([[15,1,3]]\\) code can be converted into the smallest known stabilizer code with a fault-tolerant logical \\(T\\) gate (i.e., the \\([[10,1,2]]\\) code) through a \"morphing procedure\" [Michael Vasmer and Aleksander Kubica, \u201cMorphing quantum codes\u201d. 2112.01446].", "logical": "qubits", "code_id": "stab_15_1_3", "physical": "qubits", "protection": "", "introduced": "", "description": "\\([[15,1,3]]\\) CSS code that is most easily thought of as a tetrahedral 3D color code. This code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center. The tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers. Each colored cell corresponds to a weight-8 \\(X\\)-check, and each face corresponds to a weight-4 \\(Z\\)-check. A logical \\(Z\\) is any weight-3 \\(Z\\)-string along an edge of the entire tetrahedron. The logical \\(X\\) is any weight-7 \\(X\\)-face of the entire tetrahedron. ", "name": "\\([[15,1,3]]\\) quantum Reed-Muller code", "realizations": "", "short_name": "\\([[15,1,3]]\\)", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "Code is often used in magic-state distillation protocols because of its transversal \\(T\\) gate [S. Bravyi and A. Kitaev, \u201cUniversal quantum computation with ideal Clifford gates and noisy ancillas\u201d, Physical Review A 71, (2005). DOI; quant-ph/0403025].", "features_magic_scaling_exponent": "Magic-state distillation scaling exponent \\( \\gamma= \\log_d (n/k)\\approx 2.46\\) [J. Haah et al., \u201cMagic state distillation with low space overhead and optimal asymptotic input count\u201d, Quantum 1, 31 (2017). DOI; 1703.07847].", "features_encoders": "", "features_rate": "", "features_transversal_gates": "A transversal logical \\(T^\\dagger\\) is implemented by applying a \\(T\\) gate on every qubit [E. Knill, R. Laflamme, and W. Zurek, \u201cThreshold Accuracy for Quantum Computation\u201d. quant-ph/9610011][J. T. Anderson, G. Duclos-Cianci, and D. Poulin, \u201cFault-Tolerant Conversion between the Steane and Reed-Muller Quantum Codes\u201d, Physical Review Letters 113, (2014). DOI; 1403.2734][E. T. Campbell, B. M. Terhal, and C. Vuillot, \u201cRoads towards fault-tolerant universal quantum computation\u201d, Nature 549, 172 (2017). DOI; 1612.07330].", "features_fault_tolerance": "Combining the Steane code and the 15-qubit Reed-Muller code through a fault-tolerant conversion can result in a universal transversal gate set that does not need magic state distillation [J. T. Anderson, G. Duclos-Cianci, and D. Poulin, \u201cFault-Tolerant Conversion between the Steane and Reed-Muller Quantum Codes\u201d, Physical Review Letters 113, (2014). DOI; 1403.2734][D.-X. Quan et al., \u201cFault-tolerant conversion between adjacent Reed\u2013Muller quantum codes based on gauge fixing\u201d, Journal of Physics A: Mathematical and Theoretical 51, 115305 (2018). DOI; 1703.03860].", "parents_code_id": "quantum_reed_muller\nquantum_triorthogonal\ncolor", "parents_detail": "The \\([[15,1,3]]\\) code is often noted as the 15-qubit quantum Reed-Muller code in the literature.\nThe \\([[15, 1, 3]]\\) code is a triorthogonal code [Sepehr Nezami and Jeongwan Haah, \u201cClassification of Small Triorthogonal Codes\u201d. 2107.09684]\nThe \\([[15,1,3]]\\) code is a 3D color code.", "_type": "ecc", "_page_id": "c_stab_15_1_3", "_href": "c/stab_15_1_3"}, "c_color": {"notes": "", "logical": "qubits", "code_id": "color", "physical": "qubits", "protection": "As with the surface code, the code distance depends on the specific kind of lattice used to define the code. More precisely, the distance depends on the homology of logical string operators [H. Bombin, \u201cAn Introduction to Topological Quantum Codes\u201d. 1311.0277].", "introduced": "[H. Bombin and M. A. Martin-Delgado, \u201cTopological Quantum Distillation\u201d, Physical Review Letters 97, (2006). DOI; quant-ph/0605138]", "description": "A family of abelian topological CSS stabilizer codes defined on a \\(D\\)-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial \\(D\\)-complex obtained as a triangulation of the interior of a \\(D\\)-simplex and (2) is \\(D+1\\)-colorable. Qubits are placed on the \\(D\\)-simplices and generators are supported on suitable simplices [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI]. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face [H. Bombin, \u201cAn Introduction to Topological Quantum Codes\u201d. 1311.0277].", "name": "Color code", "realizations": "", "short_name": "", "features_threshold": "\\(\\geq 6.25\\%\\) threshold for 2D color codes with error-free syndrome extraction, and \\(0.1\\%\\) with faulty syndrome extraction [D. S. Wang et al., \u201cGraphical algorithms and threshold error rates for the 2d colour code\u201d. 0907.1708].\n\\(0.46\\%\\) for 3D codes with clustering decoder [A. Kubica et al., \u201cThree-Dimensional Color Code Thresholds via Statistical-Mechanical Mapping\u201d, Physical Review Letters 120, (2018). DOI; 1708.07131].\n\\(1.9\\%\\) for 1D string-like logical operators and \\(27.6\\%\\) for 2D sheet-like operators for 3D codes with noise models using optimal decoding and perfect measurements [A. Kubica et al., \u201cThree-Dimensional Color Code Thresholds via Statistical-Mechanical Mapping\u201d, Physical Review Letters 120, (2018). DOI; 1708.07131].\n\\(0.31\\%\\) noise threshold error rate for gauge code using clustering decoder [B. J. Brown, N. H. Nickerson, and D. E. Browne, \u201cFault-tolerant error correction with the gauge color code\u201d, Nature Communications 7, (2016). DOI; 1503.08217].\n\\(0.143\\%\\) with depolarising circuit-level noise using perfect-matching decoder [Andrew J. Landahl and Ciaran Ryan-Anderson, \u201cQuantum computing by color-code lattice surgery\u201d. 1407.5103].\n\\(>0\\%\\) threshold with sweep decoder [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI].", "features_code_capacity_threshold": "\\(\\geq 6\\%\\) threshold with rescaling-based decoder [Pedro Parrado-Rodr\u00edguez, Manuel Rispler, and Markus M\u00fcller, \u201cRescaling decoder for 2D topological quantum color codes on 4.8.8 lattices\u201d. 2112.09584].", "features_decoders": "Projection decoder [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI].\nMatching decoder gives low logical failure rate [K. Sahay and B. J. Brown, \u201cDecoder for the Triangular Color Code by Matching on a M\u00f6bius Strip\u201d, PRX Quantum 3, (2022). DOI; 2108.11395].\nInteger-program-based decoder [Ashley M. Stephens, \u201cEfficient fault-tolerant decoding of topological color codes\u201d. 1402.3037].\nRestriction decoder [C. Chamberland et al., \u201cTriangular color codes on trivalent graphs with flag qubits\u201d, New Journal of Physics 22, 023019 (2020). DOI].\nCellular-automaton decoder for the \\(XYZ\\) color code [Jonathan F. San Miguel, Dominic J. Williamson, and Benjamin J. Brown, \u201cA cellular automaton decoder for a noise-bias tailored color code\u201d. 2203.16534].", "features_general_gates": "Magic-state distillation protocols [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI].\nNon-clifford gates can be implemented via code switching [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI].\nLattice surgery scheme for 2D layout yields lower resource overhead when compared to analogous surface code scheme [Felix Thomsen et al., \u201cLow-overhead quantum computing with the color code\u201d. 2201.07806].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "For general 2D manifolds, \\(kd^2 \\leq c(\\log k)^2 n\\) for some constant \\(c\\) [N. Delfosse, \u201cTradeoffs for reliable quantum information storage in surface codes and color codes\u201d, 2013 IEEE International Symposium on Information Theory (2013). DOI; 1301.6588], meaning that color codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\).", "features_transversal_gates": "Transversal CNOT can be implemented via braiding [A. G. Fowler, \u201cTwo-dimensional color-code quantum computation\u201d, Physical Review A 83, (2011). DOI; 0806.4827]. Universal transversal gates can be achieved in 3D color code using gauge fixing [H. Bombin, \u201cGauge Color Codes: Optimal Transversal Gates and Gauge Fixing in Topological Stabilizer Codes\u201d. 1311.0879], lattice surgery [Andrew J. Landahl and Ciaran Ryan-Anderson, \u201cQuantum computing by color-code lattice surgery\u201d. 1407.5103], or code deformation [H. Bombin, \u201cClifford gates by code deformation\u201d, New Journal of Physics 13, 043005 (2011). DOI][A. G. Fowler, \u201cTwo-dimensional color-code quantum computation\u201d, Physical Review A 83, (2011). DOI; 0806.4827].", "features_fault_tolerance": "Clifford gates can be performed fault-tolerantly on a suitable 2D lattice [H. Bombin and M. A. Martin-Delgado, \u201cTopological Quantum Distillation\u201d, Physical Review Letters 97, (2006). DOI; quant-ph/0605138].\nSyndrome measurement [Andrew J. Landahl and Ciaran Ryan-Anderson, \u201cQuantum computing by color-code lattice surgery\u201d. 1407.5103].\nSteane's ancilla-coupled measurement method [Andrew J. Landahl and Ciaran Ryan-Anderson, \u201cQuantum computing by color-code lattice surgery\u201d. 1407.5103]", "parents_code_id": "css\ntopological_abelian", "parents_detail": "\nWhen treated as ground states of the code Hamiltonian, 2D color code states on realize \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) topological order [M. Kargarian, H. Bombin, and M. A. Martin-Delgado, \u201cTopological color codes and two-body quantum lattice Hamiltonians\u201d, New Journal of Physics 12, 025018 (2010). DOI; 0906.4127], equivalent to the phase realized by two copies of the surface code [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065].", "parent_of_code_id": "steane\nstab_15_1_3", "parent_of_detail": "Steane code is the smallest 2D color code.\nThe \\([[15,1,3]]\\) code is a 3D color code.", "cousins_code_id": "surface\nquantum_triorthogonal", "cousins_detail": "Color code is equivalent to surface code in several ways [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065][Arun B. Aloshious, Arjun Nitin Bhagoji, and Pradeep Kiran Sarvepalli, \u201cOn the Local Equivalence of 2D Color Codes and Surface Codes with Applications\u201d. 1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.\nThe 3D color code is triorthogonal.", "cousin_of_code_id": "galois_topological\nhaah_cubic\nself_correct\n3d_surface\nsubsystem_color", "cousin_of_detail": "Color code has been extended to Galois qudits.\nThe color and cubic code families both include 3D codes that do not admit string-like operators.\nThe 6D color code is a self-correcting quantum memory [H. Bombin et al., \u201cSelf-Correcting Quantum Computers\u201d. 0907.5228].\nColor code is equivalent to surface code in several ways [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065][Arun B. Aloshious, Arjun Nitin Bhagoji, and Pradeep Kiran Sarvepalli, \u201cOn the Local Equivalence of 2D Color Codes and Surface Codes with Applications\u201d. 1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.\n", "_type": "ecc", "_page_id": "c_color", "_href": "c/color"}, "c_haah_cubic": {"notes": "", "logical": "qubits", "code_id": "haah_cubic", "physical": "qubits", "protection": "Cubic codes protect against simultaneous independent Pauli errors on different sites (not qubits, since there can be 2 qubits per site). Codes 0-4 are known to have distance \\(d \\ge L\\), meaning they can achieve macroscopic code distance as \\(L\\to\\infty\\).", "introduced": "[J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962]", "description": "Class of stabilizer codes on a length-\\(L\\) cubic lattice with one or two qubits per site. We also require that the stabilizer group \\(\\mathsf{S}\\) is translation invariant and generated by two types of operators with support on a cube. In the non-CSS case, these two are related by spatial inversion. For CSS codes, we require that the product of all corner operators is the identity. We lastly require that there are no non-trival ''string operators'', meaning that single-site operators are a phase, and any period one logical operator \\(l \\in \\mathsf{S}^{\\perp}\\) is just a phase. Haah showed in his original construction that there is exactly one non-CSS code of this form, and 17 CSS codes [J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962]. The non-CSS code is labeled code 0, and the rest are numbered from 1 - 17. Codes 1-4, 7, 8, and 10 do not have string logical operators [J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962][A. Dua et al., \u201cSorting topological stabilizer models in three dimensions\u201d, Physical Review B 100, (2019). DOI; 1908.08049].\n\nStraightforward generalizations of the above codes exist to modular qudits, oscillators, and rotors [J. Haah, Two generalizations of the cubic code model, KITP Conference: Frontiers of Quantum Information Physics, UCSB, Santa Barbara, CA.][V. V. Albert, S. Pascazio, and M. H. Devoret, \u201cGeneral phase spaces: from discrete variables to rotor and continuum limits\u201d, Journal of Physics A: Mathematical and Theoretical 50, 504002 (2017). DOI; 1709.04460]. ", "name": "Haah cubic code", "realizations": "", "short_name": "", "features_threshold": "The encoding rate depends on the code implemented, but code 0 has been shown to have \\(k \\ge L\\) (on a periodic finite cubic lattice of side length \\(L\\). In general we expect the number of logical bits to scale as \\(k \\sim L\\).", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubit_stabilizer\nfracton", "parents_detail": "\nHaah cubic codes are the first examples of Type-II fracton phases [M. Pretko, X. Chen, and Y. You, \u201cFracton phases of matter\u201d, International Journal of Modern Physics A 35, 2030003 (2020). DOI; 2001.01722].", "cousins_code_id": "color\nsurface", "cousins_detail": "The color and cubic code families both include 3D codes that do not admit string-like operators.\nThe energy of any partial implementation of code 1 is proportional to the boundary length similar to the 4D toric code, which can potentially surpress the effects of thermal errors, but it is currently an open problem.", "cousin_of_code_id": "fibonacci_model\nlifted_product\nself_correct", "cousin_of_detail": "The Fibonacci code is designed to mimic the fractal properties of (quantum) Haah cubic code so that studying the former can help us toward the development of an efficient algorithm for the latter.\nA lifted product code for the ring \\(R=\\mathbb{F}_2[x,y,z]/(x^L-1,y^L-1,z^L-1)\\) is the cubic code.\nCubic code 1 is partially self-correcting with a logarithmic energy barrier [S. Bravyi and J. Haah, \u201cQuantum Self-Correction in the 3D Cubic Code Model\u201d, Physical Review Letters 111, (2013). DOI; 1112.3252].", "_type": "ecc", "_page_id": "c_haah_cubic", "_href": "c/haah_cubic"}, "c_matching": {"notes": "", "logical": "qubits", "code_id": "matching", "physical": "qubits", "protection": "", "introduced": "[J. R. Wootton, \u201cA family of stabilizer codes for $D({{\\mathbb{Z}}_{2}})$ anyons and Majorana modes\u201d, Journal of Physics A: Mathematical and Theoretical 48, 215302 (2015). DOI; 1501.07779]", "description": "Stub.", "name": "Matching code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubit_stabilizer\ntopological_abelian", "parents_detail": "\nMatching codes were inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438], which realizes \\(\\mathbb{Z}_2\\) topological order.", "parent_of_code_id": "xyz_hexagonal", "parent_of_detail": "", "cousin_of_code_id": "honeycomb", "cousin_of_detail": "Matching and honeycomb codes are both inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438].", "_type": "ecc", "_page_id": "c_matching", "_href": "c/matching"}, "c_double_semion": {"notes": "", "logical": "qudits", "code_id": "double_semion", "physical": "qubits", "protection": "", "introduced": "[M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617]", "description": "Stub.", "name": "Double-semion code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudit_stabilizer\ntopological_abelian", "parents_detail": "Double-semion code can be realized as a modular-qudit stabilizer code with \\(q=4\\) [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394].\nWhen treated as ground states of the code Hamiltonian, the code states realize double-semion topological order, a topological phase of matter that also exists in twisted \\(\\mathbb{Z}_2\\) gauge theory [R. Dijkgraaf and E. Witten, \u201cTopological gauge theories and group cohomology\u201d, Communications in Mathematical Physics 129, 393 (1990). DOI].", "cousins_code_id": "surface", "cousins_detail": "There is a logical basis for the toric and double-semion codes where each codeword is a superposition of states corresponding to all noncontractible loops of a particular homotopy type. The superposition is equal for the toric code, whereas some loops appear with a \\(-1\\) coefficient for the double semion.", "_type": "ecc", "_page_id": "c_double_semion", "_href": "c/double_semion"}, "c_rbh": {"notes": "", "logical": "", "code_id": "rbh", "physical": "", "protection": "Code exhibiting symmetry-protected self-correction. The energy barrier for symmetry-preserving exhitations outside of the code space grows linearly with the lattice width. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the lattice width. ", "introduced": "[S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]", "description": "Stub. (see Sec. III E of [S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]) ", "name": "Raussendorf-Bravyi-Harrington (RBH) code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "cousins_code_id": "symmetry_protected_self_correct\nsubsystem_color\nsurface", "cousins_detail": "\nThe RBH code on a certain lattice is dual to the gauge color code.\nWithout symmetry protection, one of 2D boundaries of the cubic RBH code is effectively a 2D toric code.", "_type": "ecc", "_page_id": "c_rbh", "_href": "c/rbh"}, "c_xyz_hexagonal": {"notes": "Isolated \\(X\\), \\(Y\\), and \\(Z\\) errors lead to unidirectional pairs of plaquette defects along the three directions of the triangular lattice.", "logical": "qubits", "code_id": "xyz_hexagonal", "physical": "qubits", "protection": "As a stabilizer code with boundaries, protects a single qubit with parameters \\([[2 d^2, 1, d]]\\).", "introduced": "[James R. Wootton, \u201cHexagonal matching codes with 2-body measurements\u201d. 2109.13308][B. Srivastava, A. Frisk Kockum, and M. Granath, \u201cThe XYZ<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\"><mml:msup><mml:mi /><mml:mn>2</mml:mn></mml:msup></mml:math> hexagonal stabilizer code\u201d, Quantum 6, 698 (2022). DOI; 2112.06036]", "description": "An instance of the matching code based on the Kitaev honeycomb model. It is described on a hexagonal lattice with \\(XYZXYZ\\) stabilizers on each hexagonal plaquette. Each vertical pair of qubits has an \\(XX\\), \\(YY\\), or \\(ZZ\\) link stabilizer depending on the orientation of the plaquette stabilizers.", "name": "XYZ\\(^2\\) hexagonal stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "\\(50\\%\\) for pure \\(Z\\), \\(Y\\), or \\(Z\\) noise under maximum-likelihood decoding.\nThreshold matches that of the \\(XZZX\\) code for various bias levels of \\(X\\), \\(Y\\), or \\(Z\\) biased noise under maximum-likelihood decoding.\n\\(\\sim 18\\%\\) for depolarizing noise under maximum-likelihood decoding.", "features_decoders": "Maximum-likelihood decoding using the EWD decoder [K. Hammar et al., \u201cError-rate-agnostic decoding of topological stabilizer codes\u201d, Physical Review A 105, (2022). DOI; 2112.01977].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "matching", "parents_detail": "", "_type": "ecc", "_page_id": "c_xyz_hexagonal", "_href": "c/xyz_hexagonal"}, "c_fractal_surface": {"notes": "", "logical": "qubits", "code_id": "fractal_surface", "physical": "qubits", "protection": "", "introduced": "[Guanyu Zhu, Tomas Jochym-O'Connor, and Arpit Dua, \u201cTopological Order, Quantum Codes and Quantum Computation on Fractal Geometries\u201d. 2108.00018][Arpit Dua, Tomas Jochym-O'Connor, and Guanyu Zhu, \u201cQuantum error correction with fractal topological codes\u201d. 2201.03568]", "description": "Kitaev surface code on a fractal geometry, which is obtained by removing qubits from the surface code on a cubic lattice. Stub.", "name": "Fractal surface code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "surface", "parents_detail": "", "cousins_code_id": "higher_dimensional_surface", "cousins_detail": "Fractal surface codes are obtained by removing qubits from the surface code on a cubic lattice.", "_type": "ecc", "_page_id": "c_fractal_surface", "_href": "c/fractal_surface"}, "c_surface-17": {"notes": "Subject of various numerical studies examining the system for noises and architectures specific to trapped ions [Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747][C. J. Trout et al., \u201cSimulating the performance of a distance-3 surface code in a linear ion trap\u201d, New Journal of Physics 20, 043038 (2018). DOI; 1710.01378][Dripto M. Debroy et al., \u201cLogical Performance of 9 Qubit Compass Codes in Ion Traps with Crosstalk Errors\u201d. 1910.08495] and superconducting circuits [R. Versluis et al., \u201cScalable Quantum Circuit and Control for a Superconducting Surface Code\u201d, Physical Review Applied 8, (2017). DOI; 1612.08208][T. E. O\u2019Brien, B. Tarasinski, and L. DiCarlo, \u201cDensity-matrix simulation of small surface codes under current and projected experimental noise\u201d, npj Quantum Information 3, (2017). DOI; 1703.04136][B. M. Varbanov et al., \u201cLeakage detection for a transmon-based surface code\u201d, npj Quantum Information 6, (2020). DOI; 2002.07119]", "logical": "qubits", "code_id": "surface-17", "physical": "qubits", "protection": "Independent correction of single-qubit \\(X\\) and \\(Z\\) errors. Correction for some two-qubit \\(X\\) and \\(Z\\) errors.", "introduced": "[Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747]", "description": "A \\([[9,1,3]]\\) rotated surface code named for the sum of its 9 data qubits and 8 syndrome qubits. It uses the smallest number of qubits to perform error correction on a surface code with parallel syndrome extraction.", "name": "Surface-17 code", "realizations": "Implemented at ETH Zurich by the Wallraff group [Sebastian Krinner et al., \u201cRealizing Repeated Quantum Error Correction in a Distance-Three Surface Code\u201d. 2112.03708] and on the Zuchongzhi 2.1 superconducting quantum processor [Youwei Zhao et al., \u201cRealization of an Error-Correcting Surface Code with Superconducting Qubits\u201d. 2112.13505]. Both experimental error rates are above the pseudothreshold for this code relative to a single qubit. See Physics viewpoint for a summary [L. Frunzio and S. Singh, \u201cError-Correcting Surface Codes Get Experimental Vetting\u201d, Physics 15, (2022). DOI]. ", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Lookup table [Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "Pauli gates, CNOT gate, and \\(H\\) gate (with relabeling).", "features_fault_tolerance": "", "parents_code_id": "rotated_surface", "parents_detail": "", "_type": "ecc", "_page_id": "c_surface-17", "_href": "c/surface-17"}, "c_rotated_surface": {"notes": "", "logical": "qubits", "code_id": "rotated_surface", "physical": "qubits", "protection": "The \\([[L^2,1,L]]\\) variant of this family includes the \\([[9,1,3]]\\) surface-17 code, named as such because 8 ancilla qubits are used for check operator measurements alongside the 9 physical qubits.", "introduced": "[H. Bombin and M. A. Martin-Delgado, \u201cOptimal resources for topological two-dimensional stabilizer codes: Comparative study\u201d, Physical Review A 76, (2007). DOI; quant-ph/0703272][Jonas T. Anderson, \u201cHomological Stabilizer Codes\u201d. 1107.3502][A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928][Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747]", "description": "Also called a checkerboard code. CSS variant of the surface code defined on a square lattice that has been rotated 45 degrees such that qubits are on vertices, and both \\(X\\)- and \\(Z\\)-type check operators occupy plaquettes in an alternating checkerboard pattern.", "name": "Rotated surface code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Local neural-network using 3D convolutions, combined with a separate global decoder [Christopher Chamberland et al., \u201cTechniques for combining fast local decoders with global decoders under circuit-level noise\u201d. 2208.01178].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "A particular choice of CNOT gates during syndrome extraction is required to be fault-tolerant to syndrome qubit errors [Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747].", "parents_code_id": "clifford-deformed_surface\nquantum_tanner", "parents_detail": "Rotated surface codes can be obtained from surface codes via a constant-depth Clifford circuit.\nSpecializing the quantum Tanner construction to the surface code yields the rotated surface code [Nikolas P. Breuckmann, private communication, 2022][Anthony Leverrier, Mapping the toric code to the rotated toric code, 2022.].", "parent_of_code_id": "surface-17", "parent_of_detail": "", "cousins_code_id": "hypergraph_product\nheavy_hex", "cousins_detail": "Rotated code can be obtained from hypergraph product of two cyclic binary cyclic codes with palindromic generator polynomial ([A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928], Ex. 7).\nA rotated surface code can be mapped onto a heavy square lattice, resulting in a code similar to the heavy-hexagon code [C. Chamberland et al., \u201cTopological and Subsystem Codes on Low-Degree Graphs with Flag Qubits\u201d, Physical Review X 10, (2020). DOI; 1907.09528].", "cousin_of_code_id": "xzzx\nstab_4_2_2", "cousin_of_detail": "XZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).\nVarious \\([[4,1,2]]\\) subcodes are small rotated planar codes [A. Erhard et al., \u201cEntangling logical qubits with lattice surgery\u201d, Nature 589, 220 (2021). DOI; 2006.03071][C. K. Andersen et al., \u201cRepeated quantum error detection in a surface code\u201d, Nature Physics 16, 875 (2020). DOI; 1912.09410][Zijun Chen et al., \u201cExponential suppression of bit or phase flip errors with repetitive error correction\u201d. 2102.06132][J. F. Marques et al., \u201cLogical-qubit operations in an error-detecting surface code\u201d, Nature Physics 18, 80 (2021). DOI; 2102.13071].", "_type": "ecc", "_page_id": "c_rotated_surface", "_href": "c/rotated_surface"}, "c_xzzx": {"notes": "A single \\(X\\) or \\(Z\\) error gives rise to two nearby defects, which can be viewed as endpoints of a string. That way, multiple \\(Z\\) errors can be decomposed into a combination of diagonal strings.\nOriginally formulated as an example of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [X.-G. Wen, \u201cQuantum Orders in an Exact Soluble Model\u201d, Physical Review Letters 90, (2003). DOI; quant-ph/0205004].", "logical": "qubits", "code_id": "xzzx", "physical": "qubits", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "introduced": "[X.-G. Wen, \u201cQuantum Orders in an Exact Soluble Model\u201d, Physical Review Letters 90, (2003). DOI; quant-ph/0205004][J. P. Bonilla Ataides et al., \u201cThe XZZX surface code\u201d, Nature Communications 12, (2021). DOI; 2009.07851]", "description": "Non-CSS variant of the rotated surface code whose generators are \\(XZXZ\\) Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).", "name": "XZZX surface code", "realizations": "Distance-five 25-qubit code implemented on a superconducting quantum processor by Google Quantum AI [Rajeev Acharya et al., \u201cSuppressing quantum errors by scaling a surface code logical qubit\u201d. 2207.06431]. This code outperformed the average of several instances of the smaller distance-three 9-qubit \\(XZZX\\) variant of the surface-17 code realized on the same device, both in terms of logical error probability over 25 cycles and in terms of logical error per cycle. This increase in error-correcting capabilities while using more physical qubits supports the notion of an error threshold.", "short_name": "", "features_threshold": "\\(\\sim 4.5\\%\\) using minimum-weight perfect matching decoder for depolarizing noise (bias \\(\\eta=0.5\\)); \\(\\sim 10\\%\\) for infinite \\(Z\\) bias.", "features_code_capacity_threshold": "\\(50\\%\\) threshold for noise infinitely biased towards \\(X\\) or \\(Y\\) or \\(Z\\) errors using a maximum-likelihood decoder.\nFor large but finite \\(X\\)- or \\(Z\\)-biased noise, the code's thresholds exceed the zero-rate hashing bound. The difference of the threshold from the hashing bound exceeds \\(2.9\\%\\) at a \\(Z\\) or \\(X\\) bias of 300.\n\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder.\n\\(0.817\\%\\) and \\(0.940\\%\\) with minimum-weight perfect matching and belief-matching decoder, respectively, for biased circuit-level noise [Oscar Higgott et al., \u201cFragile boundaries of tailored surface codes\u201d. 2203.04948].\n\\(4.15\\%\\) when \\(98\\%\\) of depolarizing errors are coverted into erasure errors with union-find decoder on a planar code, vs. \\(0.937\\%\\) for pure depolarizing noise. In Rydberg atomic devices, erasure conversion during gates is promising because the dominant source of noise is spontaneous decay into detectable energy levels outside of the computational subspace [Yue Wu et al., \u201cErasure conversion for fault-tolerant quantum computing in alkaline earth Rydberg atom arrays\u201d. 2201.03540].", "features_decoders": "Minimum-weight perfect matching decoder, which can be used for \\(X\\) and \\(Z\\) noise. For \\(Y\\) noise, a variant of the matching decoder could be used like it is used for the XY code in Ref. [D. K. Tuckett et al., \u201cFault-Tolerant Thresholds for the Surface Code in Excess of \n<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mn>5</mml:mn><mml:mo>%</mml:mo></mml:math>\n Under Biased Noise\u201d, Physical Review Letters 124, (2020). DOI; 1907.02554].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "clifford-deformed_surface", "parents_detail": "XZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).", "cousins_code_id": "rotated_surface\nfracton\ntopological_abelian", "cousins_detail": "XZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).\nSubsystem symmetries play a role in finite-bias decoders for both codes [B. J. Brown and D. J. Williamson, \u201cParallelized quantum error correction with fracton topological codes\u201d, Physical Review Research 2, (2020). DOI; 1901.08061].\nExample of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [X.-G. Wen, \u201cQuantum Orders in an Exact Soluble Model\u201d, Physical Review Letters 90, (2003). DOI; quant-ph/0205004].", "_type": "ecc", "_page_id": "c_xzzx", "_href": "c/xzzx"}, "c_freedman_meyer_luo": {"notes": "See thesis by Fetaya for pedagogical exposition [Ethan Fetaya, \u201cHomological Error Correcting Codes and Systolic Geometry\u201d. 1108.2886].", "logical": "qubits", "code_id": "freedman_meyer_luo", "physical": "qubits", "protection": "Four-dimensional manifolds with weak systolic freedom yield \\([[n,2,\\Omega(\\sqrt{n \\sqrt{\\log n}})]]\\) surface codes.", "introduced": "[\u201cZ2-systolic freedom and quantum codes\u201d, Mathematics of Quantum Computation 303 (2002). DOI]", "description": "Hyperbolic surface code constructed using cellulation of a Riemannian Manifold \\(M\\) exhibiting systolic freedom [M. H. Freedman, \u201c<b>Z</b><sub>2</sub>\u2013Systolic-Freedom\u201d, Proceedings of the Kirbyfest (1999). DOI]. Codes derived from such manifolds can achieve distances scaling better than \\(\\sqrt{n}\\), something that is impossible using closed 2D surfaces or 2D surfaces with boundaries [E. Fetaya, \u201cBounding the distance of quantum surface codes\u201d, Journal of Mathematical Physics 53, 062202 (2012). DOI]. Improved codes are obtained by studying a weak family of Riemann metrics on closed 4-dimensional manifolds \\(S^2\\otimes S^2\\) with the \\(Z_2\\)-homology. ", "name": "Freedman-Meyer-Luo code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Codes held a 20-year record the best lower bound on asymptotic scaling of the minimum code distance, \\(d=\\Omega(\\sqrt{n \\sqrt{\\log n}})\\), broken by Ramanujan tensor-product codes.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hyperbolic_surface", "parents_detail": "", "cousin_of_code_id": "ramanujan_tensor_product", "cousin_of_detail": "Ramanujan codes broke 20-year record on minimum code distance set by Freedman-Meyer-Luo codes.", "_type": "ecc", "_page_id": "c_freedman_meyer_luo", "_href": "c/freedman_meyer_luo"}, "c_xysurface": {"notes": "", "logical": "qubits", "code_id": "xysurface", "physical": "qubits", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "introduced": "[D. K. Tuckett, S. D. Bartlett, and S. T. Flammia, \u201cUltrahigh Error Threshold for Surface Codes with Biased Noise\u201d, Physical Review Letters 120, (2018). DOI; 1708.08474]", "description": "Non-CSS derivative of the surface code whose generators are \\(XXXX\\) and \\(YYYY\\), obtained by mapping \\(Z \\to Y\\) in the surface code.", "name": "XY surface code", "realizations": "", "short_name": "", "features_threshold": "\\(6.32(3)\\%\\) for infinite \\(Z\\) bias, and thresholds of \\(\\sim 5\\%\\) for \\(Z\\) bias around \\(\\eta = 100\\) using a variant of the minimum-weight perfect matching decoder [D. K. Tuckett et al., \u201cFault-Tolerant Thresholds for the Surface Code in Excess of \n<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mn>5</mml:mn><mml:mo>%</mml:mo></mml:math>\n Under Biased Noise\u201d, Physical Review Letters 124, (2020). DOI; 1907.02554].", "features_code_capacity_threshold": "\\(50\\%\\) at infinite \\(Z\\) bias with maximum-likelihood decoder [D. K. Tuckett et al., \u201cTailoring Surface Codes for Highly Biased Noise\u201d, Physical Review X 9, (2019). DOI; 1812.08186].\n\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder [D. K. Tuckett et al., \u201cTailoring Surface Codes for Highly Biased Noise\u201d, Physical Review X 9, (2019). DOI; 1812.08186].", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "clifford-deformed_surface", "parents_detail": "XY code is obtained from the surface code by applying \\(H\\sqrt{Z}H\\) to all qubits, thereby exchaning \\(Z\\leftrightarrow Y\\).", "_type": "ecc", "_page_id": "c_xysurface", "_href": "c/xysurface"}, "c_real_projective_plane": {"notes": "", "logical": "qubits", "code_id": "real_projective_plane", "physical": "qubits", "protection": "If \\(\\mathcal{C}\\) is a cellulation of \\(\\mathbb{R}P^2\\), then the bit-flip distance \\(d_X\\) is the shortest cycle in \\(\\mathcal{C}\\), and the phase-flip distance \\(d_Z\\) is the shortest cycle in the dual cellulation \\(\\mathcal{C}^*\\).", "introduced": "[Michael H. Freedman and David A. Meyer, \u201cProjective plane and planar quantum codes\u201d. quant-ph/9810055]", "description": "A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold \\(\\mathbb{R}P^2\\) (in contrast to a genus-\\(g\\) surface). Whereas genus-\\(g\\) surface codes require \\(2g\\) logical qubits, qubit codes on \\(\\mathbb{R}P^2\\) are made from a single logical qubit.", "name": "Projective-plane surface code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "The rate is \\(1/n\\), where \\(n\\) is the number of edges of the particular cellulation.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "surface", "parents_detail": "", "cousin_of_code_id": "shor_nine", "cousin_of_detail": "Shor's code is the smallest surface code defined on the projective plane [Michael H. Freedman and David A. Meyer, \u201cProjective plane and planar quantum codes\u201d. quant-ph/9810055].", "_type": "ecc", "_page_id": "c_real_projective_plane", "_href": "c/real_projective_plane"}, "c_golden_code": {"notes": "", "logical": "qubits", "code_id": "golden_code", "physical": "qubits", "protection": "Nonvanishing rate and asymptotic distance lower bounded by \\(n^0.1\\).", "introduced": "[\u201c[]\u201d, Quantum Information and Computation 19, (2019). DOI; 1712.08578]", "description": "Variant of the Guth-Lubotzky hyperbolic surface code that uses regular tessellations for 4-dimensional hyperbolic space. ", "name": "Golden code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "four_dimensional_hyperbolic", "parents_detail": "", "_type": "ecc", "_page_id": "c_golden_code", "_href": "c/golden_code"}, "c_four_dimensional_hyperbolic": {"notes": "", "logical": "qubits", "code_id": "four_dimensional_hyperbolic", "physical": "qubits", "protection": "Protection stems from the relationship between properties of manifolds and CSS codes derived from their cellulation. The number of physical \\(k\\) qubits and distance \\(d\\) of the code will scale as \\(\\Omega(n)\\) and \\(\\Omega(n^\\epsilon)\\), respectively.", "introduced": "[L. Guth and A. Lubotzky, \u201cQuantum error correcting codes and 4-dimensional arithmetic hyperbolic manifolds\u201d, Journal of Mathematical Physics 55, 082202 (2014). DOI; 1310.5555]", "description": "Hyperbolic surface code based on cellulations of certain four-dimensional manifolds. The manifolds are shown to have good homology and systolic properties for the purposes of code construction, with corresponding codes exhibiting linear rate.\n\nGuth and Lubotzky [L. Guth and A. Lubotzky, \u201cQuantum error correcting codes and 4-dimensional arithmetic hyperbolic manifolds\u201d, Journal of Mathematical Physics 55, 082202 (2014). DOI; 1310.5555] show that there exists \\(\\epsilon\\), a four-dimensional hyperbolic manifold \\(M\\), and a sequence of manifolds \\(M_i\\) such that each \\(M_i\\) is a finite sheeted covering of \\(M\\), and the four-dimensional volumes of the manifolds \\(\\text{Vol}_4(M_i)\\) of the sequence tend to infinity. Also, the dimension of the second homology and size of systoles are bounded by \\(H_2(M_i, Z_2) \\geq \\frac{\\text{Vol}_4(M_i)}{100}\\) and \\(\\text{Sys}_2(M_i) \\geq \\text{Vol}_4(M_i)^\\epsilon\\), respectively.\n\nThen given any cellulation of \\(M\\), it can naturally be extended to cellulations for each of the manifolds \\(M_i\\) and used to define CSS codes via the homological construction by choosing the size three chain complex consisting of the \\(3,2\\) and \\(1\\)-cells of the cellulations.\n\nFor dense cellulations (i.e. large \\(n\\)) the number of physical qubits for these codes will scale with the volume of the manifolds. Therefore, bounds on the dimension of the second homology and size of systoles are achieved in terms of \\(n\\) for large \\(n\\).", "name": "Guth-Lubotzky code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hyperbolic_surface", "parents_detail": "", "parent_of_code_id": "golden_code", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_four_dimensional_hyperbolic", "_href": "c/four_dimensional_hyperbolic"}, "c_3d_surface": {"notes": "", "logical": "qubits", "code_id": "3d_surface", "physical": "qubits", "protection": "", "introduced": "[K. P. Michnicki, \u201c3D Topological Quantum Memory with a Power-Law Energy Barrier\u201d, Physical Review Letters 113, (2014). DOI; 1406.4227]", "description": "A variant of Kitaev's surface code on a 3D lattice.", "name": "Solid code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "higher_dimensional_surface", "parents_detail": "", "cousins_code_id": "color", "cousins_detail": "Color code is equivalent to surface code in several ways [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065][Arun B. Aloshious, Arjun Nitin Bhagoji, and Pradeep Kiran Sarvepalli, \u201cOn the Local Equivalence of 2D Color Codes and Surface Codes with Applications\u201d. 1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.", "cousin_of_code_id": "self_correct", "cousin_of_detail": "The 3D welded solid code is partially self-correcting with a power-law energy barrier [K. P. Michnicki, \u201c3D Topological Quantum Memory with a Power-Law Energy Barrier\u201d, Physical Review Letters 113, (2014). DOI; 1406.4227].", "_type": "ecc", "_page_id": "c_3d_surface", "_href": "c/3d_surface"}, "c_hyperbolic_surface": {"notes": "", "logical": "qubits", "code_id": "hyperbolic_surface", "physical": "qubits", "protection": "Constructions (see code children below) have yielded distances scaling favorably with the number of qubits. The use of hyperbolic surfaces allows one to circumvent bounds on surface code parameters that are valid for surfaces with bounded geometry.", "introduced": "", "description": "An extension of the Kitaev surface code construction to hyperbolic manifolds in dimension two or greater. Given a cellulation of a manifold, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers are associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\(i+1\\)-faces. ", "name": "Hyperbolic surface code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "surface", "parents_detail": "", "parent_of_code_id": "freedman_meyer_luo\nfour_dimensional_hyperbolic\ntwo_dimensional_hyperbolic_surface", "parent_of_detail": "\n\n", "cousins_code_id": "holographic", "cousins_detail": "Both holographic and hyperbolic surface codes utilize tesselations of hyperbolic surfaces. Encodings for the former are hyperbolically tiled tensor networks, while the latter is defined on hyperbolically tiled physical-qubit lattices.", "_type": "ecc", "_page_id": "c_hyperbolic_surface", "_href": "c/hyperbolic_surface"}, "c_two_dimensional_hyperbolic_surface": {"notes": "See Sec III A of Ref. [N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309] for a description of this code.\nConnection to percolation theory as shown in [Nicolas Delfosse and Gilles Z\u00e9mor, \u201cUpper Bounds on the Rate of Low Density Stabilizer Codes for the Quantum Erasure Channel\u201d. 1205.7036].", "logical": "qubits", "code_id": "two_dimensional_hyperbolic_surface", "physical": "qubits", "protection": "Protects against Pauli errors with distance \\( d \\propto \\log(n) \\). Code parameters are \\( [[n, (1-2/r - 2/s)  n + 2, O(\\log n) ]] \\)", "introduced": "[N. P. Breuckmann and B. M. Terhal, \u201cConstructions and Noise Threshold of Hyperbolic Surface Codes\u201d, IEEE Transactions on Information Theory 62, 3731 (2016). DOI; 1506.04029]", "description": "Hyperbolic surface codes based on a tessellation of a closed 2D manifold with a hyperbolic geometry (i.e., non-Euclidean geometry, e.g., saddle surfaces when defined on a 2D plane).\n\nFor a tessellation involving regular polygons with \\( r \\) sides and \\( s \\) polygons meeting at each edge, the number of logical qubits is given by \\( k = (1-2/r - 2/s) n + 2 \\). Some possible tilings are \\( {r,s}: {7,3}, {5,4} \\). The weight of the stabilizer generators are dependent on the tiling, with \\({5,4}\\) having lower weight than \\({7,3}\\). ", "name": "Two-dimensional hyperbolic surface code", "realizations": "", "short_name": "", "features_threshold": "1\\(\\%\\) - 5\\(\\%\\) for a \\({5,4}\\) tiling under minimum-weight decoding [A. A. Kovalev and L. P. Pryadko, \u201cFault tolerance of quantum low-density parity check codes with sublinear distance scaling\u201d, Physical Review A 87, (2013). DOI; 1208.2317]. For larger tilings, the lower bound on the distance decreases, suggesting the threshold will also decrease.", "features_code_capacity_threshold": "", "features_decoders": "Due to the symmetries of hyperbolic surface codes, optimal measurement schedules of the stabilizers can be found [O. Higgott and N. P. Breuckmann, \u201cSubsystem Codes with High Thresholds by Gauge Fixing and Reduced Qubit Overhead\u201d, Physical Review X 11, (2021). DOI; 2010.09626].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Two-dimensional hyperbolic surface codes have an asymptotically constant encoding rate \\( k/n \\) with a distance scaling logarithmically with \\( n\\) when the surface is closed. The encoding rate depends on the tiling \\( {r,s} \\) and is given by \\( k/n = (1-2/r - 2/s) + 2/n \\), which approaches a constant value as the number of physical qubits grows. The weight of the stabilizers is \\( r \\) for \\( Z \\)-checks and \\( s \\) for \\( X \\)-checks. For open boundary conditions, the code reduces to constant distnace.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hyperbolic_surface", "parents_detail": "", "_type": "ecc", "_page_id": "c_two_dimensional_hyperbolic_surface", "_href": "c/two_dimensional_hyperbolic_surface"}, "c_higher_dimensional_surface": {"notes": "", "logical": "qubits", "code_id": "higher_dimensional_surface", "physical": "qubits", "protection": "", "introduced": "[E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143]", "description": "A family of Kitaev surface codes on planar or toric surfaces of dimension greater than two. Stub.", "name": "Higher-dimensional surface code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "surface", "parents_detail": "", "parent_of_code_id": "3d_surface", "parent_of_detail": "", "cousin_of_code_id": "fractal_surface\nself_correct", "cousin_of_detail": "Fractal surface codes are obtained by removing qubits from the surface code on a cubic lattice.\nThe 4D toric code is a self-correcting quantum memory [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][R. Alicki et al., \u201cOn thermal stability of topological qubit in Kitaev's 4D model\u201d. 0811.0033].", "_type": "ecc", "_page_id": "c_higher_dimensional_surface", "_href": "c/higher_dimensional_surface"}, "c_clifford-deformed_surface": {"notes": "", "logical": "qubits", "code_id": "clifford-deformed_surface", "physical": "qubits", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "introduced": "[Arpit Dua et al., \u201cClifford-deformed Surface Codes\u201d. 2201.07802]", "description": "A generally non-CSS derivative of the surface code defined by applying a constant-depth Clifford circuit to the original (CSS) surface code. Unlike the surface code, CDSCs include codes whose thresholds and subthreshold performance are enhanced under noise biased towards dephasing. Examples of CDSCs include the XY code, XZZX code, and random CDSCs.", "name": "Clifford-deformed surface code (CDSC)", "realizations": "", "short_name": "CDSC", "features_threshold": "", "features_code_capacity_threshold": "A class of random CDSCs, parametrized by the probabilities \\(\\Pi_{XZ},~ \\Pi_{YZ}\\) of \\(X\\leftrightarrow Z\\) and \\(Y\\leftrightarrow Z\\) Pauli permutations, respectively, has \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.\nCertain translation-invariant CDSCs such as the XY code and the XZZX code also have \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.\nXZZX code and the \\((0.5,\\Pi_{YZ})\\) random CDSCs have a \\(50\\%\\) code capacity threshold for noise infinitely biased towards either Pauli-\\(X\\), \\(Y\\), or \\(Z\\) errors.", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "In order to leverage the benefits of CDSCs into practical universal computation, we have to implement syndrome measurement circuits and fault-tolerant logical gates in a bias-preserving way.", "parents_code_id": "qubit_stabilizer\ntopological_abelian", "parents_detail": "\nLocal deformations of the surface code preserve its \\(\\mathbb{Z}_2\\) topological order.", "parent_of_code_id": "surface\nrotated_surface\nxysurface\nxzzx", "parent_of_detail": "CDSC codes are deformations of the surface code via constant-depth Clifford circuits that may not be CSS.\nRotated surface codes can be obtained from surface codes via a constant-depth Clifford circuit.\nXY code is obtained from the surface code by applying \\(H\\sqrt{Z}H\\) to all qubits, thereby exchaning \\(Z\\leftrightarrow Y\\).\nXZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).", "cousins_code_id": "dynamic_gen\nquantum_random", "cousins_detail": "To create CDSCs, a dynamical process is applied on top of the surface code.\nMany useful CDSCs are constructed using random Clifford circuits.", "_type": "ecc", "_page_id": "c_clifford-deformed_surface", "_href": "c/clifford-deformed_surface"}, "c_surface": {"notes": "Surfmap framework provides a way to stitch the surface code to various superconducting-circuit geometries by assigning each superconducting qubit to be either a physical or ancilla qubit, designing stabilizer measurement circuits, and scheduling stabilizer measurements [Anbang Wu et al., \u201cMapping Surface Code to Superconducting Quantum Processors\u201d. 2111.13729].\n2D and 3D surface code visualization tool. \nTutorials from error-correction perspective by J. Haah and condensed-matter perspective by M. Levin and C. Nayak. ", "logical": "qubits", "code_id": "surface", "physical": "qubits", "protection": "Toric code on an \\(L\\times L\\) torus is a \\([[2L^2,2,L]]\\) CSS code, and there exists a planar code with \\([[L^2,1,L]]\\) [C. Horsman et al., \u201cSurface code quantum computing by lattice surgery\u201d, New Journal of Physics 14, 123011 (2012). DOI; 1111.4022]. More generally, the code distance is related to the homology of the cellulation [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143]. ", "introduced": "[A. Y. Kitaev, \u201cQuantum computations: algorithms and error correction\u201d, Russian Mathematical Surveys 52, 1191 (1997). DOI][A. Y. Kitaev, \u201cQuantum Error Correction with Imperfect Gates\u201d, Quantum Communication, Computing, and Measurement 181 (1997). DOI][A. Y. Kitaev, \u201cFault-tolerant quantum computation by anyons\u201d, Annals of Physics 303, 2 (2003). DOI; quant-ph/9707021] ", "description": "A family of abelian topological CSS stabilizer codes whose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a cellulation of a two-dimensional surface (with a qubit located at each edge of the cellulation). Toric code often either refers to the construction on the two-dimensional torus or is an alternative name for the general construction. The construction on surfaces with boundaries is often called the planar code [S. B. Bravyi and A. Yu. Kitaev, \u201cQuantum codes on a lattice with boundary\u201d. quant-ph/9811052].\n\nThe original construction can be naturally extended to arbitrary \\(D\\)-dimensional manifolds [\u201cZ2-systolic freedom and quantum codes\u201d, Mathematics of Quantum Computation 303 (2002). DOI][G. Z\u00e9mor, \u201cOn Cayley Graphs, Surface Codes, and the Limits of Homological Coding for Quantum Error Correction\u201d, Lecture Notes in Computer Science 259 (2009). DOI]. Given a cellulation, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers are associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\(i+1\\)-faces. Such extensions are often called the \\(D\\)-dimensional surface or \\(D\\)-dimensional toric codes.\n\nThe stabilizers of the surface code on the 2-dimensional torus are generated by star operators \\(A_v\\) and plaquette operators \\(B_p\\). Each star operator is a product of four Pauli-\\(X\\) operators on the edges adjacent to a vertex \\(v\\) of the lattice; each plaquette operator is a product of four Pauli-\\(Z\\) operators applied to the edges adjacent to a face, or plaquette, \\(p\\) of the lattice (Figure\u00a0I).\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n                  [/fig/d580bfd1b11ef8689fbb2b97ed51f625.svg]                   \n\nFigure\u00a0I: Stabilizer generators and logical operators of the 2D surface code on a torus. The star operators \\(A_v\\) and the plaquette operators \\(B_p\\) generate the stabilizer group of the toric code. The logical operators are strings that wrap around the torus.\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n\nThe two-dimensional toric code encodes two logical qubits. We denote by \\(\\overline{X}_i,\\overline{Z}_i\\) the logical Pauli-\\(X\\) and Pauli-\\(Z\\) operator of the \\(i\\)-th logical qubit. They can are represented by strings of Pauli-\\(X\\) operators or Pauli-\\(Z\\) operators that wrap around the torus as shown in Figure\u00a0I.", "name": "Kitaev surface code", "realizations": "One cycle of syndrome readout on 19-qubit planar and 24-qubit toric codes realized in two-dimensional Rydberg atomic arrays [D. Bluvstein et al., \u201cA quantum processor based on coherent transport of entangled atom arrays\u201d, Nature 604, 451 (2022). DOI; 2112.03923]. \nSignatures of corresponding topological phase of matter detected in superconducting circuits [K. J. Satzinger et al., \u201cRealizing topologically ordered states on a quantum processor\u201d, Science 374, 1237 (2021). DOI; 2104.01180] and two-dimensional Rydberg atomic arrays [G. Semeghini et al., \u201cProbing topological spin liquids on a programmable quantum simulator\u201d, Science 374, 1242 (2021). DOI; 2104.04119]. ", "short_name": "", "features_threshold": "\\(0.57\\%\\) for depolarizing noise on data and syndrome qubits as well initialization, gate, and measurement errors under MPWM decoding [A. G. Fowler et al., \u201cSurface codes: Towards practical large-scale quantum computation\u201d, Physical Review A 86, (2012). DOI; 1208.0928]. For this model, a logical qubit with a \\(10^{-14}\\) logical error rate requires between \\(10^3\\) to \\(10^4\\) physical qubits and a target gate fidelity above \\(99.9\\%\\).\n\\(0.5-2.9\\%\\) for various noise models [M. Ohzeki, \u201cLocations of multicritical points for spin glasses on regular lattices\u201d, Physical Review E 79, (2009). DOI; 0811.0464] (see also Refs. [C. Wang, J. Harrington, and J. Preskill, \u201cConfinement-Higgs transition in a disordered gauge theory and the accuracy threshold for quantum memory\u201d, Annals of Physics 303, 31 (2003). DOI; quant-ph/0207088][A. M. Stephens, \u201cFault-tolerant thresholds for quantum error correction with the surface code\u201d, Physical Review A 89, (2014). DOI; 1311.5003]).", "features_code_capacity_threshold": "Independent \\(X,Z\\) noise: \\(10.31\\%\\) under MWPM decoding [C. Wang, J. Harrington, and J. Preskill, \u201cConfinement-Higgs transition in a disordered gauge theory and the accuracy threshold for quantum memory\u201d, Annals of Physics 303, 31 (2003). DOI; quant-ph/0207088] (see also Ref. [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883]). The threshold under ML decoding corresponds to the value of critical point of the two-dimensional random-bond Ising model on the Nishimori line [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143], calculated to be \\(10.94 \\pm 0.02\\%\\) in Ref. [O. Derzhko, J. Richter, and O. Zaburannyi, \u201cSpin-Peierls instability in the spin-1/2 transverse XX chain with Dzyaloshinskii-Moriya interaction\u201d. cond-mat/0001014], \\(10.93(2)\\%\\) in Ref. [F. Merz and J. T. Chalker, \u201cTwo-dimensional random-bond Ising model, free fermions, and the network model\u201d, Physical Review B 65, (2002). DOI; cond-mat/0106023], and estimated to be between \\(10.9\\%\\) and \\(11\\%\\) in Ref. [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883].\nDepolarizing noise: between \\(17\\%\\) and \\(18.5\\%\\) under tensor-network decoding [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883], and between \\(15\\%\\) and \\(16\\%\\) under RG [G. Duclos-Cianci and D. Poulin, \u201cFast Decoders for Topological Quantum Codes\u201d, Physical Review Letters 104, (2010). DOI; 0911.0581], Markov-chain [A. Hutter, J. R. Wootton, and D. Loss, \u201cEfficient Markov chain Monte Carlo algorithm for the surface code\u201d, Physical Review A 89, (2014). DOI; 1302.2669], or MWPM [D. S. Wang et al., \u201cThreshold error rates for the toric and surface codes\u201d. 0905.0531] decoding. The threshold under ML decoding corresponds to the value of critical point in the disordered eight-vertex Ising model, calculated to be \\(18.9(3)\\%\\) [H. Bombin et al., \u201cStrong Resilience of Topological Codes to Depolarization\u201d, Physical Review X 2, (2012). DOI; 1202.1852] (see also APS Physics viewpoint [D. Gottesman, \u201cKeeping One Step Ahead of Errors\u201d, Physics 5, (2012). DOI]).\nErasure noise: \\(50\\%\\) for square tiling [T. M. Stace, S. D. Barrett, and A. C. Doherty, \u201cThresholds for Topological Codes in the Presence of Loss\u201d, Physical Review Letters 102, (2009). DOI; 0904.3556].\nPhenomenological noise: \\(3.3\\%\\) for square tiling [T. Ohno et al., \u201cPhase structure of the random-plaquette gauge model: accuracy threshold for a toric quantum memory\u201d, Nuclear Physics B 697, 462 (2004). DOI; quant-ph/0401101].", "features_decoders": "Maximum-likelihood (ML) [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143].\nMinimum weight perfect-matching (MWPM) [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][Austin G. Fowler, \u201cMinimum weight perfect matching of fault-tolerant topological quantum error correction in average $O(1)$ parallel time\u201d. 1307.1740] (based on work by Edmonds on finding a matching in a graph [J. Edmonds, \u201cPaths, Trees, and Flowers\u201d, Canadian Journal of Mathematics 17, 449 (1965). DOI][J. Edmonds, \u201cMaximum matching and a polyhedron with 0,1-vertices\u201d, Journal of Research of the National Bureau of Standards Section B Mathematics and Mathematical Physics 69B, 125 (1965). DOI]). Pipeline MWPM [Austin G. Fowler, \u201cOptimal complexity correction of correlated errors in the surface code\u201d. 1310.0863][Alexandru Paler and Austin G. Fowler, \u201cPipelined correlated minimum weight perfect matching of the surface code\u201d. 2205.09828] - a modification accounting for correlations between events. A modification utilizing the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) [Christopher A. Pattison et al., \u201cImproved quantum error correction using soft information\u201d. 2107.13589]. Correlated matching modifies MWPM to include correlations between \\(X\\) and \\(Z\\)-type errors [Austin G. Fowler, \u201cOptimal complexity correction of correlated errors in the surface code\u201d. 1310.0863]. Belief perfect matching is a combination of belief-propagation and MWPM [Oscar Higgott et al., \u201cFragile boundaries of tailored surface codes\u201d. 2203.04948].\nRenormalization group (RG) [G. Duclos-Cianci and D. Poulin, \u201cFast Decoders for Topological Quantum Codes\u201d, Physical Review Letters 104, (2010). DOI; 0911.0581][Guillaume Duclos-Cianci and David Poulin, \u201cFault-Tolerant Renormalization Group Decoder for Abelian Topological Codes\u201d. 1304.6100][F. H. E. Watson, H. Anwar, and D. E. Browne, \u201cFast fault-tolerant decoder for qubit and qudit surface codes\u201d, Physical Review A 92, (2015). DOI; 1411.3028].\nMarkov-chain Monte Carlo [A. Hutter, J. R. Wootton, and D. Loss, \u201cEfficient Markov chain Monte Carlo algorithm for the surface code\u201d, Physical Review A 89, (2014). DOI; 1302.2669].\nTensor network [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883].\nCellular automaton [M. Herold et al., \u201cCellular automaton decoders of topological quantum memories in the fault tolerant setting\u201d, New Journal of Physics 19, 063012 (2017). DOI; 1511.05579].\nNeural network [G. Torlai and R. G. Melko, \u201cNeural Decoder for Topological Codes\u201d, Physical Review Letters 119, (2017). DOI; 1610.04238][C. Chamberland and P. Ronagh, \u201cDeep neural decoders for near term fault-tolerant experiments\u201d, Quantum Science and Technology 3, 044002 (2018). DOI; 1802.06441][R. Sweke et al., \u201cReinforcement learning decoders for fault-tolerant quantum computation\u201d, Machine Learning: Science and Technology 2, 025005 (2020). DOI; 1810.07207][Yosuke Ueno et al., \u201cNEO-QEC: Neural Network Enhanced Online Superconducting Decoder for Surface Codes\u201d. 2208.05758].\nUnion-find [N. Delfosse and N. H. Nickerson, \u201cAlmost-linear time decoding algorithm for topological codes\u201d, Quantum 5, 595 (2021). DOI; 1709.06218]. A subsequent modification utilizes the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) [Christopher A. Pattison et al., \u201cImproved quantum error correction using soft information\u201d. 2107.13589]. Belief union find is a combination of belief-propagation and union-find [Oscar Higgott et al., \u201cFragile boundaries of tailored surface codes\u201d. 2203.04948].\nDecoders can be augmented with a pre-decoder [Nicolas Delfosse, \u201cHierarchical decoding to reduce hardware requirements for quantum computing\u201d. 2001.11427][Samuel C. Smith, Benjamin J. Brown, and Stephen D. Bartlett, \u201cA local pre-decoder to reduce the bandwidth and latency of quantum error correction\u201d. 2208.04660].", "features_general_gates": "Clifford gates can be implemented via lattice surgery [C. Horsman et al., \u201cSurface code quantum computing by lattice surgery\u201d, New Journal of Physics 14, 123011 (2012). DOI; 1111.4022][D. Litinski and F. von . Oppen, \u201cLattice Surgery with a Twist: Simplifying Clifford Gates of Surface Codes\u201d, Quantum 2, 62 (2018). DOI; 1709.02318][D. Litinski, \u201cA Game of Surface Codes: Large-Scale Quantum Computing with Lattice Surgery\u201d, Quantum 3, 128 (2019). DOI; 1808.02892][C. Chamberland and E. T. Campbell, \u201cUniversal Quantum Computing with Twist-Free and Temporally Encoded Lattice Surgery\u201d, PRX Quantum 3, (2022). DOI; 2109.02746], twist-based lattice surgery [C. Chamberland and E. T. Campbell, \u201cCircuit-level protocol and analysis for twist-based lattice surgery\u201d, Physical Review Research 4, (2022). DOI; 2201.05678], or braiding defects [R. Raussendorf and J. Harrington, \u201cFault-Tolerant Quantum Computation with High Threshold in Two Dimensions\u201d, Physical Review Letters 98, (2007). DOI; quant-ph/0610082][R. Raussendorf, J. Harrington, and K. Goyal, \u201cTopological fault-tolerance in cluster state quantum computation\u201d, New Journal of Physics 9, 199 (2007). DOI; quant-ph/0703143][A. G. Fowler et al., \u201cSurface codes: Towards practical large-scale quantum computation\u201d, Physical Review A 86, (2012). DOI; 1208.0928][B. J. Brown et al., \u201cPoking Holes and Cutting Corners to Achieve Clifford Gates with the Surface Code\u201d, Physical Review X 7, (2017). DOI; 1609.04673]. \nNon-Clifford gates require magic state distillation [D. Litinski, \u201cMagic State Distillation: Not as Costly as You Think\u201d, Quantum 3, 205 (2019). DOI; 1905.06903], Dehn twists [G. Zhu, A. Lavasani, and M. Barkeshli, \u201cInstantaneous braids and Dehn twists in topologically ordered states\u201d, Physical Review B 102, (2020). DOI; 1806.06078], or just-in-time decoding [B. J. Brown, \u201cA fault-tolerant non-Clifford gate for the surface code in two dimensions\u201d, Science Advances 6, (2020). DOI; 1903.11634]. ", "features_magic_scaling_exponent": "", "features_encoders": "For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit [O. Higgott et al., \u201cOptimal local unitary encoding circuits for the surface code\u201d, Quantum 5, 517 (2021). DOI; 2002.00362][Yu-Jie Liu et al., \u201cMethods for simulating string-net states and anyons on a digital quantum computer\u201d. 2110.02020] or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates [M. Aguado and G. Vidal, \u201cEntanglement Renormalization and Topological Order\u201d, Physical Review Letters 100, (2008). DOI; 0712.0348][J. Joo et al., \u201cGenerating and verifying graph states for fault-tolerant topological measurement-based quantum computing in two-dimensional optical lattices\u201d, Physical Review A 88, (2013). DOI; 1207.0253] (matching a lower bound in Ref. [Dorit Aharonov and Yonathan Touati, \u201cQuantum Circuit Depth Lower Bounds For Homological Codes\u201d. 1810.03912]).\nLindbladian-based dissipative encoding for the toric code [J. Dengis, R. K\u00f6nig, and F. Pastawski, \u201cAn optimal dissipative encoder for the toric code\u201d, New Journal of Physics 16, 013023 (2014). DOI; 1310.1036] that does not give a speedup relative to circuit-based encoders [R. K\u00f6nig and F. Pastawski, \u201cGenerating topological order: No speedup by dissipation\u201d, Physical Review B 90, (2014). DOI; 1310.1037].\nStabilizer measurement-based circuit of linear depth [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][J. \u0141odyga et al., \u201cSimple scheme for encoding and decoding a qubit in unknown state for various topological codes\u201d, Scientific Reports 5, (2015). DOI; 1404.2495].", "features_rate": "Rate depends on the underlying cellulation and manifold. For general 2D manifolds, \\(kd^2\\leq c(\\log k)^2 n\\) for some constant \\(c\\) [N. Delfosse, \u201cTradeoffs for reliable quantum information storage in surface codes and color codes\u201d, 2013 IEEE International Symposium on Information Theory (2013). DOI; 1301.6588], meaning that (1) 2D surface codes with bounded geometry have distance scaling at most as \\(O(\\sqrt{n})\\) [S. Bravyi, D. Poulin, and B. Terhal, \u201cTradeoffs for Reliable Quantum Information Storage in 2D Systems\u201d, Physical Review Letters 104, (2010). DOI; 0909.5200][E. Fetaya, \u201cBounding the distance of quantum surface codes\u201d, Journal of Mathematical Physics 53, 062202 (2012). DOI], and (2) surface codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\). Higher-dimensional hyperbolic manifolds (see code children below) yield distances scaling more favorably. Loewner's theorem provides an upper bound for any bounded-geometry surface code [\u201cZ2-systolic freedom and quantum codes\u201d, Mathematics of Quantum Computation 303 (2002). DOI]. ", "features_transversal_gates": "Transversal Pauli gates exist and are based on non-trivial loops on surface. Transversal Clifford gates can be done on folded surface codes [J. E. Moussa, \u201cTransversal Clifford gates on folded surface codes\u201d, Physical Review A 94, (2016). DOI; 1603.02286]. ", "features_fault_tolerance": "Transversal (non-Clifford) CCZ gate by bringing 2D surface codes together and using just-in-time decoding [B. J. Brown, \u201cA fault-tolerant non-Clifford gate for the surface code in two dimensions\u201d, Science Advances 6, (2020). DOI; 1903.11634]. Gate can be simulated by taking 2D slices out of 3D surface codes [T. R. Scruby et al., \u201cNumerical Implementation of Just-In-Time Decoding in Novel Lattice Slices Through the Three-Dimensional Surface Code\u201d, Quantum 6, 721 (2022). DOI; 2012.08536].", "parents_code_id": "css\nclifford-deformed_surface\ntopological_abelian", "parents_detail": "\nCDSC codes are deformations of the surface code via constant-depth Clifford circuits that may not be CSS.\nWhen treated as ground states of the code Hamiltonian, the code states realize \\(\\mathbb{Z}_2\\) topological order, a topological phase of matter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory [F. J. Wegner, \u201cDuality in Generalized Ising Models and Phase Transitions without Local Order Parameters\u201d, Journal of Mathematical Physics 12, 2259 (1971). DOI]. Codewords correspond to ground state of the code Hamiltonian, and error operators correspond to spontaneous creation and annihilation of pairs of charges or vortices. ", "parent_of_code_id": "fractal_surface\nhigher_dimensional_surface\nhyperbolic_surface\nreal_projective_plane\nstab_4_2_2", "parent_of_detail": "\n\n\n\n\\([[4,2,2]]\\) code is the smallest toric code.", "cousins_code_id": "hypergraph_product\nquantum_double\nstring_net", "cousins_detail": "Planar (toric) code can be obtained from hypergraph product of two repetition (cyclic) codes ([A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928], Ex. 6).\nA quantum-double model with \\(G=\\mathbb{Z}_2\\) is the surface code.\nString-net model reduces to the surface code when the category is the group \\(\\mathbb{Z}_2\\).", "cousin_of_code_id": "color\ndouble_semion\ngalois_topological\nhaah_cubic\nheavy_hex\nhoneycomb\nlifted_product\nqudit_surface\nrbh\ntranslationally_invariant_stabilizer", "cousin_of_detail": "Color code is equivalent to surface code in several ways [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065][Arun B. Aloshious, Arjun Nitin Bhagoji, and Pradeep Kiran Sarvepalli, \u201cOn the Local Equivalence of 2D Color Codes and Surface Codes with Applications\u201d. 1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.\nThere is a logical basis for the toric and double-semion codes where each codeword is a superposition of states corresponding to all noncontractible loops of a particular homotopy type. The superposition is equal for the toric code, whereas some loops appear with a \\(-1\\) coefficient for the double semion.\nSurface code has been extended to Galois qudits.\nThe energy of any partial implementation of code 1 is proportional to the boundary length similar to the 4D toric code, which can potentially surpress the effects of thermal errors, but it is currently an open problem.\nSurface code stabilizers are used to measure the Z-type stabilizers of the code.\nMeasurement of each check operator involves two qubits and projects the state of the two qubits to a two-dimensional subspace, which we regard as an effective qubit. These effective qubits form a surface code on a hexagonal superlattice. Electric and magnetic operators on the embedded surface code correspond to outer logical operators of the Floquet code. In fact, outer logical operators transition back and forth from magnetic to electric surface code operators under the measurement dynamics. Inspired by this code, stabilizer measurement circuits consisting of two-body measurements have been designed for the surface code [R. Chao et al., \u201cOptimization of the surface code design for Majorana-based qubits\u201d, Quantum 4, 352 (2020). DOI; 2007.00307][Craig Gidney, \u201cA Pair Measurement Surface Code on Pentagons\u201d. 2206.12780].\nA lifted product code for the ring \\(R=\\mathbb{F}_2[x,y]/(x^L-1,y^L-1)\\) is the toric code.\nThe qudit surface code with \\(q=2\\) is the surface code.\nWithout symmetry protection, one of 2D boundaries of the cubic RBH code is effectively a 2D toric code.\nTranslation-invariant 2D qubit topological stabilizer codes are equivalent to several copies of the Kitaev surface code via a local constant-depth Clifford circuit [H. Bombin, G. Duclos-Cianci, and D. Poulin, \u201cUniversal topological phase of two-dimensional stabilizer codes\u201d, New Journal of Physics 14, 073048 (2012). DOI; 1103.4606][H. Bomb\u00edn, \u201cStructure of 2D Topological Stabilizer Codes\u201d, Communications in Mathematical Physics 327, 387 (2014). DOI; 1107.2707][J. Haah, \u201cAlgebraic Methods for Quantum Codes on Lattices\u201d, Revista Colombiana de Matem\u00e1ticas 50, 299 (2017). DOI; 1607.01387].", "_type": "ecc", "_page_id": "c_surface", "_href": "c/surface"}, "c_heavy_hex": {"notes": "", "logical": "qubits", "code_id": "heavy_hex", "physical": "qubits", "protection": "Protects against Pauli noise. The code has no threshold for \\(Z\\)-type Pauli errors since they are detected by Bacon-Shor-type stabilizers.", "introduced": "[C. Chamberland et al., \u201cTopological and Subsystem Codes on Low-Degree Graphs with Flag Qubits\u201d, Physical Review X 10, (2020). DOI; 1907.09528]", "description": "Subsystem stabilizer code on the heavy-hexagonal lattice that combines Bacon-Shor and surface-code stabilizers. Encodes one logical qubit into \\(n=(5d^2-2d-1)/2\\) physical qubits with distance \\(d\\). The heavy-hexagonal lattice allows for low degree (at most 3) connectivity between all the data and ancilla qubits, which is suitable for fixed-frequency transom qubits subject to frequency collision errors.\n\nData qubits and ancillas of the code are placed on a heavy-hexagonal lattice (vertices and edges of a tilling of hexagons). A subset of the ancilla qubits are flag qubits used for detecting high-weight errors arising from fewer faults. The code stabilizers for detecting \\(X\\)-type errors are measured by measuring weight-two \\(Z\\)-type gauge operators whose product produces stabilizers of the surface code. \\(X\\)-type stabilizers are column operators corresponding to stabilizers of the Bacon-Shor code, which are measured by taking products of weight-four and weight-two \\(X\\)-type gauge operators. ", "name": "Heavy-hexagon code", "realizations": "Logical state preparation and flag-qubit error correction realized in superconducting-circuit devices (specifically, fixed-frequency transmon qubit architectures) by IBM for \\(d=2\\) [M. Takita et al., \u201cExperimental Demonstration of Fault-Tolerant State Preparation with Superconducting Qubits\u201d, Physical Review Letters 119, (2017). DOI; 1705.09259][E. H. Chen et al., \u201cCalibrated Decoders for Experimental Quantum Error Correction\u201d, Physical Review Letters 128, (2022). DOI; 2110.04285] and \\(d=3\\) [Neereja Sundaresan et al., \u201cMatching and maximum likelihood decoding of a multi-round subsystem quantum error correction experiment\u201d. 2203.07205].", "short_name": "", "features_threshold": "\\(0.45\\%\\) for \\(X\\) errors under a full circuit-level depolarizing noise model (obtained from Monte Carlo simulations).\n\\(Z\\)-errors have no threshold given the \\(X\\)-type Bacon-Shor stabilizers.", "features_code_capacity_threshold": "", "features_decoders": "Any graph-based decoder can be used, such as MWPM and Union Find. However, edge weights must be dynamically renormalized using flag-qubit measurement outcomes after each syndrome measurement round.", "features_general_gates": "Universal gate set achieved with magic state injection and lattice surgery.", "features_magic_scaling_exponent": "", "features_encoders": "For a logical-zero state, prepare all data qubits in the physical-zero state and then measure the \\(X\\)-type Bacon-Shor stabilizers. For logical-plus state, prepare all data qubits in the physical-plus state and then measure \\(Z\\)-type surface code stabilizers.\nStabilizer measurement encoding circuits have a constant depth of 10 time steps (excluding ancilla state preparation and measurement).", "features_rate": "\\(1/n\\) for a distance-\\(d\\) heavy-hexagon code on \\(n = (5d^2-2d-1)/2\\) qubits.", "features_transversal_gates": "CNOT gates are transveral for this code. However, for most architectures, all logical gates would be implemented using lattice surgery methods.", "features_fault_tolerance": "All logical gates can be fault-tolerantly implemented using lattice surgery and magic state injection.\nStabilizer measurements are measured fault-tolerantly using one-flag circuits since some single-fault events can result in weight-two data qubit errors which are parallel to the code's logical operators. Hence, using information from the flag-qubit measurements is crucial to fault-tolerantly measure the code stabilizers.", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "cousins_code_id": "surface\nbacon_shor\nstab_4_2_2", "cousins_detail": "Surface code stabilizers are used to measure the Z-type stabilizers of the code.\nBacon-Shor stabilizers are used to measure the X-type stabilizers of the code.\nThe \\(d=2\\) heavy-hexagonal code is closely related to the \\([[4,1,2]]\\) code.", "cousin_of_code_id": "rotated_surface", "cousin_of_detail": "A rotated surface code can be mapped onto a heavy square lattice, resulting in a code similar to the heavy-hexagon code [C. Chamberland et al., \u201cTopological and Subsystem Codes on Low-Degree Graphs with Flag Qubits\u201d, Physical Review X 10, (2020). DOI; 1907.09528].", "_type": "ecc", "_page_id": "c_heavy_hex", "_href": "c/heavy_hex"}, "c_subsystem_stabilizer": {"notes": "When the gauge group \\( \\mathsf{G} \\) is abelian, the above is reduced to the standard stabilizer formalism.", "logical": "qubits", "code_id": "subsystem_stabilizer", "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. More generally, a set of errors \\( \\{ E_a \\} \\) is correctable iff \\( E_aE_b \\not\\in N(\\mathsf{S}) \\setminus \\mathsf{G} \\) for all pairs \\(a,b\\). The distance of the code is the minimal weight of operators in \\( N(\\mathsf{S}) \\setminus \\mathsf{G}\\).", "introduced": "[D. Poulin, \u201cStabilizer Formalism for Operator Quantum Error Correction\u201d, Physical Review Letters 95, (2005). DOI; quant-ph/0508131]", "description": "Also called a gauge stabilizer code. A stabilizer code with some of its logical qubits denoted as gauge qubits and not used for storage of logical information. Note that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by \\([[n,k,r,d]]\\), similar to stabilizer codes, but with an extra parameter \\(r\\) denoting the number of gauge qubits.\n\nTo create these codes proceed as follows. Choose \\(2n\\) operators \\(\\{ \\tilde{X}_j,\\tilde{Z}_j\\}_{j=1}^n\\) from \\(\\mathsf{P}_n\\), the Pauli group on \\(n\\) qubits, such that they obey the same commutation relations as the regular \\(n\\)-qubit Pauli generators \\( \\{X_j,Z_j\\}_{j=1}^n \\) (the subscript on these latter operators indicates the single qubit the Pauli matrix acts on). The tilde operators might act on more than one physical (or bare) qubit but they behave as if they acted only on a single qubit. WLOG we can choose a stabilizer group as \\( \\mathsf{S} = \\langle Z_1,\\dots,Z_s \\rangle \\). It follows that the normalizer of \\(\\mathsf{S} \\) is \\( N(\\mathsf{S}) = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_n, \\tilde{X}_{s+1},\\dots, \\tilde{X}_n \\rangle \\). We now choose a gauge group as \\( \\mathsf{G} = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_s, \\tilde{X}_{s+1}, \\tilde{Z}_{s+1}, \\dots, \\tilde{X}_{s+r}, \\tilde{Z}_{s+r} \\rangle \\) with \\( s + r \\leq n \\). The logical group is choosen as \\( \\mathsf{L} = N(\\mathsf{S})/\\mathsf{G} \\simeq \\langle \\tilde{X}_{s+r+1},\\tilde{Z}_{s+r+1}, \\dots, \\tilde{X}_n,\\tilde{Z}_n \\rangle \\). Now the codespace \\( C \\) is as usual the \\(+1\\) eigenspace of the stabilizer \\( \\mathsf{S} \\). But the gauge and logical groups have further decomposed this space into \\( C = A \\otimes B \\simeq (\\mathbb{C}^2)^{\\otimes k} \\otimes (\\mathbb{C}^2)^{\\otimes r} \\). Thus the Hilbert space is partitioned into 3 sets; \\(k\\) logical qubits, \\(r\\) gauge qubits, and \\(s\\) stabilizer qubits, with \\(s+r+k=n\\). ", "name": "Subsystem qubit stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "For correlated Pauli noise, bounds can be obtained by mapping the effect of noise on the code to a statistical mechanical model [C. T. Chubb and S. T. Flammia, \u201cStatistical mechanical models for quantum codes with correlated noise\u201d, Annales de l\u2019Institut Henri Poincar\u00e9 D 8, 269 (2021). DOI; 1809.10704].", "features_decoders": "Syndrome measurements are obtained by first measuring gauge operators of the code and taking their products, which give the stabilizer measurement outcomes.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oecc", "parents_detail": "", "parent_of_code_id": "bravyi_bacon_shor\nheavy_hex\nsubsystem_color", "parent_of_detail": "\n\n", "cousins_code_id": "qubit_stabilizer", "cousins_detail": "Gauge stabilizer codes reduce to stabilizer codes when there are no gauge qubits.", "cousin_of_code_id": "balanced_product\ndistance_balanced\nfloquet", "cousin_of_detail": "Distance balancing is used to form balanced-product subsystem codes [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].\n\nThis code can be viewed as a subsystem stabilizer code, albeit one with less logical qubits.", "_type": "ecc", "_page_id": "c_subsystem_stabilizer", "_href": "c/subsystem_stabilizer"}, "c_bacon_shor": {"notes": "", "logical": "qubits", "code_id": "bacon_shor", "physical": "qubits", "protection": "The \\([[m_1 m_2,1,min(m_1,m_2)]]\\) variant has distance \\(d=min(m_1,m_2)\\). In a symmetric 3-dimensional case (defined on a cubic lattice) with \\(L^3\\) qubits, the code has the parameters \\([[L^3,1,L]]\\).", "introduced": "[P. W. Shor, \u201cScheme for reducing decoherence in quantum computer memory\u201d, Physical Review A 52, R2493 (1995). DOI][D. Bacon, \u201cOperator quantum error-correcting subsystems for self-correcting quantum memories\u201d, Physical Review A 73, (2006). DOI; quant-ph/0506023]", "description": "CSS subsystem stabilizer code defined on an \\(m_1 \\times m_2\\) lattice of qubits. It is said to be symmetric when \\(m_1=m_2\\). The \\(X\\)-type and \\(Z\\)-type stabilizers defined as \\(X\\) and \\(Z\\) operators acting on all qubits on adjacent columns and rows, respectively. Let \\(O_{i,j}\\) denote an operator acting on the qubit at a position \\((i,j)\\) on the lattice, with \\(i\\in\\{0,1,\\ldots ,m_1-1\\}\\) and \\(j\\in\\{0,1,\\ldots,m_2-1\\}\\). The code's stabilizer group is \\begin{align}\n\\mathsf{S}=\\langle X_{i,*}X_{i+1,*},Z_{*,j}Z_{*,j+1}\\rangle~,\n\\end{align} with generators expressed as products of nearest-neightbour 2-qubit gauge operators, \\begin{align}\n\\begin{split}\nX_{i,*}X_{i+1,*}= \\bigotimes_{k=0}^{m_2-1} X_{i,k}X_{i+1,k} \\\\\nZ_{*,j}Z_{*,j+1}=\\bigotimes_{k=0}^{m_1-1} Z_{k,j}Z_{k,j+1}~.\n\\end{split}\n\\end{align} Syndrome extraction can be done by measuring these gauge operators, which are on fewer qubits and local.\n\nThe error-detecting \\([[4,1,2]]\\) Bacon-Shor code, which reduces to a subcode of the \\([[4,2,2]]\\) code for a particular gauge configuration, has gauge operators \\(\\{XIXI,IIXX,ZIZI,IZIZ\\}\\). The shortest error-correcting Bacon-Shor code is \\([[9,1,3]]\\) with four stabilizer generators \\begin{align}\n  \\begin{array}{ccccccccc}\n    X & X & X & X & X & X & I & I & I\\\\\n    I & I & I & X & X & X & X & X & X\\\\\n    Z & Z & I & Z & Z & I & Z & Z & I\\\\\n    I & Z & Z & I & Z & Z & I & Z & Z\n  \\end{array}\n\\end{align} and eight gauge generators \\begin{align}\n  \\begin{array}{ccccccccc}\n  X & I & I & X & I & I & I & I & I\\\\\n  I & X & I & I & X & I & I & I & I\\\\\n  I & I & I & X & I & I & X & I & I\\\\\n  I & I & I & I & X & I & I & X & I\\\\\n  Z & Z & I & I & I & I & I & I & I\\\\\n  I & I & I & Z & Z & I & I & I & I\\\\\n  I & Z & Z & I & I & I & I & I & I\\\\\n  I & I & I & I & Z & Z & I & I & I\n  \\end{array}~.\n\\end{align} If the physical qubits are arranged in a three-by-three square, the \\(Z\\)-type (\\(X\\)-type) gauge operators are supported on qubits in the same row (column). The code reduces to the Shor code for a particular gauge configuration. ", "name": "Bacon-Shor code", "realizations": "Trapped-ion qubits: state preparation, logical measurement, and stabilizer measurement for nine-qubit Bacon-Shor code demonstrated on a 13-qubit device by M. Cetina and C. Monroe groups [Laird Egan et al., \u201cFault-Tolerant Operation of a Quantum Error-Correction Code\u201d. 2009.11482].", "short_name": "", "features_threshold": "A lower bound of \\(1.94 \\times 10^{-4}\\) for the accuracy threshold was proved for Bacon-Shor code with 5 levels of concatenation, using Steane method of FTEC [P. Aliferis and A. W. Cross, \u201cSubsystem Fault Tolerance with the Bacon-Shor Code\u201d, Physical Review Letters 98, (2007). DOI; quant-ph/0610063].\nThe three dimensional version offers the possibility of being a self-correcting quantum memory [D. Bacon, \u201cOperator quantum error-correcting subsystems for self-correcting quantum memories\u201d, Physical Review A 73, (2006). DOI; quant-ph/0506023].", "features_code_capacity_threshold": "", "features_decoders": "While check operators are few-body, stabilizer weights scale with the number of qubits, and stabilizer expectation values are obtained by taking products of gauge-operator expectation values. It is thus not clear how to extract stabilizer values in a fault-tolerant manner [Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921][M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].", "features_general_gates": "Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively [Yoder, Theodore., DSpace@MIT Practical Fault-Tolerant Quantum Computation (2018)].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "A non-LDPC family of Bacon-Shor codes achieves a distance of \\(\\Omega(n^{1-\\epsilon})\\) with sparse gauge operators.", "features_transversal_gates": "Logical Hadamard is transversal in symmetric Bacon-Shor codes up to a qubit permutation [P. Aliferis and A. W. Cross, \u201cSubsystem Fault Tolerance with the Bacon-Shor Code\u201d, Physical Review Letters 98, (2007). DOI; quant-ph/0610063] and can be implemented with teleportation [X. Zhou, D. W. Leung, and I. L. Chuang, \u201cMethodology for quantum logic gate construction\u201d, Physical Review A 62, (2000). DOI; quant-ph/0002039]. Bacon-Shor codes on an \\(m \\times mk\\) lattice admit transversal \\(k\\)-qubit-controlled \\(Z\\) gates [Theodore J. Yoder, \u201cUniversal fault-tolerant quantum computation with Bacon-Shor codes\u201d. 1705.01686].", "features_fault_tolerance": "Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively [Yoder, Theodore., DSpace@MIT Practical Fault-Tolerant Quantum Computation (2018)].", "parents_code_id": "bravyi_bacon_shor", "parents_detail": "", "cousin_of_code_id": "gnu_permutation_invariant\nheavy_hex\nquantum_parity", "cousin_of_detail": "Symmetrized versions of the Bacon-Shor codes are GNU codes\nBacon-Shor stabilizers are used to measure the X-type stabilizers of the code.\nBacon-Shor codes reduce to QPCs for a particular gauge configuration.", "_type": "ecc", "_page_id": "c_bacon_shor", "_href": "c/bacon_shor"}, "c_bravyi_bacon_shor": {"notes": "", "logical": "qubits", "code_id": "bravyi_bacon_shor", "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits, where \\(d\\) is the minimum weight of a row or column in \\(A\\) [Muyuan Li and Theodore J. Yoder, \u201cA Numerical Study of Bravyi-Bacon-Shor and Subsystem Hypergraph Product Codes\u201d. 2002.06257].", "introduced": "[S. Bravyi, \u201cSubsystem codes with spatially local generators\u201d, Physical Review A 83, (2011). DOI; 1008.1029]", "description": "An \\([[n,k,d]]\\) CSS subsystem stabilizer code generalizing Bacon-Shor codes to a larger set of qubit geometries. Defined through a binary matrix \\(A\\) such that physical qubits live on sites \\((i,j)\\) whenever \\(A_{i,j}=1\\). The gauge group is generated by 2-qubit operators, including \\(XX\\) interations between any two qubits sharing a column in \\(A\\), and \\(ZZ\\) interations between two qubits sharing a row. The code parameters are: \\(n=\\sum_{i,j}A_{i,j}\\), \\(k=\\text{rank}(A)\\), and the distance is the minimum weight of any row or column.", "name": "Bravyi-Bacon-Shor (BBS) code", "realizations": "", "short_name": "BBS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "parent_of_code_id": "bacon_shor", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_bravyi_bacon_shor", "_href": "c/bravyi_bacon_shor"}, "c_subsystem_color": {"notes": "", "logical": "qubits", "code_id": "subsystem_color", "physical": "qubits", "protection": "", "introduced": "[H. Bombin, \u201cTopological subsystem codes\u201d, Physical Review A 81, (2010). DOI; 0908.4246][H. Bombin, \u201cGauge Color Codes: Optimal Transversal Gates and Gauge Fixing in Topological Stabilizer Codes\u201d. 1311.0879]", "description": "Stub. ", "name": "Subsystem color code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "cousins_code_id": "color\nsymmetry_protected_self_correct", "cousins_detail": "\nA particular gauge-fixed version of this code on a 3D lattice yields a self-correcting memory protected by one-form symmetries (see Sec. IV D of Ref. [S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]). The symmetric energy barrier grows linearly with the length of a side of the lattice. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the side length.", "cousin_of_code_id": "honeycomb\nrbh", "cousin_of_detail": "Both honeycomb and subsystem color codes are generated via periodic sequences of measurements. However, any measurement sequence can be performed on the color code without destroying the logical qubits, while honeycomb codes can be maintained only with specific sequences. Honeycomb codes require a shorter measurement cycle and use fewer qubits at the given code distance [M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].\nThe RBH code on a certain lattice is dual to the gauge color code.", "_type": "ecc", "_page_id": "c_subsystem_color", "_href": "c/subsystem_color"}, "c_hybrid_qudit_oscillator": {"notes": "", "logical": "groups", "code_id": "hybrid_qudit_oscillator", "physical": "qudits", "protection": "", "introduced": "", "description": "Encodes a \\(K\\)-dimensional logical Hilbert space into \\(n_1\\) qudits of dimension \\(q\\) and \\(n_2 \\neq 0\\) oscillators, i.e., the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{Z}_q^{n_1} \\times \\mathbb{R}^{n_2}\\).", "name": "Hybrid qudit-oscillator code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oscillators", "parents_detail": "The physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator.", "parent_of_code_id": "very-small-logical-qubit", "parent_of_detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators.", "cousins_code_id": "qudits_into_oscillators", "cousins_detail": "Hybrid code with \\(n_1=0\\).", "_type": "ecc", "_page_id": "c_hybrid_qudit_oscillator", "_href": "c/hybrid_qudit_oscillator"}, "c_single-mode": {"notes": "", "logical": "qudits", "code_id": "single-mode", "physical": "oscillators", "protection": "", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into a single bosonic mode.", "name": "Single-mode bosonic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudits_into_oscillators", "parents_detail": "", "parent_of_code_id": "bosonic_rotation\nchebyshev\ngkp\nnumopt", "parent_of_detail": "\n\n\n", "_type": "ecc", "_page_id": "c_single-mode", "_href": "c/single-mode"}, "c_oscillators_into_oscillators": {"notes": "", "logical": "oscillators", "code_id": "oscillators_into_oscillators", "physical": "oscillators", "protection": "", "introduced": "[S. Lloyd and J.-J. E. Slotine, \u201cAnalog Quantum Error Correction\u201d, Physical Review Letters 80, 4088 (1998). DOI; quant-ph/9711021][S. L. Braunstein, \u201cError Correction for Continuous Quantum Variables\u201d, Physical Review Letters 80, 4084 (1998). DOI; quant-ph/9711049]", "description": "Also called an analog quantum code. Encodes \\(k\\) bosonic modes into \\(n\\) bosonic modes.", "name": "Oscillator-into-oscillator code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oscillators", "parents_detail": "Oscillator-into-oscillator codes are bosonic codes with an infinite-dimensional logical subspace.", "parent_of_code_id": "gkp-stabilizer\nanalog_stabilizer", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_oscillators_into_oscillators", "_href": "c/oscillators_into_oscillators"}, "c_niset_andersen_cerf": {"notes": "", "logical": "points", "code_id": "niset_andersen_cerf", "physical": "oscillators", "protection": "The deterministic protocol protects against a single erasure error on a known mode. This recovers one state perfectly and the other state with fidelity \\(F = \\frac{1}{1 + e^{-2 r}}\\) for an initial EPR pair squeezed with variance \\(e^{-2r}\\). The probabalistic protocol utilizes post-selection to protect against multiple erasures with state-dependent fidelity.", "introduced": "[J. Niset, U. L. Andersen, and N. J. Cerf, \u201cExperimentally Feasible Quantum Erasure-Correcting Code for Continuous Variables\u201d, Physical Review Letters 101, (2008). DOI; 0710.4858]", "description": "Quantum-inspired classical code encoding two-mode coherent states \\(\\{|\\alpha\\rangle, |\\beta\\rangle\\}\\) into four modes such that the complex values \\((\\alpha,\\beta)\\) are recoverable after a single-mode erasure. There are two variations of the storage procedure: a deterministic protocol that offers recovery against a single mode erasure, and a probabalistic that can protect against multiple errors with post selection. This code is effectively protecting classical information stored in \\((\\alpha,\\beta)\\) using quantum operations.", "name": "Niset-Andersen-Cerf code", "realizations": "Realized in Ref. [M. Lassen et al., \u201cQuantum optical coherence can survive photon losses using a continuous-variable quantum erasure-correcting code\u201d, Nature Photonics 4, 700 (2010). DOI] in an optical system with 3 beam-splitters. The fidelity peaked around \\(0.6\\) for deterministic approach, and around \\(0.77\\) for the probabilistic approach (with a 25% chance of error).", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Optical decoder using three beam splitters, electronic gain detectors, and two phase-insensitive amplifiers as described in Ref. [J. Niset, U. L. Andersen, and N. J. Cerf, \u201cExperimentally Feasible Quantum Erasure-Correcting Code for Continuous Variables\u201d, Physical Review Letters 101, (2008). DOI; 0710.4858].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "After an EPR pair preparation, use 2 continuous CNOT and 2 continuous inverse CNOT gates to entangle a bosonic EPR pair with initial states \\(|\\alpha \\rangle\\) and \\(|\\beta \\rangle\\).\nAlternate optical encoder using a two-mode squeezed vacuum state and two balanced beam splitters to mix the input coherent states with the EPR pair.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "points_into_lattices", "parents_detail": "The Niset-Andersen-Cerf code encodes two coherent states at a time with arbitrary complex values, making it analogous to a lattice-based (classical) code encoding two points in \\(\\mathbb{R}^2\\). The code does not encode any quantum information since superpositions of the coherent states are not stored.", "cousin_of_code_id": "homological_cv", "cousin_of_detail": "The Niset-Andersen-Cerf code can be viewed as a scheme to replicate quantum information in multiple regions [P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544].", "_type": "ecc", "_page_id": "c_niset_andersen_cerf", "_href": "c/niset_andersen_cerf"}, "c_oscillators": {"notes": "Reviews on bosonic codes can be found in Refs. [A. Joshi, K. Noh, and Y. Y. Gao, \u201cQuantum information processing with bosonic qubits in circuit QED\u201d, Quantum Science and Technology 6, 033001 (2021). DOI; 2008.13471][W. Cai et al., \u201cBosonic quantum error correction codes in superconducting quantum circuits\u201d, Fundamental Research 1, 50 (2021). DOI; 2010.08699][Steven M. Girvin, \u201cIntroduction to Quantum Error Correction and Fault Tolerance\u201d. 2111.08894].", "logical": "", "code_id": "oscillators", "physical": "oscillators", "protection": "An error set relevant to Fock-state bosonic codes is the set of loss operators associated with the amplitude damping (a.k.a. photon loss or attenuation) noise channel, a common form of physical noise in bosonic systems. For a single mode, loss operators are proportional to powers of the mode's annihilation operator \\(a=(\\hat{x}+i\\hat{p})/\\sqrt{2}\\), where \\(\\hat x\\) (\\(\\hat p\\)) is the mode's position (momentum) operator, and with the power signifying the number of particles lost during the error. For multiple modes, error set elements are tensor products of elements of the single-mode error set. A definition of distance associated with this error set is the minimum weight of a loss error that implements a nontrivial logical operation in the code.\n\nAn error set relevant to bosonic stabilizer codes is the set of displacement operators, a bosonic analogue of the Pauli string basis for qubit codes. For a single mode, its elements are products of exponentials of the mode's position and momentum operators, acting on the mode's position states \\(|y\\rangle\\) for \\(y\\in\\mathbb{R}\\) as \\begin{align}\n  e^{-iq\\hat{p}}\\left|y\\right\\rangle =\\left|y+q\\right\\rangle \\,\\,\\text{ and }\\,\\,e^{iq\\hat{x}}\\left|y\\right\\rangle =e^{iq y}\\left|y\\right\\rangle ~,\n\\end{align} where \\(q\\in\\mathbb{R}\\). For multiple modes, error set elements are tensor products of elements of the single-qudit error set, characterized by the vector of coefficients \\(\\xi\\in\\mathbb{R}^{2n}\\).\n\nThe displacement error set is a unitary basis for trace-class linear operators on the \\(n\\)-mode Hilbert space that is Dirac-orthonormal under the Hilbert-Schmidt inner product [K. E. Cahill and R. J. Glauber, \u201cOrdered Expansions in Boson Amplitude Operators\u201d, Physical Review 177, 1857 (1969). DOI]. There are two definitions of code distance associated with displacements. The definition inherited from qubit codes is the minimum weight of a displacement operator (i.e., number of nonzero entries in \\(\\xi\\)) that implements a nontrivial logical operation in the code. The second definition is the minimum Euclidean distance (i.e., \\(\\ell^2\\)-norm of \\(\\xi\\)) such that the corresponding displacement implements a nontrivial logical operation in the code.", "introduced": "", "description": "Also called an oscillator or a continuous-variable (CV) code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one oscillator (a.k.a. bosonic mode or qumode). States of a single oscillator are elements of the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}\\)). Ideal codewords may not be normalizable because the space is infinite-dimensional, so approximate versions have to be constructed in practice.", "name": "Bosonic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "oscillator_stabilizer\nhybrid_qudit_oscillator\noscillators_into_oscillators\nqudits_into_oscillators", "parent_of_detail": "\nThe physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator.\nOscillator-into-oscillator codes are bosonic codes with an infinite-dimensional logical subspace.\nQudit-into-oscillator codes are bosonic codes with a finite-dimensional logical subspace.", "cousin_of_code_id": "fermions\ngroup_quantum", "cousin_of_detail": "Bosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom.\nGroup quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes.", "_type": "ecc", "_page_id": "c_oscillators", "_href": "c/oscillators"}, "c_qudits_into_oscillators": {"notes": "", "logical": "qudits", "code_id": "qudits_into_oscillators", "physical": "oscillators", "protection": "", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into \\(n\\) bosonic modes.", "name": "Qudit-into-oscillator code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Given an encoding of a finite-dimensional code, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [K. Audenaert and B. De Moor, \u201cOptimizing completely positive maps using semidefinite programming\u201d, Physical Review A 65, (2002). DOI; quant-ph/0109155][M. Reimpell and R. F. Werner, \u201cIterative Optimization of Quantum Error Correcting Codes\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0307138] (see also Ref. [Andrew S. Fletcher, \u201cChannel-Adapted Quantum Error Correction\u201d. 0706.3400]). This approximate QEC technique can be adapted to bosonic codes as long as they are restricted to a finite-dimensional subspace of the oscillator Hilbert space [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oscillators", "parents_detail": "Qudit-into-oscillator codes are bosonic codes with a finite-dimensional logical subspace.", "parent_of_code_id": "fock_state\ngkp-cluster-state\nsingle-mode", "parent_of_detail": "\n\n", "cousins_code_id": "approximate_qecc", "cousins_detail": "Approximate QEC techniques of finding the entanglement fidelity can be adapted to bosonic codes with a finite-dimensional codespace [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].", "cousin_of_code_id": "hybrid_qudit_oscillator", "cousin_of_detail": "Hybrid code with \\(n_1=0\\).", "_type": "ecc", "_page_id": "c_qudits_into_oscillators", "_href": "c/qudits_into_oscillators"}, "c_very-small-logical-qubit": {"notes": "", "logical": "qubits", "code_id": "very-small-logical-qubit", "physical": "groups", "protection": "Passively protects against single photon loss.", "introduced": "[E. Kapit, \u201cHardware-Efficient and Fully Autonomous Quantum Error Correction in Superconducting Circuits\u201d, Physical Review Letters 116, (2016). DOI]", "description": "The two logical codewords are \\(|\\pm\\rangle \\propto (|0\\rangle\\pm|2\\rangle)(|0\\rangle\\pm|2\\rangle)|0\\rangle|0\\rangle\\), where the total Hilbert space is the tensor product of two qudits (whose ground states \\(|0\\rangle\\) and second excited states \\(|2\\rangle\\) are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.", "name": "Very small logical qubit (VSLQ) code", "realizations": "", "short_name": "VSLQ", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Logical qubit can be measured with physical qubit measurements along \\(X\\). Can be implemented by engineering a coupling of one of the qubits to a readout cavity via the interaction \\(\\sigma_x (a+a^\\dagger)\\) [N. Didier, J. Bourassa, and A. Blais, \u201cFast Quantum Nondemolition Readout by Parametric Modulation of Longitudinal Qubit-Oscillator Interaction\u201d, Physical Review Letters 115, (2015). DOI]. This results in an \\(X\\)-dependent shift of the readout cavity resonance which can be measured.", "features_general_gates": "Single logical qubit operations implemented by resonant physical qubit driving and phase shifting the SQUID drives.\nA CZ gate between two logical qubits implemented by coupling devices through another driven SQUID and applying a pulse to the coupling squid simultaneously with a single qubit operation on one of the logical qubits.", "features_magic_scaling_exponent": "", "features_encoders": "Engineering a circuit made of two transmons and two oscillators coupled through three driven superconducting quantum interference devices (SQUIDs) results in passive stabilization of the logical states.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hybrid_qudit_oscillator", "parents_detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators.", "cousins_code_id": "quantum_repetition", "cousins_detail": "Parts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss.", "_type": "ecc", "_page_id": "c_very-small-logical-qubit", "_href": "c/very-small-logical-qubit"}, "c_homological_cv": {"notes": "Proposed experimental optical procedure for realizing the simplest non-trival code with 5 modes [P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544].", "logical": "oscillators", "code_id": "homological_cv", "physical": "oscillators", "protection": "Protects against certain types of erasure errors (depending on the specific dimension). Certain constructions also protect arbitrary sized errors on multiple photon states.", "introduced": "[P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544]", "description": "An \\([[n,1]]_{\\mathbb{R}}\\) Gaussian CSS code defined using homological structres associated with an \\(n-1\\) simplex. Relevant to the study of spacetime replication of quantum information [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913].\n\nStabilizer generators are defined by two orthogonal subspaces of the \\(C_1\\) in the chain complex. \\(C_X = \\partial_2 C_2\\) and \\(C_P = \\partial_1^T Q\\) for some \\(Q \\subset C_0\\). The standard approach would use \\(Q = C_0\\), which would mean the logical dimension would be the dimension of the 1st homology group \\(H^1\\). However, \\(H^1\\) is trivial for the \\(n-1\\) simplex, so one chooses \\(Q \\neq C_0\\) such that exactly one stabilizer is removed, yielding a stabilizer code instead of a single stabilized state. ", "name": "Homological bosonic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoding requires a different circuit for each possible erasure error, with no general circuit decoding any possible erasure error. Every circuit relies on a generalized conditional rotation, which Ref. [P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544] calls the QND Gate and which is defined as \\(QND_c | x , y \\rangle = |x + c y, y \\rangle\\).", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Encoding depends on the specific dimension, but can generally be done using generalized conditional-rotation and Fourier-transform gates.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "analog_stabilizer", "parents_detail": "", "cousins_code_id": "css\nniset_andersen_cerf\nspacetime", "cousins_detail": "CSS and homological CV codes utilize chain complexes in code construction, with the latter complexes having trivial homology.\nThe Niset-Andersen-Cerf code can be viewed as a scheme to replicate quantum information in multiple regions [P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544].\nHomological CV codes have been considered in the context of spacetime replication of quantum data [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913][P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544], while STCs are designed to replicate classical data.", "_type": "ecc", "_page_id": "c_homological_cv", "_href": "c/homological_cv"}, "c_lloyd_slotine": {"notes": "", "logical": "oscillators", "code_id": "lloyd_slotine", "physical": "oscillators", "protection": "", "introduced": "[S. Lloyd and J.-J. E. Slotine, \u201cAnalog Quantum Error Correction\u201d, Physical Review Letters 80, 4088 (1998). DOI; quant-ph/9711021]", "description": "A \\([[9,1,3]]_{\\mathbb{R}}\\) Gaussian CSS analogue of Shor's nine-qubit code. ", "name": "Lloyd-Slotine nine-mode code", "realizations": "Optical network by the Furusawa group [Takao Aoki et al., \u201cQuantum error correction beyond qubits\u201d. 0811.3734].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "analog_stabilizer", "parents_detail": "", "cousins_code_id": "shor_nine", "cousins_detail": "The Lloyd-Slotine nine-mode code is a bosonic analogue of Shor's code.", "_type": "ecc", "_page_id": "c_lloyd_slotine", "_href": "c/lloyd_slotine"}, "c_gkp": {"notes": "GKP codes were obtained after iterative numerical optimization of encoding and recovery against photon loss, starting with Haar-random states [K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].\nPedagogical introduction into GKP codes presented in Ref. [A. L. Grimsmo and S. Puri, \u201cQuantum Error Correction with the Gottesman-Kitaev-Preskill Code\u201d, PRX Quantum 2, (2021). DOI; 2106.12989].", "logical": "qudits", "code_id": "gkp", "physical": "oscillators", "protection": "For stabilizer \\(\\hat{S}_q(2\\alpha),\\hat{S}_p(2\\beta)\\), code can correct displacement errors up to \\(\\frac{\\alpha}{2}\\) in the \\(q\\)-direction and \\(\\frac{\\beta}{2}\\) at \\(p\\)-direction. Approximately protects against photon loss errors [B. M. Terhal and D. Weigand, \u201cEncoding a qubit into a cavity mode in circuit QED using phase estimation\u201d, Physical Review A 93, (2016). DOI; 1506.05033], outperforming most other codes designed to explicitly protect against loss [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]. Very sensitive to dephasing errors [A. L. Grimsmo and S. Puri, \u201cQuantum Error Correction with the Gottesman-Kitaev-Preskill Code\u201d, PRX Quantum 2, (2021). DOI; 2106.12989]. A biased-noise GKP error correcting code can be prepared by choosing \\(\\alpha\\neq \\beta\\).", "introduced": "[D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040]", "description": "Bosonic qudit-into-oscillator code whose stabilizers are oscillator displacement operators \\(\\hat{S}_q(2\\alpha)=e^{-2i\\alpha \\hat{p}}\\) and \\(\\hat{S}_p(2\\beta)=e^{2i\\beta \\hat{x}}\\). To ensure \\(\\hat{S}_q(2\\alpha)\\) and \\(\\hat{S}_p(2\\beta)\\) generate a stabilizer group that is Abelian, there is another constraint that \\(\\alpha\\beta=2k\\pi\\) where \\(k\\) is an integer. Codewords can be expressed as equal weight superpositions of coherent states on an infinite lattice, such as a square lattice in phase space with spatial period \\(2\\sqrt{\\pi}\\). The exact GKP state is non-normalizable, so approximate constructs have to be considered.", "name": "Gottesman-Kitaev-Preskill (GKP) code", "realizations": "Motional degree of freedom of a trapped ion: GKP encoding realized with the help of post-selection [C. Fl\u00fchmann et al., \u201cEncoding a qubit in a trapped-ion mechanical oscillator\u201d, Nature 566, 513 (2019). DOI; 1807.01033][C. Fl\u00fchmann and J. P. Home, \u201cDirect Characteristic-Function Tomography of Quantum States of the Trapped-Ion Motional Oscillator\u201d, Physical Review Letters 125, (2020). DOI; 1907.06478], followed by realization of reduced form of GKP error correction, where displacement error syndromes are measured to one bit of precision using an ion electronic state [Brennan de Neeve et al., \u201cError correction of a logical grid state qubit by dissipative pumping\u201d. 2010.09681].\nMicrowave cavity coupled to superconducting circuits: reduced form of GKP error correction, where displacement error syndromes are measured to one bit of precision using an ancillary transmon [P. Campagne-Ibarcq et al., \u201cQuantum error correction of a qubit encoded in grid states of an oscillator\u201d. 1907.12487].\nIn signal processing, where the conjugate variables are time and frequency instead of position and momentum, GKP state position-state wavefunctions correspond to Dirac combs [H. G. Feichtinger and T. Strohmer, editors , Gabor Analysis and Algorithms (Birkh\u00e4user Boston, 1998). DOI].", "short_name": "GKP", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Syndrome measurement can be done by applying a controlled-displacement controlled by an ancilla qubit. The syndrome information can be obtained by measuring the ancilla qubit after controlled-displacement opearation. See Section. 2D in [A. L. Grimsmo and S. Puri, \u201cQuantum Error Correction with the Gottesman-Kitaev-Preskill Code\u201d, PRX Quantum 2, (2021). DOI; 2106.12989].\nPauli \\(X\\),\\(Y\\) and \\(Z\\) measurements can be performed by measuring \\(-\\hat{p},\\hat{x}-\\hat{p}\\) and \\(\\hat{x}\\) repectively. If the measurement outcome is closed to an even multiple of \\(\\sqrt{\\pi}\\), then the outcome is +1. If the measurement outcome is closed to an odd multiple of \\(\\sqrt{\\pi}\\), then the outcome is -1. See Section. 2D in [A. L. Grimsmo and S. Puri, \u201cQuantum Error Correction with the Gottesman-Kitaev-Preskill Code\u201d, PRX Quantum 2, (2021). DOI; 2106.12989].", "features_general_gates": "By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements [B. Q. Baragiola et al., \u201cAll-Gaussian Universality and Fault Tolerance with the Gottesman-Kitaev-Preskill Code\u201d, Physical Review Letters 123, (2019). DOI; 1903.00012].", "features_magic_scaling_exponent": "", "features_encoders": "Preparation of approximate GKP states is studied both theoretically and experimentally by putting the GKP lattice inside a Gaussian envelope [B. M. Terhal and D. Weigand, \u201cEncoding a qubit into a cavity mode in circuit QED using phase estimation\u201d, Physical Review A 93, (2016). DOI; 1506.05033][D. J. Weigand and B. M. Terhal, \u201cGenerating grid states from Schr\u00f6dinger-cat states without postselection\u201d, Physical Review A 97, (2018). DOI][P. Campagne-Ibarcq et al., \u201cQuantum error correction of a qubit encoded in grid states of an oscillator\u201d, Nature 584, 368 (2020). DOI][I. Tzitrin et al., \u201cProgress towards practical qubit computation using approximate Gottesman-Kitaev-Preskill codes\u201d, Physical Review A 101, (2020). DOI; 1910.03673].\nDissipative stabilization of finite-energy GKP states using stabilizers conjugated by a cooling ([N. C. Menicucci, \u201cFault-Tolerant Measurement-Based Quantum Computing with Continuous-Variable Cluster States\u201d, Physical Review Letters 112, (2014). DOI; 1310.7596], Appx. B) or damping operator, i.e., a damped exponential of the total occupation number [B. Royer, S. Singh, and S. M. Girvin, \u201cStabilization of Finite-Energy Gottesman-Kitaev-Preskill States\u201d, Physical Review Letters 125, (2020). DOI; 2009.07941][Brennan de Neeve et al., \u201cError correction of a logical grid state qubit by dissipative pumping\u201d. 2010.09681].\nTwo Josephson junctions coupled by a gyrator [M. Rymarz et al., \u201cHardware-Encoding Grid States in a Nonreciprocal Superconducting Circuit\u201d, Physical Review X 11, (2021). DOI; 2002.07718].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Clifford gates can be realized by performing linear-optical operations, sympletic transformations and displacements, all of which are Gaussian operations. Pauli gates can be performed using displacement operators. Clifford gates are fault tolerant in the sense that they map bounded-size errors to bounded-size errors [D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040].\nError correction scheme is fault-tolerant to displacement noise as long as all input states have displacement errors less than \\(\\sqrt{\\pi}/6\\) [S. Glancy and E. Knill, \u201cError analysis for encoding a qubit in an oscillator\u201d, Physical Review A 73, (2006). DOI; quant-ph/0510107].", "parents_code_id": "single-mode\nmultimodegkp", "parents_detail": "\n", "cousins_code_id": "approximate_qecc", "cousins_detail": "GKP codes approximately protect against photon loss [B. M. Terhal and D. Weigand, \u201cEncoding a qubit into a cavity mode in circuit QED using phase estimation\u201d, Physical Review A 93, (2016). DOI; 1506.05033][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].", "cousin_of_code_id": "number_phase\nrotor_gkp", "cousin_of_detail": "GKP codes utilize translational symmetry in phase space, while number-phase codes utilize rotational symmetry. The two are related via a mapping [Allan D. C. Tosta, Thiago O. Maciel, and Leandro Aolita, \u201cGrand Unification of continuous-variable codes\u201d. 2206.01751].\nGKP (rotor GKP) codes protect against shifts in linear (angular) degrees of freedom.", "_type": "ecc", "_page_id": "c_gkp", "_href": "c/gkp"}, "c_analog_stabilizer": {"notes": "", "logical": "", "code_id": "analog_stabilizer", "physical": "oscillators", "protection": "Protect against erasures of at most \\(d-1\\) modes, or arbitrarily large dispalcements on those modes. If an error operator does not commute with a nullifier, then that error is detectable. Protection of logical modes against small displacements cannot be done using only Gaussian resources [C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047][J. Eisert, S. Scheel, and M. B. Plenio, \u201cDistilling Gaussian States with Gaussian Operations is Impossible\u201d, Physical Review Letters 89, (2002). DOI; quant-ph/0204052][J. Niset, J. Fiur\u00e1\u0161ek, and N. J. Cerf, \u201cNo-Go Theorem for Gaussian Quantum Error Correction\u201d, Physical Review Letters 102, (2009). DOI; 0811.3128].", "introduced": "", "description": "Also known as an analog stabilizer code. Oscillator-into-oscillator stabilizer code encoding \\(k\\) logical modes into \\(n\\) physical modes. An \\(((n,k,d))_{\\mathbb{R}}\\) Gaussian stabilizer code is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.\n\nGaussian stabilizer codes admit continuous stabilizer group of displacements. This group can equivalently be defined in terms of its Lie algebra. The codespace is equivalently the common \\(0\\)-eigenvalue eigenspace of the Lie algebra generators, which are mutually commuting linear combinations of oscillator position and momentum operators called nullifiers [M. Gu et al., \u201cQuantum computing with continuous-variable clusters\u201d, Physical Review A 79, (2009). DOI; 0903.3233] or annihilators. A Gaussian stabilizer code admitting a set a set of nullifiers such that each nullifier consists of either position or momentum operators is called a Gaussian CSS code. ", "name": "Gaussian stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Homodyne measurement of nullifiers yields real-valued syndromes, and recovery can be performed by displacements conditional on the syndromes.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "A Gaussian operation acting on position states.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oscillator_stabilizer\noscillators_into_oscillators", "parents_detail": "\n", "parent_of_code_id": "braunstein\nhomological_cv\nlloyd_slotine", "parent_of_detail": "\n\n", "cousins_code_id": "gkp-stabilizer", "cousins_detail": "Gaussian stabilizer codes protect logical modes against artbirarily large displacements on a few modes, while GKP-stabilizer codes protect a finite-dimensional logical space against sufficiently small displacements in any number of modes. Encoding in Gaussian-stabilizer (GKP-stabilizer) codes can be done by a Gaussian operation acting on a tensor product of an arbitrary state in the first mode and position states (GKP states) on the remaining modes. Protection of logical modes against small displacements cannot be done using only Gaussian resources [C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047][J. Eisert, S. Scheel, and M. B. Plenio, \u201cDistilling Gaussian States with Gaussian Operations is Impossible\u201d, Physical Review Letters 89, (2002). DOI; quant-ph/0204052][J. Niset, J. Fiur\u00e1\u0161ek, and N. J. Cerf, \u201cNo-Go Theorem for Gaussian Quantum Error Correction\u201d, Physical Review Letters 102, (2009). DOI; 0811.3128], so GKP-stabilizer codes can be thought of as Gaussian stabilizer encodings utilizing non-Gaussian GKP resource states.", "_type": "ecc", "_page_id": "c_analog_stabilizer", "_href": "c/analog_stabilizer"}, "c_oscillator_stabilizer": {"notes": "", "logical": "", "code_id": "oscillator_stabilizer", "physical": "oscillators", "protection": "Protective properties can be delineated in terms of the nullifiers or displacements, and the most natural noise model for such codes is displacement noise. If an error operator does not commute with a stabilizer group element, then that error is detectable. Oscillator-into-oscillator stabilizer codes protect against erasures of a subset of modes, while GKP codes protect against sufficiently small displacements in any number of modes.", "introduced": "[Richard L. Barnes, \u201cStabilizer Codes for Continuous-variable Quantum Error Correction\u201d. quant-ph/0405064]", "description": "Also known as a continuous-variable (CV) stabilizer code. Bosonic code whose codespace is defined as the common \\(+1\\) eigenspace of a group of mutually commuting displacement operators. Displacements form the stabilizers of the code, and have continuous eigenvalues, in contrast with the discrete set of eigenvalues of qubit stabilizers. As a result, exact codewords are non-normalizable, so approximate constructions have to be considered.\n\nStabilizer codewords encoding a finite-dimensional codespace admit a discrete infinite stabilizer group. Such qudit-into-oscillator stabilizer codes are GKP and multimode GKP codes.\n\nStabilizer codewords encoding a logical oscillator (i.e., CV quantum information) admit either a discrete or a continuous stabilizer group. The former, called GKP-stabilizer codes, are obtained from multimode GKP codes by removing stabilizer generators for some of the modes. The latter can be defined in terms of the continuous group's Lie algebra, i.e., as the common \\(0\\)-eigenvalue eigenspace of mutually commuting linear combinations of oscillator position and momentum operators called nullifiers [M. Gu et al., \u201cQuantum computing with continuous-variable clusters\u201d, Physical Review A 79, (2009). DOI; 0903.3233] or annihilators. An \\(((n,k,d))_{\\mathbb{R}}\\) oscillator-into-oscillator stabilizer code is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.", "name": "Bosonic stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "stabilizer\noscillators", "parents_detail": "\n", "parent_of_code_id": "analog_stabilizer\nmultimodegkp", "parent_of_detail": "\n", "cousin_of_code_id": "group_gkp\nnumber_phase", "cousin_of_detail": "The group-GKP construction encompasses all bosonic CSS codes. For example, a single-mode qubit GKP code corresponds to the \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\) group construction. For another example, an \\([[n,k,d]]_{\\mathbb{R}}\\) oscillator-into-oscillator stabilizer code corresponds to the \\(\\mathbb{R}^{ k_1} \\subseteq \\mathbb{R}^{ k_2} \\subset \\mathbb{R}^{n}\\) group construction, where \\(k=k_2/k_1\\).\nNumber-phase codewords span the joint right eigenspace of the \\(N\\)th power of the Pegg-Barnett phase operator and the bosonic rotation operator [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071]. These operators no longer form a group since the phase operator is not unitary.", "_type": "ecc", "_page_id": "c_oscillator_stabilizer", "_href": "c/oscillator_stabilizer"}, "c_gkp-stabilizer": {"notes": "", "logical": "", "code_id": "gkp-stabilizer", "physical": "oscillators", "protection": "", "introduced": "[K. Noh, S. M. Girvin, and L. Jiang, \u201cEncoding an Oscillator into Many Oscillators\u201d, Physical Review Letters 125, (2020). DOI; 1903.12615]", "description": "Stub.", "name": "GKP-stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "oscillators_into_oscillators\nmultimodegkp", "parents_detail": "\nGKP-stabilizer codes are \\(n\\)-mode GKP codes with less than \\(2n\\) stabilizers. Equivalently, they correspond to multimode GKP codes constructed using a degenerate lattice (see Appx. A of Ref. [J. Conrad, J. Eisert, and F. Arzani, \u201cGottesman-Kitaev-Preskill codes: A lattice perspective\u201d, Quantum 6, 648 (2022). DOI; 2109.14645]).", "cousin_of_code_id": "analog_stabilizer", "cousin_of_detail": "Gaussian stabilizer codes protect logical modes against artbirarily large displacements on a few modes, while GKP-stabilizer codes protect a finite-dimensional logical space against sufficiently small displacements in any number of modes. Encoding in Gaussian-stabilizer (GKP-stabilizer) codes can be done by a Gaussian operation acting on a tensor product of an arbitrary state in the first mode and position states (GKP states) on the remaining modes. Protection of logical modes against small displacements cannot be done using only Gaussian resources [C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047][J. Eisert, S. Scheel, and M. B. Plenio, \u201cDistilling Gaussian States with Gaussian Operations is Impossible\u201d, Physical Review Letters 89, (2002). DOI; quant-ph/0204052][J. Niset, J. Fiur\u00e1\u0161ek, and N. J. Cerf, \u201cNo-Go Theorem for Gaussian Quantum Error Correction\u201d, Physical Review Letters 102, (2009). DOI; 0811.3128], so GKP-stabilizer codes can be thought of as Gaussian stabilizer encodings utilizing non-Gaussian GKP resource states.", "_type": "ecc", "_page_id": "c_gkp-stabilizer", "_href": "c/gkp-stabilizer"}, "c_braunstein": {"notes": "", "logical": "oscillators", "code_id": "braunstein", "physical": "oscillators", "protection": "", "introduced": "[S. L. Braunstein, \u201cError Correction for Continuous Quantum Variables\u201d, Physical Review Letters 80, 4084 (1998). DOI; quant-ph/9711049]", "description": "A \\([[5,1,3]]_{\\mathbb{R}}\\) Gaussian stabilizer analogue of the five-qubit perfect code. ", "name": "Braunstein five-mode code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Error correction can be done using linear-optical elements and feedback [S. L. Braunstein, \u201cQuantum error correction for communication with linear optics\u201d, Nature 394, 47 (1998). DOI].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "analog_stabilizer", "parents_detail": "", "cousins_code_id": "stab_5_1_3", "cousins_detail": "The Braunstein five-mode code is a bosonic analogue of the five-qubit code.", "_type": "ecc", "_page_id": "c_braunstein", "_href": "c/braunstein"}, "c_gkp-cluster-state": {"notes": "", "logical": "qudits", "code_id": "gkp-cluster-state", "physical": "oscillators", "protection": "", "introduced": "[N. C. Menicucci, \u201cFault-Tolerant Measurement-Based Quantum Computing with Continuous-Variable Cluster States\u201d, Physical Review Letters 112, (2014). DOI; 1310.7596]", "description": "Multi-mode code encoding logical qubits into a cluster-state stabilizer code concatenated with a single-mode GKP code. Provides a way to perform a continuous-variable (CV) analogue of fault-tolerant measurement-based qubit computation.\n\nA cluster state of GKP qubits on a graph is made by applying two-mode \\(C_Z\\)-type gates \\(e^{\\pm i \\hat{x}\\otimes\\hat{x}}\\) to a tensor product of \\(|\\overline{+}\\rangle\\) logical GKP states on each vertex. Logical Clifford gates are performed on the cluster state using CV measurement-based computation [N. C. Menicucci et al., \u201cUniversal Quantum Computation with Continuous-Variable Cluster States\u201d, Physical Review Letters 97, (2006). DOI; quant-ph/0605198][M. Gu et al., \u201cQuantum computing with continuous-variable clusters\u201d, Physical Review A 79, (2009). DOI; 0903.3233], i.e., via a combination of linear-optical gates and homodyne measurements on subsets of vertices. Magic-state distillation is required for universal computation. GKP error correction can be naturally combined with CV measurement-based protocols since the performance of both is quantified by a squeezing parameter. ", "name": "GKP cluster-state concatenated code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "Single-mode logical Clifford gates can be performed using Gaussian operations and measurements on a 1D GKP cluster state, while two-mode logical Clifford gates require a 2D cluster state. Magic-state distillation using photon-counting can be used for a non-Clifford logical \\(\\pi/8\\) gate.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "First encoding demonstrating the possibility of fault-tolerant measurement-based computation with CV cluster states. A fault-tolerance threshold can be achieved by concatenating existing fault-tolerant schemes for qubit-based cluster-state encodings with the GKP code [N. C. Menicucci, \u201cFault-Tolerant Measurement-Based Quantum Computing with Continuous-Variable Cluster States\u201d, Physical Review Letters 112, (2014). DOI; 1310.7596].\nHybrid cluster state consisting of GKP qubits at some modes and squeezed states at others has been proposed to work in a fault-tolerant scheme [J. E. Bourassa et al., \u201cBlueprint for a Scalable Photonic Fault-Tolerant Quantum Computer\u201d, Quantum 5, 392 (2021). DOI; 2010.02905].", "parents_code_id": "qudits_into_oscillators\nmultimodegkp", "parents_detail": "\nA GKP-based cluster state is a multimode GKP codeword, although other codewords are not utilized in CV measurement-based computation.", "cousins_code_id": "quantum_concatenated", "cousins_detail": "", "_type": "ecc", "_page_id": "c_gkp-cluster-state", "_href": "c/gkp-cluster-state"}, "c_multimodegkp": {"notes": "", "logical": "qudits", "code_id": "multimodegkp", "physical": "oscillators", "protection": "The level of protection against displacement errors is quantified by the Euclidean code distance \\(\\Delta=\\min_{x\\in {\\mathcal{L}}^{\\perp}\\setminus {\\mathcal{L}}} \\|x\\|_2\\) [J. Conrad, J. Eisert, and F. Arzani, \u201cGottesman-Kitaev-Preskill codes: A lattice perspective\u201d, Quantum 6, 648 (2022). DOI; 2109.14645].", "introduced": "[D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040][J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058]", "description": "Generalization of the GKP code to \\(n\\) bosonic modes whose stabilizer group is an infinite countable group of oscillator displacement operators.\n\nDisplacement operators on \\(n\\) modes can be written as \\begin{align}\nD(\\xi) = \\exp \\left\\{-i \\sqrt{2\\pi} {\\xi}^\\mathrm{T} J \\hat{q} \\right\\} , \\quad \\xi \\in \\mathbb{R}^{2n}~,\n\\end{align} where \\(\\hat{q}\\) is a \\(2n\\)-dimensional vector position and momentum operators of the modes, the symplectic form \\begin{align}\nJ = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} \\otimes I_n = \\begin{pmatrix}\n0 &  I_n \\\\\n-I_n  & 0 \\end{pmatrix}~,\n\\end{align} and \\(I_n\\) is the identity matrix. A group generated by a set of independent displacement operators is given by a lattice \\({\\mathcal{L}}\\) \\begin{align}\n\\langle D(\\xi_1) ,\\dots,  D(\\xi_{m})  \\rangle = \\{ e^{ i \\phi_M (\\xi) } D(\\xi) ~\\vert~ \\xi \\in {\\mathcal{L}} \\}\n\\end{align} and becomes a valid stabilizer group when every symplectic inner product between lattice vectors yields an integer. In other words, the corresponding lattice is symplectically integral, corresponding to an integer-valued symplectic Gram matrix \\(A\\), \\begin{align}\nA_{ij}={\\xi}^T_i J \\xi_j \\in \\mathbb{Z}~.\n\\end{align} The \\(m=2n\\) case yields multimode GKP codes encoding a finite-dimensional logical subspace, while removing some displacements yields GKP-stabilizer codes encoding an infinite-dimensional logical subspace. Codes defined on a hyper-rectangular lattice are CSS GKP codes, and more general lattices, obtained by Gaussian transformations, yield non-CSS codes.\n\nThe centralizer for the stabilizer group within the displacement operators for the \\(m=2n\\) case can be identified with the symplectic dual lattice \\({\\mathcal{L}}^{\\perp}\\) (i.e. all points in \\(\\mathbb{R}^{2n}\\) that have integer symplectic inner product with all points in \\({\\mathcal{L}}\\) ), such that logical operations are identified with the dual quotients \\({\\mathcal{L}}^{\\perp}/{\\mathcal{L}}\\). The size of this dual quotient is the determinant of the Gram matrix, yielding the logical dimension \\(d=\\sqrt{\\| \\det{A}\\|}\\) [D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040].", "name": "Multi-mode GKP code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The MLD decoder for Gaussian displacement errors is realized by evaluating a lattice theta function, and in general the decision can be approximated by either solving (approximating) the closest vector problem (CVP) or by using other effective iterative schemes when e.g. the lattice represents a concatenated GKP code [C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047][K. Noh and C. Chamberland, \u201cFault-tolerant bosonic quantum error correction with the surface\u2013Gottesman-Kitaev-Preskill code\u201d, Physical Review A 101, (2020). DOI; 1908.03579][J. Conrad, J. Eisert, and F. Arzani, \u201cGottesman-Kitaev-Preskill codes: A lattice perspective\u201d, Quantum 6, 648 (2022). DOI; 2109.14645][Nithin Raveendran et al., \u201cFinite Rate QLDPC-GKP Coding Scheme that Surpasses the CSS Hamming Bound\u201d. 2111.07029].", "features_general_gates": "By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements [B. Q. Baragiola et al., \u201cAll-Gaussian Universality and Fault Tolerance with the Gottesman-Kitaev-Preskill Code\u201d, Physical Review Letters 123, (2019). DOI; 1903.00012].", "features_magic_scaling_exponent": "", "features_encoders": "Multi-mode GKP codes with fixed \\(n\\) and prime-dimensional logical Hilbert space are symplectically related to a disjoint product of single-mode GKP codes on \\(n\\) modes, such that encoding via Gaussian unitaries is possible.\nDissipative stabilization of finite-energy GKP states using stabilizers conjugated by cooling ([N. C. Menicucci, \u201cFault-Tolerant Measurement-Based Quantum Computing with Continuous-Variable Cluster States\u201d, Physical Review Letters 112, (2014). DOI; 1310.7596], Appx. B) or damping operator, i.e., a damped exponential of the total occupation number [B. Royer, S. Singh, and S. M. Girvin, \u201cStabilization of Finite-Energy Gottesman-Kitaev-Preskill States\u201d, Physical Review Letters 125, (2020). DOI; 2009.07941][B. Royer, S. Singh, and S. M. Girvin, \u201cEncoding Qubits in Multimode Grid States\u201d, PRX Quantum 3, (2022). DOI; 2201.12337].", "features_rate": "Transmission schemes with multimode GKP codes achieve, up to a constant-factor offset, the capacity of displacement-noise and thermal-noise Gaussian loss channels [J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058][K. Sharma et al., \u201cBounding the energy-constrained quantum and private capacities of phase-insensitive bosonic Gaussian channels\u201d, New Journal of Physics 20, 063025 (2018). DOI; 1708.07257][M. Rosati, A. Mari, and V. Giovannetti, \u201cNarrow bounds for the quantum capacity of thermal attenuators\u201d, Nature Communications 9, (2018). DOI; 1801.04731][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].", "features_transversal_gates": "", "features_fault_tolerance": "Logical Clifford operations are given by Gaussian unitaries, which map bounded-size errors to bounded-size errors [D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040].", "parents_code_id": "oscillator_stabilizer", "parents_detail": "", "parent_of_code_id": "gkp-cluster-state\ngkp-stabilizer\ngkp", "parent_of_detail": "A GKP-based cluster state is a multimode GKP codeword, although other codewords are not utilized in CV measurement-based computation.\nGKP-stabilizer codes are \\(n\\)-mode GKP codes with less than \\(2n\\) stabilizers. Equivalently, they correspond to multimode GKP codes constructed using a degenerate lattice (see Appx. A of Ref. [J. Conrad, J. Eisert, and F. Arzani, \u201cGottesman-Kitaev-Preskill codes: A lattice perspective\u201d, Quantum 6, 648 (2022). DOI; 2109.14645]).\n", "cousins_code_id": "approximate_qecc\npoints_into_lattices", "cousins_detail": "Approximate error-correction offered by GKP codes yields achievable rates that are a constant away from the capacity of Guassian loss channels [J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058][K. Sharma et al., \u201cBounding the energy-constrained quantum and private capacities of phase-insensitive bosonic Gaussian channels\u201d, New Journal of Physics 20, 063025 (2018). DOI; 1708.07257][M. Rosati, A. Mari, and V. Giovannetti, \u201cNarrow bounds for the quantum capacity of thermal attenuators\u201d, Nature Communications 9, (2018). DOI; 1801.04731][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].\nMultimode GKP codes are quantum analogues of lattice-based codes.", "_type": "ecc", "_page_id": "c_multimodegkp", "_href": "c/multimodegkp"}, "c_chuang-leung-yamamoto": {"notes": "", "logical": "qubits", "code_id": "chuang-leung-yamamoto", "physical": "oscillators", "protection": "Protects against amplitude damping for up to \\(t = d-1\\) excitation losses. Defining the spacing between two Fock states \\(|u_1\\cdots u_n\\rangle\\) and \\(|v_1\\cdots v_n\\rangle\\), \\begin{align}\n\\text{Spacing}(u,v) = \\frac{1}{2}\\sum_{i=1}^n |u_i - v_i|,\n\\end{align} the code distance \\(d\\) can be defined as the minimial spacing between Fock states making up the codewords. ", "introduced": "[I. L. Chuang, D. W. Leung, and Y. Yamamoto, \u201cBosonic quantum codes for amplitude damping\u201d, Physical Review A 56, 1114 (1997). DOI]", "description": "Bosonic Fock-state code that encodes \\(k\\) qubits into \\(n\\) oscillators, with each oscillator restricted to having at most \\(N\\) excitations. Codewords are superpositions of oscillator Fock states which have exactly \\(N\\) total excitations, and are either uniform (i.e., balanced) superpositions or unbalanced superpositions. Codes can be denoted as \\([[N,n,2^k,d]]\\), which conflicts with stabilizer code notation.", "name": "Chuang-Leung-Yamamoto code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Destructive decoding with a photon number measurement on each mode.\nState can be decoded with a network of beamsplitters, phase shifters, and Kerr media.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Photon Fock state input into a network of beamsplitters, phase shifters, and Kerr media. These operations all preserve total photon number. Beamsplitters and phase shifters take annihilation operators to linear combinations of annihilation operators, and the transformation matrix is unitary. The operations corresponding to Kerr nonlinear media are diagonal in the Fock basis, but they implement phases that in general depend nonlinearly on the number of photons in each mode. State preparation may require ancillary modes and be conditioned on photon-number measurement results.", "features_rate": "Code rate is \\(\\frac{k}{n \\log_2(N+1)}\\). To correct the loss of up to \\(t\\) excitations with \\(K+1\\) codewords, a code exists with scaling \\(N \\sim t^3 K/2\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "fock_state\nconstant_excitation", "parents_detail": "Chuang-Leung-Yamamoto code are multi-mode Fock-state codes.\nChuang-Leung-Yamamoto codewords are constructed out of Fock states with the same total excitation number.", "parent_of_code_id": "constant_excitation_permutation_invariant", "parent_of_detail": "", "cousin_of_code_id": "binomial", "cousin_of_detail": "Two-mode version of binomial codes correspond to two-mode CLY codes (see Sec. IV.A of Ref. [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008]).", "_type": "ecc", "_page_id": "c_chuang-leung-yamamoto", "_href": "c/chuang-leung-yamamoto"}, "c_wasilewski-banaszek": {"notes": "", "logical": "qubits", "code_id": "wasilewski-banaszek", "physical": "oscillators", "protection": "Protects against single photon loss in any one mode.", "introduced": "[W. Wasilewski and K. Banaszek, \u201cProtecting an optical qubit against photon loss\u201d, Physical Review A 75, (2007). DOI]", "description": "Three-oscillator Fock-state code encoding a single logical qubit using codewords \\begin{align} \\begin{split} |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{3}}(|003\\rangle+|030\\rangle+|300\\rangle)\\\\ |\\overline{1}\\rangle &= |111\\rangle \\end{split}. \\end{align}", "name": "Wasilewski-Banaszek code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Destructive measurement with photon number measurements on each mode.", "features_general_gates": "Single-qubit gates implemented using linear optical networks, sometimes with the addition of auxiliary modes with vacuum input and (conditional) output.", "features_magic_scaling_exponent": "", "features_encoders": "A qubit in the dual-rail code can be transferred to this code via a linear optical network using four ancillary modes, each with one photon input. Successful encoding is conditioned on measuring the state \\(|110\\rangle\\) on the last three modes.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "constant_excitation_permutation_invariant", "parents_detail": "", "_type": "ecc", "_page_id": "c_wasilewski-banaszek", "_href": "c/wasilewski-banaszek"}, "c_dual_rail": {"notes": "For Deutsch's problem [\u201cRapid solution of problems by quantum computation\u201d, Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences 439, 553 (1992). DOI] with optical qubits, error correction using photon number detection reduces the error probability from \\(\\frac{1}{4} (1+e^{-\\gamma}-2e^{-3\\gamma/2}) \\) to \\(\\frac{1}{2} (1- \\text{sech} \\gamma/2)\\).", "logical": "qubits", "code_id": "dual_rail", "physical": "qubits", "protection": "This is an error-detecting code against one photon loss event; it is often used in photonic quantum devices because of its ease of realization. A single loss event can be detected because, after the loss occurs, the output state \\(|00\\rangle\\) is orthogonal to the codespace. Recovery is not possible, so a successful run of a quantum circuit is conditioned on not losing a photon during the circuit.\n\nFor Deutsch''s problem specifically, this code protects against errors resulting in states that have the correct photon number, but in the wrong modes [I. L. Chuang and Y. Yamamoto, \u201cSimple quantum computer\u201d, Physical Review A 52, 3489 (1995). DOI]. ", "introduced": "[I. L. Chuang and Y. Yamamoto, \u201cSimple quantum computer\u201d, Physical Review A 52, 3489 (1995). DOI]", "description": "Two-mode code encoding a logical qubit in Fock states with one excitation. The logical-zero state is represented by \\(|01\\rangle\\), while the logical-one state is represented by \\(|10\\rangle\\).", "name": "Dual-rail quantum code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "General gates are performed using beamsplitters and Kerr non-linearities. Universal quantum computing can be achieved with photons in dual-rail encodings using the KLM protocol [E. Knill, R. Laflamme, and G. J. Milburn, \u201cA scheme for efficient quantum computation with linear optics\u201d, Nature 409, 46 (2001). DOI] with only linear optical elements and photon detectors.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "constant_excitation_permutation_invariant", "parents_detail": "", "_type": "ecc", "_page_id": "c_dual_rail", "_href": "c/dual_rail"}, "c_paircat": {"notes": "", "logical": "qubits", "code_id": "paircat", "physical": "oscillators", "protection": "The occupation-number differences form the syndromes, as opposed to the photon number parity for the single-mode cat code. Any loss even combination that changes the relative differences of photons between modes is a detectable error. The two-mode two-legged paircat code can detect arbitrary single-mode losses, but cannot detect simultaneous photon loss in both modes. An \\(n\\)-mode code can detect any loss errors of at most \\(n-1\\) weight. Higher numbers of legs correspond to more pair-coherent state present in the codewords, and allow for protection against simulataneous losses.", "introduced": "[V. V. Albert et al., \u201cPair-cat codes: autonomous error-correction with low-order nonlinearity\u201d, Quantum Science and Technology 4, 035007 (2019). DOI; 1801.05897]", "description": "Two- or higher-mode extension of cat codes whose codewords are right eigenstates of powers of products of the modes' lowering operators.\n\nTwo-mode codewords are supported by Fock states with occupation number \\(\\hat{n}_2-\\hat{n}_1\\) fixed to some integer \\(\\Delta\\). In the two-legged case, \\(|\\overline{0}_{\\gamma,\\Delta}\\rangle \\sim |\\gamma_\\Delta \\rangle + (-1)^\\Delta |i\\gamma_\\Delta\\rangle\\) and \\(|\\overline{1}_{\\gamma,\\Delta}\\rangle \\sim |\\gamma_\\Delta\\rangle - (-1)^\\Delta |i \\gamma\\rangle\\), where \\begin{align}\n|\\alpha_\\Delta \\rangle \\propto \\sum_{n=0}^\\infty \\frac{\\alpha^{2n+\\Delta}}{\\sqrt{n! (n+\\Delta)!}} |n,n+\\Delta\\rangle\n\\end{align} is the corresponding pair-coherent state [A. O. Barut and L. Girardello, \u201cNew \u201cCoherent\u201d States associated with non-compact groups\u201d, Communications in Mathematical Physics 21, 41 (1971). DOI][G. S. Agarwal, \u201cGeneration of Pair Coherent States and Squeezing via the Competition of Four-Wave Mixing and Amplified Spontaneous Emission\u201d, Physical Review Letters 57, 827 (1986). DOI][G. S. Agarwal, \u201cNonclassical statistics of fields in pair coherent states\u201d, Journal of the Optical Society of America B 5, 1940 (1988). DOI] with complex amplitude \\(\\alpha\\), up to normalization. ", "name": "Pair-cat code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "Hamiltonian \\(X\\), \\(XX\\), \\(Z\\) gates, holonomic \\(Z\\) gate, control-phase gate are available. Many cat-code gates have two-mode analogues for the pair-cat codes.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "fock_state", "parents_detail": "", "cousins_code_id": "cat\nhamiltonian", "cousins_detail": "Cat (pair-cat) codewords are superpositions of coherent (pair-coherent) states. Many cat-code protocols have analogues for the two-mode pair-cat codes.\nTwo-legged pair-cat codewords form ground-state subspace of a multimode Kerr Hamiltonian.", "_type": "ecc", "_page_id": "c_paircat", "_href": "c/paircat"}, "c_chebyshev": {"notes": "", "logical": "", "code_id": "chebyshev", "physical": "", "protection": "The \\(s\\)th-order code corrects errors from the set \\(\\{I,a,a^{\\dagger},{\\hat n},{\\hat n}^2,\\cdots,{\\hat n}^{s-1}\\}\\).", "introduced": "[D. Layden et al., \u201cAncilla-Free Quantum Error Correction Codes for Quantum Metrology\u201d, Physical Review Letters 122, (2019). DOI; 1811.01450]", "description": "Single-mode bosonic Fock-state code that can be used for error-corrected sensing of a signal Hamiltonian \\({\\hat n}^s\\), where \\({\\hat n}\\) is the occupation number operator. Codewords for the \\(s\\)th-order Chebyshev code are \\begin{align}\n\\begin{split}\n\\ket{\\overline 0} &=\\sum_{k \\text{~even}}^{[0,s]} \\tilde{c}_k \\Ket{\\left\\lfloor M\\sin^2\\left( k\\pi/{2s}\\right) \\right\\rfloor},\\\\\n\\ket{\\overline 1} &= \\sum_{k \\text{~odd}}^{[0,s]} \\tilde{c}_k \\Ket{\\left\\lfloor M\\sin^2 \\left(k\\pi/{2s}\\right) \\right\\rfloor},\n\\end{split}\n\\end{align} where \\(\\tilde{c}_k>0\\) can be obtained by solving a system of order \\(O(s^2)\\) linear equations, and where \\(\\lfloor x \\rfloor\\) is the floor function. The code approaches optimality for sensing the signal Hamiltonian as \\(M\\) increases. ", "name": "Chebyshev code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "single-mode\nfock_state\nmetopt", "parents_detail": "\n\n", "cousins_code_id": "binomial", "cousins_detail": "Chebyshev codes resemble binomial codes, and a class of binomial codes have similar error-correcting properties [D. Layden et al., \u201cAncilla-Free Quantum Error Correction Codes for Quantum Metrology\u201d, Physical Review Letters 122, (2019). DOI; 1811.01450].", "_type": "ecc", "_page_id": "c_chebyshev", "_href": "c/chebyshev"}, "c_numopt": {"notes": "", "logical": "qubits", "code_id": "numopt", "physical": "oscillators", "protection": "Number phase codes protect from a finite number of loss events. However, unlike Fock-state codes, their protection does not stem from a Fock-state spacing.", "introduced": "[M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]", "description": "Bosonic Fock-state code obtained from a numerical minimization procedure, e.g., from enforcing error-correction criteria against some number of losses while minimizing average occupation number.\n\nThe smallest numerically optimized code is the \\(\\sqrt(17)\\) code, \\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{\\sqrt{6}}\\left(\\sqrt{7-\\sqrt{17}}|0\\rangle+\\sqrt{\\sqrt{17}-1}|3\\rangle\\right)\\\\\n|\\overline{1}\\rangle&=\\frac{1}{\\sqrt{6}}\\left(\\sqrt{9-\\sqrt{17}}|1\\rangle-\\sqrt{\\sqrt{17}-3}|4\\rangle\\right)~,\n\\end{split}\n\\end{align} correcting a single loss error. The average occupation number of the codewords is \\(\\approx 1.6\\), which is \\(0.4\\) photons lower than that of the smallest binomial code with the same level of protection. ", "name": "Numerically optimized code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "single-mode", "parents_detail": "", "_type": "ecc", "_page_id": "c_numopt", "_href": "c/numopt"}, "c_constant_excitation_permutation_invariant": {"notes": "", "logical": "qubits", "code_id": "constant_excitation_permutation_invariant", "physical": "qubits", "protection": "", "introduced": "[Y. Ouyang and R. Chao, \u201cPermutation-Invariant Constant-Excitation Quantum Codes for Amplitude Damping\u201d, IEEE Transactions on Information Theory 66, 2921 (2020). DOI; 1809.09801]", "description": "Stub. ", "name": "Constant-excitation permutation-invariant code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "permutation_invariant\nchuang-leung-yamamoto", "parents_detail": "\n", "parent_of_code_id": "dual_rail\nwasilewski-banaszek", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_constant_excitation_permutation_invariant", "_href": "c/constant_excitation_permutation_invariant"}, "c_fock_state": {"notes": "", "logical": "qudits", "code_id": "fock_state", "physical": "oscillators", "protection": "Code distance \\(d\\) is the minimum distance (assuming some metric) between any two labels of Fock states corresponding to different code basis states. For a single mode, \\(d\\) is the minimum absolute value of the difference between any two Fock-state labels; such codes can detect up to \\(d-1\\) loss events. Multimode distances can be defined analogously; see, e.g., Chuang-Leung-Yamamoto codes.", "introduced": "", "description": "Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. The simplest example is the dual-rail code, which has codewords consisting of single Fock states \\(|10\\rangle\\) and \\(|01\\rangle\\). This code can detect a single loss error since a loss operator in either mode maps one of the codewords to a different Fock state \\(|00\\rangle\\). More involved codewords consist of several well-separated Fock states such that multiple loss events can be detected and corrected.", "name": "Fock-state bosonic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudits_into_oscillators", "parents_detail": "", "parent_of_code_id": "bosonic_rotation\nchebyshev\nchuang-leung-yamamoto\npaircat", "parent_of_detail": "Single-mode Fock-state codes are typically rotationally invariant.\n\nChuang-Leung-Yamamoto code are multi-mode Fock-state codes.\n", "cousins_code_id": "bits_into_bits\nqubits_into_qubits", "cousins_detail": "Fock-state code distance is a natural extension of Hamming distance between binary strings.\nFock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators [Victor V. Albert, private communication, 2016]. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations [Steven M. Girvin, \u201cIntroduction to Quantum Error Correction and Fault Tolerance\u201d. 2111.08894].", "cousin_of_code_id": "fusion", "cousin_of_detail": "While FBQC is a general framework, an intended application to linear-optical quantum computing will likely utilize small Fock-state bosonic codes such as the dual-rail code.", "_type": "ecc", "_page_id": "c_fock_state", "_href": "c/fock_state"}, "c_binomial": {"notes": "The mean occupation number, or average Fock-state number in maximally-mixed state of the code, is \\((N+1)(S+1)(q-1)/2 \\), where \\(q\\) is the qudit dimension.", "logical": "qudits", "code_id": "binomial", "physical": "oscillators", "protection": "An \\((N, S)\\) binomial code protects against \\(L\\) boson losses, \\(G\\) boson gains, and dephasing up to \\(\\hat{n}^{D}\\), where \\(S=L+G\\) and \\(N = \\mathrm{max}(L,G,2D)\\). Binomial codes approximately protect against continuous-time amplitude damping, boson loss and gain, and dephasing.", "introduced": "[M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008]", "description": "Bosonic rotation codes designed to approximately protect against errors consisting of powers of raising and lowering operators up to some maximum power. Binomial codes can be thought of as spin-coherent states embedded into an oscillator [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]. The \\(q\\)-dimensional qudit \\((N, S)\\) binomial codeword states are \\(\\{|\\overline{i}\\rangle\\mid i\\in \\mathbb Z_q \\}\\), where \\begin{align}\n    |\\overline{i}\\rangle = \\frac{1}{\\sqrt{q^N}} \\sum_{\\substack{p=0\\\\p\\equiv i \\pmod{q}}}^{(q-1)(N+1)} \\sqrt{\\binom{N+1}{p}_q} \\ket{p(S+1)}.\n  \\end{align} The set \\( \\ket{i} \\mid i \\in \\mathbb{N}\\) is the set of Fock states. Also, \\(\\binom{N+1}{p}_q\\) are extended binomial coefficients, or polynomial coeffiients, defined recursively as \\begin{align}\n    \\binom{n}{m}_1 \\equiv 1,\\quad \\binom{n}{m}_q \\equiv \\sum_{k=0}^n \\binom{n}{k}\\binom{k}{m-k}_{q-1}.\n  \\end{align} The extended binomial coefficients \\( \\binom{n}{m}_q \\) are also the coefficients of \\( x^m \\) in the polynomial \\( (1 + x + \\cdots + x^{q-1})^n \\). ", "name": "Binomial code", "realizations": "Microwave cavities coupled to superconducting circuits: state transfer between a binomial codeword to another system [C. J. Axline et al., \u201cOn-demand quantum state transfer and entanglement between remote microwave cavity memories\u201d, Nature Physics 14, 705 (2018). DOI; 1712.05832], error-correction protocol nearly reaching break-even [L. Hu et al., \u201cQuantum error correction and universal gate set operation on a binomial bosonic logical qubit\u201d, Nature Physics 15, 503 (2019). DOI; 1805.09072], and a teleported CNOT gate [Y. Xu et al., \u201cDemonstration of Controlled-Phase Gates between Two Error-Correctable Photonic Qubits\u201d, Physical Review Letters 124, (2020). DOI; 1810.04690].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Photon loss and dephasing errors can be detected by measuring the phase-space rotation \\(\\exp\\left(2\\pi\\mathrm{i} \\hat{n} / (S+1)\\right)\\) and the check operator \\(J_x/J\\) in the spin-coherent state language, where \\(J\\) is the total angular momentum and \\(J_x\\) is the angular momentum in the \\(x\\) direction [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]. This type of error correction fails for errors that are products of photon loss/gain and dephasing errors. However, for certain \\((N,S)\\) instances of the binomial code, detection of these types of errors can be done.\nRecovery can be done via projective measurements and unitary operations [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "bosonic_rotation", "parents_detail": "One can verify by direct calculation that the logical states are eigenstates of the discrete rotation operator. One has freedom in the exact form of the primitive state to choose; see Appendix B.2 of Ref. [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "cousins_code_id": "cat\nnumber_phase\nchuang-leung-yamamoto", "cousins_detail": "For a fixed \\(S\\), binomial codes with \\(N \\to \\infty\\) coincide with cat codes as \\(\\alpha \\to \\infty\\) [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008].\nIn the limit as \\(N,S \\to \\infty\\), phase measurement in the binomial code has vanishing variance, just like in a number-phase code [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nTwo-mode version of binomial codes correspond to two-mode CLY codes (see Sec. IV.A of Ref. [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008]).", "cousin_of_code_id": "chebyshev\ngnu_permutation_invariant\nstab_4_2_2", "cousin_of_detail": "Chebyshev codes resemble binomial codes, and a class of binomial codes have similar error-correcting properties [D. Layden et al., \u201cAncilla-Free Quantum Error Correction Codes for Quantum Metrology\u201d, Physical Review Letters 122, (2019). DOI; 1811.01450].\nBinomial codes and GNU codes are both related to spin-coherent states, and a qudit generalization can be obtained from qudit binomial codes ([V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010], Appx. C).\n\\([[4,1,2]]\\) subcode consisting of \\(\\{|\\overline{00}\\rangle\\) and any other codeword reduces to the \\(0,2,4\\) binomial code when the basis labels in each codeword are written as in base-ten. Such a mapping can be generalized [Linshu Li, private communication, 2018].", "_type": "ecc", "_page_id": "c_binomial", "_href": "c/binomial"}, "c_bosonic_rotation": {"notes": "", "logical": "qudits", "code_id": "bosonic_rotation", "physical": "oscillators", "protection": "Losses or gains less than \\(N\\) are detectable. Dephasing rotations \\(\\exp(\\mathrm{i}\\theta \\hat{n})\\) can be detected whenever \\(\\theta\\) is roughly less than \\(\\pi/N\\). To get precise bounds on \\(\\theta\\), one needs to analyze the particular bosonic rotation code.", "introduced": "[A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071]", "description": "A single-mode Fock-state bosonic code whose codespace is preserved by a phase-space rotation by a multiple of \\(2\\pi/N\\) for some \\(N\\). The rotation symmetry ensures that encoded states have support only on every \\(N^{\\textrm{th}}\\) Fock state. For example, single-mode Fock-state codes for \\(N=2\\) encoding a qubit admit basis states that are, respectively, supported on Fock state sets \\(\\{|0\\rangle,|4\\rangle,|8\\rangle,\\cdots\\}\\) and \\(\\{|2\\rangle,|6\\rangle,|10\\rangle,\\cdots\\}\\).\n\nEncoding of a \\(q\\)-dimensional logical qudit admit a basis whose elements are eigenstates of the rotation operator \\(\\exp\\left(\\mathrm{i} 2\\pi \\hat{n}/qN \\right)\\), where \\(\\hat{n}\\) is the number operator diagonal in the Fock basis. Basis elements are of the form \\(\\sum_{j=0}^\\infty c_j |(kq+j)N \\rangle\\) for some coefficients \\(c_j\\) and \\(k\\). This is because the rotation acting on a general Fock-state superposition \\(\\sum_n a_n |n\\rangle\\) yields \\(\\sum_n a_n \\exp\\left(\\mathrm{i} 2\\pi n / qN \\right) |n\\rangle\\). In order for a codeword to be an eigenvector of this operation, \\(a_n\\) must be zero whenever \\(n \\neq (kq+j)N\\) for some \\(k\\).\n\nCodewords can be uniquely specified by choosing a primitive state \\(|\\Theta\\rangle\\). To ensure valid (orthogonal and nonzero) codewords, \\(|\\Theta\\rangle\\) must satisfy the following requirement: for each \\(j \\in \\mathbb{Z}_q\\), \\(|\\Theta\\rangle\\) must have support on the Fock state \\(|(k_j q+j)N\\rangle\\) for at least one \\(k_j \\in \\mathbb{N}_0\\). From such a primitive, the codewords \\(\\{|\\overline{j}\\rangle \\mid j \\in \\mathbb{Z}_q\\}\\) are constructed as \\begin{align}\n|\\overline{j}\\rangle \\propto \\sum_{m=0}^{2N-1} \\mathrm{e}^{2\\pi \\mathrm{i} m (\\hat n  / N + j) / q} |\\Theta\\rangle~.\n\\end{align}", "name": "Bosonic rotation code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "One can distinguish (destructively) the codewords by performing a Fock-state number measurement. If a Fock state state \\(|n\\rangle\\) is measured, then one rounds to the nearest integer of the form \\((kq+j)/N\\), and deduces that the true state was \\(|\\overline{j}\\rangle\\).\nOne can distinguish states in the dual basis by performing phase estimation on \\(\\mathrm{e}^{\\mathrm{i} \\theta \\hat n}\\). One then rounds the resulting \\(\\theta\\) to the nearest number \\(2\\pi j / qN\\) in order to determine which dual basis state \\(j \\in \\mathbb Z_q\\) it came from.\nAutonomous quantum error correction schemes for \\(S=1\\) codes [S. Kwon, S. Watabe, and J.-S. Tsai, \u201cAutonomous quantum error correction in a four-photon Kerr parametric oscillator\u201d, npj Quantum Information 8, (2022). DOI; 2203.09234].", "features_general_gates": "The logical Pauli-\\(Z\\) gate can be the discrete rotation operator \\(\\mathrm{e}^{\\mathrm{i} \\pi \\hat n /N}\\), and the logical Pauli-\\(X\\) gate can be the (note: non-unitary) number-translation operator \\(\\sum_{n=0}^\\infty |n\\rangle\\bra{n+N}\\).\nFor qubit codes, a logical phase gate is \\(S = \\mathrm{e}^{\\pi \\mathrm{i} \\hat n^2 / 2N^2}\\).\nThe \\(T = \\mathrm{diag}(1,\\exp(\\mathrm{i}\\pi/4))\\) gate can be done via gate teleportation and a resource state \\(\\vert 0_N\\rangle + \\exp(\\mathrm{i}\\pi/4) \\vert 1_N \\rangle\\).\nA controlled-rotation gate between an order \\(N\\) rotation code and an order \\(M\\) rotation code is \\(\\mathrm{CROT}_{NM} = \\mathrm{e}^{(2\\pi\\mathrm{i} / qNM) \\hat n \\otimes \\hat n}\\).", "features_magic_scaling_exponent": "", "features_encoders": "The optimal way to prepare codewords depends on the exact rotation code in question [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "single-mode\nfock_state", "parents_detail": "\nSingle-mode Fock-state codes are typically rotationally invariant.", "parent_of_code_id": "binomial\ncat\nnumber_phase", "parent_of_detail": "One can verify by direct calculation that the logical states are eigenstates of the discrete rotation operator. One has freedom in the exact form of the primitive state to choose; see Appendix B.2 of Ref. [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nThe cat code is a bosonic rotation code whose primitive state is the coherent state \\(|\\alpha\\rangle\\) [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nNumber-phase codes are bosonic rotation codes with the primitive state is a Pegg-Barnett phase state [S. M. Barnett and D. T. Pegg, \u201cPhase in quantum optics\u201d, Journal of Physics A: Mathematical and General 19, 3849 (1986). DOI].", "_type": "ecc", "_page_id": "c_bosonic_rotation", "_href": "c/bosonic_rotation"}, "c_cat": {"notes": "Pedagogical introduction to cat codes in the context of microwave cavities can be found in Refs. [J\u00e9r\u00e9mie Guillaud, Joachim Cohen, and Mazyar Mirrahimi, \u201cQuantum computation with cat qubits\u201d. 2203.03222][Shruti Puri, QEC when the noise is biased, 2019.], and in the context of optical systems in books [S. Haroche and J.-M. Raimond, Exploring the Quantum (Oxford University Press, 2006). DOI][H. Bachor and T. C. Ralph, A Guide to Experiments in Quantum Optics (Wiley, 2019). DOI].", "logical": "qubits", "code_id": "cat", "physical": "oscillators", "protection": "Due to the spacing between sets of Fock states, the distance between two distinct logical states is \\(d=S+1\\). Hence, this code is able to detect \\(S\\)-photon loss error. Two-legged cat codes (\\(S=0\\)) do not protect against loss events, but there exist modifications based on sign alternation [L. Li et al., \u201cPhase-engineered bosonic quantum codes\u201d, Physical Review A 103, (2021). DOI; 1901.05358] or squeezing [David S. Schlegel, Fabrizio Minganti, and Vincenzo Savona, \u201cQuantum error correction using squeezed Schr\u00f6dinger cat states\u201d. 2201.02570] that add such protection.", "introduced": "[P. T. Cochrane, G. J. Milburn, and W. J. Munro, \u201cMacroscopically distinct quantum-superposition states as a bosonic code for amplitude damping\u201d, Physical Review A 59, 2631 (1999). DOI; quant-ph/9809037][Z. Leghtas et al., \u201cHardware-Efficient Autonomous Quantum Memory Protection\u201d, Physical Review Letters 111, (2013). DOI; 1207.0679]", "description": "Rotation-symmetric bosonic Fock-state code encoding a \\(q\\)-dimensional qudit into one oscillator. Codewords for a qubit code (\\(q=2\\)) consist of a coherent state \\(|\\alpha\\rangle\\) projected onto a subspace of Fock state number modulo \\(2(S+1)\\). The logical state \\(|\\overline{0}\\rangle\\) is in the \\(\\{|0\\rangle , |2(S+1)\\rangle , |4(S+1)\\rangle \\cdots \\}\\) Fock-state subspace, while \\(|\\overline{1}\\rangle\\) is in the \\(\\{|(S+1)\\rangle, |3(S+1)\\rangle , |5(S+1)\\rangle , |7(S+1)\\rangle \\cdots \\}\\) subspace. An alternative basis, valid for for general \\(q\\) and \\(\\alpha\\neq 0\\), consists of \\(q\\) coherent states distributed equidistanctly around a circle in phase space of radius \\(\\alpha\\). ", "name": "Cat code", "realizations": "Two-legged (\\(S=0\\)) Lindbladian-based [Z. Leghtas et al., \u201cConfining the state of light to a quantum manifold by engineered two-photon loss\u201d, Science 347, 853 (2015). DOI; 1412.4633][S. Touzard et al., \u201cCoherent Oscillations inside a Quantum Manifold Stabilized by Dissipation\u201d, Physical Review X 8, (2018). DOI; 1705.02401] and Hamiltonian-based 'Kerr-cat' encoding [A. Grimm et al., \u201cStabilization and operation of a Kerr-cat qubit\u201d, Nature 584, 205 (2020). DOI; 1907.12131] has been achieved in superconducting circuit devices by the Devoret group; Ref. [S. Touzard et al., \u201cCoherent Oscillations inside a Quantum Manifold Stabilized by Dissipation\u201d, Physical Review X 8, (2018). DOI; 1705.02401] also demonstrated a displacement-based gate. The Lindbladian-based scheme has further achieved a suppression of bit-flip errors that is exponential in the average photon number [R. Lescanne et al., \u201cExponential suppression of bit-flips in a qubit encoded in an oscillator\u201d, Nature Physics 16, 509 (2020). DOI; 1907.11729] up to a bit-flip time of 1ms. A bit-flip time of 1s has been achieved in a similar system in the classical bit regime [C. Berdou et al., \u201cOne hundred second bit-flip time in a two-photon dissipative oscillator\u201d. 2204.09128].\nFour-legged (\\(S=1\\)) cat code has been realized in a superconducting circuit device [Nissim Ofek et al., \u201cDemonstrating Quantum Error Correction that Extends the Lifetime of Quantum Information\u201d. 1602.04768]. This paper is the first to reach break-even error-correction, where the lifetime of a logical qubit is on par with the lifetime of the noisiest constituent of the system.\nApproximate version of the \\(S=0\\) code realized in a superconducting circuit device by the Wang group [J. M. Gertler et al., \u201cProtecting a bosonic qubit with autonomous quantum error correction\u201d, Nature 590, 243 (2021). DOI; 2004.09322].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Measurement in the Fock basis. For a \\(2(S+1)\\) cat code, a number measurement returns outcome \\(2(S+1)k\\), if \\(k\\) is even, then it corresponds to logical 0 state; if \\(k\\) is odd, then it corresponds to logical 1 state.", "features_general_gates": "For \\(S=0\\), universal gates in the quantum optical setting can be performed using teleportation, Bell measurements, displacements, and rotations [T. C. Ralph et al., \u201cQuantum computation with optical coherent states\u201d, Physical Review A 68, (2003). DOI; quant-ph/0306004].\nFor \\(S=0\\), universal gates in the microwave setting can be performed using displacement operators and a rotation based on the Kerr nonlinearity [M. Mirrahimi et al., \u201cDynamically protected cat-qubits: a new paradigm for universal quantum computation\u201d, New Journal of Physics 16, 045014 (2014). DOI; 1312.2017]. For \\(S=1\\), squeezing replaces displacements.\nHolonomic gates utilizing the Berry phase of coherent states are universal [V. V. Albert et al., \u201cHolonomic Quantum Control with Continuous Variable Systems\u201d, Physical Review Letters 116, (2016). DOI; 1503.00194].\nBias-preserving Hamiltonian-based CNOT gate utilizing an \\(X\\) gate with a topological Berry phase [J. Guillaud and M. Mirrahimi, \u201cRepetition Cat Qubits for Fault-Tolerant Quantum Computation\u201d, Physical Review X 9, (2019). DOI; 1904.09474][S. Puri et al., \u201cBias-preserving gates with stabilized cat qubits\u201d, Science Advances 6, (2020). DOI; 1905.00450].", "features_magic_scaling_exponent": "", "features_encoders": "Lindbladian-based dissipative encoding [M. Mirrahimi et al., \u201cDynamically protected cat-qubits: a new paradigm for universal quantum computation\u201d, New Journal of Physics 16, 045014 (2014). DOI; 1312.2017] utilizing multi-photon absorption [M. Wolinsky and H. J. Carmichael, \u201cQuantum noise in the parametric oscillator: From squeezed states to coherent-state superpositions\u201d, Physical Review Letters 60, 1836 (1988). DOI][L. Krippner, W. J. Munro, and M. D. Reid, \u201cTransient macroscopic quantum superposition states in degenerate parametric oscillation: Calculations in the large-quantum-noise limit using the positive<i>P</i>representation\u201d, Physical Review A 50, 4330 (1994). DOI][E. E. Hach III and C. C. Gerry, \u201cGeneration of mixtures of Schr\u00f6dinger-cat states from a competitive two-photon process\u201d, Physical Review A 49, 490 (1994). DOI][L. Gilles, B. M. Garraway, and P. L. Knight, \u201cGeneration of nonclassical light by dissipative two-photon processes\u201d, Physical Review A 49, 2785 (1994). DOI]. Encoding passively protects against cavity dephasing, suppressing dephasing noise exponentially with \\(\\alpha^2\\) [M. Mirrahimi et al., \u201cDynamically protected cat-qubits: a new paradigm for universal quantum computation\u201d, New Journal of Physics 16, 045014 (2014). DOI; 1312.2017].\nHamiltonian-based 'Kerr-cat' encoding utilizing the Kerr effect [S. Puri, S. Boutin, and A. Blais, \u201cEngineering the quantum states of light in a Kerr-nonlinear resonator by two-photon driving\u201d, npj Quantum Information 3, (2017). DOI; 1605.09408] (see also Ref. [H. Goto, \u201cBifurcation-based adiabatic quantum computation with a nonlinear oscillator network\u201d, Scientific Reports 6, (2016). DOI; 1510.02566]).\nCombined dissipative and Hamiltonian-based encoding utilizing two-photon exchange for \\(S=0\\) codes [Ronan Gautier, Alain Sarlette, and Mazyar Mirrahimi, \u201cCombined Dissipative and Hamiltonian Confinement of Cat Qubits\u201d. 2112.05545].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Bias-preserving Hamiltonian-based CNOT gate [S. Puri et al., \u201cBias-preserving gates with stabilized cat qubits\u201d, Science Advances 6, (2020). DOI; 1905.00450] is part of a universal bias-preserving gate set that can be made fault tolerant using concatenation [J. Guillaud and M. Mirrahimi, \u201cRepetition Cat Qubits for Fault-Tolerant Quantum Computation\u201d, Physical Review X 9, (2019). DOI; 1904.09474][S. Puri et al., \u201cBias-preserving gates with stabilized cat qubits\u201d, Science Advances 6, (2020). DOI; 1905.00450].\nAncilla qubits encoded in cat codes yield fault-tolerant syndrome extraction circuits [S. Puri et al., \u201cStabilized Cat in a Driven Nonlinear Cavity: A Fault-Tolerant Error Syndrome Detector\u201d, Physical Review X 9, (2019). DOI; 1807.09334].", "parents_code_id": "bosonic_rotation", "parents_detail": "The cat code is a bosonic rotation code whose primitive state is the coherent state \\(|\\alpha\\rangle\\) [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "cousins_code_id": "number_phase\nhamiltonian", "cousins_detail": "In the limit as \\(N,S \\to \\infty\\), phase measurement in the cat code has vanishing variance, just like in a number-phase code [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nTwo-legged cat codewords form ground-state subspace of a Kerr Hamiltonian [S. Puri, S. Boutin, and A. Blais, \u201cEngineering the quantum states of light in a Kerr-nonlinear resonator by two-photon driving\u201d, npj Quantum Information 3, (2017). DOI; 1605.09408].", "cousin_of_code_id": "binomial\npaircat", "cousin_of_detail": "For a fixed \\(S\\), binomial codes with \\(N \\to \\infty\\) coincide with cat codes as \\(\\alpha \\to \\infty\\) [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008].\nCat (pair-cat) codewords are superpositions of coherent (pair-coherent) states. Many cat-code protocols have analogues for the two-mode pair-cat codes.", "_type": "ecc", "_page_id": "c_cat", "_href": "c/cat"}, "c_number_phase": {"notes": "", "logical": "qubits", "code_id": "number_phase", "physical": "oscillators", "protection": "Number-phase codes of order \\(N\\) detect up to \\(N\\) photon loss or gain errors, and dephasing up to \\(\\theta = \\pi/N\\).", "introduced": "[A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071]", "description": "Bosonic rotation code consisting of superpositions of Pegg-Barnett phase states [S. M. Barnett and D. T. Pegg, \u201cPhase in quantum optics\u201d, Journal of Physics A: Mathematical and General 19, 3849 (1986). DOI], \\begin{align}\n|\\phi\\rangle \\equiv \\frac{1}{\\sqrt{2\\pi}}\\sum_{n=0}^{\\infty} \\mathrm{e}^{\\mathrm{i} n \\phi} \\ket{n}.\n\\end{align} Since phase states and thus the ideal codewords are not normalizable, approximate versions need to be constructed. The codes' key feature is that, in the ideal case, phase measurement has zero uncertainty, making it a good canditate for a syndrome measurement.\n\nLogical states of an order-\\(N\\) number-phase qubit encoding are \\(|\\overline{0}\\rangle= \\sum_{m=0}^{2N-1} |\\phi = m\\pi/N\\rangle\\) and \\(|\\overline{1}\\rangle = \\sum_{m=0}^{2N-1} (-1)^m |\\phi=m\\pi/N\\rangle\\). By performing the summation over \\(m\\), one finds that \\(|\\overline{0}\\rangle\\) is supported on Fock states \\(|2kN\\rangle\\), while \\(|\\overline{1}\\rangle\\) is supported on states \\(|(2k+1)N\\rangle\\), for \\(k \\geq 0\\). ", "name": "Number-phase code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Modular phase measurement done in the logical \\(X\\), or dual, basis has zero uncertainty in the case of ideal number phase codes. Approximate number-phase codes are characterized by vanishing phase uncertainty. Such measurements can be utilized for Knill error correction (a.k.a. telecorrection [C. M. Dawson, H. L. Haselgrove, and M. A. Nielsen, \u201cNoise thresholds for optical cluster-state quantum computation\u201d, Physical Review A 73, (2006). DOI; quant-ph/0601066]), which is based on teleportation [E. Knill, \u201cQuantum computing with realistically noisy devices\u201d, Nature 434, 39 (2005). DOI; quant-ph/0410199][E. Knill, \u201cScalable Quantum Computation in the Presence of Large Detected-Error Rates\u201d. quant-ph/0312190]. This type of error correction substitutes the complicated correction procedures typical in Fock-state codes for necessity of clean codewords [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nNumber measurement can be done by extracting modular number information using a CROT gate \\(\\mathrm{e}^{(2\\pi \\mathrm{i} / NM) \\hat n \\otimes \\hat n}\\) and performing phase measurements [C. W. Helstrom, \u201cQuantum detection and estimation theory\u201d, Journal of Statistical Physics 1, 231 (1969). DOI][A. Holevo, Probabilistic and Statistical Aspects of Quantum Theory (Edizioni della Normale, 2011). DOI] on an ancillary mode. See Section 4.B.1 of Ref. [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Fault-tolerant computation schemes with number-phase codes have been proposed based on concatenation with Bacon-Shor subsystem codes [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "parents_code_id": "bosonic_rotation", "parents_detail": "Number-phase codes are bosonic rotation codes with the primitive state is a Pegg-Barnett phase state [S. M. Barnett and D. T. Pegg, \u201cPhase in quantum optics\u201d, Journal of Physics A: Mathematical and General 19, 3849 (1986). DOI].", "cousins_code_id": "rotor_gkp\noscillator_stabilizer\ngkp", "cousins_detail": "Number-phase codes are a manifestation of planar-rotor GKP codes in an oscillator. Both codes protect against small shifts in angular degrees of freedom.\nNumber-phase codewords span the joint right eigenspace of the \\(N\\)th power of the Pegg-Barnett phase operator and the bosonic rotation operator [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071]. These operators no longer form a group since the phase operator is not unitary.\nGKP codes utilize translational symmetry in phase space, while number-phase codes utilize rotational symmetry. The two are related via a mapping [Allan D. C. Tosta, Thiago O. Maciel, and Leandro Aolita, \u201cGrand Unification of continuous-variable codes\u201d. 2206.01751].", "cousin_of_code_id": "binomial\ncat", "cousin_of_detail": "In the limit as \\(N,S \\to \\infty\\), phase measurement in the binomial code has vanishing variance, just like in a number-phase code [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nIn the limit as \\(N,S \\to \\infty\\), phase measurement in the cat code has vanishing variance, just like in a number-phase code [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "_type": "ecc", "_page_id": "c_number_phase", "_href": "c/number_phase"}, "c_rotor": {"notes": "", "logical": "groups", "code_id": "rotor", "physical": "groups", "protection": "", "introduced": "", "description": "Encodes a logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space of \\(\\ell^2\\)-normalizable functions on either the integers \\(\\mathbb Z\\) or the circle group \\(U(1)\\).", "name": "Rotor code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "group_quantum", "parents_detail": "", "parent_of_code_id": "rotor_gkp\nrotor_3_1_2\nrotor_5_1_3", "parent_of_detail": "\n\n", "_type": "ecc", "_page_id": "c_rotor", "_href": "c/rotor"}, "c_rotor_5_1_3": {"notes": "", "logical": "", "code_id": "rotor_5_1_3", "physical": "", "protection": "Normalized codewords approximately protect against erasure while maintaining covariance [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]. ", "introduced": "[P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]", "description": "Extension of the \\([[5,1,3]]\\) qubit stabilizer code to the integer alphabet, i.e., the angular momentum states of a planar rotor. The code is \\(U(1)\\)-covariant and ideal codewords are not normalizable. ", "name": "\\([[5,1,3]]_{\\mathbb Z}\\) rotor code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "rotor\ncovariant", "parents_detail": "\nThe \\([[5,1,3]]_{\\mathbb Z}\\) code is \\(U(1)\\)-covariant.", "cousins_code_id": "stab_5_1_3", "cousins_detail": "", "_type": "ecc", "_page_id": "c_rotor_5_1_3", "_href": "c/rotor_5_1_3"}, "c_group_quantum": {"notes": "", "logical": "groups", "code_id": "group_quantum", "physical": "groups", "protection": "", "introduced": "", "description": "Encodes a logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space of \\(\\ell^2\\)-normalizable functions on a second-countable unimodular group. For \\(K\\)-dimensional logical subspace and for groups \\(G^{n}\\), can be denoted as \\(((n,K))_G\\). When the logical subspace is the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(G^{ k}\\), can be denoted as \\([[n,k]]_G\\). Ideal codewords may not be normalizable, depending on whether \\(G\\) is continuous and/or noncompact, so approximate versions have to be constructed in practice.", "name": "Group-based quantum code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "group_gkp\nrotor", "parent_of_detail": "\n", "cousins_code_id": "qubits_into_qubits\nqudits_into_qudits\noscillators", "cousins_detail": "Group quantum codes whose physical spaces are constructed using the group \\(\\mathbb{Z}_2\\) are qubit codes.\nGroup quantum codes whose physical spaces are constructed using modular-integer groups \\(\\mathbb{Z}_q\\) are modular-qudit codes.\nGroup quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes.", "cousin_of_code_id": "group_classical", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_group_quantum", "_href": "c/group_quantum"}, "c_rotor_gkp": {"notes": "", "logical": "qudits", "code_id": "rotor_gkp", "physical": "groups", "protection": "", "introduced": "[D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040][V. V. Albert, J. P. Covey, and J. Preskill, \u201cRobust Encoding of a Qubit in a Molecule\u201d, Physical Review X 10, (2020). DOI; 1911.00099]", "description": "GKP code protecting against small angular position and momentum shifts of a planar rotor.", "name": "Rotor GKP code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "rotor", "parents_detail": "", "cousins_code_id": "gkp", "cousins_detail": "GKP (rotor GKP) codes protect against shifts in linear (angular) degrees of freedom.", "cousin_of_code_id": "number_phase", "cousin_of_detail": "Number-phase codes are a manifestation of planar-rotor GKP codes in an oscillator. Both codes protect against small shifts in angular degrees of freedom.", "_type": "ecc", "_page_id": "c_rotor_gkp", "_href": "c/rotor_gkp"}, "c_molecular": {"notes": "Physical space characterizes orientations of a rigid body in 3D, which correspond to rotational states of an asymmetric molecule. See APS Physics Synopsis [E. K. Carlson, \u201cProtecting Molecular Qubits from Noise\u201d, Physics 13, (2020). DOI] and Physical Review Journal club discussing molecular applications.", "logical": "rigid_bodies", "code_id": "molecular", "physical": "groups", "protection": "Protects against generalized bit-flip errors \\(g\\in SO_3\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "introduced": "[V. V. Albert, J. P. Covey, and J. Preskill, \u201cRobust Encoding of a Qubit in a Molecule\u201d, Physical Review X 10, (2020). DOI; 1911.00099]", "description": "Encodes finite-dimensional Hilbert space into the Hilbert space of \\(\\ell^2\\)-normalizable functions on the group \\(SO_3\\). Construction is based on nested subgroups \\(H\\subset K \\subset SO_3\\), where \\(H,K\\) are finite. The \\(|K|/|H|\\)-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\).", "name": "Molecular code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "group_gkp", "parents_detail": "", "_type": "ecc", "_page_id": "c_molecular", "_href": "c/molecular"}, "c_quantum_double": {"notes": "The \\( \\Phi, \\Lambda \\) Decodoku game is based on the quantum double model for the group \\(S_3\\) of permutations on three letters.", "logical": "groups", "code_id": "quantum_double", "physical": "groups", "protection": "Error-correcting properties established in Ref. [S. X. Cui et al., \u201cKitaev's quantum double model as an error correcting code\u201d, Quantum 4, 331 (2020). DOI; 1908.02829]. The code distance is the number of edges in the shortest non contractible cycle in the tesselation or dual tesselation [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143].", "introduced": "[A. Y. Kitaev, \u201cFault-tolerant quantum computation by anyons\u201d, Annals of Physics 303, 2 (2003). DOI; quant-ph/9707021]", "description": "A family of topological codes, defined by a finite group \\( G \\), whose generators are few-body operators associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit of dimension \\( |G| \\) located at each edge of the tesselation).\n\nThe physical Hilbert space has dimension \\( |G|^E  \\), where \\( E \\) is the number of edges in the tessellation. The dimension of the code space is the number of orbits of the conjugation action of \\( G \\) on \\( \\text{Hom}(\\pi_1(\\Sigma),G) \\), the set of group homomorphisms from the fundamental group of the surface \\( \\Sigma \\) into the finite group \\( G \\) [S. X. Cui et al., \u201cKitaev's quantum double model as an error correcting code\u201d, Quantum 4, 331 (2020). DOI; 1908.02829]. When \\( G \\) is abelian, the formula for the dimension simplifies to \\( |G|^{2g} \\), where \\( g \\) is the genus of the surface \\( \\Sigma \\).\n\nThe codespace is the ground-state subspace of the quantum double model Hamiltonian. For nonabelian groups, alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model [R. Walter Ogburn and J. Preskill, \u201cTopological Quantum Computation\u201d, Quantum Computing and Quantum Communications 341 (1999). DOI][C. Mochon, \u201cAnyon computers with smaller groups\u201d, Physical Review A 69, (2004). DOI; quant-ph/0306063][J. K. Pachos, Introduction to Topological Quantum Computation (Cambridge University Press, 2009). DOI]. The fusion space of such nonabelian anyons has dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.", "name": "Quantum-double code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "For any solvable group \\(G\\), topological charge measurements can be done with an adaptive constant-depth circuit with geometrically local gates and measurements throughout [Sergey Bravyi et al., \u201cAdaptive constant-depth circuits for manipulating non-abelian anyons\u201d. 2205.01933].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit [G. K. Brennen, M. Aguado, and J. I. Cirac, \u201cSimulations of quantum double models\u201d, New Journal of Physics 11, 053009 (2009). DOI; 0901.1345][M. Aguado, \u201cFrom entanglement renormalisation to the disentanglement of quantum double models\u201d, Annals of Physics 326, 2444 (2011). DOI; 1101.0527] or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates [M. Aguado and G. Vidal, \u201cEntanglement Renormalization and Topological Order\u201d, Physical Review Letters 100, (2008). DOI; 0712.0348].\nFor any solvable group \\(G\\), ground-state preparation and anyon-pair creation can be done with an adaptive constant-depth circuit with geometrically local gates and measurements throughout [Sergey Bravyi et al., \u201cAdaptive constant-depth circuits for manipulating non-abelian anyons\u201d. 2205.01933] (see Ref. [Ruben Verresen, Nathanan Tantivasadakarn, and Ashvin Vishwanath, \u201cEfficiently preparing Schr\u00f6dinger's cat, fractons and non-Abelian topological order in quantum devices\u201d. 2112.03061] for specific dihedral groups). Anyon-pair creation requires an adaptive circuit for any nonabelian \\(G\\) [Sergey Bravyi et al., \u201cAdaptive constant-depth circuits for manipulating non-abelian anyons\u201d. 2205.01933].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "group_gkp\ntopological", "parents_detail": "Quantum-double models admit stabilizer-like \\(X\\)- and \\(Z\\)-type operators [Victor V. Albert et al., \u201cSpin chains, defects, and quantum wires for the quantum-double edge\u201d. 2111.12096], and the codes can be formulated as group GKP codes.\nQuantum-double code Hamiltonians admit topological phases associated with finite groups \\(G\\).", "cousins_code_id": "qudit_surface\nstring_net", "cousins_detail": "A quantum-double model with \\(G=\\mathbb{Z}_q\\) is the qudit surface code.\nString-net model reduces to the quantum-double model for group categories.", "cousin_of_code_id": "surface", "cousin_of_detail": "A quantum-double model with \\(G=\\mathbb{Z}_2\\) is the surface code.", "_type": "ecc", "_page_id": "c_quantum_double", "_href": "c/quantum_double"}, "c_rotor_3_1_2": {"notes": "", "logical": "", "code_id": "rotor_3_1_2", "physical": "", "protection": "Normalized codewords approximately protect against erasure while maintaining covariance [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]. ", "introduced": "[P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471]", "description": "Extension of the \\([[3,1,2]]_3\\) qutrit CSS code to the integer alphabet, i.e., the angular momentum states of a planar rotor. The code is \\(U(1)\\)-covariant and ideal codewords are not normalizable. ", "name": "\\([[3,1,2]]_{\\mathbb Z}\\) rotor code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "rotor\ncovariant", "parents_detail": "\nThe \\([[3,1,2]]_{\\mathbb Z}\\) code is \\(U(1)\\)-covariant.", "cousins_code_id": "stab_3_1_2", "cousins_detail": "", "_type": "ecc", "_page_id": "c_rotor_3_1_2", "_href": "c/rotor_3_1_2"}, "c_group_gkp": {"notes": "", "logical": "groups", "code_id": "group_gkp", "physical": "groups", "protection": "Protects against generalized bit-flip errors \\(g\\in G\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "introduced": "[V. V. Albert, J. P. Covey, and J. Preskill, \u201cRobust Encoding of a Qubit in a Molecule\u201d, Physical Review X 10, (2020). DOI; 1911.00099]", "description": "Group code whose construction is based on nested subgroups \\(H\\subset K \\subset G\\). Logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\), and can be finite- or infinite-dimensional. Extension of the GKP code construction.", "name": "Group GKP code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "Group-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{ k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates representing \\(G\\) [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].", "features_fault_tolerance": "", "parents_code_id": "group_quantum", "parents_detail": "", "parent_of_code_id": "molecular\nquantum_double", "parent_of_detail": "\nQuantum-double models admit stabilizer-like \\(X\\)- and \\(Z\\)-type operators [Victor V. Albert et al., \u201cSpin chains, defects, and quantum wires for the quantum-double edge\u201d. 2111.12096], and the codes can be formulated as group GKP codes.", "cousins_code_id": "oscillator_stabilizer\ncss", "cousins_detail": "The group-GKP construction encompasses all bosonic CSS codes. For example, a single-mode qubit GKP code corresponds to the \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\) group construction. For another example, an \\([[n,k,d]]_{\\mathbb{R}}\\) oscillator-into-oscillator stabilizer code corresponds to the \\(\\mathbb{R}^{ k_1} \\subseteq \\mathbb{R}^{ k_2} \\subset \\mathbb{R}^{n}\\) group construction, where \\(k=k_2/k_1\\).\nAn \\(n\\)-qubit CSS code corresponds to the \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{n}\\) group construction.", "cousin_of_code_id": "covariant", "cousin_of_detail": "Group-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates that represent the group \\(G\\), and are thus \\(G\\)-covariant [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].", "_type": "ecc", "_page_id": "c_group_gkp", "_href": "c/group_gkp"}, "c_stab_3_1_2": {"notes": "Connections to Ads/CFT from the perspetive of how arbitrary operators are encoded into the logical space. This encoding is analagous and helps explain why operators acting on the bulk are protected against localized boundary errors [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041].", "logical": "qudits", "code_id": "stab_3_1_2", "physical": "qudits", "protection": "Detects single qutrit errors and protects against a single-qutrit erasure. There does not exist a three-qubit code with analogous properties.\n\nThe code is an example of a \\( ((n = 3, k = 2)) \\) threshold scheme where a secret (the quantum information) is split into \\( n \\) shares and can be reconstructed by \\( k \\) pieces.\n\nThey key property of this code is that the reduced density matrix of any single qutrit is maximally mixed, meaning no information can be extracted from that qutrit. Therefore, a single qutrit tells you nothing about the encoded message, but access to any two pairs of qutrits will reveal the secret.", "introduced": "[R. Cleve, D. Gottesman, and H.-K. Lo, \u201cHow to Share a Quantum Secret\u201d, Physical Review Letters 83, 648 (1999). DOI; quant-ph/9901025]", "description": "A \\([[3,1,2]]_3\\) prime-qudit CSS code with stabilizer generators \\(ZZZ\\) and \\(XXX\\). The code defines a quantum secret-sharing scheme and serves as a minimal model for the AdS/CFT holographic duality. It is also the smallest non-trivial instance of a quantum maximum distance separable code (QMDS), saturating the quantum Singleton bound. The codewords are \\begin{align}\n  \\begin{split}\n    | \\overline{0} \\rangle &= \\frac{1}{\\sqrt{3}} (| 000 \\rangle + | 111 \\rangle + | 222 \\rangle) \\\\\n    | \\overline{1} \\rangle &= \\frac{1}{\\sqrt{3}} (| 012 \\rangle + | 120 \\rangle + | 201 \\rangle) \\\\\n    | \\overline{2} \\rangle &= \\frac{1}{\\sqrt{3}} (| 021 \\rangle + | 102 \\rangle + | 210 \\rangle)~.\n  \\end{split}\n\\end{align} The elements in the superposition of each logical codeword are related to each other via cyclic permutations. ", "name": "Three qutrit code", "realizations": "", "short_name": "\\([[3,1,2]]_3\\)", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The quantum information (the secret) can be recovered from a unitary transformation acting on only two qutrits, \\( U_{ij} \\otimes I \\), where \\(U_{ij}\\) acts on qutrits \\(i,j\\) and \\(I\\) is the identity on the remaining qutrit. By the cyclic structure of the codewords, this unitary transformation performs a permutation that recovers the information and stores it in one of the two qutrits involved in recovery.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "In addition to thinking about the encoding of states, it is also interesting to look at the trasformation of operators from the physical space into the logical space. Due to the unique structure and recovery protocol of the three qutrit code, the representation of a logical operator \\( \\overline{O} \\) is not unique. Instead, \\( \\overline{O} \\) can be constructed from unitary matricies with support on only two out of the three qutrits. Therefore, the logical operator has valid representations constructed from support on different sets of two qutrits. This operator construction is directly analogous to the construction of operators in the bulk (at the center) of the AdS\\(_3\\)-Rindler reconstruction. The three-qutrit code can then be used to describe how these local bulk operators are protected against localized boundary errors [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041].\nThis construction is related to the cleaning lemma [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983], which was introduced in the context of constructing self-correcting quantum memories from stabilizer codes with geometrically-local generators. In this lemma, subspaces can be cleaned out by removing operators with support on a subset of qutrits.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudit_css\nholographic\nquantum_mds", "parents_detail": "Smallest single-erasure correcting qudit code for \\(q>2\\).\nThree-qutrit code is a minimal model for holography [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][D. Harlow, \u201cThe Ryu\u2013Takayanagi Formula from Quantum Error Correction\u201d, Communications in Mathematical Physics 354, 865 (2017). DOI; 1607.03901].\nThe three-qutrit code is the smallest nontrivial quantum MDS code.", "cousins_code_id": "quantum_secret_sharing", "cousins_detail": "Three-qutrit code defines a minimal secret-sharing scheme [R. Cleve, D. Gottesman, and H.-K. Lo, \u201cHow to Share a Quantum Secret\u201d, Physical Review Letters 83, 648 (1999). DOI; quant-ph/9901025] that is substantially generalized by approximate secret-sharing codes.", "cousin_of_code_id": "rotor_3_1_2", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_stab_3_1_2", "_href": "c/stab_3_1_2"}, "c_qudit_hamming_css": {"notes": "", "logical": "qudits", "code_id": "qudit_hamming_css", "physical": "qudits", "protection": "", "introduced": "[Arun J. Moorthy and Lane G. Gunderman, \u201cLocal-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise\u201d. 2110.11510]", "description": "A family of CSS codes extending Hamming-based CSS codes to prime qudits of dimension \\(p\\) by expressing the qubit code stabilizers in local-dimension-invariant (LDI) form [Arun J. Moorthy and Lane G. Gunderman, \u201cLocal-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise\u201d. 2110.11510].", "name": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) prime-qudit CSS code", "realizations": "", "short_name": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\)", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudit_css", "parents_detail": "", "cousins_code_id": "quantum_hamming_css", "cousins_detail": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) codes are prime-qudit extensions of \\([[2^r-1, 2^r-2r-1, 3]]\\) codes.", "_type": "ecc", "_page_id": "c_qudit_hamming_css", "_href": "c/qudit_hamming_css"}, "c_frobenius": {"notes": "Frobenius codes that are also stabilizer codes have been completely classified. No such codes exist when \\(t\\) is odd. All such codes with even \\(t\\) can be directly constructed.", "logical": "qudits", "code_id": "frobenius", "physical": "qudits", "protection": "Protects against Pauli noise.", "introduced": "[Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code of length dividing $p^{t}+1$\u201d. 1011.5814]", "description": "Let \\(C\\) be a quantum cyclic code on \\(n\\) prime-dimensional qudits. \\(C\\) is a Frobenius code if there exists a positive integer \\(t\\) such that \\(n\\) divides \\(p^t +1\\).", "name": "Frobenius code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Adapted from the Berlekamp decoding algorithm for classical BCH codes. There exists a polynomial time quantum algorithm to correct errors of weight at most \\(\\tau\\), where \\(\\delta=2\\tau+1\\) is the BCH distance of the code [Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code of length dividing $p^{t}+1$\u201d. 1011.5814]. ", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudit_stabilizer\nquantum_cyclic", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_frobenius", "_href": "c/frobenius"}, "c_qudit_stabilizer": {"notes": "A standardized definition of the qudit stabilizer group is developed in [V. Gheorghiu, \u201cStandard form of qudit stabilizer groups\u201d, Physics Letters A 378, 505 (2014). DOI; 1101.1519].", "logical": "qudits", "code_id": "qudit_stabilizer", "physical": "qudits", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "introduced": "[Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052]", "description": "An \\(((n,K,d))_q\\) modular-qudit code whose logical subspace is the joint eigenspace of commuting qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code.\n\nA modular-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{q}\\) or \\([[n,k,d]]_{q}\\). For composite \\(q\\), such codes need not encode an integer number of qudits, with \\(K=q^n/|\\mathsf{S}|\\) [V. Gheorghiu, \u201cStandard form of qudit stabilizer groups\u201d, Physics Letters A 378, 505 (2014). DOI; 1101.1519]. This is because \\(|{\\mathsf{S}}|\\) need not be a power of \\(q\\), as group generators may have different orders. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\). Prime-qudit stabilizer codes, where \\(q=p\\) for some prime \\(p\\), do not suffer from this issue and encode \\(n-k\\) logical qudits, with \\(K=p^{n-k}\\).\n\nEach code can be represented by a check matrix (a.k.a. stabilizer generator matrix) \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(q\\)-ary symplectic representation of a stabilizer generator. The check matrix can be brought into standard form via Gaussian elimination [V. Gheorghiu, \u201cStandard form of qudit stabilizer groups\u201d, Physics Letters A 378, 505 (2014). DOI; 1101.1519].", "name": "Modular-qudit stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The structure of stabilizer codes allows for syndrome-based decoding, where errors are corrected based on the results of stabilizer measurements (syndromes).\nTrellis decoder for prime-dimensional qudits, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) [Eric Sabo, Arun B. Aloshious, and Kenneth R. Brown, \u201cTrellis Decoding For Qudit Stabilizer Codes And Its Application To Qubit Topological Codes\u201d. 2106.08251].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "stabilizer\nqudits_into_qudits\nquantum_lego", "parents_detail": "\n\nModular-qudit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qudit repetition code, single-qudit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state.", "parent_of_code_id": "double_semion\nfrobenius\nqudit_css", "parent_of_detail": "Double-semion code can be realized as a modular-qudit stabilizer code with \\(q=4\\) [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394].\n\n", "cousin_of_code_id": "topological_abelian\ngalois_stabilizer\nqubit_stabilizer\ntranslationally_invariant_stabilizer", "cousin_of_detail": "All abelian topological orders can be realized as modular-qudit stabilizer codes [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394].\nRecalling that \\(q=p^m\\), Galois-qudit stabilizer codes can also be treated as prime-qudit stabilizer codes on \\(mn\\) qudits, giving \\(k=nm-r\\) [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]. The case \\(m=1\\) reduces to conventional prime-qudit stabilizer codes on \\(n\\) qudits.\nModular-qudit stabilizer codes for prime-dimensional qudits \\(q=p\\) inherit most of the features of qubit stabilizer codes, including encoding an integer number of qudits and a Pauli group with a unique number of generators. Conversely, qubit codes can be extended to modular-qudit codes by decorating appropriate generators with powers. For example, \\([[4,2,2]]\\) qubit code generators can be adjusted to \\(ZZZZ\\) and \\(XX^{-1} XX^{-1}\\). A systematic procedure extending a qubit code to prime-qudit codes involves putting its generator matrix into local-dimension-invariant (LDI) form [L. G. Gunderman, \u201cLocal-dimension-invariant qudit stabilizer codes\u201d, Physical Review A 101, (2020). DOI; 1910.08122]. Various bounds exist on the distance of the resulting codes [Arun J. Moorthy and Lane G. Gunderman, \u201cLocal-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise\u201d. 2110.11510][L. G. Gunderman, \u201cDegenerate local-dimension-invariant stabilizer codes and an alternative bound for the distance preservation condition\u201d, Physical Review A 105, (2022). DOI; 2110.15274].\nModular-qudit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site.", "_type": "ecc", "_page_id": "c_qudit_stabilizer", "_href": "c/qudit_stabilizer"}, "c_polynomial": {"notes": "", "logical": "qudits", "code_id": "polynomial", "physical": "qudits", "protection": "", "introduced": "[M. Grassl, W. Geiselmann, and T. Beth, \u201cQuantum Reed\u2014Solomon Codes\u201d, Applied Algebra, Algebraic Algorithms and Error-Correcting Codes 231 (1999). DOI; quant-ph/9910059]", "description": "Also called prime-qudit polynomial code (QPyC). Prime-qudit CSS code constructed using two Reed-Solomon codes.\n\nThe original construction [M. Grassl, W. Geiselmann, and T. Beth, \u201cQuantum Reed\u2014Solomon Codes\u201d, Applied Algebra, Algebraic Algorithms and Error-Correcting Codes 231 (1999). DOI; quant-ph/9910059] was for a qubit code (\\(p=2\\)) by using a basis for a larger Galois field over \\(GF(2)\\), yielding an \\([[kN,k(N-2K),K+1]]\\) qubit code from a \\([N,K,\\delta]_{GF(2^k)}\\) RS code with \\(N=2^k-1\\) and \\(K=N-\\delta+1\\).\n\nAn alternative construction [D. Gottesman. Surviving as a quantum computer in a classical world] yields an \\([[n,k,n-k+1]]_p\\) (with prime \\(p>n\\)) prime-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(p)=\\mathbb{Z}_p\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(\\mathbb{Z}_p\\), and let \\(g\\) be a number satisfying \\(0\\leq k \\leq g < n\\). Then, define degree-\\(g\\) polynomials \\begin{align}\n  f_{\\mu\\cup c}\\left(x\\right)=\\mu_{0}+\\mu_{1}x+\\cdots+\\mu_{k-1}x^{k-1}+c_{k}x^{k}+\\cdots+c_{g}x^{g}\\,,\n\\end{align} where the first \\(k\\) coefficients are indexed by the coefficient vector \\(\\mu\\in\\mathbb{Z}_p^{ k}\\), and the remaining coefficients are indexed by the vector \\(c\\in\\mathbb{Z}_p^{ (g+1-k)}\\). Logical states, labeled by \\(\\mu\\), are superpositions of canonical basis states whose \\(i\\)th bit is \\(f_{\\mu\\cup c}\\), evaluated at \\(\\alpha_i\\) and summed over all possible vectors \\(c\\), \\begin{align}\n  |\\overline{\\mu}\\rangle=\\sum_{c\\in\\mathbb{Z}_{p}^{(g+1-k)}}|f_{\\mu\\cup c}(\\alpha_{1}),|f_{\\mu\\cup c}(\\alpha_{2}),\\cdots,|f_{\\mu\\cup c}(\\alpha_{n})\\rangle.\n\\end{align}", "name": "Quantum Reed-Solomon code", "realizations": "", "short_name": "Quantum RS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudit_css", "parents_detail": "", "cousins_code_id": "reed_solomon\nquantum_mds", "cousins_detail": "Polynomial codes are CSS codes constructed from Reed-Solomon codes.\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).", "cousin_of_code_id": "galois_polynomial", "cousin_of_detail": "Polynomial codes can be defined for modular qudits of prime dimension or, more generally, for Galois qudits.", "_type": "ecc", "_page_id": "c_polynomial", "_href": "c/polynomial"}, "c_qudit_surface": {"notes": "The simplest Decodoku game is based on the qudit surface code with \\( q=10\\).", "logical": "qudits", "code_id": "qudit_surface", "physical": "qudits", "protection": "When defined on an \\(L\\times L\\) square tiling of the torus, protects against \\(L\\) errors. More generally, the code distance is the number of edges in the shortest non contractible cycle in the tesselation or dual tesselation [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143].", "introduced": "[A. Y. Kitaev, \u201cFault-tolerant quantum computation by anyons\u201d, Annals of Physics 303, 2 (2003). DOI; quant-ph/9707021]", "description": "A family of stabilizer codes whose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit located at each edge of the tesselation). The code has \\( n=E \\) many physical qudits, where \\( E \\) is the number of edges of the tesselation, and \\( k=2g \\) many logical qudits, where \\( g \\) is the genus of the surface.", "name": "Modular-qudit surface code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudit_css\ntopological_abelian", "parents_detail": "Plaquette and star operators are stabilizer generators.\nQudit surface code Hamiltonians admit topological phases associated with \\(\\mathbb{Z}_q\\) [S. S. Bullock and G. K. Brennen, \u201cQudit surface codes and gauge theory with finite cyclic groups\u201d, Journal of Physics A: Mathematical and Theoretical 40, 3481 (2007). DOI; quant-ph/0609070].", "cousins_code_id": "surface\nstring_net", "cousins_detail": "The qudit surface code with \\(q=2\\) is the surface code.\nString-net model reduces to the qudit surface code when the category is the group \\(\\mathbb{Z}_q\\).", "cousin_of_code_id": "quantum_double\ntranslationally_invariant_stabilizer", "cousin_of_detail": "A quantum-double model with \\(G=\\mathbb{Z}_q\\) is the qudit surface code.\nTranslation-invariant 2D prime-qudit topological stabilizer codes are equivalent to several copies of the prime-qudit surface code via a local constant-depth Clifford circuit [J. Haah, \u201cClassification of translation invariant topological Pauli stabilizer codes for prime dimensional qudits on two-dimensional lattices\u201d, Journal of Mathematical Physics 62, 012201 (2021). DOI; 1812.11193].", "_type": "ecc", "_page_id": "c_qudit_surface", "_href": "c/qudit_surface"}, "c_qudits_into_qudits": {"notes": "See Refs. [\u201cFull length article\u201d, Chaos, Solitons &amp; Fractals 10, 1749 (1999). DOI; quant-ph/9802007][E. Hostens, J. Dehaene, and B. De Moor, \u201cStabilizer states and Clifford operations for systems of arbitrary dimensions and modular arithmetic\u201d, Physical Review A 71, (2005). DOI; quant-ph/0408190] for descriptions of the qudit Clifford group.\nWeight distribution of a code depends on the average entanglement of codewords [A. J. Scott, \u201cMultipartite entanglement, quantum-error-correcting codes, and entangling power of quantum evolutions\u201d, Physical Review A 69, (2004). DOI; quant-ph/0310137].", "logical": "qudits", "code_id": "qudits_into_qudits", "physical": "qudits", "protection": "A convenient and often considered error set is the modular-qudit analogue of the Pauli string basis for qubit codes. For a single qudit, this set consists of products of powers of the qudit Pauli matrices \\(X\\) and \\(Z\\), which act on computational basis states \\(|k\\rangle\\) for \\(k\\in\\mathbb{Z}_q\\) as \\begin{align}\n  X\\left|k\\right\\rangle =\\left|k+1\\right\\rangle \\,\\,\\text{ and }\\,\\,Z\\left|k\\right\\rangle =e^{i\\frac{2\\pi}{q}k}\\left|k\\right\\rangle ~,\n\\end{align} with addition performed modulo \\(q\\). For multiple qudits, error set elements are tensor products of elements of the single-qudit error set.\n\nThe Pauli error set is a unitary basis for linear operators on the multi-qudit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a nice error basis [E. Knill, \u201cNon-binary Unitary Error Bases and Quantum Codes\u201d. quant-ph/9608048]. The distance associated with this set is often the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code. ", "introduced": "", "description": "Also called a \\(\\mathbb{Z}_q\\)-qudit code. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the group \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\). Usually denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined, and with \\(q=p\\) when the dimension is prime. ", "name": "Modular-qudit code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "qudit_stabilizer", "parent_of_detail": "", "cousin_of_code_id": "eaqecc\ngalois_into_galois\ngroup_quantum", "cousin_of_detail": "Pure modular-qudit codes can be used to make EA-QECCs with the same distance and dimension; see Thm. 10 of Ref. [M. Grassl, F. Huber, and A. Winter, \u201cEntropic Proofs of Singleton Bounds for Quantum Error-Correcting Codes\u201d, IEEE Transactions on Information Theory 68, 3942 (2022). DOI; 2010.07902].\nA Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]; see Sec. 5.3 of Ref. [Annika Niehage, \u201cQuantum Goppa Codes over Hyperelliptic Curves\u201d. quant-ph/0501074]. The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently.\nGroup quantum codes whose physical spaces are constructed using modular-integer groups \\(\\mathbb{Z}_q\\) are modular-qudit codes.", "_type": "ecc", "_page_id": "c_qudits_into_qudits", "_href": "c/qudits_into_qudits"}, "c_stabilizer_over_gfqsq": {"notes": "", "logical": "galois", "code_id": "stabilizer_over_gfqsq", "physical": "galois", "protection": "", "introduced": "[Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070]", "description": "An \\([[n,k,d]]_{GF(q)}\\) Galois-qudit stabilizer code constructed from a classical code over \\(GF(q^2)\\) using the one-to-one correspondence between the Galois-qudit Pauli matrices and elements of the Galois field \\(GF(q^2)\\).\n\nAn \\(n\\) Galois-qudit Pauli stabilizer can be represented as a length-\\(n\\) vector over \\(GF(q^2)\\). The stabilizer commutation condition corresponds to a zero trace-alternating inner product between the corresponding vectors. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from classical trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\) [Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070]. Hermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal, and applying this construction to such codes yields a class of true stabilizer codes. ", "name": "Stabilizer code over \\(GF(q^2)\\)", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_true_stabilizer", "parents_detail": "Trace-alternating self-orthogonal linear codes over \\(GF(q^2)\\) are equivalent to a class of true stabilizer codes [D. Gottesman. Surviving as a quantum computer in a classical world]. Hermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal and can be used to construct true stabilizer codes via the stabilizer-over-\\(GF(q^2)\\) construction ([Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19).", "cousins_code_id": "dual_additive\nstabilizer_over_gf4", "cousins_detail": "The stabilizer commutation condition for stabilizer codes over \\(GF(q^2)\\) can equivalently be stated in the representation of stabilizers as vectors over \\(GF(q^2)\\). A pair of \\(n\\) Galois-qudit stabilizers commute iff the trace-alternating inner product of their their corresponding vectors is zero. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\).\nStabilizer codes over \\(GF(q^2)\\) are Galois-qudit extensions of those over \\(GF(4)\\).", "_type": "ecc", "_page_id": "c_stabilizer_over_gfqsq", "_href": "c/stabilizer_over_gfqsq"}, "c_qudit_css": {"notes": "", "logical": "qudits", "code_id": "qudit_css", "physical": "qudits", "protection": "", "introduced": "[A. R. Calderbank and P. W. Shor, \u201cGood quantum error-correcting codes exist\u201d, Physical Review A 54, 1098 (1996). DOI; quant-ph/9512032][A. M. Steane, \u201cError Correcting Codes in Quantum Theory\u201d, Physical Review Letters 77, 793 (1996). DOI][\u201cMultiple-particle interference and quantum error correction\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 452, 2551 (1996). DOI; quant-ph/9601029]", "description": "An \\(((n,K,d))_q\\) modular-qudit stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The stabilizer generator matrix, taking values from \\(\\mathbb{Z}_q\\), is of the form \\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityq}\n\\end{align} such that the rows of the two blocks must be orthogonal \\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commQ}\n\\end{align} The above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nFor composite \\(q\\), such codes need not encode an integer number of qudits. For prime \\(q=p\\), properties reminiscent of qubit CSS codes are restored: encoding is based on two related \\(p\\)-ary linear codes, an \\([n,k_X,d_X]_p \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_p \\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\(\\eqref{eq:parityq}\\) is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\(\\eqref{eq:commQ}\\). Basis states for the code are, for \\(\\gamma \\in C_X\\), \\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align} ", "name": "Modular-qudit CSS code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qudit_stabilizer", "parents_detail": "", "parent_of_code_id": "qudit_surface\npolynomial\nstab_3_1_2\nqudit_hamming_css", "parent_of_detail": "Plaquette and star operators are stabilizer generators.\n\nSmallest single-erasure correcting qudit code for \\(q>2\\).\n", "cousins_code_id": "css\nq-ary_linear", "cousins_detail": "Extension of CSS codes to modular-integer qudits.\nConstruction for prime \\(q=p\\) uses two related \\(p\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).", "_type": "ecc", "_page_id": "c_qudit_css", "_href": "c/qudit_css"}, "c_galois_topological": {"notes": "", "logical": "galois", "code_id": "galois_topological", "physical": "galois", "protection": "", "introduced": "[P. Sarvepalli, \u201cTopological color codes over higher alphabet\u201d, 2010 IEEE Information Theory Workshop (2010). DOI][Iryna Andriyanova, Denise Maurice, and Jean-Pierre Tillich, \u201cNew constructions of CSS codes obtained by moving to higher alphabets\u201d. 1202.3338]", "description": "Abelian topological code, such as a surface [Iryna Andriyanova, Denise Maurice, and Jean-Pierre Tillich, \u201cNew constructions of CSS codes obtained by moving to higher alphabets\u201d. 1202.3338] or color [P. Sarvepalli, \u201cTopological color codes over higher alphabet\u201d, 2010 IEEE Information Theory Workshop (2010). DOI] code, constructed on lattices of Galois qudits. ", "name": "Galois-qudit topological code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_css\ntopological", "parents_detail": "\n", "cousins_code_id": "surface\ncolor", "cousins_detail": "Surface code has been extended to Galois qudits.\nColor code has been extended to Galois qudits.", "_type": "ecc", "_page_id": "c_galois_topological", "_href": "c/galois_topological"}, "c_skew-cyclic_galois_css": {"notes": "", "logical": "qudits", "code_id": "skew-cyclic_galois_css", "physical": "qudits", "protection": "", "introduced": "[H. Q. Dinh et al., \u201cA class of skew cyclic codes and application in quantum codes construction\u201d, Discrete Mathematics 344, 112189 (2021). DOI]", "description": "Stub.", "name": "Skew-cyclic CSS code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_css", "parents_detail": "", "cousins_code_id": "skew_cyclic", "cousins_detail": "Skew-cyclic CSS codes are constructed from classical skew-cylic codes.", "_type": "ecc", "_page_id": "c_skew-cyclic_galois_css", "_href": "c/skew-cyclic_galois_css"}, "c_galois_bch": {"notes": "", "logical": "galois", "code_id": "galois_bch", "physical": "galois", "protection": "", "introduced": "[Salah Aly, Andreas Klappenecker, and Pradeep Kiran Sarvepalli, \u201cPrimitive Quantum BCH Codes over Finite Fields\u201d. quant-ph/0501126][Salah A. Aly, Andreas Klappenecker, and Pradeep Kiran Sarvepalli, \u201cOn Quantum and Classical BCH Codes\u201d. quant-ph/0604102][S. A. Aly, A. Klappenecker, and P. K. Sarvepalli, \u201cOn Quantum and Classical BCH Codes\u201d, IEEE Transactions on Information Theory 53, 1183 (2007). DOI][R. Li et al., \u201cHermitian dual containing BCH codes and Construction of new quantum codes\u201d, Quantum Information and Computation 13, 21 (2013). DOI][G. G. La Guardia, \u201cConstructions of new families of nonbinary quantum codes\u201d, Physical Review A 80, (2009). DOI][X. Zhao et al., \u201cHermitian dual-containing constacyclic BCH codes and related quantum codes of length $\\frac{q^{2m}-1}{q+1}$\u201d. 2007.13309]", "description": "True Galois-qudit stabilizer code constructed from BCH codes via either the Hermitian construction or the Galois-qudit CSS construction. ", "name": "Galois-qudit BCH code", "realizations": "", "short_name": "Galois-qudit BCH", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_true_stabilizer", "parents_detail": "Galois-qudit BCH codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes.", "cousins_code_id": "quantum_bch\nq-ary_bch\ngalois_css", "cousins_detail": "\n\nSome Galois-qudit BCH codes are CSS.", "_type": "ecc", "_page_id": "c_galois_bch", "_href": "c/galois_bch"}, "c_galois_stabilizer": {"notes": "", "logical": "galois", "code_id": "galois_stabilizer", "physical": "galois", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. Corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qudits.", "introduced": "[A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI][Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070]", "description": "An \\(((n,K,d))_{GF(q)}\\) Galois-qudit code whose logical subspace is the joint eigenspace of commuting Galois-qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a Galois-qudit Pauli string that implements a nontrivial logical operation in the code.\n\nA Galois-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{GF(q)}\\) or \\([[n,k,d]]_{GF(q)}\\). This notation differentiates between Galois-qudit and modular-qudit stabilizer codes, although the same notation, \\([[n,k,d]]_q\\), is usually used for both. Galois-qudit stabilizer codes need not encode an integer number of qudits, with \\(K=q^{n-\\frac{r}{m}}\\), where \\(r\\) is the number of generators of the stabilizer group, and \\(q=p^m\\) given prime \\(p\\) for all Galois qudits. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\).\n\nThe stabilizer commutation condition can equivalently be stated in the symplectic representation. A pair of Galois-qudit stabilizers on \\(n\\) Galois qudits with symplectic representation vectors \\((a|b)\\) and \\((a^{\\prime}|b^{\\prime})\\) commute iff their trace symplectic inner product is zero, \\begin{align}\n\\text{tr}(a \\cdot b^{\\prime} - a^{\\prime}\\cdot b) = \\sum_{j=1}^{n} \\text{tr}(a_j b^{\\prime}_j - a^{\\prime}_i b_i) = 0~.\n\\end{align} Symplectic representations of stabilizer group elements thus form a self-orthogonal subspace of \\(GF(q)^{2n}\\) with respect to the trace-symplectic inner product.\n\nNote that the above trace-symplectic inner product reduces to the symplectic inner product when the trace is removed, and a symplectic self-orthogonal set of vectors is automatically trace-symplectic self-orthogonal. More generally, any additive classical code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code (see children).", "name": "Galois-qudit stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "As opposed to modular qudits for composite \\(q\\), Galois qudits inherit most of the properties of the prime-qudit Clifford group due to the correspondence between a \\(q=p^m\\) Galois qudit and \\(m\\) prime qudits of dimension \\(p\\) [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI].", "features_magic_scaling_exponent": "", "features_encoders": "Encoder with \\(O(n^2)\\) gates can be determined in classical runtime of order \\(O(n^3)\\) [M. GRASSL, M. R\u00d6TTELER, and T. BETH, \u201cEFFICIENT QUANTUM CIRCUITS FOR NON-QUBIT QUANTUM ERROR-CORRECTING CODES\u201d, International Journal of Foundations of Computer Science 14, 757 (2003). DOI; quant-ph/0211014].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "stabilizer\nnon_stabilizer", "parents_detail": "\nA non-stabilizer code is also a stabilizer code if its Fourier description \\(\\mathsf{B}\\) is a subgroup of some Gottesman subgroup \\(\\mathsf{S}\\). When \\(\\mathsf{B}\\) is just a subset, the code is explicitly not a stabilizer code.", "parent_of_code_id": "galois_true_stabilizer", "parent_of_detail": "", "cousins_code_id": "qubit_stabilizer\nqudit_stabilizer\nq-ary_additive\ndual_additive", "cousins_detail": "Galois-qudit stabilizer codes reduce to qubit stabilizer codes for \\(q=2\\).\nRecalling that \\(q=p^m\\), Galois-qudit stabilizer codes can also be treated as prime-qudit stabilizer codes on \\(mn\\) qudits, giving \\(k=nm-r\\) [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]. The case \\(m=1\\) reduces to conventional prime-qudit stabilizer codes on \\(n\\) qudits.\nA Galois-qudit stabilizer code is the closest quantum analogue of an additive code over \\(GF(q)\\) because addition in the field corresponds to multiplication of stabilizers in the quantum case.\nAn additive code of length \\(2n\\) over \\(GF(q)\\) that is self-orthogonal with respect to the trace-symplectic inner product corresponds to symplectic representations of an \\(n\\) Galois-qudit stabilizer group [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]. Moreover, any additive code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code.", "_type": "ecc", "_page_id": "c_galois_stabilizer", "_href": "c/galois_stabilizer"}, "c_galois_true_stabilizer": {"notes": "", "logical": "galois", "code_id": "galois_true_stabilizer", "physical": "galois", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.", "introduced": "[A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI][Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070][D. Gottesman. Surviving as a quantum computer in a classical world]", "description": "Also called a linear stabilizer code. A \\([[n,k,d]]_{GF(q)}\\) stabilizer code whose stabilizer's symplectic representation forms a linear subspace. In other words, the set of \\(q\\)-ary vectors representing the stabilizer group is closed under both addition and multiplication by elements of \\(GF(q)\\). In contrast, Galois-qudit stabilizer codes admit sets of vectors that are closed under addition only.\n\nThe number of generators \\(r\\) for a true stabilizer code is a multiple of \\(m\\) (recall that \\(q=p^m\\) for Galois qudits). As a result, the number \\(k=n-r/m\\) of logical qudits is an integer.\n\nEach code can be represented by a stabilizer generator matrix \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(GF(q)\\)-valued symplectic representation of a stabilizer generator.\n\nA Hermitian self-orthogonal linear \\([n,k,d]_{GF(q^2)}\\) code can be used to construct an \\([[n,n-2k]]_{GF(q)}\\) true stabilizer code with distance no less than \\(d\\). This Hermitian construction was first proven via the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI], Corr. 1), and later proven via the stabilizer-over-\\(GF(q^2)\\) construction (showing self-orthogonality under the trace-alternating inner product; see Ref. [Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19). There is an isomorphism between the symplectic and stabilizer-over-\\(GF(q^2)\\) representations (Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.8). The Hermitian construction has been extended to \\(q^{2m}\\)-ary Hermitian self-orthogonal linear codes [Carlos Galindo and Fernando Hernando, \u201cOn the generalization of the construction of quantum codes from Hermitian self-orthogonal codes\u201d. 2012.11998] and similar constructions exist [M. F. Ezerman, S. Ling, and P. Sole, \u201cAdditive Asymmetric Quantum Codes\u201d, IEEE Transactions on Information Theory 57, 5536 (2011). DOI; 1002.4088].", "name": "True Galois-qudit stabilizer code", "realizations": "", "short_name": "True stabilizer", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_stabilizer", "parents_detail": "", "parent_of_code_id": "galois_bch\ngalois_css\ngalois_grs\nstabilizer_over_gfqsq", "parent_of_detail": "Galois-qudit BCH codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes.\nGalois-qudit CSS codes are true stabilizer codes [D. Gottesman. Surviving as a quantum computer in a classical world].\nGalois-qudit GRS codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes.\nTrace-alternating self-orthogonal linear codes over \\(GF(q^2)\\) are equivalent to a class of true stabilizer codes [D. Gottesman. Surviving as a quantum computer in a classical world]. Hermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal and can be used to construct true stabilizer codes via the stabilizer-over-\\(GF(q^2)\\) construction ([Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19).", "cousins_code_id": "q-ary_linear\ndual\nquantum_mds\nmatrix_product", "cousins_detail": "A true Galois-qudit stabilizer code is the closest quantum analogue of a linear code over \\(GF(q)\\) because the \\(q\\)-ary vectors corresponding to the symplectic representation of the stabilizers form a linear subspace.\nHermitian self-orthogonal linear codes over \\(GF(q^2)\\) yield true stabilizer codes via either the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI], Corr. 1) or the stabilizer-over-\\(GF(q^2)\\) construction (showing self-orthogonality under the trace-alternating inner product; see Ref. [Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19 or Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.8).\nMany MDS codes are constructed from Hermitian self-orthogonal codes over \\(GF(q^2)\\) using the Hermitian construction [M. GRASSL, T. BETH, and M. R\u00d6TTELER, \u201cON OPTIMAL QUANTUM CODES\u201d, International Journal of Quantum Information 02, 55 (2004). DOI; quant-ph/0312164][R. Li and Z. Xu, \u201cConstruction of<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mo stretchy=\"false\">[</mml:mo><mml:mo stretchy=\"false\">[</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>\u2212</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy=\"false\">]</mml:mo><mml:mo stretchy=\"false\">]</mml:mo><mml:msub><mml:mrow /><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>quantum codes for odd prime power<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:math>\u201d, Physical Review A 82, (2010). DOI; 0906.2509][Xianmang He, Liqing Xu, and Hao Chen, \u201cNew $q$-ary Quantum MDS Codes with Distances Bigger than $\\frac{q}{2}$\u201d. 1507.08355][Liangdong Lu et al., \u201cNew Quantum MDS codes constructed from Constacyclic codes\u201d. 1803.07927], in particular from cyclic [G. G. La Guardia, \u201cNew Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 57, 5551 (2011). DOI], constacyclic [X. Kai, S. Zhu, and P. Li, \u201cConstacyclic Codes and Some New Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 60, 2080 (2014). DOI][B. Chen, S. Ling, and G. Zhang, \u201cApplication of Constacyclic Codes to Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 61, 1474 (2015). DOI] and negacyclic [X. Kai and S. Zhu, \u201cNew Quantum MDS Codes From Negacyclic Codes\u201d, IEEE Transactions on Information Theory 59, 1193 (2013). DOI] codes.\nHermitian self-orthogonal matrix-product codes over \\(GF(q^2)\\) can be used to construct true stabilizer codes [M. Cao and J. Cui, \u201cConstruction of new quantum codes via Hermitian dual-containing matrix-product codes\u201d, Quantum Information Processing 19, (2020). DOI][Xiusheng Liu, Hualu Liu, and Long Yu, \u201cOn New Quantum Codes From Matrix Product Codes\u201d. 1604.05823].", "_type": "ecc", "_page_id": "c_galois_true_stabilizer", "_href": "c/galois_true_stabilizer"}, "c_galois_grs": {"notes": "", "logical": "galois", "code_id": "galois_grs", "physical": "galois", "protection": "", "introduced": "[Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129][Lingfei Jin and Chaoping Xing, \u201cA Construction of New Quantum MDS Codes\u201d. 1311.3009]", "description": "True \\(q\\)-Galois-qudit stabilizer code constructed from generalized Reed-Solomon (GRS) codes via either the Hermitian construction [Lingfei Jin and Chaoping Xing, \u201cA Construction of New Quantum MDS Codes\u201d. 1311.3009][X. Liu, L. Yu, and H. Liu, \u201cNew quantum codes from Hermitian dual-containing codes\u201d, International Journal of Quantum Information 17, 1950006 (2019). DOI][L. Jin et al., \u201cApplication of Classical Hermitian Self-Orthogonal MDS Codes to Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 56, 4735 (2010). DOI] or the Galois-qudit CSS construction [Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129]. ", "name": "Galois-qudit GRS code", "realizations": "", "short_name": "Galois GRS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_true_stabilizer", "parents_detail": "Galois-qudit GRS codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes.", "parent_of_code_id": "galois_polynomial", "parent_of_detail": "", "cousins_code_id": "generalized_reed_solomon\nquantum_mds", "cousins_detail": "Hermitian self-orthogonal GRS codes are used to construct Galois-qudit GRS codes in the Hermitian construction.\nSome Galois-qudit GRS codes are quantum MDS [Lingfei Jin and Chaoping Xing, \u201cA Construction of New Quantum MDS Codes\u201d. 1311.3009].", "_type": "ecc", "_page_id": "c_galois_grs", "_href": "c/galois_grs"}, "c_binary_quantum_goppa": {"notes": "", "logical": "galois", "code_id": "binary_quantum_goppa", "physical": "galois", "protection": "Protects against weight \\(t\\) errors where \\( 0 < t \\leq  \\lfloor \\frac{d^*-g-1}{2} \\rfloor \\) where \\( d^* = \\text{deg} G + 2 -2g \\) and \\(g\\) is the genus of the function field and \\(d \\geq n - \\lfloor \\frac{deg G}{2} \\rfloor\\).", "introduced": "[Annika Niehage, \u201cQuantum Goppa Codes over Hyperelliptic Curves\u201d. quant-ph/0501074][A. Niehage, \u201cNonbinary Quantum Goppa Codes Exceeding the Quantum Gilbert-Varshamov Bound\u201d, Quantum Information Processing 6, 143 (2006). DOI]", "description": "Also known as a quantum AG code. Binary quantum Goppa codes are a family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes for \\( q=2^m \\), generated using classical Goppa codes.\n\nLet \\( F/GF(q) \\) be an algebraic function field of one variable, \\(\\sigma \\) be an automorphism of order 2 of \\(F\\) which leaves \\(GF(q)\\) invariant, and \\(P_1, \\cdots, P_n \\) be pairwise distinct places of degree one such that \\( \\sigma P_i = P_j\\) for all \\(i,j = 1, \\cdots, n\\). A place \\( P_i \\) of \\( F/ GF(q) \\) is the unique maximal ideal of a discrete valuation ring of the function field. Let \\( \\nu \\) be a differential that satisfies the properties guaranteed by the strong approximation theorem of discrete evaluations. Let \\(G\\) be a divisor such that \\( \\sigma G = G \\) and the discrete valuation corresponding to place \\(P_i \\) of \\(G\\) and the discrete valuation corresponding to place \\(\\sigma P_i \\) of \\(G\\) are both 0 for all \\(i\\). Then we can define a code \\( C(G)  = \\{ f(P_1), \\cdots, f(P_n), f(\\sigma P_1), \\cdots , f(\\sigma P_n) | f \\in \\mathcal{L}(G)\\} \\subset GF(q^{2n})\\) and a code \\(C(H)\\) where \\(H = (P_1 + \\cdots + P_n + \\sigma P_1 + \\cdots + \\sigma P_n) - G + \\nu \\). Then the dual of \\(C(G)\\) with respect to the weighted symplectic inner product with weights \\(s_i\\) on \\( GF(q^n) \\) is equivalent to \\(C(H)\\). Therefore, the orthogonal code of \\(C(G)\\) is generated by \\(H\\). Using these properties and the assumption that \\(H\\) is a subgroup of \\(G\\), we can construct a classical Goppa code \\(C(D,G)\\), where \\(D\\) is the sum of all \\(P_i\\). Using \\(C(D,G)\\), we can construct a \\([[n,k,d]]_{GF(q)}\\) quantum stabilizer code such that \\(k  = \\text{dim} G - \\text{dim}(G-P_1 - \\cdots - P_n - \\sigma P_1 - \\cdots  - \\sigma P_n) - n~.\\) ", "name": "Binary quantum Goppa code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Farran algorithm [J. I. Farran, \u201cDecoding Algebraic Geometry codes by a key equation\u201d. math/9910151].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Encoding defined in Ref. [R. Matsumoto, \u201cImprovement of Ashikhmin-Litsyn-Tsfasman bound for quantum codes\u201d, IEEE Transactions on Information Theory 48, 2122 (2002). DOI; quant-ph/0107129] uses a technique from Ref. [Alexei Ashikhmin and Emanuel Knill, \u201cNonbinary Quantum Stabilizer Codes\u201d. quant-ph/0005008] to encode quantum stabilizer codes.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_css", "parents_detail": "Goppa codes can be realized in the CSS code construction [A. Niehage, \u201cNonbinary Quantum Goppa Codes Exceeding the Quantum Gilbert-Varshamov Bound\u201d, Quantum Information Processing 6, 143 (2006). DOI].", "cousins_code_id": "goppa", "cousins_detail": "Classical Goppa codes are used to construct their quantum versions.", "_type": "ecc", "_page_id": "c_binary_quantum_goppa", "_href": "c/binary_quantum_goppa"}, "c_galois_into_galois": {"notes": "Introduction to Galois qudits by Gottesman.\nWigner function for Galois qudits [K. S. Gibbons, M. J. Hoffman, and W. K. Wootters, \u201cDiscrete phase space based on finite fields\u201d, Physical Review A 70, (2004). DOI; quant-ph/0401155].", "logical": "galois", "code_id": "galois_into_galois", "physical": "galois", "protection": "A convenient and often considered error set is the Galois-qudit analogue of the Pauli string set for qubit codes. For a single Galois qudit, this set consists of products of \\(X\\)-type and \\(Z\\)-type operators labeled by elements \\(\\beta \\in GF(q)\\), which act on computational basis states \\(|\\gamma\\rangle\\) for \\(\\gamma\\in GF(q)\\) as \\begin{align}\n  X_{\\beta}\\left|\\gamma\\right\\rangle =\\left|\\gamma+\\beta\\right\\rangle \\,\\,\\text{ and }\\,\\,Z_{\\beta}\\left|\\gamma\\right\\rangle =e^{i\\frac{2\\pi}{p}\\text{tr}(\\beta\\gamma)}\\left|\\gamma\\right\\rangle~,\n\\end{align} where the trace maps elements of the field to elements of \\(\\mathbb{Z}_p\\) as \\begin{align}\n  \\text{tr}(\\gamma)=\\sum_{k=0}^{m-1}\\gamma^{p^{k}}~.\n\\end{align} For multiple Galois qudits, error set elements are tensor products of elements of the single-qudit error set.\n\nThe Galois-qudit Pauli error set is a unitary basis for linear operators on the multi-qudit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a nice error basis [E. Knill, \u201cNon-binary Unitary Error Bases and Quantum Codes\u201d. quant-ph/9608048]. The distance associated with this set is often the minimum weight of a Galois qudit Pauli string that implements a nontrivial logical operation in the code. ", "introduced": "[J. Bierbrauer and Y. Edel, \u201cQuantum twisted codes\u201d, Journal of Combinatorial Designs 8, 174 (2000). DOI][Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070]", "description": "Also called a \\(GF(q)\\)- or \\(\\mathbb{F}_q\\)-qudit code. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the Galois field \\(GF(q)\\) and with \\(q\\) being a power of a prime \\(p\\). A Galois field can be thought of as a vector space whose basis vectors are the \\(m\\) roots of some polynomial and whose coefficients (i.e., field) are \\(p\\)th roots of unity. Codes can be denoted as \\(((n,K))_{GF(q)}\\) or \\(((n,K,d))_{GF(q)}\\), whenever the code's distance \\(d\\) is defined. This notation differentiates between Galois-qudit and modular-qudit codes, although the same notation, \\(((n,K,d))_q\\), is usually used for both.", "name": "Galois-qudit code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "non_stabilizer", "parent_of_detail": "", "cousins_code_id": "qudits_into_qudits", "cousins_detail": "A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]; see Sec. 5.3 of Ref. [Annika Niehage, \u201cQuantum Goppa Codes over Hyperelliptic Curves\u201d. quant-ph/0501074]. The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently.", "_type": "ecc", "_page_id": "c_galois_into_galois", "_href": "c/galois_into_galois"}, "c_non_stabilizer": {"notes": "", "logical": "galois", "code_id": "non_stabilizer", "physical": "galois", "protection": "", "introduced": "[V. Arvind, Piyush P Kurur, and K. R. Parthasarathy, \u201cNonstabilizer Quantum Codes from Abelian Subgroups of the Error Group\u201d. quant-ph/0210097]", "description": "The projection onto a stabilizer code is proportional to an equal sum over all elements of the stabilizer group \\(\\mathsf{S}\\). Non-stabilizer codes generalize stabilizer codes by modifying the code projection with elements of a subset \\(\\mathsf{B}\\subset\\mathsf{S}\\) called the Fourier description (see proof of Thm. 2.7 in Ref. [V. Arvind, Piyush P Kurur, and K. R. Parthasarathy, \u201cNonstabilizer Quantum Codes from Abelian Subgroups of the Error Group\u201d. quant-ph/0210097]). When \\(\\mathsf{B}\\) is a subgroup of \\(\\mathsf{S}\\), then the code reduces to an ordinary stabilizer code.\n\nThe following non-stabilizer codes were constructed in Ref. [V. Arvind, Piyush P Kurur, and K. R. Parthasarathy, \u201cNonstabilizer Quantum Codes from Abelian Subgroups of the Error Group\u201d. quant-ph/0210097]: \\(((33, 155, 3))\\), \\(((15, 8, 3))\\), \\(((n, \\lceil\\frac{q^n}{n(q^2-1)}\\rceil,2))_{GF(q)}\\) and \\(((n, 1+n(q-1),2))_{GF(q)}\\), where \\(n\\) is odd. The last code family is a Galois-qudit extension of the non-additive \\(((5,6,2))\\) qubit code from Ref. [E. M. Rains et al., \u201cA Nonadditive Quantum Code\u201d, Physical Review Letters 79, 953 (1997). DOI; quant-ph/9703002]. ", "name": "Galois-qudit non-stabilizer code", "realizations": "", "short_name": "Non-stabilizer", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The decoding circuit involves the application of phase estimation.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "The encoding circuit involves the application of quantum Fourier transform.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_into_galois", "parents_detail": "", "parent_of_code_id": "galois_stabilizer", "parent_of_detail": "A non-stabilizer code is also a stabilizer code if its Fourier description \\(\\mathsf{B}\\) is a subgroup of some Gottesman subgroup \\(\\mathsf{S}\\). When \\(\\mathsf{B}\\) is just a subset, the code is explicitly not a stabilizer code.", "_type": "ecc", "_page_id": "c_non_stabilizer", "_href": "c/non_stabilizer"}, "c_quantum_secret_sharing": {"notes": "", "logical": "galois", "code_id": "quantum_secret_sharing", "physical": "galois", "protection": "Corrects up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors with fidelity exponentially lose to 1.", "introduced": "[Claude Crepeau, Daniel Gottesman, and Adam Smith, \u201cApproximate Quantum Error-Correcting Codes and Secret Sharing Schemes\u201d. quant-ph/0503139]", "description": "A family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes approximately correcting errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) qubits, i.e., with approximate distance approaching the no-cloning bound \\(n/2\\). Constructed using a non-degenerate CSS code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an \\(t\\)-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.", "name": "Approximate secret-sharing code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Decoding is analagous to reconstruction in a secret sharing scheme and is done in polynomial time. The only required operations are verification of quantum authentication, which is a pair of polynomial-time quantum algorithms that check if the fidelity of the received state is close to 1, and erasure correction for a stabilizer code, which involves solving a system of linear equations.", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Uses a quantum authentication scheme, which is a keyed system in which a valid state has high fidelity, and a classical secret-sharing scheme.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_css", "parents_detail": "The code required to construct this code must be a non-degenerate Galois-qubit CSS code.", "cousins_code_id": "approximate_qecc\ngalois_polynomial\nreed_solomon", "cousins_detail": "Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors.\nPolynomial codes can be used for a specific construction of this code.\nThe classical information in this code is encoded using a Reed-Solomon code.", "cousin_of_code_id": "stab_3_1_2", "cousin_of_detail": "Three-qutrit code defines a minimal secret-sharing scheme [R. Cleve, D. Gottesman, and H.-K. Lo, \u201cHow to Share a Quantum Secret\u201d, Physical Review Letters 83, 648 (1999). DOI; quant-ph/9901025] that is substantially generalized by approximate secret-sharing codes.", "_type": "ecc", "_page_id": "c_quantum_secret_sharing", "_href": "c/quantum_secret_sharing"}, "c_galois_css": {"notes": "", "logical": "galois", "code_id": "galois_css", "physical": "galois", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "introduced": "[A. R. Calderbank and P. W. Shor, \u201cGood quantum error-correcting codes exist\u201d, Physical Review A 54, 1098 (1996). DOI; quant-ph/9512032][A. M. Steane, \u201cError Correcting Codes in Quantum Theory\u201d, Physical Review Letters 77, 793 (1996). DOI][\u201cMultiple-particle interference and quantum error correction\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 452, 2551 (1996). DOI; quant-ph/9601029][M. GRASSL, T. BETH, and M. R\u00d6TTELER, \u201cON OPTIMAL QUANTUM CODES\u201d, International Journal of Quantum Information 02, 55 (2004). DOI; quant-ph/0312164][J.-L. Kim and J. Walker, \u201cNonbinary quantum error-correcting codes from algebraic curves\u201d, Discrete Mathematics 308, 3115 (2008). DOI]", "description": "An \\([[n,k,d]]_{GF(q)} \\) Galois-qudit true stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Galois-qudit Pauli strings. The stabilizer generator matrix, taking values from \\(GF(q)\\), is of the form \\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityg}\n\\end{align} such that the rows of the two blocks must be orthogonal \\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commG}\n\\end{align} The above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related \\(q\\)-ary linear codes, an \\([n,k_X,d_X]_q \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_q \\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\(\\eqref{eq:parityg}\\) is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\(\\eqref{eq:commG}\\). Basis states for the code are, for \\(\\gamma \\in C_X\\), \\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align} ", "name": "Galois-qudit CSS code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_true_stabilizer", "parents_detail": "Galois-qudit CSS codes are true stabilizer codes [D. Gottesman. Surviving as a quantum computer in a classical world].", "parent_of_code_id": "quantum_secret_sharing\nbinary_quantum_goppa\ngalois_polynomial\ngalois_topological\nlifted_product\nskew-cyclic_galois_css", "parent_of_detail": "The code required to construct this code must be a non-degenerate Galois-qubit CSS code.\nGoppa codes can be realized in the CSS code construction [A. Niehage, \u201cNonbinary Quantum Goppa Codes Exceeding the Quantum Gilbert-Varshamov Bound\u201d, Quantum Information Processing 6, 143 (2006). DOI].\n\n\n\n", "cousins_code_id": "css\nq-ary_linear\nq-ary_cyclic", "cousins_detail": "Extension of qubit CSS codes to Galois qudits.\nConstruction uses two related \\(q\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).\nGalois CSS codes can be constructed using self-orthogonal \\(q\\)-ary cyclic codes [Yongsheng Tang et al., \u201cNew quantum codes from dual-containing cyclic codes over finite rings\u201d. 1608.06674].", "cousin_of_code_id": "galois_bch", "cousin_of_detail": "Some Galois-qudit BCH codes are CSS.", "_type": "ecc", "_page_id": "c_galois_css", "_href": "c/galois_css"}, "c_galois_polynomial": {"notes": "", "logical": "galois", "code_id": "galois_polynomial", "physical": "galois", "protection": "", "introduced": "[Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129]", "description": "Also called polynomial code (QPyC). An \\([[n,k,n-k+1]]_{GF(q)}\\) (with \\(q>n\\)) Galois-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(q)\\).\n\nLet \\(C_1\\) be a \\([n,k_1,d_1]_q\\) Reed-Solomon code and \\(C_2^\\perp\\) be a \\([n,k_2,d_2]_q\\) Reed-Solomon code, modified such that \\(C_2^\\perp \\subseteq C_1\\) and \\(0\\le k_2 \\le k_1 \\le n\\). Then, a polynomial code is a non-degenerate \\([[n,k_2,d]]_{GF(q)}\\) Galois-qudit CSS code with \\(d=\\min(n-k_1+1,k_1-k_2+1)\\). The polynomial code is the span of the basis codewords over GF(\\(q\\)) \\begin{align}\n|\\overline{\\beta_0,\\cdots,\\beta_{k_2-1}}\\rangle\n=\n\\sum_{(\\beta_{k_2},\\cdots,\\beta_{k_1-1})\\in GF(q) }\n\\bigotimes_{i=1}^{n}\n\\left|\\sum_{j=0}^{k_1-1} \\beta_j \\alpha_i^j \\right\\rangle,\n\\end{align} where \\((\\alpha_1, \\cdots, \\alpha_n)\\) are \\(n\\) distinct points chosen for code \\(C_1\\) from \\(GF(q)\\setminus \\{0\\}\\).' ", "name": "Galois-qudit RS code", "realizations": "", "short_name": "Galois RS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "galois_grs\ngalois_css", "parents_detail": "\n", "cousins_code_id": "polynomial\nreed_solomon\nquantum_mds", "cousins_detail": "Polynomial codes can be defined for modular qudits of prime dimension or, more generally, for Galois qudits.\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).", "cousin_of_code_id": "quantum_secret_sharing", "cousin_of_detail": "Polynomial codes can be used for a specific construction of this code.", "_type": "ecc", "_page_id": "c_galois_polynomial", "_href": "c/galois_polynomial"}, "c_dynamic_gen": {"notes": "", "logical": "", "code_id": "dynamic_gen", "physical": "", "protection": "", "introduced": "[P. Hayden and J. Preskill, \u201cBlack holes as mirrors: quantum information in random subsystems\u201d, Journal of High Energy Physics 2007, 120 (2007). DOI; 0708.4025]", "description": "Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process. Such processes, which are often non-deterministic, update the code structure and can include random unitary evolution or non-commuting projective measurements.", "name": "Dynamically-generated quantum error-correcting code", "realizations": "", "short_name": "Dynamically-generated", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "floquet\nrandom_circuit", "parent_of_detail": "\n", "cousin_of_code_id": "clifford-deformed_surface\nqldpc", "cousin_of_detail": "To create CDSCs, a dynamical process is applied on top of the surface code.\nQLDPC codes can arise from a dynamical process [M. Ippoliti et al., \u201cEntanglement Phase Transitions in Measurement-Only Dynamics\u201d, Physical Review X 11, (2021). DOI; 2004.09560].", "_type": "ecc", "_page_id": "c_dynamic_gen", "_href": "c/dynamic_gen"}, "c_quantum_concatenated": {"notes": "", "logical": "", "code_id": "quantum_concatenated", "physical": "", "protection": "", "introduced": "", "description": "A combination of two codes, an inner code \\(C\\) and an outer code \\(C^\\prime\\), where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code \\(C^\\prime\\), and then one encodes each of the physical registers of \\(C^\\prime\\) in an inner code \\(C\\).", "name": "Concatenated quantum code", "realizations": "", "short_name": "", "features_threshold": "The first method to achieve a fault-tolerant computational threshold uses concatenated stabilizer codes [E. Knill, R. Laflamme, and W. H. Zurek, \u201cResilient quantum computation: error models and thresholds\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 454, 365 (1998). DOI; quant-ph/9702058][Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129][J. Preskill, \u201cReliable quantum computers\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 454, 385 (1998). DOI; quant-ph/9705031][Panos Aliferis, Daniel Gottesman, and John Preskill, \u201cQuantum accuracy threshold for concatenated distance-3 codes\u201d. quant-ph/0504218].", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "quantum_lego", "parents_detail": "", "cousin_of_code_id": "concatenated\ngkp-cluster-state\nquantum_divisible\nquantum_parity\nshor_nine", "cousin_of_detail": "\n\nA fault-tolerant \\(T\\) gate on the five-qubit or Steane code can be obtained by concatenating with particular quantum divisible codes.\nA QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code.\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.", "_type": "ecc", "_page_id": "c_quantum_concatenated", "_href": "c/quantum_concatenated"}, "c_qecc_finite": {"notes": "", "logical": "", "code_id": "qecc_finite", "physical": "", "protection": "Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a finite-dimensional quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{K}\\to\\mathsf{H}_{N}\\) with a set of correctable errors \\({\\cal{E}}:\\mathsf{H}_N\\to\\mathsf{H}_M\\) with the following property: there exists a quantum operation \\({\\cal{D}}:\\mathsf{H}_M\\to \\mathsf{H}_K\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{K}\\), \\begin{align}\n{\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\end{align} for some constant \\(c\\) [D. Gottesman. Surviving as a quantum computer in a classical world]. A code is said to protect against or correct the errors \\(\\mathcal{E}\\).\n\nKnill-Laflamme error correction conditions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nEquivalently, correction capability is determined by of the quantum error-correction conditions [E. Knill, R. Laflamme, and L. Viola, \u201cTheory of Quantum Error Correction for General Noise\u201d, Physical Review Letters 84, 2525 (2000). DOI; quant-ph/9604034][C. H. Bennett et al., \u201cMixed-state entanglement and quantum error correction\u201d, Physical Review A 54, 3824 (1996). DOI; quant-ph/9604024], which may admit infinite terms due to non-normalizability of ideal code states. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an approximate code.\n\nKnill-Laflamme conditions: In a finite-dimensional Hilbert space, there are necessary and sufficient conditions for a code to successfully correct a set of errors. These are called the Knill-Laflamme conditions\u00a0[E. Knill, R. Laflamme, and L. Viola, \u201cTheory of Quantum Error Correction for General Noise\u201d, Physical Review Letters 84, 2525 (2000). DOI; quant-ph/9604034][J. Preskill. Lecture notes on Quantum Computation. (1997\u20132020) URL][M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum Information (Cambridge University Press, 2009). DOI]. A code defined by a partial isometry \\(U\\) with code space projector \\(\\Pi = U U^\\dagger\\) can correct a set of errors \\(\\{ E_j \\}\\) if and only if \\begin{align}\n  \\Pi E_i^\\dagger E_j \\Pi = c_{ij}\\, \\Pi\\qquad\\text{for all \\(i,j\\),}\n\\end{align} where \\(c_{ij}\\) can be arbitrary numbers.\n\nA code is degenerate with respect to a noise model if different errors map code states to the same error subspace. For a linearly independent error set \\(\\cal{E}\\), degeneracy is equivalent to \\(\\text{rank}(c_{ij}) < |\\cal{E}|\\).", "introduced": "", "description": "Encodes quantum information in a \\(K\\)-dimensional (logical) subspace of an \\(N\\)-dimensional (physical) Hilbert space such that it is possible to recover said information from errors. The logical subspace is spanned by a basis comprised of code basis states or codewords.", "name": "Finite-dimensional quantum error-correcting code", "realizations": "", "short_name": "Finite QECC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The operation \\(\\cal{D}\\) in the definition of this code is called the decoder. However, the term decoder can sometimes be used for the inverse of an encoder, which does not correct errors.\nQuantum machine-learning based decoders such as quantum convolutional neural networks [I. Cong, S. Choi, and M. D. Lukin, \u201cQuantum convolutional neural networks\u201d, Nature Physics 15, 1273 (2019). DOI; 1810.03787] and quantum autoencoders [David F. Locher, Lorenzo Cardarelli, and Markus M\u00fcller, \u201cQuantum Error Correction with Quantum Autoencoders\u201d. 2202.00555].", "features_general_gates": "Universal gate set cannot be transversal for any code that detects single-qubit errors due to Eastin-Knill theorem [B. Eastin and E. Knill, \u201cRestrictions on Transversal Encoded Quantum Gate Sets\u201d, Physical Review Letters 102, (2009). DOI; 0811.4262].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "category_quantum\nmetopt\nfermions\ngalois_into_galois\nqudits_into_qudits\nquantum_perfect\nquantum_mds\nqubits_into_qubits\nspins_into_spins", "parent_of_detail": "\nSemidefinite-program optimization procedure for finding a metrologically optimal code holds for finite-dimensional spaces.\n\n\n\n\n\n\n", "_type": "ecc", "_page_id": "c_qecc_finite", "_href": "c/qecc_finite"}, "c_symmetry_protected_self_correct": {"notes": "", "logical": "", "code_id": "symmetry_protected_self_correct", "physical": "", "protection": "The code is intended to be used as a self-correcting quantum memory when the symmetry is enforced, and protection is characterized by the scaling of the memory time \\(\\tau\\) in the system size.\n\nAnother characterization of the protection property is the symmetric version of the energy barrier \\(\\Delta\\), defined as follows. For a given logical operator and a given decomposition into a product of local operators, we consider the maximal energy attained when implementing this logical operator stepwise with this decomposition. Then, \\(\\Delta\\) is defined by minimizing this quantity over all logical operators and over those decompositions for which each local operator respects the symmetry. For some models [S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474], the linear growth of \\(\\Delta\\) with system size \\(n\\) implies the exponential growth of \\(\\tau\\) below a critical temperature.", "introduced": "[S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]", "description": "Also called a symmetry-protected self-correcting memory. An restricted notion of thermal stability against symmetric perturbations, i.e., perturbations that commute with a set of operators forming a group \\(G\\) called the symmetry group.\n\nGiven a symmetry group \\(G\\) and its unitary representation \\(S\\) on the \\(n\\)-site physical Hilbert space (in this case, a lattice), an operator \\(O\\) is \\(G\\)-symmetric (a.k.a. respects the \\(G\\) symmetry) if \\([S(g),O]=0\\) for all \\(g\\in G\\). A symmetry-protected self-correcting memory is a ground-state encoding of an \\(n\\)-body \\(G\\)-symmetric geometrically local Hamiltonian whose logical information is recoverable for arbitrary long times in the \\(n\\to\\infty\\) limit after a \\(G\\)-symmetric interaction with a thermal environment at sufficiently low temperature.\n\nTensor-product symmetries of the form \\(S(g)=u(g)^{\\otimes n}\\), where \\(u\\) is a unitary representation of \\(G\\ni g\\) on a site, cannot support symmetry-protected self-correction. One can instead use 1-form symmetries, i.e., symmetries generated by operators of the form \\begin{align}\n  S_{\\mathcal{M}}(g)=\\bigotimes_{\\text{sites}\\in\\mathcal{M}}u(g),\n\\end{align} where \\(\\mathcal{M}\\) runs over all closed codimension-one submanifolds of the lattice. Recent work further relaxed the requirement so that symmetries need only be enforced on the system's boundaries [Charles Stahl, \u201cSelf-correction from higher-form symmetry protection on a boundary\u201d. 2206.05294].", "name": "Symmetry-protected self-correcting quantum code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "self_correct", "parents_detail": "", "cousin_of_code_id": "rbh\nsubsystem_color", "cousin_of_detail": "\nA particular gauge-fixed version of this code on a 3D lattice yields a self-correcting memory protected by one-form symmetries (see Sec. IV D of Ref. [S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]). The symmetric energy barrier grows linearly with the length of a side of the lattice. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the side length.", "_type": "ecc", "_page_id": "c_symmetry_protected_self_correct", "_href": "c/symmetry_protected_self_correct"}, "c_stabilizer": {"notes": "", "description": "A code whose logical subspace is the joint eigenspace (usually with eigenvalue \\(+1\\)) of a set of commuting unitary operators forming the code's stabilizer group. Stabilizer codes have been defined for qubits, modular qudits, Galois qudits, and oscillators using their respective Pauli-type groups.\n\nThe coding theory motivation for stabilizer codes came from linear binary codes, whose codewords form a closed subspace in the space of binary strings. Stabilizer codes extend this property, in various ways, to quantum error correction. The stabilizer formalism is applicable to the qubit, modular-qudit, Galois-qudit, bosonic, and fermionic kingdoms; see list of stabilizer codes for a list of all stabilizer codes in the zoo.\n\nStabilizer codes were originally defined for qubits, where the relevant commuting operators are tensor products of Pauli matrices. The Pauli stabilizer structure is immensely useful in providing standardized encoding, gates, decoding, and performance bounds. Elements of this structure remain in qudit extensions, in particular for prime-dimensional modular qudits and Galois qudits. Other qubit-based extensions, such as XS and XP stabilizer codes, relax the mutual commutation property. Still other extensions defined for qudits include non-stabilizer codes.\n\nAn important property of qubit and qudit stabilizer codes is the QLDPC property, which means (roughly) that working with them remains not too hard as number of qudits grows; these remain as the primary ingredients for a quantum memory.", "name": "Stabilizer code", "code_id": "stabilizer", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "oscillator_stabilizer\ngalois_stabilizer\nqudit_stabilizer\nqldpc\nqubit_stabilizer", "parent_of_detail": "\n\n\n\n", "cousin_of_code_id": "linear\nmajorana_stab", "cousin_of_detail": "Linear (stabilizer) codes form a large and well-studied subset of all classical (quantum) codes because features such as decoding and level of protection are typically easier to determine than those of nonlinear (non-stabilizer) codes.\nMajorana stabilizer codes are useful for Majorana-based architectures, where the degrees of freedom are electrons, and the notion of locality is different than all other code kingdoms.", "_type": "ecc", "_page_id": "c_stabilizer", "_href": "c/stabilizer"}, "c_quantum_cyclic": {"notes": "Many examples have been found by computer algebra programs. Ref. [Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code\u201d. 1007.1697] give examples of \\([[17,1,7]]\\) and \\([[17,9,3]]\\) quantum cyclic codes.", "logical": "", "code_id": "quantum_cyclic", "physical": "", "protection": "Cyclic symmetry guarantees that if a single subsystem is protected against some noise, then all other subsystems are also.", "introduced": "[Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code\u201d. 1007.1697]", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) such that cyclic permutations of the subsystems leave any codeword invariant.", "name": "Quantum cyclic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Adapted from the Berlekamp decoding algorithm for classical BCH codes [Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code\u201d. 1007.1697].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "frobenius\npermutation_invariant", "parent_of_detail": "\nThe cyclic group of these codes is a subgroup of the \\(S_n\\) symmetric group used in permutation invariant codes.", "cousins_code_id": "cyclic", "cousins_detail": "", "cousin_of_code_id": "stab_5_1_3", "cousin_of_detail": "\\([[5,1,3]]\\) code is the smallest known example of quantum cyclic code.", "_type": "ecc", "_page_id": "c_quantum_cyclic", "_href": "c/quantum_cyclic"}, "c_random_circuit": {"notes": "", "logical": "", "code_id": "random_circuit", "physical": "", "protection": "", "introduced": "", "description": "Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.", "name": "Random-circuit code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "dynamic_gen\nquantum_random", "parents_detail": "\n", "parent_of_code_id": "haar_random\nt-designs\nnonlocal_lowdepth\nmonitored_random_circuits", "parent_of_detail": "\n\n\nMonitored random circuits are random circuits where projective measurements are interspersed throughout the circuit and measurement results are recorded.", "_type": "ecc", "_page_id": "c_random_circuit", "_href": "c/random_circuit"}, "c_approximate_qecc": {"notes": "There exist approximate versions of the Knill-Laflamme conditions that can be used to determine the degree to which a code is an approximate error-correcting code\u00a0[C. B\u00e9ny and O. Oreshkov, \u201cGeneral Conditions for Approximate Quantum Error Correction and Near-Optimal Recovery Channels\u201d, Physical Review Letters 104, (2010). DOI; 0907.5391]. Various sufficient criteria have also been derived; see for instance refs.\u00a0[D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002][Claude Crepeau, Daniel Gottesman, and Adam Smith, \u201cApproximate Quantum Error-Correcting Codes and Secret Sharing Schemes\u201d. quant-ph/0503139][F. G. S. L. Brand\u00e3o et al., \u201cQuantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains\u201d, Physical Review Letters 123, (2019). DOI; 1710.04631][P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]. ", "logical": "", "code_id": "approximate_qecc", "physical": "", "protection": "", "introduced": "[D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002][A. Y. Kitaev, \u201cQuantum computations: algorithms and error correction\u201d, Russian Mathematical Surveys 52, 1191 (1997). DOI][M. Reimpell and R. F. Werner, \u201cIterative Optimization of Quantum Error Correcting Codes\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0307138][Claude Crepeau, Daniel Gottesman, and Adam Smith, \u201cApproximate Quantum Error-Correcting Codes and Secret Sharing Schemes\u201d. quant-ph/0503139][C\u00e9dric B\u00e9ny, \u201cConditions for the approximate correction of algebras\u201d. 0907.4207][C. B\u00e9ny and O. Oreshkov, \u201cGeneral Conditions for Approximate Quantum Error Correction and Near-Optimal Recovery Channels\u201d, Physical Review Letters 104, (2010). DOI; 0907.5391]", "description": "Stub.", "name": "Approximate quantum error-correcting code (AQECC)", "realizations": "", "short_name": "AQECC", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Given an encoding, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [K. Audenaert and B. De Moor, \u201cOptimizing completely positive maps using semidefinite programming\u201d, Physical Review A 65, (2002). DOI; quant-ph/0109155][M. Reimpell and R. F. Werner, \u201cIterative Optimization of Quantum Error Correcting Codes\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0307138] (see also Ref. [Andrew S. Fletcher, \u201cChannel-Adapted Quantum Error Correction\u201d. 0706.3400]).\nThe Petz recovery map (a.k.a. the transpose map) [D. Petz, \u201cSufficient subalgebras and the relative entropy of states of a von Neumann algebra\u201d, Communications in Mathematical Physics 105, 123 (1986). DOI][D. PETZ, \u201cSUFFICIENCY OF CHANNELS OVER VON NEUMANN ALGEBRAS\u201d, The Quarterly Journal of Mathematics 39, 97 (1988). DOI], a quantum channel determined by the codespace and noise channel, recovers information perfectly for strictly correctable noise and yields an infidelity of recovery that is at most twice away from the infidelity of the best possible recovery [H. Barnum and E. Knill, \u201cReversing quantum dynamics with near-optimal quantum and classical fidelity\u201d. quant-ph/0004088]. The infidelity of a modified Petz recovery map can be bounded using relative entropies between uncorrupted and corrupted code states on countably infinite Hilbert spaces [M. Junge et al., \u201cUniversal Recovery Maps and Approximate Sufficiency of Quantum Relative Entropy\u201d, Annales Henri Poincar\u00e9 19, 2955 (2018). DOI; 1509.07127].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Given a decoder, an encoding that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [K. Audenaert and B. De Moor, \u201cOptimizing completely positive maps using semidefinite programming\u201d, Physical Review A 65, (2002). DOI; quant-ph/0109155][M. Reimpell and R. F. Werner, \u201cIterative Optimization of Quantum Error Correcting Codes\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0307138] (see also Ref. [Andrew S. Fletcher, \u201cChannel-Adapted Quantum Error Correction\u201d. 0706.3400]).", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "eth\nnonabelian_covariant_erasure", "parent_of_detail": "ETH codes approximately protect against erasures in the thermodynamic limit.\n", "cousin_of_code_id": "quantum_secret_sharing\ncovariant\ngnu_permutation_invariant\ngkp\nt-designs\nmultimodegkp\nqudits_into_oscillators\nstab_4_2_2", "cousin_of_detail": "Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors.\nNormalizable constructions of infinite-dimensional \\(G\\)-covariant codes for continuous \\(G\\) are approximately error-correcting.\nGNU codes protect approximately against amplitude damping errors.\nGKP codes approximately protect against photon loss [B. M. Terhal and D. Weigand, \u201cEncoding a qubit into a cavity mode in circuit QED using phase estimation\u201d, Physical Review A 93, (2016). DOI; 1506.05033][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].\n\nApproximate error-correction offered by GKP codes yields achievable rates that are a constant away from the capacity of Guassian loss channels [J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058][K. Sharma et al., \u201cBounding the energy-constrained quantum and private capacities of phase-insensitive bosonic Gaussian channels\u201d, New Journal of Physics 20, 063025 (2018). DOI; 1708.07257][M. Rosati, A. Mari, and V. Giovannetti, \u201cNarrow bounds for the quantum capacity of thermal attenuators\u201d, Nature Communications 9, (2018). DOI; 1801.04731][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].\nApproximate QEC techniques of finding the entanglement fidelity can be adapted to bosonic codes with a finite-dimensional codespace [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].\n\\([[4,1,2]]\\) subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002] and \\(\\{|\\overline{01}\\rangle,|\\overline{11}\\rangle\\}\\) [G. Alber et al., \u201cStabilizing Distinguishable Qubits against Spontaneous Decay by Detected-Jump Correcting Quantum Codes\u201d, Physical Review Letters 86, 4402 (2001). DOI; quant-ph/0103042] approximately correct a single amplitude damping error.", "_type": "ecc", "_page_id": "c_approximate_qecc", "_href": "c/approximate_qecc"}, "c_holographic": {"notes": "All Boundary global symmetries must be dual to bulk gauge symmetries, and vice versa [Daniel Harlow and Hirosi Ooguri, \u201cSymmetries in quantum field theory and quantum gravity\u201d. 1810.05338].", "logical": "", "code_id": "holographic", "physical": "", "protection": "Protects against erasure errors on the boundary. Error-correction properties are often stated in the Heisenberg picture, i.e., in terms of which logical operators can be reconstructed after erasures. Specifically, bulk operators outside the entanglement wedges of the erased boundary operators can be reconstructed using the remaining boundary operators. However, the protection can be nontrivial, and may only apply to a subalgebra of bulk operators [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][F. Pastawski and J. Preskill, \u201cCode Properties from Holographic Geometries\u201d, Physical Review X 7, (2017). DOI; 1612.00017].", "introduced": "[F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237]", "description": "A code whose encoding isometry serves to model aspects of the AdS/CFT holographic duality. Encodes operators in the bulk of the Anti de Sitter (AdS) space, represented by logical qudits, into operators on the boundary of the corresponding Conformal Field Theory (CFT), represented by physical qudits. Encoding can often be represented by a tensor network associated with a tiling of hyperbolic space. See Defn 4.3 of Ref. [Kfir Dolev et al., \u201cGauging the bulk: generalized gauging maps and holographic codes\u201d. 2108.11402] for a technical formulation.\n\nTypically, the encoding isometry \\(U\\) obeys the entanglement-wedge reconstruction condition, which states that for any boundary region \\(R\\), any bulk operator \\(O\\) localized to the entanglement wedge of \\(R\\) must be implementable by some boundary operator \\(\\tilde{O}\\) localized to \\(R\\). Formally, \\(UO = \\tilde{O}U\\) and \\([\\tilde{O},UU^\\dagger] = 0\\). The entanglement wedge is the space enclosed within the Ryu\u2013Takayanagi surface in the bulk (minimal surface) with boundary \\(R\\). ", "name": "Holographic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "The ideal holographic code (perfect representation of AdS/CFT) should be able to protect a central bulk operator against erasures of half of the physical qubits on the boundary, in line with AdS-Rindler reconstruction [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nHolographic codes are argued to have a algebraic threshold, for which the error rate scales polynomially (as opposed to exponentially) in the thermodynamic limit [Ning Bao, Charles Cao, and Guanyu Zhu, \u201cDeconfinement and Error Thresholds in Holography\u201d. 2202.04710]. Such a threshold is governed by the underlying conformal field theory describing the boundary.", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "There exist holographic approximate codes with arbitrary transversal gate sets for any compact Lie group [Kfir Dolev et al., \u201cGauging the bulk: generalized gauging maps and holographic codes\u201d. 2108.11402]. However, for sufficiently localized logical subsystems of holographic stabilizer codes, the set of transversally implementable logical operations is contained in the Clifford group [S. Cree et al., \u201cFault-Tolerant Logical Gates in Holographic Stabilizer Codes Are Severely Restricted\u201d, PRX Quantum 2, (2021). DOI; 2103.13404].", "features_fault_tolerance": "", "parents_code_id": "oaecc", "parents_detail": "Properties of holographic codes are often quantified in the Heisenberg picture, i.e., in terms of operator algebras [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][F. Pastawski and J. Preskill, \u201cCode Properties from Holographic Geometries\u201d, Physical Review X 7, (2017). DOI; 1612.00017].", "parent_of_code_id": "happy\nstab_3_1_2", "parent_of_detail": "\nThree-qutrit code is a minimal model for holography [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][D. Harlow, \u201cThe Ryu\u2013Takayanagi Formula from Quantum Error Correction\u201d, Communications in Mathematical Physics 354, 865 (2017). DOI; 1607.03901].", "cousin_of_code_id": "hyperbolic_surface\nquantum_lego", "cousin_of_detail": "Both holographic and hyperbolic surface codes utilize tesselations of hyperbolic surfaces. Encodings for the former are hyperbolically tiled tensor networks, while the latter is defined on hyperbolically tiled physical-qubit lattices.\nHolographic codes whose encoders are tensor networks discretizing hyperbolic space are quantum Lego codes.", "_type": "ecc", "_page_id": "c_holographic", "_href": "c/holographic"}, "c_quantum_random": {"notes": "", "description": "Quantum code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes (e.g., random-circuit codes), to codes whose multi-step construction is deterministic with the exception of a single step (e.g., expander lifter-product codes).", "name": "Random quantum code", "code_id": "quantum_random", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "random_circuit", "parent_of_detail": "", "cousins_code_id": "random", "cousins_detail": "", "cousin_of_code_id": "clifford-deformed_surface\ncovariant\nfiber_bundle\nhomological_product", "cousin_of_detail": "Many useful CDSCs are constructed using random Clifford circuits.\nRandom \\(U(d)\\)-covariant almost exactly error-correcting codes exist [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][L. Kong and Z.-W. Liu, \u201cNear-Optimal Covariant Quantum Error-Correcting Codes from Random Unitaries with Symmetries\u201d, PRX Quantum 3, (2022). DOI; 2112.01498].\n\n", "_type": "ecc", "_page_id": "c_quantum_random", "_href": "c/quantum_random"}, "c_fusion": {"notes": "", "logical": "qubits", "code_id": "fusion", "physical": "qubits", "protection": "Protects against erasure, Pauli errors, photon loss, fusion failure from non-determinism, and faulty resource states. Redundancy in fusion outcomes is captured by the check operator group. Fusion measurement outcomes form a syndrome that allows to correct for Pauli errors. There is no physical error correction, and decoding output is simply used to update the Pauli frame.", "introduced": "[Sara Bartolucci et al., \u201cFusion-based quantum computation\u201d. 2101.09310]", "description": "Fusion Based Quantum Computing, or FBQC, describes a fault tolerant way to produce fusion networks, or large entangled states starting from small constant-sized entangled resource states along with destructive measurements called fusions. These large states can be produced asychronously in the fusion framework and can be used as resources, as in measurement-based quantum computation (MBQC), or as logical states of topological codes. The difference from ordinary MBQC is that error-correction is baked into the state-generation protocol.", "name": "Fusion-based quantum computing (FBQC) code", "realizations": "", "short_name": "FBQC", "features_threshold": "\\(11.98\\%\\) against erasure in fusion measurements.\n\\(1.07\\%\\) against Pauli error.\nIn linear optical systems, can tolerate \\(10.4\\%\\) probability of photon loss in each fusion.\n\\(43.2\\%\\) against fusion failure.", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "Clifford gates by creating topological features such as boundaries, defects, or twists, which can be done by single qubit measurements.\nLogical gates can be performed by code deformation.\nNon Clifford gates by Magic-state injection\nLogical Clifford operations can be kept track of using the classical Pauli-frame register and need not be explicitly applied at the quantum level.", "features_magic_scaling_exponent": "", "features_encoders": "Resource state generators, which produce small constant size cluster states, and Fusion measurements (Bell fusions).", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Fusion networks are constructed in a fault tolerant way (as a stabilizer code), and they can be created in a way that naturally encodes topological fault tolerance.", "parents_code_id": "qubit_stabilizer", "parents_detail": "The resource states in FBQC are small stabilizer states, and after fusion measurements, the outputs are stabilizers (conditioned on measurement outcomes.", "cousins_code_id": "topological\nfock_state", "cousins_detail": "Arbitrary topological codes can be created using FBQC, as can topological features such as defects and boundaries, by modifying fusion measurements or adding single qubit measurements.\nWhile FBQC is a general framework, an intended application to linear-optical quantum computing will likely utilize small Fock-state bosonic codes such as the dual-rail code.", "_type": "ecc", "_page_id": "c_fusion", "_href": "c/fusion"}, "c_quantum_perfect": {"notes": "", "logical": "", "code_id": "quantum_perfect", "physical": "", "protection": "Perfect codes have been classified. For qubits (\\(q=2\\)), the only codes are the stabilizer code family \\([[(4^r-1)/3, (4^r-1)/3 - 2r, 3]]\\) for \\(r \\geq 2\\) [Daniel Gottesman, \u201cPasting Quantum Codes\u201d. quant-ph/9607027][A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006]. For qudits, the family is parameterized by \\(K=q^{n-2r}\\) for \\(n=\\frac{q^{2r}-1}{q^{2}-1}\\) and \\(r \\geq 2\\); all codes correct a single error (\\(t=1\\)) [Zhuo Li and Lijuan Xing, \u201cNo More Perfect Codes: Classification of Perfect Quantum Codes\u201d. 0907.0049][J. Bierbrauer and Y. Edel, \u201cQuantum twisted codes\u201d, Journal of Combinatorial Designs 8, 174 (2000). DOI]. The trivial code (\\(k=n\\)) is also perfect.", "introduced": "", "description": "A non-degenerate code constructed out of \\(q\\)-dimensional qudits and having parameters \\(((n,K,2t+1))\\) is perfect if \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the quantum Hamming bound \\begin{align}\n\\sum_{j=0}^{t}(q^2-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align} becomes an equality. For example, for a qubit \\(q=2\\) code with one logical qubit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(3n+1 \\leq 2^{n-1}\\). The bound can be saturated only at certain \\(n\\).\n\nFor qubit codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit, \\begin{align}\n\\frac{k}{n}\\leq 1-\\frac{t}{n}\\log_{2}3-h(t/n),\n\\end{align} where \\(h\\) is the binary entropy function. ", "name": "Perfect quantum code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "\\(k/n\\to 1\\) asymptotically with \\(n\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "", "cousins_code_id": "perfect", "cousins_detail": "A classical (quantum) perfect code saturates the classical (quantum) Hamming bound.", "cousin_of_code_id": "quantum_hamming\nstab_5_1_3", "cousin_of_detail": "Quantum Hamming codes saturate the asymptotic Hamming bound.\nThe smallest perfect code.", "_type": "ecc", "_page_id": "c_quantum_perfect", "_href": "c/quantum_perfect"}, "c_quantum_mds": {"notes": "The \\([[5,1,3]]\\) code and \\([[n,n-2,2]]\\) codes, where \\(n\\) is even, are the only examples of MDS qubit codes.", "logical": "", "code_id": "quantum_mds", "physical": "", "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error correction properties.", "introduced": "", "description": "An \\(((n,q^k,d))\\) code constructed out of \\(q\\)-dimensional qudits is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the quantum Singleton bound \\begin{align}\n2(d-1) \\leq n-k\n\\end{align} becomes an equality. ", "name": "Quantum maximum-distance-separable (MDS) code", "realizations": "", "short_name": "Quantum MDS", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "stab_3_1_2", "parent_of_detail": "The three-qutrit code is the smallest nontrivial quantum MDS code.", "cousins_code_id": "mds\nq-ary_cyclic", "cousins_detail": "\nQuantum MDS codes can be constructed from \\(q\\)-ary cyclic codes using the Hermitian construction [G. G. La Guardia, \u201cNew Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 57, 5551 (2011). DOI].", "cousin_of_code_id": "galois_grs\ngalois_polynomial\npolynomial\ngalois_true_stabilizer\nstab_5_1_3", "cousin_of_detail": "Some Galois-qudit GRS codes are quantum MDS [Lingfei Jin and Chaoping Xing, \u201cA Construction of New Quantum MDS Codes\u201d. 1311.3009].\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).\nMany MDS codes are constructed from Hermitian self-orthogonal codes over \\(GF(q^2)\\) using the Hermitian construction [M. GRASSL, T. BETH, and M. R\u00d6TTELER, \u201cON OPTIMAL QUANTUM CODES\u201d, International Journal of Quantum Information 02, 55 (2004). DOI; quant-ph/0312164][R. Li and Z. Xu, \u201cConstruction of<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mo stretchy=\"false\">[</mml:mo><mml:mo stretchy=\"false\">[</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>\u2212</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy=\"false\">]</mml:mo><mml:mo stretchy=\"false\">]</mml:mo><mml:msub><mml:mrow /><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>quantum codes for odd prime power<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:math>\u201d, Physical Review A 82, (2010). DOI; 0906.2509][Xianmang He, Liqing Xu, and Hao Chen, \u201cNew $q$-ary Quantum MDS Codes with Distances Bigger than $\\frac{q}{2}$\u201d. 1507.08355][Liangdong Lu et al., \u201cNew Quantum MDS codes constructed from Constacyclic codes\u201d. 1803.07927], in particular from cyclic [G. G. La Guardia, \u201cNew Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 57, 5551 (2011). DOI], constacyclic [X. Kai, S. Zhu, and P. Li, \u201cConstacyclic Codes and Some New Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 60, 2080 (2014). DOI][B. Chen, S. Ling, and G. Zhang, \u201cApplication of Constacyclic Codes to Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 61, 1474 (2015). DOI] and negacyclic [X. Kai and S. Zhu, \u201cNew Quantum MDS Codes From Negacyclic Codes\u201d, IEEE Transactions on Information Theory 59, 1193 (2013). DOI] codes.\nThe smallest quantum MDS code.", "_type": "ecc", "_page_id": "c_quantum_mds", "_href": "c/quantum_mds"}, "c_permutation_invariant": {"notes": "Can be constructed using real polynomials for high-dimensional qudit spaces [Y. Ouyang, \u201cPermutation-invariant qudit codes from polynomials\u201d, Linear Algebra and its Applications 532, 43 (2017). DOI].", "logical": "", "code_id": "permutation_invariant", "physical": "", "protection": "Depends on the family. The GNU permutation-invariant family (parameterized by \\(t\\)) protects against arbitrary weight \\(t\\) qubit errors and approximately corrects spontaneous decay errors [Y. Ouyang, \u201cPermutation-invariant quantum codes\u201d, Physical Review A 90, (2014). DOI; 1302.3247][Y. Ouyang and J. Fitzsimons, \u201cPermutation-invariant codes encoding more than one qubit\u201d, Physical Review A 93, (2016). DOI]. Other related codes protect against amplitude damping [Y. Ouyang and R. Chao, \u201cPermutation-Invariant Constant-Excitation Quantum Codes for Amplitude Damping\u201d, IEEE Transactions on Information Theory 66, 2921 (2020). DOI; 1809.09801] while admitting a constant number of excitations, and against deletion errors [Y. Ouyang, \u201cPermutation-invariant quantum coding for quantum deletion channels\u201d, 2021 IEEE International Symposium on Information Theory (ISIT) (2021). DOI; 2102.02494][T. Shibayama and M. Hagiwara, \u201cPermutation-Invariant Quantum Codes for Deletion Errors\u201d, 2021 IEEE International Symposium on Information Theory (ISIT) (2021). DOI; 2102.03015].", "introduced": "[Harriet Pollatsek and Mary Beth Ruskai, \u201cPermutationally Invariant Codes for Quantum Error Correction\u201d. quant-ph/0304153]", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) such that any permutation of the subsystems leaves any codeword invariant.", "name": "Permutation-invariant code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "For a family of codes, using projection, probability amplitude rebalancing, and gate teleportation can be done in \\(O(N^2)\\) [Y. Ouyang, \u201cPermutation-invariant quantum coding for quantum deletion channels\u201d, 2021 IEEE International Symposium on Information Theory (ISIT) (2021). DOI; 2102.02494].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "With quantum harmonic oscillators (superconducting charge qubits in a ultrastrong coupling regime) in \\(O(N)\\) as in [C. Wu et al., \u201cInitializing a permutation-invariant quantum error-correction code\u201d, Physical Review A 99, (2019). DOI]. Can be done in \\(O(N^2)\\) steps using quantum circuits [A. B\u00e4rtschi and S. Eidenbenz, \u201cDeterministic Preparation of Dicke States\u201d, Fundamentals of Computation Theory 126 (2019). DOI; 1904.07358], or using geometric phase gates in \\(O(N)\\) [M. T. Johnsson et al., \u201cGeometric Pathway to Scalable Quantum Sensing\u201d, Physical Review Letters 125, (2020). DOI; 1908.01120].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "quantum_cyclic", "parents_detail": "The cyclic group of these codes is a subgroup of the \\(S_n\\) symmetric group used in permutation invariant codes.", "parent_of_code_id": "constant_excitation_permutation_invariant\ngnu_permutation_invariant", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_permutation_invariant", "_href": "c/permutation_invariant"}, "c_quantum_lego": {"notes": "Many known codes can be created using this code's methods in order to further their understanding, including a 6 qubit implementaion of the generalized Bacon-Shor code, the Toric code, and the \\([[7,1,3]]\\) Steane code.\nFor example, a simple \\( [[4,2,2]] \\) stabilizer code can be written as a rank 6 tensor. Attaching two of these via gluing together one logical leg from each can produce a \\( [[6,4,2]] \\) stabilizer code.\nTensor-network codes are types of LEGO codes made from stabilizer codes where logical and physical legs are pre-assigned and logical legs are not contracted. In other words, logical legs resulting from the conversion of codes to tensors must remain logical in the final tensor network, and the same for physical. Contracting logical legs is another word for gluing two logical legs together.", "logical": "", "code_id": "quantum_lego", "physical": "", "protection": "", "introduced": "[C. Cao and B. Lackey, \u201cQuantum Lego: Building Quantum Error Correction Codes from Tensor Networks\u201d, PRX Quantum 3, (2022). DOI; 2109.08158]", "description": "Code constructed using a tensor-network-based graphical framework from quantum lego blocks, which are smaller quantum codes over qubits or qudits. The class of codes constructed using the framework depends on the choice of atomic lego blocks. For instance, any stabilizer code can be built out of atomic blocks like the 2-site repetition code, single-site trivial stabilizer codes, and tensor products of the \\(|0\\rangle\\) state. Specifically, the HaPPY code is a quantum Lego code whose atomic Lego block is the five-qubit perfect code.\n\nThe individual lego blocks and resulting quantum lego codes can be stabilizer or non-stabilizer. However, both the logical and physical degrees of freedom must have the same local dimension.\n\nTo construct a Lego code, the encoding map \\(V\\) for each code that is to be used in the construction is converted to a tensor by decomposing it using the formula \\begin{align}\nV = \\sum_{i_j} V_{i_1 \\ldots i_{n+k}} | i_{k+1} \\ldots i_{k+n} \\rangle \\langle i_1 \\ldots i_k |~.\n\\end{align} We then look at the codes graphically, treating each \\(i_j\\) as an edge dangling out of the tensor vertex \\(V_{i_1 \\ldots i_{n+k}}\\). These edges are either connected to another tensor vertex's edges or left dangling. If the block codes are stabilizer, then each local tensor has unitary product stabilizers (UPS). The goal is to push each UPS through the tensor network until each dangling edge has only trivial support. Otherwise, a matching value is pushed through the edge and the process is repeated on the next tensor. If a UPS can be pushed through the whole network, then a UPS for the larger network has been found. The dangling legs (edges) and UPS of the whole network can then be converted to physical/logical elements and stabilizers/logical operators for a new quantum code.", "name": "Quantum Lego code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "The decoder is created by creating a decoding quantum circuit with dangling legs replaced with input/output wires, and tensors converted to unitary gates. Maximum likelihood decoding can be used when the tensors are stabilizer codes.\nTensor-network decoder when the tensor network is contractible via stabilizer isometries [T. Farrelly et al., \u201cTensor-Network Codes\u201d, Physical Review Letters 127, (2021). DOI; 2009.10329].\nTensor-network-based decoder when the encoding unitary is known [A. J. Ferris and D. Poulin, \u201cTensor Networks and Quantum Error Correction\u201d, Physical Review Letters 113, (2014). DOI; 1312.4578].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Unitary-circuit encoding exists for a restricted class of tensor networks contractible via isometries [C. Cao and B. Lackey, \u201cQuantum Lego: Building Quantum Error Correction Codes from Tensor Networks\u201d, PRX Quantum 3, (2022). DOI; 2109.08158].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "quantum_concatenated\nqudit_stabilizer\nqubit_stabilizer", "parent_of_detail": "\nModular-qudit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qudit repetition code, single-qudit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state.\nQubit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qubit repetition code, single-qubit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state.", "cousins_code_id": "holographic", "cousins_detail": "Holographic codes whose encoders are tensor networks discretizing hyperbolic space are quantum Lego codes.", "_type": "ecc", "_page_id": "c_quantum_lego", "_href": "c/quantum_lego"}, "c_self_correct": {"notes": "", "logical": "", "code_id": "self_correct", "physical": "", "protection": "Self-correcting classical memories exist in two and higher dimensions, with the canonical example being the classical Ising model. In that model, a classical bit is stored in the overall magnetization. The magnetization is thermally stable due to the fact that there is an \\(n\\)-dependent (i.e., macroscopic) energy cost of flipping a contiguous region of physical bits [R. Peierls, \u201cOn Ising's model of ferromagnetism\u201d, Mathematical Proceedings of the Cambridge Philosophical Society 32, 477 (1936). DOI][B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643]. This cost scales with the surface area of the region, and the surface area is \\(n\\)-dependent for dimensions greater than one.\n\nSelf-correcting quantum memories currently exist in four and higher dimensions, with their existence in three dimensions being an open question. For similar reasons as the classical Ising model, the four-dimensional toric code is a self-correcting quantum memory due to an order \\(O(n)\\) energy cost of creating a logical error [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][R. Alicki et al., \u201cOn thermal stability of topological qubit in Kitaev's 4D model\u201d. 0811.0033]. On the other hand, the 2D toric code is not thermally stable because its string-like logical operators anti-commite with stabilizer generators supported only at their ends, and thus have a constant energy cost of creation.\n\nAn \\(n\\)-dependent energy barrier to all logical errors is likely necessary for a thermally stable memory, having been shown as such for a large class of 2D topological phases [Kristan Temme, \u201cThermalization time bounds for Pauli stabilizer Hamiltonians\u201d. 1412.2858][A. K\u00f3m\u00e1r, O. Landon-Cardinal, and K. Temme, \u201cNecessity of an energy barrier for self-correction of Abelian quantum doubles\u201d, Physical Review A 93, (2016). DOI; 1601.01324][Angelo Lucia, David P\u00e9rez-Garc\u00eda, and Antonio P\u00e9rez-Hern\u00e1ndez, \u201cThermalization in Kitaev's quantum double models via Tensor Network techniques\u201d. 2107.01628]. Two-dimensional stabilizer codes [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983] and encodings of frustration-free code Hamiltonians [O. Landon-Cardinal and D. Poulin, \u201cLocal Topological Order Inhibits Thermal Stability in 2D\u201d, Physical Review Letters 110, (2013). DOI; 1209.5750] admit only constant-energy excitations, and so do not have admit such a barrier. No-go theorems for 3D models are much more restrictive, and there exist several candidates for self-correction as well as several partially self-correcting memories (see cousins below).", "introduced": "[E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][R. Alicki et al., \u201cOn thermal stability of topological qubit in Kitaev's 4D model\u201d. 0811.0033]", "description": "Also called a self-correcting quantum memory or thermally stable encoding. A ground-state encoding of an \\(n\\)-body geometrically local Hamiltonian whose logical information is recoverable for arbitrary long times in the \\(n\\to\\infty\\) limit after interaction with a sufficiently cold thermal environment. Typically, one also requires a decoder whose decoding time scales polynomially with \\(n\\) and a finite energy density.\n\nThe effect of a Markovian thermal environment consists of a Lindbladian in Davies form admitting a Gibbs steady state at some temperature \\(T\\) [B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643]. To test whether a system is self-correcting, an initial codeword \\(\\rho(0)\\) is evolved under the Davies Lindbladian and the code Hamiltonian (or code Lindbladian) to the state \\(\\rho(t)\\) at time \\(t\\), after which it is decoded via decoding map \\(\\cal{D}\\). The memory time \\(\\tau\\) is defined to be \\begin{align}\n  \\tau=\\sup\\left\\{ t>0\\,|\\left\\Vert {\\cal D}(\\rho(t))-\\rho(0)\\right\\Vert _{1}<\\epsilon\\right\\}\n\\end{align} for some fixed \\(\\epsilon\\). For a self-correcting memory, there exists a critical temperature \\(T_\\star>0\\) such that \\(\\tau\\to\\infty\\) (typically, exponentially with \\(n\\)) as \\(n\\to\\infty\\) for any temperature \\(T<T_{\\star}\\) and any codeword \\(\\rho(0)\\). A memory is partially self-correcting if \\(\\tau\\) scales polynomially with \\(n\\) up to some cutoff \\(n_{max}\\). A self-correcting memory is typically associated with a (stable) phase of quantum matter. ", "name": "Self-correcting quantum code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hamiltonian", "parents_detail": "", "parent_of_code_id": "symmetry_protected_self_correct", "parent_of_detail": "", "cousins_code_id": "translationally_invariant_stabilizer\nhigher_dimensional_surface\n3d_surface\ncolor\nhaah_cubic\nquantum_repetition", "cousins_detail": "3D translationally-invariant qubit stabilizer code families with constant \\(k\\) support logical string operators and thus cannot be self-correcting [B. Yoshida, \u201cFeasibility of self-correcting quantum memory and thermal stability of topological order\u201d, Annals of Physics 326, 2566 (2011). DOI; 1103.1885]. For non-constant \\(k\\), such families can support at most a logarithmic energy barrier [J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962].\nThe 4D toric code is a self-correcting quantum memory [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][R. Alicki et al., \u201cOn thermal stability of topological qubit in Kitaev's 4D model\u201d. 0811.0033].\nThe 3D welded solid code is partially self-correcting with a power-law energy barrier [K. P. Michnicki, \u201c3D Topological Quantum Memory with a Power-Law Energy Barrier\u201d, Physical Review Letters 113, (2014). DOI; 1406.4227].\nThe 6D color code is a self-correcting quantum memory [H. Bombin et al., \u201cSelf-Correcting Quantum Computers\u201d. 0907.5228].\nCubic code 1 is partially self-correcting with a logarithmic energy barrier [S. Bravyi and J. Haah, \u201cQuantum Self-Correction in the 3D Cubic Code Model\u201d, Physical Review Letters 111, (2013). DOI; 1112.3252].\nThe bit-flip repetition code associated with the 2D classical Ising model is a self-correcting classical memory.", "_type": "ecc", "_page_id": "c_self_correct", "_href": "c/self_correct"}, "c_topological": {"notes": "", "logical": "", "code_id": "topological", "physical": "", "protection": "", "introduced": "", "description": "Stub.", "name": "Topological code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "The unitary circuit depth required to initialize in a topologically ordered state using geometrically local gates on an \\(L\\times L\\) lattice is \\(\\Omega(L)\\) [S. Bravyi, M. B. Hastings, and F. Verstraete, \u201cLieb-Robinson Bounds and the Generation of Correlations and Topological Quantum Order\u201d, Physical Review Letters 97, (2006). DOI; quant-ph/0603121], irrespective of whether the ground state admits Abelian or non-Abelian anyonic excitations.", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hamiltonian", "parents_detail": "Codespace is either the ground-state or low-energy subspace of a geometrically local Hamiltonian admitting a topological phase.", "parent_of_code_id": "topological_abelian\ngalois_topological\nquantum_double\nstring_net", "parent_of_detail": "\n\nQuantum-double code Hamiltonians admit topological phases associated with finite groups \\(G\\).\nString-net codes can be realized using Levin-Wen model Hamiltonians, which realize various topological phases [M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816][Alexander Kirillov Jr, \u201cString-net model of Turaev-Viro invariants\u201d. 1106.6033].", "cousin_of_code_id": "eth\nfracton\nfusion\nt-designs\nmonitored_random_circuits\nqldpc", "cousin_of_detail": "ETH codewords, like topological codewords, are locally indistinguishable.\nFracton phases can be understood as topological defect networks, meaning that they can be described in the language of topological quantum field theory [D. Aasen et al., \u201cTopological defect networks for fractons of all types\u201d, Physical Review Research 2, (2020). DOI; 2002.05166].\nArbitrary topological codes can be created using FBQC, as can topological features such as defects and boundaries, by modifying fusion measurements or adding single qubit measurements.\nLocal Haar-random codewords, like topological codewords, are locally indistinguishable [F. G. S. L. Brand\u00e3o, A. W. Harrow, and M. Horodecki, \u201cLocal Random Quantum Circuits are Approximate Polynomial-Designs\u201d, Communications in Mathematical Physics 346, 397 (2016). DOI].\nTopological order can be generated in 2D monitored random circuits [A. Lavasani, Y. Alavirad, and M. Barkeshli, \u201cTopological Order and Criticality in <mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mo stretchy=\"false\">(</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy=\"false\">)</mml:mo><mml:mi mathvariant=\"normal\">D</mml:mi></mml:mrow></mml:math> Monitored Random Quantum Circuits\u201d, Physical Review Letters 127, (2021). DOI; 2011.06595].\nTopological codes are not generally defined using Pauli strings. However, for appropriate tesselations, the codespace forms a ground-state subspace of a geometrically local Hamiltonain. In this sense, topological codes are QLDPC codes. On the other hand, chain complexes describing some QLDPC codes can be 'lifted' into higher-dimensional manifolds admitting some notion of geometric locality [Michael Freedman and Matthew B. Hastings, \u201cBuilding manifolds from quantum codes\u201d. 2012.02249]. This opens up the possibility that some QLDPC codes, despite not being geometrically local, can in fact be associated with a geometrically local theory described by a category.", "_type": "ecc", "_page_id": "c_topological", "_href": "c/topological"}, "c_fracton": {"notes": "", "logical": "", "code_id": "fracton", "physical": "", "protection": "", "introduced": "", "description": "A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.", "name": "Fracton code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hamiltonian\nqldpc", "parents_detail": "Codespace is the ground-state subspace of a geometrically local commuting-projector Hamiltonian admitting a fracton phase.\nFracton codes admit geometrically local stabilizer generators on a cubic lattice.", "parent_of_code_id": "haah_cubic", "parent_of_detail": "Haah cubic codes are the first examples of Type-II fracton phases [M. Pretko, X. Chen, and Y. You, \u201cFracton phases of matter\u201d, International Journal of Modern Physics A 35, 2030003 (2020). DOI; 2001.01722].", "cousins_code_id": "topological", "cousins_detail": "Fracton phases can be understood as topological defect networks, meaning that they can be described in the language of topological quantum field theory [D. Aasen et al., \u201cTopological defect networks for fractons of all types\u201d, Physical Review Research 2, (2020). DOI; 2002.05166].", "cousin_of_code_id": "translationally_invariant_stabilizer\nxzzx", "cousin_of_detail": "Translationally-invariant stabilizer codes can realize fracton orders. Conversely, fracton codes need not be translationally invariant, and can realize multiple phases on one lattice.\nSubsystem symmetries play a role in finite-bias decoders for both codes [B. J. Brown and D. J. Williamson, \u201cParallelized quantum error correction with fracton topological codes\u201d, Physical Review Research 2, (2020). DOI; 1901.08061].", "_type": "ecc", "_page_id": "c_fracton", "_href": "c/fracton"}, "c_hamiltonian": {"notes": "", "logical": "", "code_id": "hamiltonian", "physical": "", "protection": "Often determined from the underlying physical properties of the Hamiltonian.", "introduced": "", "description": "Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy.\n\nWhen the physical space is a tensor product of subsystems, the Hamiltonian is typically local, consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., QLDPC codes). When the physical space is endowed with a geometry, the Hamiltonian is typically geometrically local, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., topological codes). When the terms in a geometrically local Hamiltonian commute and can be expressed as projectors (i.e., having eigenvalues 0 or 1), the Hamiltonian is called commuting-projector. ", "name": "Hamiltonian-based code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "Lindbladian-based dissipative encoding can be constructed for a codespace that is the ground-state subspace of a frustration-free Hamiltonian [Francesco Ticozzi and Lorenza Viola, \u201cAnalysis and synthesis of attractive quantum Markovian dynamics\u201d. 0809.0613][F. Ticozzi and L. Viola, \u201cStabilizing entangled states with quasi-local quantum dynamical semigroups\u201d, Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 370, 5259 (2012). DOI; 1112.4860][Frank Verstraete, Michael M. Wolf, and J. Ignacio Cirac, \u201cQuantum computation, quantum state engineering, and quantum phase transitions driven by dissipation\u201d. 0803.1447][Victor V. Albert, \u201cLindbladians with multiple steady states: theory and applications\u201d. 1802.00010].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "constant_excitation\neth\nfracton\nmovassagh_ouyang\nself_correct\ntopological", "parent_of_detail": "Constant-excitation codes are associated with a Hamiltonian governing the total excitations of the system.\nETH codewords are eigenstates of a local Hamiltonian whose eigenstates satisfy ETH.\nCodespace is the ground-state subspace of a geometrically local commuting-projector Hamiltonian admitting a fracton phase.\nMovassagh-Ouyang codes reside in the ground space of a Hamiltonian.\n\nCodespace is either the ground-state or low-energy subspace of a geometrically local Hamiltonian admitting a topological phase.", "cousins_code_id": "qldpc", "cousins_detail": "Hamiltonian-based codes are not generally defined using Pauli strings. However, codes forming the ground-state subspace of a local Hamiltonain consisting of commuting terms are QLDPC codes in the sense that they satisfy the QLDPC locality requirements.", "cousin_of_code_id": "cat\nmetopt\ngnu_permutation_invariant\npaircat\nquantum_repetition\nqubit_stabilizer\nstab_5_1_3", "cousin_of_detail": "Two-legged cat codewords form ground-state subspace of a Kerr Hamiltonian [S. Puri, S. Boutin, and A. Blais, \u201cEngineering the quantum states of light in a Kerr-nonlinear resonator by two-photon driving\u201d, npj Quantum Information 3, (2017). DOI; 1605.09408].\nMetrologically optimal codes admit a \\(U(1)\\) set of gates generated by a signal Hamiltonian \\(H\\), meaning that there exists a basis of codewords that are eigenstates of the \\(H\\).\nGNU codes lie within the ground state of ferromagnetic Heisenberg models without an external magnetic field [Y. Ouyang, \u201cQuantum storage in quantum ferromagnets\u201d, Physical Review B 103, (2021). DOI; 1904.01458].\nTwo-legged pair-cat codewords form ground-state subspace of a multimode Kerr Hamiltonian.\nBit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions.\nCodespace is the ground-state space of the code Hamiltonian, which consists of an equal linear combination of stabilizer generators and which can be made into a commuting projector Hamiltonian.\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].", "_type": "ecc", "_page_id": "c_hamiltonian", "_href": "c/hamiltonian"}, "c_topological_abelian": {"notes": "", "description": "Code whose codewords realize topological order associated with an abelian group. Stub.\n\nAny local quantum circuit connecting ground states of topological orders with non-isomorphic abelian groups must have depth that is at least linear in the system\u2019s diameter [J. Haah, \u201cAn Invariant of Topologically Ordered States Under Local Unitary Transformations\u201d, Communications in Mathematical Physics 342, 771 (2016). DOI; 1407.2926]. ", "name": "Abelian topological code", "code_id": "topological_abelian", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "topological\nqldpc", "parents_detail": "\nAll abelian topological orders can be realized as geometrically local modular-qudit stabilizer codes [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394], and topological-code Hamiltonians are geometrically local for appropriate tesselations.", "parent_of_code_id": "clifford-deformed_surface\ncolor\ndouble_semion\nsurface\nmatching\nqudit_surface", "parent_of_detail": "Local deformations of the surface code preserve its \\(\\mathbb{Z}_2\\) topological order.\nWhen treated as ground states of the code Hamiltonian, 2D color code states on realize \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) topological order [M. Kargarian, H. Bombin, and M. A. Martin-Delgado, \u201cTopological color codes and two-body quantum lattice Hamiltonians\u201d, New Journal of Physics 12, 025018 (2010). DOI; 0906.4127], equivalent to the phase realized by two copies of the surface code [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065].\nWhen treated as ground states of the code Hamiltonian, the code states realize double-semion topological order, a topological phase of matter that also exists in twisted \\(\\mathbb{Z}_2\\) gauge theory [R. Dijkgraaf and E. Witten, \u201cTopological gauge theories and group cohomology\u201d, Communications in Mathematical Physics 129, 393 (1990). DOI].\nWhen treated as ground states of the code Hamiltonian, the code states realize \\(\\mathbb{Z}_2\\) topological order, a topological phase of matter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory [F. J. Wegner, \u201cDuality in Generalized Ising Models and Phase Transitions without Local Order Parameters\u201d, Journal of Mathematical Physics 12, 2259 (1971). DOI]. Codewords correspond to ground state of the code Hamiltonian, and error operators correspond to spontaneous creation and annihilation of pairs of charges or vortices. \nMatching codes were inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438], which realizes \\(\\mathbb{Z}_2\\) topological order.\nQudit surface code Hamiltonians admit topological phases associated with \\(\\mathbb{Z}_q\\) [S. S. Bullock and G. K. Brennen, \u201cQudit surface codes and gauge theory with finite cyclic groups\u201d, Journal of Physics A: Mathematical and Theoretical 40, 3481 (2007). DOI; quant-ph/0609070].", "cousins_code_id": "qudit_stabilizer", "cousins_detail": "All abelian topological orders can be realized as modular-qudit stabilizer codes [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394].", "cousin_of_code_id": "translationally_invariant_stabilizer\nxs_stabilizer\nxzzx", "cousin_of_detail": "Translationally-invariant stabilizer codes can realize abelian topological orders. Conversely, abelian topological codes need not be translationally invariant, and can realize multiple topological phases on one lattice.\nTwisted quantum double models for the groups \\(\\mathbb{Z}_2^k\\) can be realized as XS stabilizer codes.\nExample of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [X.-G. Wen, \u201cQuantum Orders in an Exact Soluble Model\u201d, Physical Review Letters 90, (2003). DOI; quant-ph/0205004].", "_type": "ecc", "_page_id": "c_topological_abelian", "_href": "c/topological_abelian"}, "c_constant_excitation": {"notes": "", "logical": "", "code_id": "constant_excitation", "physical": "", "protection": "", "introduced": "[M. B. Plenio, V. Vedral, and P. L. Knight, \u201cQuantum error correction in the presence of spontaneous emission\u201d, Physical Review A 55, 67 (1997). DOI; quant-ph/9603022][P. Zanardi and M. Rasetti, \u201cNoiseless Quantum Codes\u201d, Physical Review Letters 79, 3306 (1997). DOI; quant-ph/9705044][D. A. Lidar, D. Bacon, and K. B. Whaley, \u201cConcatenating Decoherence-Free Subspaces with Quantum Error Correcting Codes\u201d, Physical Review Letters 82, 4556 (1999). DOI; quant-ph/9809081]", "description": "Code whose codewords lie in an excited-state eigenspace of a Hamiltonian governing the total energy or total number of excitations of the underlying quantum system. For qubit codes, such a Hamiltonian is often the total spin Hamiltonian, \\(H=\\sum_i Z_i\\). For spin-\\(S\\) codes, this generalizes to \\(H=\\sum_i J_z^{(i)}\\), where \\(J_z\\) is the spin-\\(S\\) \\(Z\\)-operator. For bosonic codes, such as Fock-state codes, codewords are often in an eigenspace with eigenvalue \\(N>0\\) of the total excitation or energy Hamiltonian, \\(H=\\sum_i \\hat{n}_i\\).\n\nOne of the first such codes [M. B. Plenio, V. Vedral, and P. L. Knight, \u201cQuantum error correction in the presence of spontaneous emission\u201d, Physical Review A 55, 67 (1997). DOI; quant-ph/9603022] is a \\(((8,1,3))\\) qubit code, with codewords \\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&= |00001111\\rangle + |11101000\\rangle \u2212 |10010110\\rangle \u2212 |01110001\\rangle\\\\\n                    & +|11010100\\rangle + |00110011\\rangle + |01001101\\rangle + |10101010\\rangle\\\\\n|\\overline{1}\\rangle&= X^{\\otimes 8} |\\overline{0}\\rangle~.\n\\end{split}\n\\end{align} Each logical state is a superposition of computational basis states with four excitations. ", "name": "Constant-excitation (CE) code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Fock-state CE codes can be used in a protocol that achieves the two-way quantum capacity of the pure-loss Gaussian channel [Matthew S. Winnel et al., \u201cAchieving the ultimate end-to-end rates of lossy quantum communication networks\u201d. 2203.13924].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "hamiltonian", "parents_detail": "Constant-excitation codes are associated with a Hamiltonian governing the total excitations of the system.", "parent_of_code_id": "chuang-leung-yamamoto", "parent_of_detail": "Chuang-Leung-Yamamoto codewords are constructed out of Fock states with the same total excitation number.", "cousin_of_code_id": "constant_weight", "cousin_of_detail": "Constant-weight codes are classical analogues of qubit constant-excitation codes.", "_type": "ecc", "_page_id": "c_constant_excitation", "_href": "c/constant_excitation"}, "c_distance_balanced": {"notes": "", "logical": "qubits", "code_id": "distance_balanced", "physical": "qubits", "protection": "", "introduced": "[M. B. Hastings, \u201cWeight Reduction for Quantum Codes\u201d. 1611.03790][Shai Evra, Tali Kaufman, and Gilles Z\u00e9mor, \u201cDecodable quantum LDPC codes beyond the $\\sqrt{n}$ distance barrier using high dimensional expanders\u201d. 2004.07935]", "description": "CSS stabilizer code constructed from a CSS code and a classical code using a distance-balancing procedure based on a generalized homological product. The initial code is said to be unbalanced, i.e., tailored to noise biased toward either bit- or phase-flip errors, and the procedure can result in a code that is treats both types of errors on a more equal footing. The original distance-balancing procedure [M. B. Hastings, \u201cWeight Reduction for Quantum Codes\u201d. 1611.03790], later generalized in Ref. [Shai Evra, Tali Kaufman, and Gilles Z\u00e9mor, \u201cDecodable quantum LDPC codes beyond the $\\sqrt{n}$ distance barrier using high dimensional expanders\u201d. 2004.07935], can yield QLDPC codes; see Thm. 1 in Ref. [M. B. Hastings, \u201cWeight Reduction for Quantum Codes\u201d. 1611.03790].", "name": "Distance-balanced code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "css\nhomological_product", "parents_detail": "\nDistance balancing relies on taking homological product of chain complexes corresponding to a classical and a quantum code.", "cousins_code_id": "subsystem_stabilizer", "cousins_detail": "", "cousin_of_code_id": "balanced_product\nfiber_bundle\nramanujan_tensor_product", "cousin_of_detail": "Distance balancing is used to form balanced-product subsystem codes [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].\nFiber-bundle code constructions use distance balancing to increase distance.\nRamanujan tensor-product constructions use distance balancing to increase distance.", "_type": "ecc", "_page_id": "c_distance_balanced", "_href": "c/distance_balanced"}, "c_ramanujan_tensor_product": {"notes": "Codes were first to break a 20-year record set by the Freedman-Meyer-Luo code for the lower bound on scaling of the minimum distance [N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309].", "logical": "qubits", "code_id": "ramanujan_tensor_product", "physical": "qubits", "protection": "Without distance balancing, a Ramanujan code can have \\(d_X =\\Omega(\\log n)\\) and \\(d_Z = \\Omega (n)\\). For 2D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}\\). For 3D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d= \\Omega(n^{1/2}\\log n )\\).", "introduced": "[Shai Evra, Tali Kaufman, and Gilles Z\u00e9mor, \u201cDecodable quantum LDPC codes beyond the $\\sqrt{n}$ distance barrier using high dimensional expanders\u201d. 2004.07935]", "description": "CSS code constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.", "name": "Ramanujan-complex product code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "For 2D simplicial complexes, cycle code decoder admitting a polynomial-time decoding algorithm can be used [Shai Evra, Tali Kaufman, and Gilles Z\u00e9mor, \u201cDecodable quantum LDPC codes beyond the $\\sqrt{n}$ distance barrier using high dimensional expanders\u201d. 2004.07935].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "For 2D Ramanujan complexes, the rate is \\(\\Omega(\\sqrt{ \\frac{1}{n \\log n} })\\), with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}) \\). For 3D, the rate is \\( \\Omega(\\frac{1}{\\sqrt{n}\\log n}) \\) with minimum distance \\(d \\geq \\sqrt{n} \\log n \\).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_homological_product", "parents_detail": "Ramanujan codes result from a tensor product of a classical-code and a quantum-code chain complex.", "cousins_code_id": "distance_balanced\nfreedman_meyer_luo", "cousins_detail": "Ramanujan tensor-product constructions use distance balancing to increase distance.\nRamanujan codes broke 20-year record on minimum code distance set by Freedman-Meyer-Luo codes.", "_type": "ecc", "_page_id": "c_ramanujan_tensor_product", "_href": "c/ramanujan_tensor_product"}, "c_fiber_bundle": {"notes": "", "logical": "qubits", "code_id": "fiber_bundle", "physical": "qubits", "protection": "", "introduced": "[Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921]", "description": "CSS code constructed by combining a random LDPC code as the base and a cyclic repetition code as the fiber of a fiber bundle. After applying distance balancing, a QLDPC code with distance \\(\\Omega(n^{3/5}\\text{polylog}(n))\\) and rate \\(\\Omega(n^{-2/5}\\text{polylog}(n))\\) is obtained.", "name": "Fiber-bundle code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Greedy algorithm can be used to efficiently decode \\(X\\) errors, but no known efficient decoding of \\(Z\\) errors yet [Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Rate \\(k/n = \\Omega(n^{-2/5}/\\text{polylog}(n))\\), distance \\(d=\\Omega(n^{3/5}/\\text{polylog}(n))\\). This is the first QLDPC code to achieve a distance scaling better than \\(\\sqrt{n}~\\text{polylog}(n)\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "balanced_product", "parents_detail": "Fiber-bundle codes can be formulated in terms of a balanced product [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].", "parent_of_code_id": "homological_product", "parent_of_detail": "Fiber-bundle code can be viewed as a homological product code with a twisted product.", "cousins_code_id": "distance_balanced\nquantum_random", "cousins_detail": "Fiber-bundle code constructions use distance balancing to increase distance.\n", "_type": "ecc", "_page_id": "c_fiber_bundle", "_href": "c/fiber_bundle"}, "c_quantum_tanner": {"notes": "For details, see talk by A. Leverrier.", "logical": "qubits", "code_id": "quantum_tanner", "physical": "qubits", "protection": "Minimum distance bound obtained using robustness of dual tensor-product codes [Anthony Leverrier and Gilles Z\u00e9mor, \u201cA parallel decoder for good quantum LDPC codes\u201d. 2208.05537].", "introduced": "[Anthony Leverrier and Gilles Z\u00e9mor, \u201cQuantum Tanner codes\u201d. 2202.13641]", "description": "Stub.", "name": "Quantum Tanner code", "realizations": "Used to obtain explicit lower bounds in the sum-of-squares game [Max Hopkins and Ting-Chun Lin, \u201cExplicit Lower Bounds Against $\u03a9(n)$-Rounds of Sum-of-Squares\u201d. 2204.11469].\nStates that, on average, achieve small violations of check operators for quantum Tanner codes require a circuit of non-constant depth to make. They are used in the proof of the No low-energy trivial states (NLTS) conjecture [Anurag Anshu, Nikolas Breuckmann, and Chinmay Nirkhe, \u201cNLTS Hamiltonians from good quantum codes\u201d. 2206.13228].", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Linear-time decoder similar to the small-set-flip decoder for quantum expander codes [Shouzhen Gu, Christopher A. Pattison, and Eugene Tang, \u201cAn efficient decoder for a linear distance quantum LDPC code\u201d. 2206.06557].\nLinear-time decoder [Anthony Leverrier and Gilles Z\u00e9mor, \u201cEfficient decoding up to a constant fraction of the code length for asymptotically good quantum codes\u201d. 2206.07571].\nLogarithmic-time decoder [Anthony Leverrier and Gilles Z\u00e9mor, \u201cA parallel decoder for good quantum LDPC codes\u201d. 2208.05537].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Asymptotically good QLDPC codes.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "generalized_homological_product\ncss", "parents_detail": "\n", "parent_of_code_id": "rotated_surface", "parent_of_detail": "Specializing the quantum Tanner construction to the surface code yields the rotated surface code [Nikolas P. Breuckmann, private communication, 2022][Anthony Leverrier, Mapping the toric code to the rotated toric code, 2022.].", "cousins_code_id": "good_qldpc\ntanner\ntensor\nexpander_lifted_product", "cousins_detail": "Quantum Tanner code construction yields asymptotically good QLDPC codes.\nTanner codes are used in constructing quantum Tanner codes.\nTensor codes are used in constructing quantum Tanner codes.\nQuantum Tanner codes are an attempt to construct asymptotically good QLDPC codes that are similar to but simpler than expander lifted-product codes; see Ref. [Anthony Leverrier and Gilles Z\u00e9mor, \u201cEfficient decoding up to a constant fraction of the code length for asymptotically good quantum codes\u201d. 2206.07571] for connection between the codes.", "_type": "ecc", "_page_id": "c_quantum_tanner", "_href": "c/quantum_tanner"}, "c_translationally_invariant_stabilizer": {"notes": "", "logical": "", "code_id": "translationally_invariant_stabilizer", "physical": "", "protection": "", "introduced": "[J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962][J. Haah, \u201cCommuting Pauli Hamiltonians as Maps between Free Modules\u201d, Communications in Mathematical Physics 324, 351 (2013). DOI; 1204.1063][J. Haah, Lattice Quantum Codes and Exotic Topological Phases of Matter, California Institute of Technology, 2013. DOI]", "description": "A geometrically local qubit or qudit stabilizer code with qudits organized on a lattice modeled by the additive group \\(\\mathbb{Z}^D\\) for spatial dimension \\(D\\) such that each lattice point, referred to as a site, contains \\(m\\) qudits of dimension \\(q\\). The stabilizer group of the translationally invariant code is generated by site-local Pauli operators and their translations.\n\nA single-qudit Pauli operator can be specified by the lattice coordinate of the site and the symplectic vector representation of the Pauli operator within the site. In an extension of the sympletic representation, each lattice coordinate can be represented by a Laurent monomial of \\(D\\) formal variables. For example, when \\(D=2\\) and \\(m=1\\), the product of an \\(X\\) acting on the qubit at lattice coordinate \\((-1,2)\\) and a \\(Z\\) acting on the qubit at \\((1,0)\\) can be represented by the vector \\( (x^{-1} y^2 | x) \\). The multiplicative group of finitely supported Pauli operators modulo phase factors on the lattice of dimension \\(D\\) with \\(m\\) prime-dimensional qubits per site is isomorphic to the additive group of Laurent polynomial column vectors of length \\(2m\\) in \\(D\\) formal variables (see Ref. [J. Haah, \u201cAlgebraic Methods for Quantum Codes on Lattices\u201d, Revista Colombiana de Matem\u00e1ticas 50, 299 (2017). DOI; 1607.01387] and Sec. IV of Ref. [Jeongwan Haah, Lukasz Fidkowski, and Matthew B. Hastings, \u201cNontrivial Quantum Cellular Automata in Higher Dimensions\u201d. 1812.01625]).\n\nTranslationally-invariant prime-qudit (\\(q=p\\)) stabilizer codes have been classified in dimensions \\(D\\in\\{1,2\\}\\), up to equivalence under local constant-depth Clifford circuits. Any 1D (2D) code can be converted to several copies of the 1D repetition code (prime-qudit 2D surface code) along with some trivial codes [J. Haah, \u201cAlgebraic Methods for Quantum Codes on Lattices\u201d, Revista Colombiana de Matem\u00e1ticas 50, 299 (2017). DOI; 1607.01387] ([J. Haah, \u201cClassification of translation invariant topological Pauli stabilizer codes for prime dimensional qudits on two-dimensional lattices\u201d, Journal of Mathematical Physics 62, 012201 (2021). DOI; 1812.11193]). Three-dimensional qubit codes can be characterized by four coarse classes [A. Dua et al., \u201cSorting topological stabilizer models in three dimensions\u201d, Physical Review B 100, (2019). DOI; 1908.08049]:\n\n1. Abelian topological phase: Excitations are mobile in all 3 dimensions, as is typical in a topological code. Such codes are conjectured to be equivalent to a \\(\\mathbb{Z}_2\\) gauge theory, i.e., multiple copies of the 3D surface code or its variant where the charge excitation is a fermion.\n\n2. Foliated type-I fracton phase: Excitations are mobile in less than 3 dimensions, but codes can be grown by foliation, i.e., stacking copies of the 2D surface code.\n\n3. Fractal type-I fracton phase: Excitations are mobile in less than 3 dimensions, and codes are not foliated.\n\n4. Type-II fracton phase: Excitations are not mobile in any dimension and there are no string operators.", "name": "Translationally-invariant stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Clustering decoder [J. W. Harrington, Analysis of Quantum Error-correcting Codes: Symplectic Lattice Codes and Toric Codes, California Institute of Technology, 2004. DOI][S. Bravyi and J. Haah, \u201cQuantum Self-Correction in the 3D Cubic Code Model\u201d, Physical Review Letters 111, (2013). DOI; 1112.3252].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qldpc", "parents_detail": "Translationally-invariant stabilizer codes are geometrically local.", "parent_of_code_id": "quantum_parity\ntfim", "parent_of_detail": "\n", "cousins_code_id": "qubit_stabilizer\nqudit_stabilizer\nsurface\nqudit_surface\ntopological_abelian\nfracton", "cousins_detail": "Qubit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site.\nModular-qudit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site.\nTranslation-invariant 2D qubit topological stabilizer codes are equivalent to several copies of the Kitaev surface code via a local constant-depth Clifford circuit [H. Bombin, G. Duclos-Cianci, and D. Poulin, \u201cUniversal topological phase of two-dimensional stabilizer codes\u201d, New Journal of Physics 14, 073048 (2012). DOI; 1103.4606][H. Bomb\u00edn, \u201cStructure of 2D Topological Stabilizer Codes\u201d, Communications in Mathematical Physics 327, 387 (2014). DOI; 1107.2707][J. Haah, \u201cAlgebraic Methods for Quantum Codes on Lattices\u201d, Revista Colombiana de Matem\u00e1ticas 50, 299 (2017). DOI; 1607.01387].\nTranslation-invariant 2D prime-qudit topological stabilizer codes are equivalent to several copies of the prime-qudit surface code via a local constant-depth Clifford circuit [J. Haah, \u201cClassification of translation invariant topological Pauli stabilizer codes for prime dimensional qudits on two-dimensional lattices\u201d, Journal of Mathematical Physics 62, 012201 (2021). DOI; 1812.11193].\nTranslationally-invariant stabilizer codes can realize abelian topological orders. Conversely, abelian topological codes need not be translationally invariant, and can realize multiple topological phases on one lattice.\nTranslationally-invariant stabilizer codes can realize fracton orders. Conversely, fracton codes need not be translationally invariant, and can realize multiple phases on one lattice.", "cousin_of_code_id": "self_correct", "cousin_of_detail": "3D translationally-invariant qubit stabilizer code families with constant \\(k\\) support logical string operators and thus cannot be self-correcting [B. Yoshida, \u201cFeasibility of self-correcting quantum memory and thermal stability of topological order\u201d, Annals of Physics 326, 2566 (2011). DOI; 1103.1885]. For non-constant \\(k\\), such families can support at most a logarithmic energy barrier [J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962].", "_type": "ecc", "_page_id": "c_translationally_invariant_stabilizer", "_href": "c/translationally_invariant_stabilizer"}, "c_qldpc": {"notes": "Links to code tables of notable QLDPC codes [N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309].\nReviews of QLDPC codes provided in Refs. [Z. Babar et al., \u201cFifteen Years of Quantum LDPC Coding and Improved Decoding Strategies\u201d, IEEE Access 3, 2492 (2015). DOI][N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309].", "logical": "", "code_id": "qldpc", "physical": "", "protection": "Detects errors on \\(d-1\\) sites, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) sites. Asymptotic scaling of \\(k\\) and \\(d\\) with \\(n\\) is often of interest, and this depends heavily on the code construction. Geometrically local qubit codes are limited by the BPT bound [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983], which states that \\(d=O(n^{1-1/D})\\) for \\(D\\)-dimensional lattice geometries. For general graphs, distance is limited by graphs' connectivity, and a constant relative minimum distance can be achieved only for graphs that contain expanders [N. Baspin and A. Krishna, \u201cConnectivity constrains quantum codes\u201d, Quantum 6, 711 (2022). DOI; 2106.00765]. Conversely, a code with parameters \\(k\\) and \\(d\\) requires a graph with \\(\\Omega(d)\\) edges of length \\(\\Omega(d/n^{1/D})\\) [Nou\u00e9dyn Baspin and Anirudh Krishna, \u201cQuantifying nonlocality: how outperforming local quantum codes is expensive\u201d. 2109.10982].\n\nCode distance may not be a reliable marker of code performance. QLDPC codes with generator weights bounded by some constant can correct many stochastic errors far beyond the distance, which may not scale as favorably. Together with more accurate, faster, and easier-to-parallelize measurements than those of general stabilizer codes, this property makes QLDPC codes interesting in practice.", "introduced": "[D. J. C. MacKay, G. Mitchison, and P. L. McFadden, \u201cSparse-Graph Codes for Quantum Error Correction\u201d, IEEE Transactions on Information Theory 50, 2315 (2004). DOI; quant-ph/0304161]", "description": "Family of \\([[n,k,d]]\\) stabilizer codes for which the number of sites (either qubit or qudit) participating in each stabilizer generator and the number of stabilizer generators that each site participates in are both bounded by a constant as \\(n\\to\\infty\\). A geometrically local stabilizer code is a QLDPC code where the sites involved in any syndrome bit are contained in a fixed volume that does not scale with \\(n\\).\n\nStrictly speaking, the term parity check describes only bitwise qubit error syndromes. Nevertheless, qudit stabilizer codes satisfying the above criteria are also called QLDPC codes. ", "name": "Quantum low-density parity-check (QLDPC) code", "realizations": "", "short_name": "QLDPC", "features_threshold": "QLDPC codes with a constant encoding rate can reduce the overhead of fault-tolerant quantum computation to be constant [Daniel Gottesman, \u201cFault-Tolerant Quantum Computation with Constant Overhead\u201d. 1310.2984].", "features_code_capacity_threshold": "Bounds on code capacity thresholds using maximum-likelihood (ML) decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][A. A. Kovalev and L. P. Pryadko, \u201cFault tolerance of quantum low-density parity check codes with sublinear distance scaling\u201d, Physical Review A 87, (2013). DOI; 1208.2317][Alexey A. Kovalev and Leonid P. Pryadko, \u201cSpin glass reflection of the decoding transition for quantum error correcting codes\u201d. 1311.7688].\nBounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights [I. Dumer, A. A. Kovalev, and L. P. Pryadko, \u201cThresholds for Correcting Errors, Erasures, and Faulty Syndrome Measurements in Degenerate Quantum Codes\u201d, Physical Review Letters 115, (2015). DOI; 1412.6172].", "features_decoders": "Belief-propagation (BP) decoder [David Poulin and Yeojin Chung, \u201cOn the iterative decoding of sparse quantum codes\u201d. 0801.1241].\nNon-binary decoding algorithm for CSS-type QLDPC codes [Z. Babar et al., \u201cFifteen Years of Quantum LDPC Coding and Improved Decoding Strategies\u201d, IEEE Access 3, 2492 (2015). DOI].\nBP-OSD decoder adds a post-processing step based on ordered statistics decoding (OSD) to the belief propogation (BP) decoder [P. Panteleev and G. Kalachev, \u201cDegenerate Quantum LDPC Codes With Good Finite Length Performance\u201d, Quantum 5, 585 (2021). DOI; 1904.02703].\nSoft (i.e., analog) syndrome iterative belief propagation for CSS-type QLDPC codes, utilizing the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) [Nithin Raveendran et al., \u201cSoft Syndrome Decoding of Quantum LDPC Codes for Joint Correction of Data and Syndrome Errors\u201d. 2205.02341].\nMessage-passing decoder utilizing stabilizer inactivation (MP-SI) for CSS-type QLDPC qubit codes [Julien du Crest, Mehdi Mhalla, and Valentin Savin, \u201cStabilizer Inactivation for Message-Passing Decoding of Quantum LDPC Codes\u201d. 2205.06125].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Lattice surgery techniques with ancilla qubits [L. Z. Cohen et al., \u201cLow-overhead fault-tolerant quantum computing using long-range connectivity\u201d, Science Advances 8, (2022). DOI; 2110.10794].\nFault-tolerance with constant overhead can be performed on certain QLDPC codes [Daniel Gottesman, \u201cFault-Tolerant Quantum Computation with Constant Overhead\u201d. 1310.2984], e.g., quantum expander codes [Omar Fawzi, Antoine Grospellier, and Anthony Leverrier, \u201cConstant overhead quantum fault-tolerance with quantum expander codes\u201d. 1808.03821].", "parents_code_id": "stabilizer", "parents_detail": "", "parent_of_code_id": "topological_abelian\nfracton\ngeneralized_homological_product\ngood_qldpc\ntranslationally_invariant_stabilizer", "parent_of_detail": "All abelian topological orders can be realized as geometrically local modular-qudit stabilizer codes [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394], and topological-code Hamiltonians are geometrically local for appropriate tesselations.\nFracton codes admit geometrically local stabilizer generators on a cubic lattice.\nHomological products are a primary tool for generating QLDPC codes with favorable parameters. Typically, whenever the input codes are LDPC or QLDPC, the resulting code will be QLDPC with non geometrically local stabilizer generators.\n\nTranslationally-invariant stabilizer codes are geometrically local.", "cousins_code_id": "ldpc\ntopological\ndynamic_gen", "cousins_detail": "\nTopological codes are not generally defined using Pauli strings. However, for appropriate tesselations, the codespace forms a ground-state subspace of a geometrically local Hamiltonain. In this sense, topological codes are QLDPC codes. On the other hand, chain complexes describing some QLDPC codes can be 'lifted' into higher-dimensional manifolds admitting some notion of geometric locality [Michael Freedman and Matthew B. Hastings, \u201cBuilding manifolds from quantum codes\u201d. 2012.02249]. This opens up the possibility that some QLDPC codes, despite not being geometrically local, can in fact be associated with a geometrically local theory described by a category.\nQLDPC codes can arise from a dynamical process [M. Ippoliti et al., \u201cEntanglement Phase Transitions in Measurement-Only Dynamics\u201d, Physical Review X 11, (2021). DOI; 2004.09560].", "cousin_of_code_id": "hamiltonian\nhoneycomb", "cousin_of_detail": "Hamiltonian-based codes are not generally defined using Pauli strings. However, codes forming the ground-state subspace of a local Hamiltonain consisting of commuting terms are QLDPC codes in the sense that they satisfy the QLDPC locality requirements.\nThe Floquet check operators are weight-two, and each qubit participates in one check each round.", "_type": "ecc", "_page_id": "c_qldpc", "_href": "c/qldpc"}, "c_good_qldpc": {"notes": "", "description": "Also called asymptotically good QLDPC codes. A family of QLDPC codes \\([[n_i,k_i,d_i]]\\) whose asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.\n\nThe first good QLDPC codes are families of expander lifted-product codes, followed by quantum Tanner codes and Dinur-Hsieh-Lin-Vidick codes. ", "name": "Good QLDPC code", "code_id": "good_qldpc", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qldpc", "parents_detail": "", "cousin_of_code_id": "dhlv\nexpander_lifted_product\nquantum_tanner", "cousin_of_detail": "DHLV code construction yields asymptotically good QLDPC codes.\nLifted products of certain classical Tanner codes are the first asymptotically good QLDPC codes.\nQuantum Tanner code construction yields asymptotically good QLDPC codes.", "_type": "ecc", "_page_id": "c_good_qldpc", "_href": "c/good_qldpc"}, "c_quantum_expander": {"notes": "", "logical": "qubits", "code_id": "quantum_expander", "physical": "qubits", "protection": "Pauli errors of weight \\(\\leq t\\), distance scales as \\(\\Omega(n^{1/2})\\).", "introduced": "[A. Leverrier, J.-P. Tillich, and G. Zemor, \u201cQuantum Expander Codes\u201d, 2015 IEEE 56th Annual Symposium on Foundations of Computer Science (2015). DOI; 1504.00822]", "description": "CSS codes constructed from a hypergraph product of bipartite expander graphs with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as \\(X\\) checks, and the parity check matrix of the other as \\(Z\\) checks.", "name": "Quantum expander code", "realizations": "", "short_name": "", "features_threshold": "Current estimate of \\(2.7 \\cdot 10^{-16}\\) in locally stochastic noise model [Omar Fawzi, Antoine Grospellier, and Anthony Leverrier, \u201cEfficient decoding of random errors for quantum expander codes\u201d. 1711.08351].", "features_code_capacity_threshold": "", "features_decoders": "Small set-flip linear-time decoder, which corrects \\(\\Omega(n^{1/2})\\) adversarial errors [A. Leverrier, J.-P. Tillich, and G. Zemor, \u201cQuantum Expander Codes\u201d, 2015 IEEE 56th Annual Symposium on Foundations of Computer Science (2015). DOI; 1504.00822].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "\\([[n,k=\\Theta(n),d=O(\\sqrt{n})]]\\) code with asymptotically constant rate.", "features_transversal_gates": "", "features_fault_tolerance": "Fault-tolerance with constant overhead can be achieved [Omar Fawzi, Antoine Grospellier, and Anthony Leverrier, \u201cConstant overhead quantum fault-tolerance with quantum expander codes\u201d. 1808.03821].", "parents_code_id": "hypergraph_product", "parents_detail": "", "cousins_code_id": "expander", "cousins_detail": "", "_type": "ecc", "_page_id": "c_quantum_expander", "_href": "c/quantum_expander"}, "c_expander_lifted_product": {"notes": "Construction outlined in talk by R. O'Donnell.\nPopular summary in Quanta Magazine.", "logical": "galois", "code_id": "expander_lifted_product", "physical": "galois", "protection": "Code performance strongly depends on \\(G\\). Certain nonabelian groups yield asymptotically good QLDPC codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n)]]\\) [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654]. Abelian groups like \\(\\mathbb{Z}_{\\ell}\\) for \\(\\ell=\\Theta(n / \\log n)\\) yield constant-rate codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n / \\log n)]]\\) [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068]; this construction can be derandomized by being reformulated as a balanced product code [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].", "introduced": "[Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654]", "description": "Family of \\(G\\)-lifted product codes constructed using two random classical Tanner codes defined on expander graphs. For certain parameters, this construction yields the first asymptotically good QLDPC codes [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654].\n\nAn expander lifted-product code family is constructed as follows. First, take the Cayley graph of a finite group \\(G\\). Second, take the double cover of the graph, resulting in a graph that satisfies the requirements of participating in a \\(G\\)-lifted product (i.e., the resulting graph is a free \\({\\mathbb{F}}_q G\\)-module). Third, create a Tanner code out of the graph, in which parity-check supports are defined by the graph, and bitstrings satisfying a particular parity check are defined to be the codewords of a small classical code (chosen to be a random code in the construction). Fourth, take the \\(G\\)-lifted product of two copies of the Tanner code.\n\nThe small classical codes used in the construction of good QLDPC codes are required to have a certain product-expansion property (Lemma 10 in Ref. [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654]); it is proven that random codes satisfy said property in the thermodynamic limit.", "name": "Expander lifted-product code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Linear-time decoder [Anthony Leverrier and Gilles Z\u00e9mor, \u201cEfficient decoding up to a constant fraction of the code length for asymptotically good quantum codes\u201d. 2206.07571].\nLogarithmic-time subroutine [Anthony Leverrier and Gilles Z\u00e9mor, \u201cA parallel decoder for good quantum LDPC codes\u201d. 2208.05537].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Expander lifted-product codes include the first examples [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654] of (asymptotically) good QLDPC codes, i.e., codes with asymptotically constant rate and linear distance. The existence of such codes proves the QLDPC conjecture [N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309]. Another notable family encodes \\(k \\in \\Theta(n^\\alpha \\log n)\\) logical qubits with distance \\(d \\in \\Omega(n^{1 - \\alpha} / \\log n)\\) for any number of physical qubits \\(n\\) and any real parameter \\(0 \\leq \\alpha < 1\\) [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "lifted_product", "parents_detail": "", "cousins_code_id": "good_qldpc\ntanner\nrandom", "cousins_detail": "Lifted products of certain classical Tanner codes are the first asymptotically good QLDPC codes.\nExpander lifted-product codes are products of \\(q\\)-ary Tanner codes defined on expander graphs.\nExpander lifted-product codes are quantum CSS codes that utilize short classical codes in their construction which need to satisfy some properties (Ref. [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654], Lemma 10). It is shown that such codes exist, but they are not explicitly constructed. Such codes can be obtained by repeated random sampling or by performing a search of all codes of desired length. Nevertheless, since the length of the desired short codes does not scale with \\(n\\), this construction is effectively explicit.", "cousin_of_code_id": "quantum_tanner", "cousin_of_detail": "Quantum Tanner codes are an attempt to construct asymptotically good QLDPC codes that are similar to but simpler than expander lifted-product codes; see Ref. [Anthony Leverrier and Gilles Z\u00e9mor, \u201cEfficient decoding up to a constant fraction of the code length for asymptotically good quantum codes\u201d. 2206.07571] for connection between the codes.", "_type": "ecc", "_page_id": "c_expander_lifted_product", "_href": "c/expander_lifted_product"}, "c_homological_product": {"notes": "", "logical": "qubits", "code_id": "homological_product", "physical": "qubits", "protection": "Given two codes \\([[n_a, k_a, d_a, w_a]]\\) for \\(a\\in\\{1,2\\}\\), where \\(w_a\\) denotes the maximum hamming weight of all rows and columns of \\(\\partial_a\\), the homological product code has parameter \\([[n=n_1 n_2, k=k_1 k_2, d\\leq d_1 d_2, w\\leq w_1+w_2]]\\). From this formula, and the fact that a randomly selected boundary operator \\(\\partial\\) yields a CSS code that is good with high probability, we see that the product code has \\(k=\\Theta(n)\\) and \\(w=O(\\sqrt{n})\\) with high probability. The main result in [Sergey Bravyi and Matthew B. Hastings, \u201cHomological Product Codes\u201d. 1311.0885] is to show that the product code actually has linear distance with high probability as well. To sum up, it is shown that we have a family of \\([[n,k=c_1 n, d=c_2 n, w=c_3 \\sqrt{n}]]\\) codes given small enough \\(c_1,c_2,c_3\\).", "introduced": "[M. H. Freedman and M. B. Hastings, \u201cQuantum Systems on Non-$k$-Hyperfinite Complexes: A Generalization of Classical Statistical Mechanics on Expander Graphs\u201d. 1301.1363][Sergey Bravyi and Matthew B. Hastings, \u201cHomological Product Codes\u201d. 1311.0885]", "description": "CSS code formulated using the homological product of two chain complexes (see CSS-to-homology correspondence). Stub. ", "name": "Homological product code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Union-find [N. Delfosse and M. B. Hastings, \u201cUnion-Find Decoders For Homological Product Codes\u201d, Quantum 5, 406 (2021). DOI; 2009.14226].", "features_general_gates": "Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state [T. Jochym-O'Connor, \u201cFault-tolerant gates via homological product codes\u201d, Quantum 3, 120 (2019). DOI; 1807.09783].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state [T. Jochym-O'Connor, \u201cFault-tolerant gates via homological product codes\u201d, Quantum 3, 120 (2019). DOI; 1807.09783].", "parents_code_id": "fiber_bundle", "parents_detail": "Fiber-bundle code can be viewed as a homological product code with a twisted product.", "parent_of_code_id": "distance_balanced\nhypergraph_product", "parent_of_detail": "Distance balancing relies on taking homological product of chain complexes corresponding to a classical and a quantum code.\nA homological product of chain complexes corresponding to two classical codes is a hypergraph product code [Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921].", "cousins_code_id": "quantum_random", "cousins_detail": "", "_type": "ecc", "_page_id": "c_homological_product", "_href": "c/homological_product"}, "c_dhlv": {"notes": "", "logical": "qubits", "code_id": "dhlv", "physical": "qubits", "protection": "", "introduced": "[Irit Dinur et al., \u201cGood Quantum LDPC Codes with Linear Time Decoders\u201d. 2206.07750]", "description": "Stub.", "name": "Dinur-Hsieh-Lin-Vidick (DHLV) code", "realizations": "", "short_name": "DHLV", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Linear-time decoder utilizing the small set-flip decoder [Shouzhen Gu, Christopher A. Pattison, and Eugene Tang, \u201cAn efficient decoder for a linear distance quantum LDPC code\u201d. 2206.06557] for \\(Z\\) errors and a reconstruction procedure for \\(X\\) errors [Irit Dinur et al., \u201cGood Quantum LDPC Codes with Linear Time Decoders\u201d. 2206.07750].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Asymptotically good QLDPC codes.", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "balanced_product\ncss", "parents_detail": "\n", "cousins_code_id": "good_qldpc\ntanner\ntensor", "cousins_detail": "DHLV code construction yields asymptotically good QLDPC codes.\nTanner codes are used in constructing quantum DHLV codes.\nTensor codes are used in constructing quantum DHLV codes.", "_type": "ecc", "_page_id": "c_dhlv", "_href": "c/dhlv"}, "c_generalized_homological_product": {"notes": "", "description": "Stabilizer code formulated in terms a chain complex consisting of some type of product of other chain complexes. The CSS-to-homology correspondence yields an interpretation of codes in terms of manifolds, thus allowing for the use of various products from topology in constructing codes. The codes participating in the product can be quantum, classical, or mixed. Products can be of more than two codes, in which case the output code need not be of CSS type (e.g., for XYZ-product codes). The simplest product is a tensor product, with more general products imposing equivalence or symmetry relations on the outputs of the tensor product. A product of two codes can be interpreted as a fiber bundle, with one element of the product being the base and the other being the fiber. ", "name": "Generalized homological product code", "code_id": "generalized_homological_product", "logical": "", "realizations": "", "physical": "", "short_name": "", "protection": "", "introduced": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qldpc", "parents_detail": "Homological products are a primary tool for generating QLDPC codes with favorable parameters. Typically, whenever the input codes are LDPC or QLDPC, the resulting code will be QLDPC with non geometrically local stabilizer generators.", "parent_of_code_id": "balanced_product\nquantum_tanner\nramanujan_tensor_product\nxyz_product", "parent_of_detail": "Balanced product codes result from a tensor product of two classical-code chain complexes, followed by a factoring out of certain symmetries.\n\nRamanujan codes result from a tensor product of a classical-code and a quantum-code chain complex.\nXYZ product codes result from a tensor product of three classical-code chain complexes.", "cousins_code_id": "css", "cousins_detail": "The notion of homological products arose from interpreting CSS codes in terms of chain complexes over manifolds, but some generalized products no longer yield CSS codes.", "_type": "ecc", "_page_id": "c_generalized_homological_product", "_href": "c/generalized_homological_product"}, "c_balanced_product": {"notes": "", "logical": "qubits", "code_id": "balanced_product", "physical": "qubits", "protection": "Taking balanced products of two classical LDPC codes which have a symmetry group which grows linearly in their block lengths were known to give QLDPC codes with a linear rate and which were conjectured to have linear distance [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271]. This conjecture was proved in Ref. [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654].", "introduced": "[N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271]", "description": "Family of CSS quantum codes based on products of two classical codes which share common symmetries. The balanced product can be understood as taking the usual tensor/hypergraph product and then factoring out the symmetries factored. This reduces the overall number of physical qubits \\(n\\), while, under certain circumstances, leaving the number of encoded qubits \\(k\\) and the code distance \\(d\\) invariant. This leads to a more favourable encoding rate \\(k/n\\) and normalized distance \\(d/n\\) compared to the tensor/hypergraph product.", "name": "Balanced product code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "BP-OSD decoder [P. Panteleev and G. Kalachev, \u201cDegenerate Quantum LDPC Codes With Good Finite Length Performance\u201d, Quantum 5, 585 (2021). DOI; 1904.02703].", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "A notable family of balanced product codes encode \\(k \\in \\Theta(n^{4/5})\\) logical qubits with distance \\(d \\in \\Omega(n^{3/5})\\) for any number of physical qubits \\(n\\). Additionally, it is known that the code constructed from the balanced product of two good classical LDPC codes over groups of order \\(\\Theta(n)\\) has a constant encoding rate [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "css\ngeneralized_homological_product", "parents_detail": "\nBalanced product codes result from a tensor product of two classical-code chain complexes, followed by a factoring out of certain symmetries.", "parent_of_code_id": "dhlv\nfiber_bundle\nlifted_product", "parent_of_detail": "\nFiber-bundle codes can be formulated in terms of a balanced product [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].\n", "cousins_code_id": "subsystem_stabilizer\ndistance_balanced", "cousins_detail": "Distance balancing is used to form balanced-product subsystem codes [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].\nDistance balancing is used to form balanced-product subsystem codes [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].", "_type": "ecc", "_page_id": "c_balanced_product", "_href": "c/balanced_product"}, "c_xyz_product": {"notes": "", "logical": "qubits", "code_id": "xyz_product", "physical": "qubits", "protection": "", "introduced": "[Anthony Leverrier, Simon Apers, and Christophe Vuillot, \u201cQuantum XYZ Product Codes\u201d. 2011.09746]", "description": "A non-CSS QLDPC code constructed from three classical codes. The construction of an XYZ product code is similar to that of a hypergraph product code and related codes. The idea is that rather than taking a product of only two classical codes to produce a CSS code, a third classical code is considered, acting with Pauli-\\(Y\\) operators. ", "name": "XYZ product code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "Not much has been proven about the relationship between XYZ-product codes and other codes. The logical dimension depends on properties of the input classical codes, specifically similarity invariants from abstract algebra. It is conjectured that specific instances of XYZ-product codes have a constant encoding rate and a minimum distance of \\(d \\in \\Theta(n^{2/3})\\) [Anthony Leverrier, Simon Apers, and Christophe Vuillot, \u201cQuantum XYZ Product Codes\u201d. 2011.09746]. ", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qubit_stabilizer\ngeneralized_homological_product", "parents_detail": "\nXYZ product codes result from a tensor product of three classical-code chain complexes.", "cousins_code_id": "hypergraph_product", "cousins_detail": "The XYZ product code is based on a hypergraph product of three classical codes.", "_type": "ecc", "_page_id": "c_xyz_product", "_href": "c/xyz_product"}, "c_hypergraph_product": {"notes": "", "logical": "qubits", "code_id": "hypergraph_product", "physical": "qubits", "protection": "The hypergraph product has distance \\(d=O(\\sqrt{n})\\). The number of encoded logical qubits is \\(k=O(k_1k_2)\\) where \\(k_1\\) and \\(k_2\\) are the dimensions of the classical seed codes \\(C_1\\) and \\(C_2\\).", "introduced": "[J.-P. Tillich and G. Zemor, \u201cQuantum LDPC Codes With Positive Rate and Minimum Distance Proportional to the Square Root of the Blocklength\u201d, IEEE Transactions on Information Theory 60, 1193 (2014). DOI; 0903.0566][A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928]", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two binary linear seed codes \\(C_1\\) and \\(C_2\\).", "name": "Hypergraph product code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "ReShape decoder that uses minimum weight decoders for the classical codes used in the hypergraph construction [Armanda O. Quintavalle and Earl T. Campbell, \u201cLifting decoders for classical codes to decoders for quantum codes\u201d. 2105.02370].\nErasure-correction can be implemented approximately with \\(O(n^2)\\) operations, with a probabilistic version running in \\(O(n^{1.5})\\) operations [Nicholas Connolly et al., \u201cFast erasure decoder for a class of quantum LDPC codes\u201d. 2208.01002].", "features_general_gates": "Code deformation techniques yield Clifford gates [A. Krishna and D. Poulin, \u201cFault-Tolerant Gates on Hypergraph Product Codes\u201d, Physical Review X 11, (2021). DOI; 1909.07424].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "Hadamard (up to logical SWAP gates) and control-\\(Z\\) on all logical qubits [Armanda O. Quintavalle, Paul Webster, and Michael Vasmer, \u201cPartitioning qubits in hypergraph product codes to implement logical gates\u201d. 2204.10812].", "features_fault_tolerance": "", "parents_code_id": "lifted_product\nhomological_product", "parents_detail": "Lifted-product codes for trivial group \\(G\\) are hypergraph-product codes.\nA homological product of chain complexes corresponding to two classical codes is a hypergraph product code [Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921].", "parent_of_code_id": "quantum_expander", "parent_of_detail": "", "cousin_of_code_id": "surface\nrotated_surface\nxyz_product", "cousin_of_detail": "Planar (toric) code can be obtained from hypergraph product of two repetition (cyclic) codes ([A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928], Ex. 6).\nRotated code can be obtained from hypergraph product of two cyclic binary cyclic codes with palindromic generator polynomial ([A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928], Ex. 7).\nThe XYZ product code is based on a hypergraph product of three classical codes.", "_type": "ecc", "_page_id": "c_hypergraph_product", "_href": "c/hypergraph_product"}, "c_lifted_product": {"notes": "Formerly known as generalized hypergraph product codes [P. Panteleev and G. Kalachev, \u201cDegenerate Quantum LDPC Codes With Good Finite Length Performance\u201d, Quantum 5, 585 (2021). DOI; 1904.02703], and later renamed to lifted-product codes [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068][N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309].", "logical": "galois", "code_id": "lifted_product", "physical": "galois", "protection": "Code performance strongly depends on the group \\(G\\) used in the product [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068].", "introduced": "[P. Panteleev and G. Kalachev, \u201cDegenerate Quantum LDPC Codes With Good Finite Length Performance\u201d, Quantum 5, 585 (2021). DOI; 1904.02703][Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654]", "description": "Also called a Panteleev-Kalachev (PK) code. Code that utilizes the notion of a lifted product in its construction. Lifted products of certain classical Tanner codes are the first (asymptotically) good QLDPC codes.\n\nA lifted product over a ring \\(R\\) is a product of two chain complexes whose chains are free modules over \\(R\\). An interesting case is when \\(R=\\mathbb{F}_q G\\), the group-\\(G\\) algebra over the finite field \\({\\mathbb{F}}_q = GF(q)\\); in this case, the product can be called a \\(G\\)-lifted product. Just like its further generalization the balanced product, a lifted product code generalizes a hypergraph product code in that a reduction of symmetry is exploited to decrease the number of physical qubits required.\n\nThe key operation behind the \\(G\\)-lifted product is the \\(G\\)-lift. A \\(G\\)-lift of a \\(\\mathbb{F}_q\\)-valued matrix \\(A\\) substitutes matrix elements of \\(A\\) with matrices forming the regular representation of the group algebra \\({\\mathbb{F}}_q G\\) according to some rule. A combination of the lift and the usual hypergraph product yields lifted-product codes. The two operations commute: one can first take the usual hypergraph product of two chain complexes, and then lift the resulting product complex; equivalently, one can take the hypergraph product of the two lifted complexes.", "name": "Lifted-product (LP) code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "There is no known simple way to compute the logical dimension \\(k\\) in the general case [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068].", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "balanced_product\ngalois_css", "parents_detail": "\n", "parent_of_code_id": "expander_lifted_product\nhypergraph_product", "parent_of_detail": "\nLifted-product codes for trivial group \\(G\\) are hypergraph-product codes.", "cousins_code_id": "surface\nhaah_cubic", "cousins_detail": "A lifted product code for the ring \\(R=\\mathbb{F}_2[x,y]/(x^L-1,y^L-1)\\) is the toric code.\nA lifted product code for the ring \\(R=\\mathbb{F}_2[x,y,z]/(x^L-1,y^L-1,z^L-1)\\) is the cubic code.", "_type": "ecc", "_page_id": "c_lifted_product", "_href": "c/lifted_product"}, "c_covariant": {"notes": "", "logical": "", "code_id": "covariant", "physical": "", "protection": "Finite-dimensional codes correcting a single-subsystem erasure and admitting a continuous-parameter family of transversal gates (assuming \\(n>1\\)) cannot exist in finite dimensions due to the Eastin-Knill theorem. As a result, there is generally a tradeoff between covariance and error correction.\n\nExact error-correcting \\(G\\)-covariant codes can exist in infinite dimensions, but their codewords are non-normalizable, meaning that approximate constructions have to be considered that are only approximately error correcting. On the other hand, there exist exact error-correcting codes in finite dimensions that are approximately covariant [Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cApproximate symmetries and quantum error correction\u201d. 2111.06355]. Various bounds quantify the covariance-performance tradeoff [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][S. Zhou, Z.-W. Liu, and L. Jiang, \u201cNew perspectives on covariant quantum error correction\u201d, Quantum 5, 521 (2021). DOI; 2005.11918][A. Kubica and R. Demkowicz-Dobrza\u0144ski, \u201cUsing Quantum Metrological Bounds in Quantum Error Correction: A Simple Proof of the Approximate Eastin-Knill Theorem\u201d, Physical Review Letters 126, (2021). DOI; 2004.11893][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cApproximate symmetries and quantum error correction\u201d. 2111.06355].", "introduced": "[P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471]", "description": "Code constructed in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits) that admits a group \\(G\\) of transversal gates. The group has to be finite for finite-dimensional codes due to the Eastin-Knill theorem. Continuous-\\(G\\) covariant codes, necessarily infinite-dimensional, are relevant to error correction of quantum reference frames [P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471] and error-corrected parameter estimation.\n\nDenoting the code's encoding map as \\(U\\), covariance is equivalent to \\begin{align}\n  \\left(\\bigotimes_{j=1}^{n}V_{j}\\left(g\\right)\\right)U=UV_{L}\\left(g\\right)\\quad\\quad\\forall g\\in G\\,,\n\\end{align} where \\(V_j(g)\\) is a unitary representation of \\(g\\) acting on the \\(j\\) subsystem, and \\(V_L\\) is a unitary representation acting on the unencoded logical information. In this way, covariant encoding maps are equivariant (i.e., commute) with group actions on the logical and physical spaces.\n\nAlmost always, the physical representation is defined to be the transversal one (with respect to some tensor-product decomposition), but can reduce to any representation when the code is a subspace of a larger space that is not expressed as a tensor product (\\(n=1\\)). More generally, a code is sometimes said to be time-covariant if it admits a continuous-parameter \\(U(1)\\) family of gates, not necessarily transversal [Philippe Faist et al., \u201cTime-energy uncertainty relation for noisy quantum metrology\u201d. 2207.13707].", "name": "Covariant code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "\\(G\\)-covariant codes defined on a tensor product space consisting of \\(n\\) subsystems are equivalent to codes with a transversal gate set realizing \\(G\\).", "features_fault_tolerance": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "g_covariant_erasure\nnonabelian_covariant_erasure\nrotor_3_1_2\nrotor_5_1_3", "parent_of_detail": "In a proof of principle demonstration, error-correcting codes that are finite-\\(G\\) covariant can be constructed from a base encoding \\(U_0\\).\n\nThe \\([[3,1,2]]_{\\mathbb Z}\\) code is \\(U(1)\\)-covariant.\nThe \\([[5,1,3]]_{\\mathbb Z}\\) code is \\(U(1)\\)-covariant.", "cousins_code_id": "approximate_qecc\nquantum_reed_muller\neth\nquantum_random\ngroup_gkp", "cousins_detail": "Normalizable constructions of infinite-dimensional \\(G\\)-covariant codes for continuous \\(G\\) are approximately error-correcting.\nQuantum RM codes are approximately covariant and nearly saturate certain covariance-performance bounds [Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360].\nETH codes consisting of Dicke states are approximately \\(U(1)\\)-covariant and nearly saturate certain covariance-performance bounds [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360].\nRandom \\(U(d)\\)-covariant almost exactly error-correcting codes exist [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][L. Kong and Z.-W. Liu, \u201cNear-Optimal Covariant Quantum Error-Correcting Codes from Random Unitaries with Symmetries\u201d, PRX Quantum 3, (2022). DOI; 2112.01498].\nGroup-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates that represent the group \\(G\\), and are thus \\(G\\)-covariant [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].", "cousin_of_code_id": "metrological", "cousin_of_detail": "Any time-covariant QECC, i.e., a code admitting a continuous-parameter \\(U(1)\\) family of gates, is automatically a metrological code.", "_type": "ecc", "_page_id": "c_covariant", "_href": "c/covariant"}, "c_metopt": {"notes": "", "logical": "", "code_id": "metopt", "physical": "", "protection": "", "introduced": "[R. Demkowicz-Dobrza\u0144ski, J. Czajkowski, and P. Sekatski, \u201cAdaptive Quantum Metrology under General Markovian Noise\u201d, Physical Review X 7, (2017). DOI; 1704.06280][S. Zhou et al., \u201cAchieving the Heisenberg limit in quantum metrology using quantum error correction\u201d, Nature Communications 9, (2018). DOI; 1706.02445]", "description": "Code that can be obtained via an optimization procedure that ensures correction against a set \\(\\cal{E}\\) of errors as well as guaranteeting optimal precision in locally estimating a parameter using a noiseless ancilla. For tensor-product spaces consisting of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits), the procedure can yield a code whose parameter estimation precision satisfies Heisenberg scaling, i.e., scales quadratically with the number \\(n\\) of subsystems.\n\nThe conditions required for a code are that it corrects errors in the set \\(\\cal{E}\\) and admits a continuous-parameter \\(U(1)\\) group of logical gates generated by some signal Hamiltonian \\(H\\) (with the time of evolution by \\(H\\) the parameter that is to be estimated). This means that \\(H\\) cannot itself be a detectable error, i.e., \\(H\\) cannot be expressed as a linear combination of the errors, a condition known as the Hamiltonian-not-in-Kraus-span condition [S. Zhou and L. Jiang, \u201cAsymptotic Theory of Quantum Channel Estimation\u201d, PRX Quantum 2, (2021). DOI; 2003.10559] (alternatively, Hamiltonian-not-in-Lindblad-span for Markovian noise [S. Zhou et al., \u201cAchieving the Heisenberg limit in quantum metrology using quantum error correction\u201d, Nature Communications 9, (2018). DOI; 1706.02445]). If these conditions are satisfied, a semidefinite-program based optimization procedure yields a metrologically optimal code. The procedure has been generalized to more general groups, corresponding to multiparameter estimation [W. G\u00f3recki et al., \u201cOptimal probes and error-correction schemes in multi-parameter quantum metrology\u201d, Quantum 4, 288 (2020). DOI; 1901.00896]. If these conditions are not satisfied, Heisenberg scaling is not achievable, but metrologically optimal codes can still be obtained via another semidefinite-program based optimization procedure [S. Zhou and L. Jiang, \u201cOptimal approximate quantum error correction for quantum metrology\u201d, Physical Review Research 2, (2020). DOI; 1910.08472][S. Zhou and L. Jiang, \u201cAsymptotic Theory of Quantum Channel Estimation\u201d, PRX Quantum 2, (2021). DOI; 2003.10559].\n\nMetrologically optimal QECCs require error-free ancillas for optimal local parameter estimation using an entangling gate. In this sense, such codes can be thought of as being entanglement-assisted. Ancilla-free versions exist in the case when the noise commutes with the signal Hamiltonian [D. Layden et al., \u201cAncilla-Free Quantum Error Correction Codes for Quantum Metrology\u201d, Physical Review Letters 122, (2019). DOI; 1811.01450].", "name": "Error-corrected sensing code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "Semidefinite-program optimization procedure for finding a metrologically optimal code holds for finite-dimensional spaces.", "parent_of_code_id": "chebyshev", "parent_of_detail": "", "cousins_code_id": "eaqecc\nhamiltonian", "cousins_detail": "Metrologically optimal codes can be thought of as being entanglement-assisted because they require error-free ancillas for optimal local parameter estimation, and the estimation procedure uses an entangling gate.\nMetrologically optimal codes admit a \\(U(1)\\) set of gates generated by a signal Hamiltonian \\(H\\), meaning that there exists a basis of codewords that are eigenstates of the \\(H\\).", "cousin_of_code_id": "metrological", "cousin_of_detail": "Error-corrected sensing codes are required to satisfy the Knill-Laflamme conditions, while metrological codes need only satisfy the conditions partially.", "_type": "ecc", "_page_id": "c_metopt", "_href": "c/metopt"}, "c_nonabelian_covariant_erasure": {"notes": "", "logical": "", "code_id": "nonabelian_covariant_erasure", "physical": "", "protection": "", "introduced": "[Y. Yang et al., \u201cOptimal universal quantum error correction via bounded reference frames\u201d, Physical Review Research 4, (2022). DOI; 2007.09154]", "description": "Stub. ", "name": "\\(U(d)\\)-covariant approximate erasure code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "covariant\napproximate_qecc", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_nonabelian_covariant_erasure", "_href": "c/nonabelian_covariant_erasure"}, "c_g_covariant_erasure": {"notes": "", "logical": "", "code_id": "g_covariant_erasure", "physical": "", "protection": "Depends on the base encoding \\(U_0\\). ", "introduced": "[P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471]", "description": "A \\(G\\)-covariant code constructed in a physical space consisting of a tensor product of identical subsystems (e.g., qubits, modular qudits, or Galois qudits). The code is a proof-of-principle construction to demonstrate the existence of \\(G\\)-covariant codes where \\(G\\) is a finite group, and the physical space is finite-dimensional.\n\nConsider a finite group \\(G\\) acting on a finite set \\(A\\) as a subgroup of the symmetric group on \\(|A|\\) elements, \\(G \\subset S_{|A|}\\). Let \\(U_0: \\mathsf{H}_{\\text{logical}} \\rightarrow \\mathsf{H}_{\\text{physical}}\n= \\mathsf{H}^{\\otimes n}\\) be any QECC, possibly non-covariant. Define the covariant encoder \\(U \\equiv U_0^{\\otimes |A|}: \\mathsf{H}_{\\text{logical}}^{\\otimes |A|}\n\\rightarrow \\mathsf{H}_{\\text{physical}}^{\\otimes |A|}\\) on \\(|A|\\). Then, the group acts on codewords by index permutation: \\begin{align}\nV(g) | \\phi_{a_1} \\rangle | \\phi_{a_2} \\rangle \\cdots | \\phi_{a_{|A|}} \\rangle = | \\phi_{g^{-1} a_1} \\rangle | \\phi_{g^{-1} a_2} \\rangle \\cdots | \\phi_{g^{-1} a_{|A|}} \\rangle~,\n\\end{align} where \\(V(g)\\) is the unitary representation of \\(g \\in G\\) acting on the physical space. The action of \\(V(g)\\) is transversal with respect to the partition \\(\\mathsf{H}_{\\text{physical}}^{\\otimes |A|}\\).", "name": "\\(G\\)-covariant erasure code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "covariant", "parents_detail": "In a proof of principle demonstration, error-correcting codes that are finite-\\(G\\) covariant can be constructed from a base encoding \\(U_0\\).", "_type": "ecc", "_page_id": "c_g_covariant_erasure", "_href": "c/g_covariant_erasure"}, "c_j_gross": {"notes": "", "logical": "spins", "code_id": "j_gross", "physical": "spins", "protection": "", "introduced": "[J. A. Gross, \u201cDesigning Codes around Interactions: The Case of a Spin\u201d, Physical Review Letters 127, (2021). DOI; 2005.10910]", "description": "A spin code designed to realize Clifford gates using \\(SU(2)\\) rotations. Codewords are subspaces of a spin's Hilbert space that house irreducible representations (irreps) of the single-qubit Clifford group (i.e., the binary octahedral (\\(2O\\)) subgroup of \\(SU(2)\\)). This is done by restricting the \\(SU(2)\\) irrep to \\(2O\\), and determining the carrier spaces of any nontrivial irreps of \\(2O\\). Since irreps of \\(2O\\) do not appear in integer spins, half-integer spins are used.\n\nA simple example of a codespace is a projection onto an instance of a particular irrep of \\(2O\\), referred to as either \\( \\varrho_4 \\) or \\( \\varrho_5 \\). In the case of only one instance of the desired irrep present in the spin, the projection is created as follows: \\begin{align}\n  P_\\varrho = \\frac{\\text{dim} \\varrho}{|2O|} \\sum_{g \\in 2O} \\chi_\\varrho (g)^* D(g)~,\n\\end{align} where \\(D(g)\\) is the \\(SU(2)\\) Wigner matrix corresponding to group element \\(g\\), and the character \\(\\chi_\\varrho (g) = \\text{tr}(\\varrho(g))\\) is the trace of the desired irrep evaluated at a group element.\n\nLogical Pauli matrices \\(\\overline{\\sigma}_w\\) are defined using the above projection and the angular momentum operators: \\begin{align}\n  \\overline{\\sigma}_w = i P_\\varrho e^{-i \\pi J_w} P_\\varrho~.\n\\end{align} Finally, \\(|\\overline{0} \\rangle\\) is defined as the \\(+1\\) eigenvalue of \\(\\overline{\\sigma}_z\\) and \\(|\\overline{1} \\rangle = \\overline{\\sigma}_x |\\overline{0} \\rangle \\).", "name": "Gross spin code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "Universal computation results from being able to prepare a single logical state, perform one measurement, and the following logical gates: the phase gate (\\( \\overline{S} \\)), the Hadamard gate (\\(\\overline{H}\\)), the conditional phase gate (\\(\\overline{CZ}\\)), and the square root of the phase gate (\\(\\overline{T}\\)). Single-qubit Cliffords can be generated using \\(\\overline{S}\\) and \\(\\overline{H}\\), the extension to multiple-qubit Cliffords is done using \\(\\overline{CZ}\\), and \\(\\overline{T}\\) is to transform to non-Clifford states. Together these gates can be used to create all logical unitaries, while preparation and measurement complete universal quantum computation.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "spins_into_spins", "parents_detail": "", "_type": "ecc", "_page_id": "c_j_gross", "_href": "c/j_gross"}, "c_spins_into_spins": {"notes": "", "logical": "spins", "code_id": "spins_into_spins", "physical": "spins", "protection": "Spin codes are often designed to protect against \\(SU(2)\\) rotations by small angles.", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, where the canonical qudit basis consists of states of a quantum mechanical spin. In other words, canonical single-qudit states \\(|^\\ell_m\\rangle\\) are labeled by total angular momentum \\(\\ell\\) (either integer or half-integer) and its \\(z\\)-axis projection \\(m\\), with \\(q=2\\ell+1\\).\n\nIn contrast to other qudit codes, spin codes are closely associated with the angular momentum Lie algebra and/or the Lie groups \\(SU(2)\\) or \\(SO(3)\\). ", "name": "Spin code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "j_gross", "parent_of_detail": "", "cousins_code_id": "qubits_into_qubits", "cousins_detail": "Spin codes with spin \\(\\ell=1/2\\) correspond to qubit codes.", "_type": "ecc", "_page_id": "c_spins_into_spins", "_href": "c/spins_into_spins"}, "c_fermions": {"notes": "", "logical": "fermions", "code_id": "fermions", "physical": "fermions", "protection": "", "introduced": "", "description": "Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators [S. B. Bravyi and A. Y. Kitaev, \u201cFermionic Quantum Computation\u201d, Annals of Physics 298, 210 (2002). DOI; quant-ph/0003137].", "name": "Fermionic code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "majorana_stab", "parent_of_detail": "", "cousins_code_id": "qubits_into_qubits\noscillators", "cousins_detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation [A. Y. Kitaev, \u201cUnpaired Majorana fermions in quantum wires\u201d, Physics-Uspekhi 44, 131 (2001). DOI; cond-mat/0010440], codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations.\nBosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom.", "_type": "ecc", "_page_id": "c_fermions", "_href": "c/fermions"}, "c_majorana_stab": {"notes": "", "logical": "fermions", "code_id": "majorana_stab", "physical": "fermions", "protection": "Detects products of Majorana operators with weight up to \\(d-1\\). Physically, protects against dephasing errors caused by coupling of fermion density to the environment and bit-flip errors caused by quasiparticle poisoning processes.", "introduced": "[S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791]", "description": "Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as Majorana stabilizers. The codespace is the mutual \\(+1\\) eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as \\([[n,k,d]]_{f}\\) [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459], where \\(n\\) is the number of fermionic modes.", "name": "Majorana stabilizer code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "fermions\nqubit_stabilizer", "parents_detail": "\nThe Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438][S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791]. However, Pauli- and Majorana-based stabilizer codes have different notions of locality [A. Y. Kitaev, \u201cUnpaired Majorana fermions in quantum wires\u201d, Physics-Uspekhi 44, 131 (2001). DOI; cond-mat/0010440] and are thus useful for different physical platforms.", "cousins_code_id": "dual\ncss\nbinary_cyclic\nreed_muller\nstabilizer", "cousins_detail": "Classical self-orthogonal codes can be used to construct Majorana stabilizer codes [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a self-orthogonal classical code. A self-orthogonal classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\).\nWhen constructing a Majorana stabilizer code from a self-orthogonal classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space [S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791][Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different self-orthogonal classical codes with an odd number of bits, as is often done in the CSS construction.\nCyclic binary linear codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also self-orthogonal [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459].\nMajorana stabilizer codes can be constructed by self-orthogonal RM codes [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code.\nMajorana stabilizer codes are useful for Majorana-based architectures, where the degrees of freedom are electrons, and the notion of locality is different than all other code kingdoms.", "cousin_of_code_id": "floquet\nhoneycomb\nhappy\ntfim\nstab_5_1_3", "cousin_of_detail": "Floquet codes are viable candidates for storage in Majorana-qubit devices [Adam Paetznick et al., \u201cPerformance of planar Floquet codes with Majorana-based qubits\u201d. 2202.11829].\nThe Honeycomb code admits a representation in terms of Majorana fermions. This leads to a possible physical realization of the code in terms of tetrons [T. Karzig et al., \u201cScalable designs for quasiparticle-poisoning-protected topological quantum computation with Majorana zero modes\u201d, Physical Review B 95, (2017). DOI; 1610.05289], where each physical qubit is composed of four Majorana modes.\nHaPPY code Hamiltonian can be expressed in terms of mutually commuting two-body Majorana operators [A. Jahn et al., \u201cMajorana dimers and holographic quantum error-correcting codes\u201d, Physical Review Research 1, (2019). DOI; 1905.03268].\nThe TFIM code stabilizers can be expressed in terms of Majorana operators.\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].", "_type": "ecc", "_page_id": "c_majorana_stab", "_href": "c/majorana_stab"}, "c_string_net": {"notes": "", "logical": "categories", "code_id": "string_net", "physical": "categories", "protection": "Error-correcting properties established in Ref. [Y. Qiu and Z. Wang, \u201cGround subspaces of topological phases of matter as error correcting codes\u201d, Annals of Physics 422, 168318 (2020). DOI; 2004.11982].", "introduced": "[M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816]", "description": "Also called a Turaev-Viro or Levin-Wen model code. A family of topological codes, defined by a finite unitary spherical category \\( \\mathcal{C} \\), whose generators are few-body operators acting on a cell decomposition dual to a triangulation of a two-dimensional surface (with a qudit of dimension \\( |\\mathcal{C}| \\) located at each edge of the decomposition).\n\nThe codespace is the ground-state subspace of the Levin-Wen model Hamiltonian [M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617], a many-body Hamiltonian realizing the 3-manifold Turaev-Viro invariant [R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816][Alexander Kirillov Jr, \u201cString-net model of Turaev-Viro invariants\u201d. 1106.6033]. Alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model [Michael Freedman, Michael Larsen, and Zhenghan Wang, \u201cA modular functor which is universal for quantum computation\u201d. quant-ph/0001108][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816]. The fusion space can have dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes. ", "name": "String-net code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "Syndrome measurement circuits analyzed in Ref. [N. E. Bonesteel and D. P. DiVincenzo, \u201cQuantum circuits for measuring Levin-Wen operators\u201d, Physical Review B 86, (2012). DOI; 1206.6048].", "features_general_gates": "Gates can be implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles for triangulations of toroidal [G. Zhu, A. Lavasani, and M. Barkeshli, \u201cUniversal Logical Gates on Topologically Encoded Qubits via Constant-Depth Unitary Circuits\u201d, Physical Review Letters 125, (2020). DOI; 1806.02358][G. Zhu, A. Lavasani, and M. Barkeshli, \u201cInstantaneous braids and Dehn twists in topologically ordered states\u201d, Physical Review B 102, (2020). DOI; 1806.06078] and hyperbolic [A. Lavasani, G. Zhu, and M. Barkeshli, \u201cUniversal logical gates with constant overhead: instantaneous Dehn twists for hyperbolic quantum codes\u201d, Quantum 3, 180 (2019). DOI; 1901.11029] manifolds. Whether or not a gate set is universal depends on the choice of input category; in some cases such as the Ising category, gates can be complemented by topological charge measurements to obtain a universal gate set.\nAlternatively, one could encode the logical quantum information into the degenerate fusion space of a number of computational anyons. In this case, a universal logical gate set can be implemented through the braiding of the computational anyons [Michael Freedman, Michael Larsen, and Zhenghan Wang, \u201cA modular functor which is universal for quantum computation\u201d. quant-ph/0001108][M. H. Freedman, M. J. Larsen, and Z. Wang, \u201cThe Two-Eigenvalue Problem and Density\u00b6of Jones Representation of Braid Groups\u201d, Communications in Mathematical Physics 228, 177 (2002). DOI; math/0103200][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816], e.g., for the case of the Fibonacci input category.", "features_magic_scaling_exponent": "", "features_encoders": "For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit [Yu-Jie Liu et al., \u201cMethods for simulating string-net states and anyons on a digital quantum computer\u201d. 2110.02020].", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "category_quantum\ntopological", "parents_detail": "\nString-net codes can be realized using Levin-Wen model Hamiltonians, which realize various topological phases [M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816][Alexander Kirillov Jr, \u201cString-net model of Turaev-Viro invariants\u201d. 1106.6033].", "parent_of_code_id": "fibonacci", "parent_of_detail": "", "cousin_of_code_id": "surface\nqudit_surface\nquantum_double", "cousin_of_detail": "String-net model reduces to the surface code when the category is the group \\(\\mathbb{Z}_2\\).\nString-net model reduces to the qudit surface code when the category is the group \\(\\mathbb{Z}_q\\).\nString-net model reduces to the quantum-double model for group categories.", "_type": "ecc", "_page_id": "c_string_net", "_href": "c/string_net"}, "c_fibonacci": {"notes": "", "logical": "categories", "code_id": "fibonacci", "physical": "categories", "protection": "When defined on a \\(L \\times L\\) tailed honeycomb lattice on a torus, the code distance for ground-state encoding is \\(L\\).", "introduced": "[M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617]", "description": "Quantum error correcting code associated with the Levin-Wen string-net model with the Fibonacci input category, admitting two types of encodings.\n\nThe first type of encoding is into the ground-state subspace of the Levin-Wen model Hamiltonian, defined on a cell decomposition (dual to a triangulation) of a manifold with a qubit on each link. The code space is the simultaneous \\(+1\\) eigenspace of a set of vertex operators and plaquette operators, which are defined by the fusion rules and the numerical data of the Fibonacci category, respectively. The degeneracy of the code space is \\(4g\\), were \\(g\\) is the genus of the surface on which the cell decomposition is defined.\n\nThe second type of encoding is into the degenerate fusion space of a number of anyonic quasiparticle excitations of the Levin-Wen model.", "name": "Fibonacci string-net code", "realizations": "", "short_name": "", "features_threshold": "\\(4.7\\%\\) for depolarizing noise, \\(7.3\\%\\) for dephasing noise, and \\(3.8\\%\\) for bit-flip noise with clustering decoder, assuming perfect measurements and gates [Alexis Schotte et al., \u201cQuantum error correction thresholds for the universal Fibonacci Turaev-Viro code\u201d. 2012.04610].\n\\(3.0\\%\\) for depolarizing noise, \\(6.0\\%\\) for dephasing noise, and \\(2.5\\%\\) for bit-flip noise with fusion-aware iterative MWPM decoder, assuming perfect measurements and gates [Alexis Schotte et al., \u201cQuantum error correction thresholds for the universal Fibonacci Turaev-Viro code\u201d. 2012.04610].", "features_code_capacity_threshold": "", "features_decoders": "Clustering decoder (provides best known threshold for this code) [Alexis Schotte et al., \u201cQuantum error correction thresholds for the universal Fibonacci Turaev-Viro code\u201d. 2012.04610].\nFusion aware iterative minimum-weight perfect matching decoder. Note that ordinary MWPM decoders do not produce a threshold with this code [Alexis Schotte et al., \u201cQuantum error correction thresholds for the universal Fibonacci Turaev-Viro code\u201d. 2012.04610].", "features_general_gates": "Universal gate set for the ground-state encoding is implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles. These Dehn-twists can be implemented using constant-dept circuits when allowing long-range permutations of qubits [G. Zhu, A. Lavasani, and M. Barkeshli, \u201cUniversal Logical Gates on Topologically Encoded Qubits via Constant-Depth Unitary Circuits\u201d, Physical Review Letters 125, (2020). DOI; 1806.02358][G. Zhu, A. Lavasani, and M. Barkeshli, \u201cInstantaneous braids and Dehn twists in topologically ordered states\u201d, Physical Review B 102, (2020). DOI; 1806.06078].\nUniversal gate set for the fusion-space encoding is implemented through braiding of the computational anyons [Michael Freedman, Michael Larsen, and Zhenghan Wang, \u201cA modular functor which is universal for quantum computation\u201d. quant-ph/0001108][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "A universal transversal gate set could be implemented in a folded version of this code using the techniques introduced in Ref.[G. Zhu, M. Hafezi, and M. Barkeshli, \u201cQuantum origami: Transversal gates for quantum computation and measurement of topological order\u201d, Physical Review Research 2, (2020). DOI; 1711.05752].", "features_fault_tolerance": "", "parents_code_id": "string_net", "parents_detail": "", "_type": "ecc", "_page_id": "c_fibonacci", "_href": "c/fibonacci"}, "c_category_quantum": {"notes": "", "logical": "categories", "code_id": "category_quantum", "physical": "categories", "protection": "", "introduced": "", "description": "Encodes a finite-dimensional logical Hilbert space into a physical Hilbert space associated with a category. Often associated with a particular topological quantum field theory (TQFT), as the data of such theories is described by a category.", "name": "Category-based quantum code", "realizations": "", "short_name": "", "features_threshold": "", "features_code_capacity_threshold": "", "features_decoders": "", "features_general_gates": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_rate": "", "features_transversal_gates": "", "features_fault_tolerance": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "string_net", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_category_quantum", "_href": "c/category_quantum"}}