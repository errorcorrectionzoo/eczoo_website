{"c_oaecc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Operator-algebra error-correcting code", "code_id": "oaecc", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "Operator-algebra QECC", "introduced": "[Greg Kuperberg, \u201cThe capacity of hybrid quantum memory\u201d. quant-ph/0203105][C. B\u00e9ny, A. Kempf, and D. W. Kribs, \u201cGeneralization of Quantum Error Correction via the Heisenberg Picture\u201d, Physical Review Letters 98, (2007). DOI; quant-ph/0608071][C. B\u00e9ny, A. Kempf, and D. W. Kribs, \u201cQuantum error correction of observables\u201d, Physical Review A 76, (2007). DOI; 0705.1574][C. B\u00c9NY, D. W. KRIBS, and A. PASIEKA, \u201cALGEBRAIC FORMULATION OF QUANTUM ERROR CORRECTION\u201d, International Journal of Quantum Information 06, 597 (2008). DOI]", "description": "Stub.", "parent_of_code_id": "classical_into_quantum\necc\nholographic\nqecc\noecc", "parent_of_detail": "\nAny ECC can be embedded into a quantum Hilbert space, and thus passed through a quantum channel, by associating elements of the alphabet with basis vectors in a Hilbert space over the complex numbers. For example, a bit of information can be embedded into a two-dimensional vector space by associating the two bit values with two basis vectors for the space.\nProperties of holographic codes are often quantified in the Heisenberg picture, i.e., in terms of operator algebras [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][F. Pastawski and J. Preskill, \u201cCode Properties from Holographic Geometries\u201d, Physical Review X 7, (2017). DOI; 1612.00017].\n\n", "cousin_of_code_id": "eacq", "cousin_of_detail": "Entanglement-assisted hybrid codes are hybrid classical-quantum codes utilizing pre-shared entanglement.", "_type": "ecc", "_page_id": "c_oaecc", "_href": "c/oaecc"}, "c_eacq": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Entanglement-assisted hybrid classical-quantum (EACQ) code", "code_id": "eacq", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "EACQ", "introduced": "[I. Kremsky, M.-H. Hsieh, and T. A. Brun, \u201cClassical enhancement of quantum-error-correcting codes\u201d, Physical Review A 78, (2008). DOI; 0802.2414][Andrew Nemec and Andreas Klappenecker, \u201cInfinite Families of Quantum-Classical Hybrid Codes\u201d. 1911.12260][Manideep Mamindlapally and Andreas Winter, \u201cSingleton Bounds for Entanglement-Assisted Classical and Quantum Error Correcting Codes\u201d. 2202.02184]", "description": "Stub.", "parent_of_code_id": "eaqecc\neaoecc\nquantum_into_quantum", "parent_of_detail": "\n\n", "cousins_code_id": "oaecc", "cousins_detail": "Entanglement-assisted hybrid codes are hybrid classical-quantum codes utilizing pre-shared entanglement.", "_type": "ecc", "_page_id": "c_eacq", "_href": "c/eacq"}, "c_classical_into_quantum": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Classical-into-quantum code", "code_id": "classical_into_quantum", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Code designed specifically for transmission of classical information through non-classical channels, e.g., quantum channels, hybrid quantum-classical channels, or channels with classical inputs and quantum outputs. Such codes include maps from a classical alphabet into a quantum Hilbert space. ", "parents_code_id": "oaecc", "parents_detail": "", "parent_of_code_id": "niset_andersen_cerf\npolar_for_quantum", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_classical_into_quantum", "_href": "c/classical_into_quantum"}, "c_polar_for_quantum": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Codes achieve the symmetric Holevo information for sending classical information over any quantum channel.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Quantum-limited successive-cancellation (SC) joint-detection receiver [M. M. Wilde and S. Guha, \u201cPolar Codes for Classical-Quantum Channels\u201d, IEEE Transactions on Information Theory 59, 1175 (2013). DOI; 1109.2591].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum-classical polar code", "code_id": "polar_for_quantum", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[M. M. Wilde and S. Guha, \u201cPolar Codes for Classical-Quantum Channels\u201d, IEEE Transactions on Information Theory 59, 1175 (2013). DOI; 1109.2591][R. Nasser and J. M. Renes, \u201cPolar Codes for Arbitrary Classical-Quantum Channels and Arbitrary cq-MACs\u201d, IEEE Transactions on Information Theory 64, 7424 (2018). DOI; 1701.03397]", "description": "Polar code used to transmit classical information over channels with classical inputs and quantum outputs. ", "parents_code_id": "classical_into_quantum", "parents_detail": "", "cousin_of_code_id": "bpsk\npolar", "cousin_of_detail": "BPSK concatenated with quantum-classical polar codes achieves the Holevo capacity for the pure-loss channel [S. Guha and M. M. Wilde, \u201cPolar coding to achieve the Holevo capacity of a pure-loss optical channel\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0533].\nQuantum-classical polar codes generalize polar codes for transmission through channels with quantum output.", "_type": "ecc", "_page_id": "c_polar_for_quantum", "_href": "c/polar_for_quantum"}, "c_niset_andersen_cerf": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "After an EPR pair preparation, use 2 continuous CNOT and 2 continuous inverse CNOT gates to entangle a bosonic EPR pair with initial states \\(|\\alpha \\rangle\\) and \\(|\\beta \\rangle\\).\nAlternate optical encoder using a two-mode squeezed vacuum state and two balanced beam splitters to mix the input coherent states with the EPR pair.", "features_decoders": "Optical decoder using three beam splitters, electronic gain detectors, and two phase-insensitive amplifiers as described in Ref. [J. Niset, U. L. Andersen, and N. J. Cerf, \u201cExperimentally Feasible Quantum Erasure-Correcting Code for Continuous Variables\u201d, Physical Review Letters 101, (2008). DOI; 0710.4858].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Niset-Andersen-Cerf code", "code_id": "niset_andersen_cerf", "realizations": "Realized in Ref. [M. Lassen et al., \u201cQuantum optical coherence can survive photon losses using a continuous-variable quantum erasure-correcting code\u201d, Nature Photonics 4, 700 (2010). DOI] in an optical system with 3 beam-splitters. The fidelity peaked around \\(0.6\\) for deterministic approach, and around \\(0.77\\) for the probabilistic approach (with a 25% chance of error).", "protection": "The deterministic protocol protects against a single erasure error on a known mode. This recovers one state perfectly and the other state with fidelity \\(F = \\frac{1}{1 + e^{-2 r}}\\) for an initial EPR pair squeezed with variance \\(e^{-2r}\\). The probabalistic protocol utilizes post-selection to protect against multiple erasures with state-dependent fidelity.", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[J. Niset, U. L. Andersen, and N. J. Cerf, \u201cExperimentally Feasible Quantum Erasure-Correcting Code for Continuous Variables\u201d, Physical Review Letters 101, (2008). DOI; 0710.4858]", "description": "Classical-into-quantum code encoding two-mode coherent states \\(\\{|\\alpha\\rangle, |\\beta\\rangle\\}\\) into four modes such that the complex values \\((\\alpha,\\beta)\\) are recoverable after a single-mode erasure. There are two variations of the storage procedure: a deterministic protocol that offers recovery against a single mode erasure, and a probabalistic that can protect against multiple errors with post selection. This code is effectively protecting classical information stored in \\((\\alpha,\\beta)\\) using quantum operations.", "parents_code_id": "classical_into_quantum", "parents_detail": "", "cousins_code_id": "qam", "cousins_detail": "The Niset-Andersen-Cerf code encodes two coherent states at a time with arbitrary complex values, making it analogous to a two-point QAM code. The code does not encode any quantum information since superpositions of the coherent states are not stored. However, analysis of the code is done via a quantum treatment.", "cousin_of_code_id": "homological_cv", "cousin_of_detail": "The Niset-Andersen-Cerf code can be viewed as a scheme to replicate quantum information in multiple regions [P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544].", "_type": "ecc", "_page_id": "c_niset_andersen_cerf", "_href": "c/niset_andersen_cerf"}, "c_ecc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Error-correcting code (ECC)", "code_id": "ecc", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "ECC", "introduced": "", "description": "Code designed for transmission of classical information through classical channels in a robust way. ", "parents_code_id": "oaecc", "parents_detail": "Any ECC can be embedded into a quantum Hilbert space, and thus passed through a quantum channel, by associating elements of the alphabet with basis vectors in a Hilbert space over the complex numbers. For example, a bit of information can be embedded into a two-dimensional vector space by associating the two bit values with two basis vectors for the space.", "parent_of_code_id": "analog\necc_finite\ngeneralized_concatenated\ngroup_classical\nlinear\nparallel_concatenated\nrandom", "parent_of_detail": "\n\n\n\n\n\n", "cousin_of_code_id": "qecc", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_ecc", "_href": "c/ecc"}, "c_analog": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Random analog codes can achieve the capacity of the additive Gaussian white-noise channel [C. E. Shannon, \u201cProbability of Error for Optimal Codes in a Gaussian Channel\u201d, Bell System Technical Journal 38, 611 (1959). DOI]; see the book [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI] for more details. Deterministic sets of constellations from quadrature rules can also achieve capacity [Y. Wu and S. Verdu, \u201cThe impact of constellation cardinality on Gaussian channel capacity\u201d, 2010 48th Annual Allerton Conference on Communication, Control, and Computing (Allerton) (2010). DOI].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Each signal point is assigned its own Voronoi cell, and a received point is mapped back to the center of the Voronoi cell that it is located upon reception.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Analog code", "code_id": "analog", "realizations": "", "protection": "The primary application of analog codes is to transmist information using electromagnetic signals. The primary noise channel for such signals is the additive Gaussian white-noise channel (AGWN), which adds a random Gaussian-distributed displacement to each signal point. Protection of a constellation thus depends on how far apart its points are in terms of the Euclidean distance. As usual, there is a tradeoff between packing of space and level of protection. ", "notes": "", "physical": "reals", "short_name": "", "introduced": "", "description": "Encodes states (codewords) into coordinates in the \\(n\\)-dimensional real coordinate space \\(\\mathbb{R}^n\\). The number of codewords may be infinite because the coordinate space is infinite-dimensional, so various restricted versions have to be constructed in practice.\n\nAnalog codes provide ways of encoding digital or analog information into the frequency, amplitude, and phase of one or more analog waveforms for transmission through, e.g., an optical fiber or free space. This is due to Kotelnikov's [V. A. Kotelnikov, \u201cThe theory of optimum noise immunity,\u201d PhD Thesis, Molotov Energy Institute, Moscow, Jan. 1947] and Shannon's [C. E. Shannon, \u201cCommunication in the Presence of Noise\u201d, Proceedings of the IRE 37, 10 (1949). DOI] fundamental observation that a discretized electromagnetic signal of finite-bandwidth can be represented as a point in \\(\\mathbb{R}^n\\). Questions of capacity of electromagnetic communication channels then translate to packing problems in \\(\\mathbb{R}^n\\) [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI].\n\nIn the electromagnetic context, the information stored in the code is called the bitstream, coordinates used for encoding are often called signal points and form a constellation, and \\(\\mathbb{R}^n\\) is called the signal space.\n\nAn analog code is mapped into a time-dependent electromagnetic signal using a modulation scheme [J. K. Wolf et al., editors , Coded Modulation Systems (Kluwer Academic Publishers, 2002). DOI][A. Lapidoth, A Foundation in Digital Communication (Cambridge University Press, 2017). DOI]. There is a close relation between abstract real-space encodings and modulation schemes, so analog codes are often named after modulation schemes.\n\nLinear modulation schemes encode points into amplitudes of electromagnetic waveforms. Pulse-amplitude modulation (PAM) associates each point with a real-valued amplitude of one quadrature of an electromagnetic waveform [A. Lapidoth, A Foundation in Digital Communication (Cambridge University Press, 2017). DOI; Sec. 10.5]. Quadrature amplitude modulation (QAM) associates each pair of points with a complex-valued two-quadrature amplitude of band-limited signal [A. Lapidoth, A Foundation in Digital Communication (Cambridge University Press, 2017). DOI; Ch. 16].", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "points_into_lattices\nqam\npoints_into_spheres", "parent_of_detail": "\n\n", "cousin_of_code_id": "coherent_constellation\ngroup_classical", "cousin_of_detail": "Coherent-state constellation codes are quantum versions of analog codes in that their codewords are superpositions of points in a constellation. Additionally, analog codes that achieve AGWN capacity [Y. Wu and S. Verdu, \u201cThe impact of constellation cardinality on Gaussian channel capacity\u201d, 2010 48th Annual Allerton Conference on Communication, Control, and Computing (Allerton) (2010). DOI] can be used to develop capacity-achieving concatenations of coherent-state constellation codes with quantum polar codes [F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent-state constellations and polar codes for thermal Gaussian channels\u201d, Physical Review A 95, (2017). DOI; 1603.05970][F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent state constellations for Bosonic Gaussian channels\u201d, 2016 IEEE International Symposium on Information Theory (ISIT) (2016). DOI].\nGroup-based codes whose alphabet is based on the reals \\(\\mathbb{R}\\), taken to be an abelian group under addition, are analog codes.", "_type": "ecc", "_page_id": "c_analog", "_href": "c/analog"}, "c_points_into_spheres": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Spherical code", "code_id": "points_into_spheres", "realizations": "", "protection": "", "notes": "See the book [T. Ericson, and V. Zinoviev, eds. Codes on Euclidean spheres. Elsevier, 2001.] for more details.", "physical": "reals", "short_name": "", "introduced": "", "description": "Code whose codewords are points on an \\(n\\)-dimensional sphere \\(S^n\\). It is denoted as \\((n,M,\\rho)\\), where \\(n\\) is the dimension, \\(M\\) is the size or number of codewords, and \\(\\rho\\) is the squared minimum distance, i.e., the smallest Euclidean distance between pairs of distinct codewords, \\begin{align}\n  \\rho=\\min\\left\\{ \\left\\Vert x-y\\right\\Vert ^{2}\\,\\text{s.t.}\\,x,y\\in C,\\,\\,x\\neq y\\right\\}~.\n\\end{align} The radius of the sphere squared is called the energy, and it is taken to be unity for spherical codes. Points on a sphere with non-unity radius make up constant-energy codes.\n\nA spherical code can be defined using the Gram matrix \\(G = XX^T\\), where the rows of \\(X\\) are the codeword vectors. The Gram matrix is symmetric, positive-definite, and has all diagonal elements equal to one. ", "parents_code_id": "analog", "parents_detail": "", "parent_of_code_id": "psk", "parent_of_detail": "PSK is a spherical code on the 1D sphere.", "cousins_code_id": "bits_into_bits\nconstant_weight", "cousins_detail": "Any binary \\((n,K,d)\\) code can be converted into an \\((n,K,4d/n)\\) spherical code via a component-wise antipodal mapping \\(0\\to +1\\) and \\(1 \\to -1\\) [T. Ericson, and V. Zinoviev, eds. Codes on Euclidean spheres. Elsevier, 2001.; Example 1.2.1].\nAny \\((n,K,d)\\) code of constant weight \\(w\\) can be converted into an \\((n-1,K,\\frac{nd}{nw-w^2})\\) spherical code [T. Ericson, and V. Zinoviev, eds. Codes on Euclidean spheres. Elsevier, 2001.; Example 1.2.2].", "_type": "ecc", "_page_id": "c_points_into_spheres", "_href": "c/points_into_spheres"}, "c_pam": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Pulse-amplitude modulation (PAM) code", "code_id": "pam", "realizations": "", "protection": "", "notes": "", "physical": "reals", "short_name": "PAM", "introduced": "", "description": "Encodes a \\(q\\)-ary digit into a constellation of equally spaced points on the real line. For example, a \\(q\\)-PAM scheme for \\(q=8\\) could encode the constellation \\(\\{ \\pm \\alpha,\\pm 3\\alpha,\\pm 5\\alpha, \\pm 7\\alpha \\}\\) with real scaling factor \\(\\alpha\\). The points in the constellation are typically associated with one quadrature of an electromagnetic signal. ", "parents_code_id": "qam", "parents_detail": "PAM codes can be thought of as QAM codes restricted to the real line. A \\(q\\times q\\)-QAM code is informationally equivalent to two \\(q\\)-PAM codes.", "cousin_of_code_id": "bpsk", "cousin_of_detail": "BPSK for real \\(\\alpha\\) is the simplest non-trivial PAM encoding.", "_type": "ecc", "_page_id": "c_pam", "_href": "c/pam"}, "c_psk": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Nearly achieves Shannon AWGN capacity for one-dimensional constellations in the limit of infinite signal to noise [R. E. Blahut, Modem Theory (Cambridge University Press, 2009). DOI; Fig. 11.7].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Phase-shift keyring (PSK) code", "code_id": "psk", "realizations": "Telephone-line modems: 1967 Milgo 4400/48 and international standard V.27 used 8-PSK [International Telecommunication Union-T, Recommendation V.27ter: 4800/2400 Bits Per Second Modem Standardized For Use in the General Switched Telephone Network, 1984].", "protection": "", "notes": "", "physical": "reals", "short_name": "PSK", "introduced": "", "description": "A \\(q\\)-ary phase-shift keyring (\\(q\\)-PSK) encodes one \\(q\\)-ary digit of information into a constellation of \\(q\\) points distributed equidistantly on a circle in \\(\\mathbb{C}\\) or, equivalently, \\(\\mathbb{R}^2\\). For example, such a constellation could be \\begin{align}\n  \\{1,e^{i\\frac{2\\pi}{q}},\\cdots,e^{i\\frac{2\\pi}{q}(q-1)}\\}~.\n\\end{align} Each point is typically associated with a complex amplitude of an electromagnetic signal, and information is encoded into the phase of that signal. ", "parents_code_id": "points_into_spheres\nqam", "parents_detail": "PSK is a spherical code on the 1D sphere.\nPSK is a version of QAM where the constellation consists of points arranged equidistantly on a circle.", "parent_of_code_id": "bpsk\nqpsk", "parent_of_detail": "BPSK is also known as 2-PSK.\nQPSK is also known as 4-PSK.", "cousins_code_id": "gray\ncat\nq-ary_over_zq", "cousins_detail": "1D Gray codes are often concatenated with PSKs so that the Hamming distance between the bitstrings encoded into the points is a discretized version of the Euclidean distance between the points.\nThe cat code is a quantum analogue of PSK for \\(q=2S\\).\nConcatenating linear codes over \\(\\mathbb{Z}_q\\) with \\(q\\)-ary PSK yields a natural non-binary way of digitizing the analog AGWN channel [Massey, J. L. \"Convolutional codes over rings.\" Fourth Joint Swedish-Soviet International Workshop on Information Theory. 1989.][Massey, J. L. \"Ring convolutional codes for phase modulation.\" presented at the IEEE Int. Symp. on Information Theory, San Diego, CA, Jan. 14-19. 1990.].", "_type": "ecc", "_page_id": "c_psk", "_href": "c/psk"}, "c_bpsk": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Achieve capacity of AGWN in the low signal-to-noise regime [Y. Wu and S. Verdu, \u201cThe impact of constellation cardinality on Gaussian channel capacity\u201d, 2010 48th Annual Allerton Conference on Communication, Control, and Computing (Allerton) (2010). DOI] (see also [C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 623 (1948). DOI]). BPSK concatenated with quantum-classical polar codes achieves the Holevo capacity for the pure-loss channel [S. Guha and M. M. Wilde, \u201cPolar coding to achieve the Holevo capacity of a pure-loss optical channel\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0533].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary PSK (BPSK) code", "code_id": "bpsk", "realizations": "Telephone-line modems throughout 1950s and 1960s: Bell 103 and 202, as well as international standards V.21 [International Telecommunication Union-T, Recommendation V.21: 300 bits per second duplex modem standardized for use in the general switched telephone network, 1984] and V.23 [International Telecommunication Union-T, Recommendation V.23: 600/1200-baud modem standardized for use in the general switched telephone network, 1988].", "protection": "", "notes": "", "physical": "reals", "short_name": "BPSK", "introduced": "[C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 623 (1948). DOI]", "description": "Also called a binary antipodal modulation, phase-reversal keyring (PRK), or antipodal signaling. Encodes one bit of information into a constellation of antipodal points \\(\\pm\\alpha\\) for complex \\(\\alpha\\). These points are typically associated with two phases of an electromagnetic signal in a PAM, PSK, or QAM scheme. ", "parents_code_id": "psk", "parents_detail": "BPSK is also known as 2-PSK.", "cousins_code_id": "pam\nbinary_linear\ntwo-legged-cat\npolar_for_quantum", "cousins_detail": "BPSK for real \\(\\alpha\\) is the simplest non-trivial PAM encoding.\nConcatenating binary linear codes with BPSK yields a standard way of digitizing the analog AGWN channel [A. Lapidoth, A Foundation in Digital Communication (Cambridge University Press, 2017). DOI; Ch. 29].\nThe two-component cat code is a quantum analogue of BPSK.\nBPSK concatenated with quantum-classical polar codes achieves the Holevo capacity for the pure-loss channel [S. Guha and M. M. Wilde, \u201cPolar coding to achieve the Holevo capacity of a pure-loss optical channel\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0533].", "_type": "ecc", "_page_id": "c_bpsk", "_href": "c/bpsk"}, "c_qpsk": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quadrature PSK (QPSK) code", "code_id": "qpsk", "realizations": "Japanese and North American digital cellular and personal systems [K. Feher, \u201cModems for emerging digital cellular-mobile radio system\u201d, IEEE Transactions on Vehicular Technology 40, 355 (1991). DOI].\nTelephone-line modems: 1962 Bell 201 and international standard V.24 [International Telecommunication Union-T, Recommendation V.24: List of definitions for interchange circuits between data terminal equipment (DTE) and data circuit-terminating equipment (DCE), 1988].", "protection": "", "notes": "", "physical": "reals", "short_name": "QPSK", "introduced": "[P. A. Baker, \u201cPhase-modulation data sets for serial transmission at 2,000 and 2,400 bits per second\u201d, Transactions of the American Institute of Electrical Engineers, Part I: Communication and Electronics 81, 166 (1962). DOI]", "description": "Also known as quadriphase PSK, 4-PSK, or 4-QAM. Quaternary encoding into a constellation of four points distributed equidistantly on a circle. For the case of \\(\\pi/4\\)-QPSK, the constellation is \\(\\{e^{\\pm i\\frac{\\pi}{4}},e^{\\pm i\\frac{3\\pi}{4}}\\}\\). ", "parents_code_id": "psk", "parents_detail": "QPSK is also known as 4-PSK.", "_type": "ecc", "_page_id": "c_qpsk", "_href": "c/qpsk"}, "c_qam": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Nearly achieves Shannon AWGN capacity for two-dimensional constellations in the limit of infinite signal to noise [R. E. Blahut, Modem Theory (Cambridge University Press, 2009). DOI; Fig. 11.8].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quadrature-amplitude modulation (QAM) code", "code_id": "qam", "realizations": "Optical communication (e.g., Ref. [F. Buchali et al., \u201cRate Adaptation and Reach Increase by Probabilistically Shaped 64-QAM: An Experimental Demonstration\u201d, Journal of Lightwave Technology 34, 1599 (2016). DOI]).\nTelephone-line modems: 1971 Codex 9600C and international standard V.29 used 16-QAM [International Telecommunication Union-T, Recommendation V.29: 9600 Bits Per Second Modem Standardized For Use on Point-to-Point 4-Wire Leased Telephone-Tpe Circuits, 1993].", "protection": "", "notes": "", "physical": "reals", "short_name": "QAM", "introduced": "", "description": "Encodes into points into a subset of points lying on in \\(\\mathbb{R}^{2}\\), here treated as \\(\\mathbb{C}\\). Each pair of points is associated with a complex amplitude of an electromagnetic signal, and information is encoded into both the norm and phase of that signal [A. Lapidoth, A Foundation in Digital Communication (Cambridge University Press, 2017). DOI; Ch. 16].\n\nQAM schemes with \\(q\\) complex coordinates are often called \\(q\\)-QAM, and \\(q\\) is often a power of two in order to further concatenate with a binary code. ", "parents_code_id": "analog", "parents_detail": "", "parent_of_code_id": "psk\npam", "parent_of_detail": "PSK is a version of QAM where the constellation consists of points arranged equidistantly on a circle.\nPAM codes can be thought of as QAM codes restricted to the real line. A \\(q\\times q\\)-QAM code is informationally equivalent to two \\(q\\)-PAM codes.", "cousins_code_id": "points_into_lattices\ngkp\ngray", "cousins_detail": "QAM encodings often consist of lattice constellations, i.e., finite sets of points scooped out of an infinite 2D lattice.\nGKP codes are quantum analogues of lattice-based QAM codes.\n2D Gray codes are often concatenated with \\(n=1\\) lattice-based QAM codes so that the Hamming distance between the bitstrings encoded into the points is a discretized version of the Euclidean distance between the points.", "cousin_of_code_id": "niset_andersen_cerf", "cousin_of_detail": "The Niset-Andersen-Cerf code encodes two coherent states at a time with arbitrary complex values, making it analogous to a two-point QAM code. The code does not encode any quantum information since superpositions of the coherent states are not stored. However, analysis of the code is done via a quantum treatment.", "_type": "ecc", "_page_id": "c_qam", "_href": "c/qam"}, "c_eeight": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Gosset \\(E_8\\) lattice code", "code_id": "eeight", "realizations": "", "protection": "The \\(E_8\\) lattice has a nominal coding gain of \\(2\\). ", "notes": "", "physical": "reals", "short_name": "", "introduced": "", "description": "BW lattice in dimension \\(8\\), which is the lattice corresponding to the \\([8,4,4]\\) Hamming code via the mod-two lattice construction. ", "parents_code_id": "barnes_wall\nconstruction_a", "parents_detail": "\n", "cousins_code_id": "hamming", "cousins_detail": "The \\([8,4,4]\\) Hamming code yields the \\(E_8\\) lattice code via the mod-two lattice construction.", "_type": "ecc", "_page_id": "c_eeight", "_href": "c/eeight"}, "c_leech": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Leech lattice code", "code_id": "leech", "realizations": "", "protection": "The \\(E_8\\) lattice has a nominal coding gain of \\(4\\). ", "notes": "", "physical": "reals", "short_name": "", "introduced": "", "description": "Lattice in 24 dimensions that exhibits optimal packing. ", "parents_code_id": "points_into_lattices", "parents_detail": "", "_type": "ecc", "_page_id": "c_leech", "_href": "c/leech"}, "c_construction_a": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Mod-2 lattice code", "code_id": "construction_a", "realizations": "", "protection": "", "notes": "", "physical": "reals", "short_name": "", "introduced": "", "description": "Lattice constructed from a binary linear \\([n,k,d]\\) code using Construction A [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. Each binary codeword \\(c\\) of the code is mapped to an infinite set of points \\(x\\) such that \\(x = c\\) modulo two. Linearity of the code ensures that the resulting set of points forms a lattice. ", "parents_code_id": "points_into_lattices", "parents_detail": "", "parent_of_code_id": "eeight\ndfour", "parent_of_detail": "\n", "cousins_code_id": "binary_linear", "cousins_detail": "Each binary linear code yields a mod-two lattice code.", "_type": "ecc", "_page_id": "c_construction_a", "_href": "c/construction_a"}, "c_dfour": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(D_4\\) lattice code", "code_id": "dfour", "realizations": "", "protection": "The \\(D_4\\) lattice has a nominal coding gain of \\(\\sqrt{2}\\). ", "notes": "", "physical": "reals", "short_name": "", "introduced": "", "description": "BW lattice in dimension \\(4\\), which is the lattice corresponding to the \\([4,1,4]\\) repetition and \\([4,3,2]\\) SPC codes via the mod-two lattice construction. ", "parents_code_id": "barnes_wall\nconstruction_a", "parents_detail": "\n", "cousins_code_id": "repetition\nparity_check", "cousins_detail": "The four-bit repetition code yields the \\(D_4\\) lattice code via the mod-two lattice construction.\nThe \\([4,3,2]\\) SPC code yields the \\(D_4\\) lattice code via the mod-two lattice construction.", "_type": "ecc", "_page_id": "c_dfour", "_href": "c/dfour"}, "c_points_into_lattices": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Lattice-based code", "code_id": "points_into_lattices", "realizations": "", "protection": "Lattices are characterized by the minimum (Euclidean) distance \\(d_{\\text{min}}\\) between two lattice points, the kissing number \\(K_{\\text{min}}\\) of nearest neighbors at each lattice point, and the volume \\(V=\\det G\\), which is equal to the determinant of the lattice generator matrix \\(G\\).\n\nThe nominal coding gain \\(\\gamma_{c}\\) (a.k.a. Hermite parameter) of an \\(n\\)-dimensional lattice is \\begin{align}\n  \\gamma_{c}=\\left(d_{\\text{min}}/\\sqrt[n]{V}\\right)^{2}~,\n\\end{align} characterizing the ratio of the level of protection to the required spatial resources. ", "notes": "See book [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI] for an introduction and overview of lattices.", "physical": "reals", "short_name": "", "introduced": "", "description": "Encodes states (codewords) in coordinates of an \\(n\\)-dimensional lattice. The number of codewords may be infinite because the coordinate space is infinite-dimensional, so various restricted versions have to be constructed in practice. Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.", "parents_code_id": "analog", "parents_detail": "", "parent_of_code_id": "barnes_wall\nleech\nconstruction_a", "parent_of_detail": "\n\n", "cousins_code_id": "linear", "cousins_detail": "Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.", "cousin_of_code_id": "group_linear\nmultimodegkp\nqam", "cousin_of_detail": "Linear codes over \\(G=\\mathbb{R}\\) are lattices.\nMultimode GKP codes are quantum analogues of lattice-based codes.\nQAM encodings often consist of lattice constellations, i.e., finite sets of points scooped out of an infinite 2D lattice.", "_type": "ecc", "_page_id": "c_points_into_lattices", "_href": "c/points_into_lattices"}, "c_barnes_wall": {"logical": "reals", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Barnes-Wall (BW) lattice code", "code_id": "barnes_wall", "realizations": "", "protection": "BW lattices in dimension \\(2^{m+1}\\) have a nominal coding gain of \\(2^{m/2}\\). Their kissing number is \\(K_{\\text{min}} = \\prod_{i=1}^{m+1} (2^i + 2)\\). ", "notes": "", "physical": "reals", "short_name": "", "introduced": "", "description": "Member of a family of \\(2^{m+1}\\)-dimensional lattices, denoted as BW\\(_{2^{m+1}}\\), that are the densest lattices known. Members include the integer square lattice \\(\\mathbb{Z}^2\\), \\(D_4\\), the Gosset \\(E_8\\) lattice, and the \\(\\Lambda_{16}\\) lattice, corresponding to \\(m\\in\\{0,1,2,3\\}\\), respectively. ", "parents_code_id": "points_into_lattices", "parents_detail": "", "parent_of_code_id": "eeight\ndfour", "parent_of_detail": "\n", "cousins_code_id": "reed_muller", "cousins_detail": "BW lattice codes are lattice analogues of RM codes in that both can be constructed recursively via a \\(|u|u+v|\\) construction [E. L. Cusack, \u201cError control codes for QAM signalling\u201d, Electronics Letters 20, 62 (1984). DOI][G. D. Forney, \u201cCoset codes. I. Introduction and geometrical classification\u201d, IEEE Transactions on Information Theory 34, 1123 (1988). DOI].", "_type": "ecc", "_page_id": "c_barnes_wall", "_href": "c/barnes_wall"}, "c_regenerating": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Regenerating code (RGC)", "code_id": "regenerating", "realizations": "", "protection": "", "notes": "", "physical": "matrices", "short_name": "RGC", "introduced": "", "description": "Stub.", "parents_code_id": "distributed_storage\nmatrices_into_matrices", "parents_detail": "\n", "parent_of_code_id": "mbr\nmsr", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_regenerating", "_href": "c/regenerating"}, "c_matrix_computation": {"logical": "matrices", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Matrix computation code", "code_id": "matrix_computation", "realizations": "", "protection": "Allows computation to complete without waiting for stragglers, or nodes that either do not finish or finish their portion of the computation much later than all other nodes.", "notes": "", "physical": "matrices", "short_name": "", "introduced": "", "description": "Encoding that provides an extra redundancy for distributed matrix computation algorithms such as matrix multiplication. Parallelized algorithms distribute a desired computation over many nodes, and a key performance bottleneck is due to some nodes completing their individual tasks much later than other nodes. Matrix computation codes provide a layer of redundancy such that the computation can be performed without having all nodes finish their piece of the computation. ", "parents_code_id": "matrices_into_matrices", "parents_detail": "", "cousins_code_id": "mds", "cousins_detail": "The first matrix multiplication code encoded each entry of the matrices to be multiplied into an MDS code [K. Lee et al., \u201cSpeeding Up Distributed Machine Learning Using Codes\u201d, IEEE Transactions on Information Theory 64, 1514 (2018). DOI; 1512.02673].", "_type": "ecc", "_page_id": "c_matrix_computation", "_href": "c/matrix_computation"}, "c_rank_metric": {"logical": "matrices", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Polynomial-reconstruction Berlekamp-Welch based decoder [P. Loidreau, \u201cA Welch\u2013Berlekamp Like Algorithm for Decoding Gabidulin Codes\u201d, Coding and Cryptography 36 (2006). DOI].\nBerlekamp-Massey based decoder [G. Richter and S. Plass, \u201cFast decoding of rank-codes with rank errors and column erasures\u201d, International Symposium onInformation Theory, 2004. ISIT 2004. Proceedings.. DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Rank-metric code", "code_id": "rank_metric", "realizations": "", "protection": "Protects against errors with rank \\(\\leq \\lfloor \\frac{d-1}2 \\rfloor\\).", "notes": "See Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333] for a discussion of MacWilliams identities and the relationship between rank metric and Gabidulin codes.", "physical": "matrices", "short_name": "", "introduced": "[P. Delsarte, \u201cBilinear forms over a finite field, with applications to coding theory\u201d, Journal of Combinatorial Theory, Series A 25, 226 (1978). DOI]", "description": "Also called a Delsarte code. Each codeword is a matrix over \\(GF(q)\\), with codewords forming a \\(GF(q)\\)-linear subspace, and with the metric being the rank of the difference of matrices. The distance \\(d\\) is the minimum rank of all nonzero matrices in the code. Rank-metric codes on \\(n\\times m\\) matrices are denoted as \\([n\\times m,k,d]_q\\).\n\nThe number of codewords satisfies \\(k \\leq \\max(n, m) M\\), where \\(M\\) is the maximum rank of all matrices in the code. Codes that achieve this bound with equality are called Delsarte optimal anticodes. ", "parents_code_id": "matrices_into_matrices", "parents_detail": "", "parent_of_code_id": "gabidulin\nmaximum_rank_distance", "parent_of_detail": "Gabidulin codes over \\(GF(q^N)\\), when expressed as matrices over \\(GF(q)\\), are rank-metric codes (see Def. 14 in Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333]). The reverse is not always true since Gabidulin codes are not always \\(GF(q^N)\\)-linear (see Rm. 16 in Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333]).\n", "_type": "ecc", "_page_id": "c_rank_metric", "_href": "c/rank_metric"}, "c_alamouti": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The only OSTBC with unity rate.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Alamouti code", "code_id": "alamouti", "realizations": "Wireless standards since: 3G, LTE, LTE-Advanced, and 5G.\nWiFi standards: 802.11n, 802.11ad, 802.11ay, etc.", "protection": "", "notes": "", "physical": "matrices", "short_name": "", "introduced": "[S. M. Alamouti, \u201cA simple transmit diversity technique for wireless communications\u201d, IEEE Journal on Selected Areas in Communications 16, 1451 (1998). DOI]", "description": "The simplest OSTBC, with two time slots, two channels, and with unitary coding matrix \\begin{align}\n  \\begin{pmatrix}c_{1} & c_{2}\\\\\n  -c_{2}^{\\star} & c_{1}^{\\star}\n  \\end{pmatrix}~,\n\\end{align} where \\(c_i\\) are complex numbers. ", "parents_code_id": "orth_spacetime_block", "parents_detail": "", "_type": "ecc", "_page_id": "c_alamouti", "_href": "c/alamouti"}, "c_matrices_into_matrices": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Matrix-based code", "code_id": "matrices_into_matrices", "realizations": "", "protection": "", "notes": "", "physical": "matrices", "short_name": "", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in an \\(m\\times n\\)-dimensional matrix of coordinates over a field (e.g., the Galois field \\(GF(q)\\) or the complex numbers \\(\\mathbb{C}\\)).", "parents_code_id": "ecc_finite", "parents_detail": "", "parent_of_code_id": "matrix_computation\nrank_metric\nregenerating\nspacetime\ntensor", "parent_of_detail": "\n\n\n\n", "_type": "ecc", "_page_id": "c_matrices_into_matrices", "_href": "c/matrices_into_matrices"}, "c_spacetime": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Spacetime code (STC)", "code_id": "spacetime", "realizations": "", "protection": "", "notes": "See the chapter [B. Clerckx and C. Oestges, \u201cFrom Multi-Dimensional Propagation to Multi-Link MIMO Channels\u201d, Mimo Wireless Networks 29 (2013). DOI] or the Ch. 28 of Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI] for an introduction to spacetime coding.", "physical": "matrices", "short_name": "STC", "introduced": "[V. Tarokh, N. Seshadri, and A. R. Calderbank, \u201cSpace-time codes for high data rate wireless communication: performance criterion and code construction\u201d, IEEE Transactions on Information Theory 44, 744 (1998). DOI]", "description": "Code designed for wireless transmission of information (via, e.g., radio waves) such that the sender can send multiple times from multiple locations. A spacetime code uses a modulation scheme to encode a message into signals that are sent at different times through different antennas, thereby utilizing both spatial and temporal (i.e., spacetime) degrees of freedom. ", "parents_code_id": "matrices_into_matrices", "parents_detail": "", "parent_of_code_id": "spacetime_block", "parent_of_detail": "Spacetime codes also use spatial and temporal diversity, but do not necessarily use blocks as codewords.", "cousin_of_code_id": "cws\nhomological_cv", "cousin_of_detail": "CWS codes have been considered in the context of spacetime replication of quantum data [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913][P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544], while STCs are designed to replicate classical data.\nHomological CV codes have been considered in the context of spacetime replication of quantum data [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913][P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544], while STCs are designed to replicate classical data.", "_type": "ecc", "_page_id": "c_spacetime", "_href": "c/spacetime"}, "c_spacetime_block": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Spacetime block code (STBC)", "code_id": "spacetime_block", "realizations": "High data-rate wireless communication, e.g., WiMAX (IEEE 802.16m) [R. Vidhya\u00a0Lavanya and M. Madheswaran, \u201cWimax (IEEE 802.16 m) system based on space time block code and discrete multiwavelet transform and implementation in FPGA\u201d, Telecommunication Systems 56, 327 (2013). DOI][S. P. Alex and L. M. A. Jalloul, \u201cPerformance Evaluation of MIMO in IEEE802.16e/WiMAX\u201d, IEEE Journal of Selected Topics in Signal Processing 2, 181 (2008). DOI][\u201cAdvances in smart antennas - MIMO-OFDM wireless systems: basics, perspectives, and challenges\u201d, IEEE Wireless Communications 13, 31 (2006). DOI].", "protection": "Provides protection against errors due to thermal noise and destructive interference arising from traversing an environment with scattering, reflection, and/or refraction.", "notes": "", "physical": "matrices", "short_name": "STBC", "introduced": "[S. M. Alamouti, \u201cA simple transmit diversity technique for wireless communications\u201d, IEEE Journal on Selected Areas in Communications 16, 1451 (1998). DOI]", "description": "In a space-time block code, \\(n\\) spatially separated channels transmit symbols in \\(T\\) time slots. These symbols can be arranged in a \\(T\\times n\\) matrix where the columns correspond to the channels, and the rows correspond to the time slots. The codewords \\(\\{X\\}\\) are \\(T\\times n\\) matrices such that the codeword difference matrices have rank \\(n\\), and \\(\\min_{X\\neq 0}\\det(XX^*)\\) is maximized.", "parents_code_id": "spacetime", "parents_detail": "Spacetime codes also use spatial and temporal diversity, but do not necessarily use blocks as codewords.", "parent_of_code_id": "orth_spacetime_block", "parent_of_detail": "The same construction without the constraint that the codeword matrices are orthogonal.", "_type": "ecc", "_page_id": "c_spacetime_block", "_href": "c/spacetime_block"}, "c_mbr": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Minimum-bandwidth regenerating (MBR) code", "code_id": "mbr", "realizations": "", "protection": "", "notes": "", "physical": "matrices", "short_name": "MBR", "introduced": "", "description": "Stub.", "parents_code_id": "regenerating", "parents_detail": "", "_type": "ecc", "_page_id": "c_mbr", "_href": "c/mbr"}, "c_orth_spacetime_block": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The greatest rate which can be achieved is \\(\\frac{n_0+1}{2n_0}\\), where either \\(n=2n_0\\) or \\(n=2n_0-1\\) [Xue-Bin Liang, \u201cOrthogonal designs with maximal rates\u201d, IEEE Transactions on Information Theory 49, 2468 (2003). DOI].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Maximum-likelihood decoding can be achieved with only linear processing [V. Tarokh, H. Jafarkhani, and A. R. Calderbank, \u201cSpace-time block coding for wireless communications: performance results\u201d, IEEE Journal on Selected Areas in Communications 17, 451 (1999). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Orthogonal Spacetime Block Code (OSTBC)", "code_id": "orth_spacetime_block", "realizations": "", "protection": "If the matrix \\(C-C'\\), where \\(C\\) and \\(C'\\) are distinct codewords, has minimum rank \\(b\\), the code has diversity order \\(bn_R\\) (see Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 28.2.1), where \\(n_R\\) is the number of receivers. The maximum possible diversity order is \\(nn_R\\).", "notes": "", "physical": "matrices", "short_name": "OSTBC", "introduced": "[S. M. Alamouti, \u201cA simple transmit diversity technique for wireless communications\u201d, IEEE Journal on Selected Areas in Communications 16, 1451 (1998). DOI]", "description": "The codewords are \\(T\\times n\\) matrices as defined for spacetime codes, with the additional condition that columns of the coding matrix are orthogonal. The parameter \\(n\\) is the number of channels, and \\(T\\) is the number of time slots.", "parents_code_id": "spacetime_block", "parents_detail": "The same construction without the constraint that the codeword matrices are orthogonal.", "parent_of_code_id": "alamouti", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_orth_spacetime_block", "_href": "c/orth_spacetime_block"}, "c_msr": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Minimum-storage regenerating (MSR) code", "code_id": "msr", "realizations": "", "protection": "", "notes": "", "physical": "matrices", "short_name": "MSR", "introduced": "", "description": "Stub.", "parents_code_id": "regenerating", "parents_detail": "", "_type": "ecc", "_page_id": "c_msr", "_href": "c/msr"}, "c_maximum_rank_distance": {"logical": "matrices", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Maximum-rank distance (MRD) code", "code_id": "maximum_rank_distance", "realizations": "Useful for error and erasure correction in network coding [Ralf Koetter and Frank Kschischang, \u201cCoding for Errors and Erasures in Random Network Coding\u201d. cs/0703061][D. Silva, F. R. Kschischang, and R. Koetter, \u201cA Rank-Metric Approach to Error Control in Random Network Coding\u201d, IEEE Transactions on Information Theory 54, 3951 (2008). DOI; 0711.0708].", "protection": "", "notes": "", "physical": "matrices", "short_name": "MRD", "introduced": "[P. Delsarte, \u201cBilinear forms over a finite field, with applications to coding theory\u201d, Journal of Combinatorial Theory, Series A 25, 226 (1978). DOI][E. M. Gabidulin, \"Theory of Codes with Maximum Rank Distance\", Problemy Peredachi Informacii, Volume 21, Issue 1, 3\u201316 (1985)][R. M. Roth, \u201cMaximum-rank array codes and their application to crisscross error correction\u201d, IEEE Transactions on Information Theory 37, 328 (1991). DOI]", "description": "Also called an optimal rank-distance code. An \\([n\\times m,k,d]_q\\) rank-metric code whose parameters are such that the Singleton-like bound \\begin{align}\nk \\leq \\max(n, m) (\\min(n, m) - d + 1)\n\\end{align} become an equality. ", "parents_code_id": "rank_metric", "parents_detail": "", "cousins_code_id": "mds\nreed_solomon", "cousins_detail": "MRD codes are matrix-code analogues of MDS codes.\nMRD rank-metric codes can be thought of as matrix analogues of MDS Reed-Solomon codes as both constructions utilize a Vandermonde matrix [R. Koetter and F. R. Kschischang, \u201cCoding for Errors and Erasures in Random Network Coding\u201d, IEEE Transactions on Information Theory 54, 3579 (2008). DOI].", "cousin_of_code_id": "gabidulin", "cousin_of_detail": "Gabidulin codes over \\(GF(q^N)\\) with maximum rank-distance, when expressed as matrices over \\(GF(q)\\), are MRD codes.", "_type": "ecc", "_page_id": "c_maximum_rank_distance", "_href": "c/maximum_rank_distance"}, "c_tensor": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Rate of the tensor-product code \\(C_A \\otimes C_B\\) is a product of the rates of the codes \\(C_A\\) and \\(C_B\\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "The simple decoding algorithm (first decode all columns with \\(C_1\\), then all rows with \\(C_2\\)) corrects up to \\((d_A d_B-1)/4 \\) errors.\nAlgorithms such as generalized minimum-distance decoding [G. Forney, \u201cGeneralized minimum distance decoding\u201d, IEEE Transactions on Information Theory 12, 125 (1966). DOI] or the min-sum algorithm can decode all errors of weight up to \\((d_A d_B-1)/2\\). Error location may be coupled with Viterbi decoding for every faulty sub-block [P. Chaichanavong and P. H. Siegel, \u201cTensor-product parity code for magnetic recording\u201d, IEEE Transactions on Magnetics 42, 350 (2006). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Tensor-product code", "code_id": "tensor", "realizations": "Construction can be used in magnetic recording by taking the tensor product of a Reed-Solomon code and a parity-check code [P. Chaichanavong and P. H. Siegel, \u201cTensor-product parity code for magnetic recording\u201d, IEEE Transactions on Magnetics 42, 350 (2006). DOI].", "protection": "For linear codes \\(C_A=[n_A,k_A,d_A]\\) and \\(C_B=[n_B,k_B,d_B]\\), the resulting tensor code is \\(C_A \\otimes C_B=[n_A n_B,k_A k_B,d_A d_B]\\). Tensor codes can be useful for protecting against burst errors [L. Bahl and R. Chien, \u201cSingle- and multiple-burst-correcting properties of a class of cyclic product codes\u201d, IEEE Transactions on Information Theory 17, 594 (1971). DOI][R. Chien and S. Ng, \u201cDual product codes for correction of multiple low-density burst errors\u201d, IEEE Transactions on Information Theory 19, 672 (1973). DOI].\n\nMany (but not all [P. Valiant, \u201cThe Tensor Product of Two Codes Is Not Necessarily Robustly Testable\u201d, Lecture Notes in Computer Science 472 (2005). DOI]) tensor codes are robustly testable [Eli Ben-Sasson and Madhu Sudan, \u201cRobust Locally Testable Codes and Products of Codes\u201d. cs/0408066][I. Dinur, M. Sudan, and A. Wigderson, \u201cRobust Local Testability of Tensor Products of LDPC Codes\u201d, Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques 304 (2006). DOI][E. Ben-Sasson and M. Viderman, \u201cTensor Products of Weakly Smooth Codes Are Robust\u201d, Lecture Notes in Computer Science 290 (2008). DOI], a property useful for constructing LTCs [I. Dinur, \u201cThe PCP theorem by gap amplification\u201d, Journal of the ACM 54, 12 (2007). DOI], including a family of \\(c^3\\)-LTCs [Irit Dinur et al., \u201cLocally Testable Codes with constant rate, distance, and locality\u201d. 2111.04808]. Duals of tensor codes formed by two random linear codes are also robustly testable, a property useful for constructing asymptotically good QLDPC codes [Irit Dinur et al., \u201cGood Quantum LDPC Codes with Linear Time Decoders\u201d. 2206.07750][Gleb Kalachev and Pavel Panteleev, \u201cTwo-sided Robustly Testable Codes\u201d. 2206.09973] and proving distance bounds [Anthony Leverrier and Gilles Z\u00e9mor, \u201cA parallel decoder for good quantum LDPC codes\u201d. 2208.05537]. ", "notes": "See Refs. ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 18; [Wolf, Jack Keil. \"An introduction to tensor product codes and applications to digital storage systems.\" 2006 IEEE Information Theory Workshop-ITW 2006 Chengdu. IEEE, 2006.]) for expositions.", "physical": "matrices", "short_name": "", "introduced": "[P. Elias, \u201cError-free Coding\u201d, Transactions of the IRE Professional Group on Information Theory 4, 29 (1954). DOI][H. Burton and E. Weldon, \u201cCyclic product codes\u201d, IEEE Transactions on Information Theory 11, 433 (1965). DOI][G. D. Forney, Jr (1966). Concatenated Codes. MIT Press, Cambridge, MA.][W. Gore, \u201cFurther results on product codes\u201d, IEEE Transactions on Information Theory 16, 446 (1970). DOI]", "description": "Also called tensor code, Kroneckerian code, or product code. A matrix-based code constructed out of two linear binary or \\(q\\)-ary codes \\(C_A,C_B\\) in an outer-product construction denoted as \\(C_A \\otimes C_B\\). Its dual is sometimes called the check-product code [Andrew Cross et al., \u201cQuantum Locally Testable Code with Exotic Parameters\u201d. 2209.11405; Lemma 3.3].\n\nCodewords are those matrices whose column vectors are in \\(C_A\\) and whose row vectors are in \\(C_B\\). In other words, the matrix-valued codewords \\(c\\) of a tensor code satisfy the parity check equation \\(H_A c H^{\\text{T}}_B = 0\\). ", "parents_code_id": "matrices_into_matrices\ngeneralized_concatenated", "parents_detail": "\n", "cousin_of_code_id": "classical_product\ndhlv\nlr-cayley-complex\nldpc\nquantum_tanner\ncheck_product\nreed_solomon", "cousin_of_detail": "Tensor-product codes are utilized in classical-product code constructions.\nTensor codes are used in constructing quantum DHLV codes.\nLeft-right Cayley complex codewords for a fixed graph vertex are codewords of a tensor code.\nTensor products of random LDPC codes are robustly testable [I. Dinur, M. Sudan, and A. Wigderson, \u201cRobust Local Testability of Tensor Products of LDPC Codes\u201d, Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques 304 (2006). DOI][E. Ben-Sasson and M. Viderman, \u201cTensor Products of Weakly Smooth Codes Are Robust\u201d, Lecture Notes in Computer Science 290 (2008). DOI].\nTensor codes are used in constructing quantum Tanner codes.\nQuantum check-product codes extend the concept of a check product, which yields the dual of a tensor code, to a product between a classical and a quantum code.\nTensor codes constructed from RS codes are robustly testable [A. Polishchuk and D. A. Spielman, \u201cNearly-linear size holographic proofs\u201d, Proceedings of the twenty-sixth annual ACM symposium on Theory of computing - STOC '94 (1994). DOI].", "_type": "ecc", "_page_id": "c_tensor", "_href": "c/tensor"}, "c_nonlinear_ag": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Certain nonlinear code sequences beat the Tsfasman-Vladut-Zink bound, outperforming linear AG codes.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Nonlinear AG code", "code_id": "nonlinear_ag", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[Noam D. Elkies, \u201cExcellent nonlinear codes from modular curves\u201d. math/0104115][Chaoping Xing, \u201cNonlinear codes from algebraic curves improving the Tsfasman-Vladut-Zink bound\u201d, IEEE Transactions on Information Theory 49, 1653 (2003). DOI][Noam D. Elkies, \u201cStill better nonlinear codes from modular curves\u201d. math/0308046][H. Niederreiter and F. \u00d6zbudak, \u201cConstructive Asymptotic Codes with an Improvement on the Tsfasman-Vl\u0103du\u0163-Zink and Xing Bounds\u201d, Coding, Cryptography and Combinatorics 259 (2004). DOI][H. Stichtenoth and C. Xing, \u201cExcellent Nonlinear Codes From Algebraic Function Fields\u201d, IEEE Transactions on Information Theory 51, 4044 (2005). DOI]", "description": "Nonlinear \\(q\\)-ary code constructed by evaluating functions on an algebraic curve. ", "parents_code_id": "ag", "parents_detail": "", "_type": "ecc", "_page_id": "c_nonlinear_ag", "_href": "c/nonlinear_ag"}, "c_q-ary_parity_check": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(q\\)-ary parity-check code", "code_id": "q-ary_parity_check", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "Also known as a sum-zero code. An \\([n,n-1,2]_q\\) linear \\(q\\)-ary code whose codewords consist of the message string appended with a parity-check digit such that the sum over all coordinates of each codeword is zero.", "parents_code_id": "reed_solomon\nq-ary_cyclic\nmds", "parents_detail": "RS codes for \\(k=n-1\\) are parity-check codes [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cExtended Reed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html].\nSince permutations preserve coordinate sums, the cyclic permutation of a parity-check codeword is another codeword.\n", "cousins_code_id": "ldgm", "cousins_detail": "Concatenated parity-check codes are LDGM [T. R. Oenning and Jaekyun Moon, \u201cA low-density generator matrix interpretation of parallel concatenated single bit parity codes\u201d, IEEE Transactions on Magnetics 37, 737 (2001). DOI].", "cousin_of_code_id": "parity_check", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_q-ary_parity_check", "_href": "c/q-ary_parity_check"}, "c_q-ary_digits_into_q-ary_digits": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "For small \\(n\\), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.\nGiven a received string \\(x\\) and an error bound \\(e\\), a list decoder returns a list of all codewords that are at most \\(e\\) from \\(x\\). The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-field \\(q\\)-ary code", "code_id": "q-ary_digits_into_q-ary_digits", "realizations": "", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "notes": "Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by Brouwer [Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.], are maintained by M. Grassl at this website.", "physical": "q-ary_digits", "short_name": "\\(q\\)-ary", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) \\(q\\)-ary coordinates over the field \\(GF(q)=\\mathbb{F}_q\\) and has distance \\(d\\). Usually denoted as \\((n,K,d)_q\\). The distance is the minimum number of coordinates where two strings in the code differ.", "parents_code_id": "ecc_finite", "parents_detail": "", "parent_of_code_id": "q-ary_additive\nag\nmatrix_product", "parent_of_detail": "\n\n", "cousin_of_code_id": "group_classical", "cousin_of_detail": "Group-based codes whose alphabet is based on the field \\(GF(q)\\), taken to be an abelian under addition, are \\(q\\)-ary codes.", "_type": "ecc", "_page_id": "c_q-ary_digits_into_q-ary_digits", "_href": "c/q-ary_digits_into_q-ary_digits"}, "c_q-ary_additive": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Additive \\(q\\)-ary code", "code_id": "q-ary_additive", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "A \\(q\\)-ary code whose codewords are closed under addition, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword.", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "dual_additive\nq-ary_linear", "parent_of_detail": "\nFor \\(q>2\\), additive codes need not be linear since linearity also requires closure under multiplication.", "cousin_of_code_id": "galois_stabilizer", "cousin_of_detail": "A Galois-qudit stabilizer code is the closest quantum analogue of an additive code over \\(GF(q)\\) because addition in the field corresponds to multiplication of stabilizers in the quantum case.", "_type": "ecc", "_page_id": "c_q-ary_additive", "_href": "c/q-ary_additive"}, "c_q-ary_hamming": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(q\\)-ary Hamming code", "code_id": "q-ary_hamming", "realizations": "", "protection": "Can detect 1-bit and 2-bit errors, and can correct 1-dit errors.", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[M. J. E. Golay, Notes on digital coding, Proc. IEEE, 37 (1949) 657.]", "description": "Member of an infinite family of perfect linear \\(q\\)-ary codes with parameters \\([(q^r-1)/(q-1),(q^r-1)/(q-1)-r, 3]_q\\) for \\(r \\geq 2\\).", "parents_code_id": "q-ary_linear\nperfect", "parents_detail": "\n", "cousins_code_id": "projective\nq-ary_cyclic\nbch\ngeneralized_reed_muller", "cousins_detail": "Columns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(q)^n\\).\nHamming codes are equivalent to cyclic codes when \\(q\\) and \\(r\\) are relatively prime ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 194).\nSome narrow sense BCH codes of length \\(n=(q^r-1)/(q-1)\\) such that \\(\\text{gcd}(r,q-1)=1\\) are \\(q\\)-ary Hamming codes ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thm. 5.1.4).\nHamming codes are dual to first-order GRM codes ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 45).", "cousin_of_code_id": "hamming\nsimplex", "cousin_of_detail": "\nHamming and simplex codes are dual to each other.", "_type": "ecc", "_page_id": "c_q-ary_hamming", "_href": "c/q-ary_hamming"}, "c_q-ary_linear": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Soft-decision maximum-likelihood trellis-based decoder [J. Wolf, \u201cEfficient maximum likelihood decoding of linear block codes using a trellis\u201d, IEEE Transactions on Information Theory 24, 76 (1978). DOI].\nRandom linear codes over large fields are list-recoverable and list-decodable up to near-optimal rates [Atri Rudra and Mary Wootters, \u201cAverage-radius list-recovery of random linear codes: it really ties the room together\u201d. 1704.02420].\nExtensions of algebraic-geometry decoders to linear codes [R. Kotter. A unified description of an error locating procedure for linear codes. In D. Yorgov, editor, Proc. 3rd International Workshop on Algebraic and Combinatorial Coding Theory, pages 113\u2013117, Voneshta Voda, Bulgaria, June 1992. Hermes.][R. Pellikaan, \u201cOn decoding by error location and dependent sets of error positions\u201d, Discrete Mathematics 106-107, 369 (1992). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Linear \\(q\\)-ary code", "code_id": "q-ary_linear", "realizations": "", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set such that the difference of any pair of distinct elements of the set is a codeword.", "notes": "Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\).\nUniversity of Salzburg's MinT application generates an optimal parameter table for a linear code \\([n,k,d]_q\\), contingent on an optional fluctuation of maximal Hamming code distance, rank, and length, along with other specifications.", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "An \\((n,K,d)_q\\) linear code is denoted as \\([n,k,d]_q\\), where \\(k=\\log_{q}K\\) need not be an integer. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any \\(q\\)-ary digits \\(\\alpha,\\beta\\).\n\nLinear codes can be defined in terms of a generator matrix \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a message \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its standard or systematic form \\(G = [I_k~~A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) \\(q\\)-ary matrix. ", "parents_code_id": "q-ary_additive\nlinear", "parents_detail": "For \\(q>2\\), additive codes need not be linear since linearity also requires closure under multiplication.\n", "parent_of_code_id": "q-ary_cyclic\nevaluation\nfolded_reed_solomon\ngabidulin\ngeneralized_reed_muller\ninterleaved_reed_solomon\nprojective\nwozencraft\nq-ary_hamming\nq-ary_ltc", "parent_of_detail": "\nThe degree of the divisor for evaluation AG codes is restricted to be less than \\(n\\). When there is no restriction, any \\(q\\)-ary linear code can be formulated as an evaluation AG code [R. Pellikan, B.-Z. Shen, and G. J. M. van Wee, \u201cWhich linear codes are algebraic-geometric?\u201d, IEEE Transactions on Information Theory 37, 583 (1991). DOI].\n\n\n\nIRS codes are linear over \\(GF(q)\\) but not necessarily over \\(GF(q^t)\\).\nColumns of the generator matrix of a projective linear \\([n,k]_q\\) code correspond to distinct nonzero points in projective space. In general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], Thm. 1.1).\n\n\n", "cousins_code_id": "q-ary_ltc", "cousins_detail": "Linear \\(q\\)-ary codes with distances \\(\\frac{1}{2}n-\\sqrt{t n}\\) for some \\(t\\) are called almost-orthogonal and are locally testable with query complexity of order \\(O(t)\\) [T. Kaufman and S. Litsyn, \u201cAlmost Orthogonal Linear Codes are Locally Testable\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI]. This was later improved to codes with distance \\(\\frac{1}{2}n-O(n^{1-\\gamma})\\) for any positive \\(\\gamma\\) [T. Kaufman and M. Sudan, \u201cSparse Random Linear Codes are Locally Decodable and Testable\u201d, 48th Annual IEEE Symposium on Foundations of Computer Science (FOCS'07) (2007). DOI], provided that the number of codewords is polynomial in \\(n\\).", "cousin_of_code_id": "eaqecc\neastab\nevaluation_varieties\ngalois_css\ngroup_linear\nqudit_css\ngalois_true_stabilizer", "cousin_of_detail": "Any linear \\(q\\)-ary code can be used to construct an EAQECC.\nAny linear quaternary (\\(q=4\\)) code can be used to construct an EA stabilizer code.\nEvaluation codes are defined using polynomial or rational functions evaluated on a subset of affine or projective space. Given access to more general structures (i.e., morphisms of algebras), any \\(q\\)-ary linear code can be formulated as an evaluation code ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Sec. 4.1; [M. Tsfasman, S. Vl\u01cedu\u0163, and D. Nogin. Algebraic geometric codes: basic notions. Vol. 139. American Mathematical Society, 2022.], Prop. 1.1.4).\nConstruction uses two related \\(q\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).\nLinear codes over \\(G=GF(q)\\) are \\(q\\)-ary linear codes since fields are abelian groups under addition.\nConstruction for prime \\(q=p\\) uses two related \\(p\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).\nA true Galois-qudit stabilizer code is the closest quantum analogue of a linear code over \\(GF(q)\\) because the \\(q\\)-ary vectors corresponding to the symplectic representation of the stabilizers form a linear subspace.", "_type": "ecc", "_page_id": "c_q-ary_linear", "_href": "c/q-ary_linear"}, "c_gabidulin": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Fast decoder based on a transform-domain approach [D. Silva and F. R. Kschischang, \u201cFast encoding and decoding of Gabidulin codes\u201d, 2009 IEEE International Symposium on Information Theory (2009). DOI; 0901.2483].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Gabidulin code", "code_id": "gabidulin", "realizations": "Public-key cryptosystems [T. P. Berger and P. Loidreau, \u201cHow to Mask the Structure of Codes for a Cryptographic Use\u201d, Designs, Codes and Cryptography 35, 63 (2005). DOI].\nDigital watermarking. The Gabidulin code provides efficient correction against luminance tampering and image-slicing distortion due to the consistency of the rank against alterations such as column swapping [P. Lefevre, P. Carre, and P. Gaborit, \u201cWatermarking and Rank Metric Codes\u201d, 2018 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP) (2018). DOI].", "protection": "Set of vectors \\(\\{x_1, x_2, \\ldots, x_M\\}\\) determines a rank code with distance \\(d=\\min d(x_i, x_j)\\). The code with distance \\(d\\) corrects all errors with rank of the error not greater than \\(\\lfloor (d-1)/2\\rfloor\\).", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[E. M. Gabidulin, Theory of Codes with Maximum Rank Distance, Problemy Peredachi Informacii, Volume 21, Issue 1, 3\u201316 (1985)][R. M. Roth, \u201cMaximum-rank array codes and their application to crisscross error correction\u201d, IEEE Transactions on Information Theory 37, 328 (1991). DOI]", "description": "Also called a vector rank-metric code. A linear code over \\(GF(q^N)\\) that corrects errors over rank metric instead of the traditional Hamming distance. Every element \\(GF(q^N)\\) can be written as an \\(N\\)-dimensional vector with coefficients in \\(GF(q)\\), and the rank of a set of elements is rank of the matrix formed by their coefficients.\n\nGiven \\(X^n=\\text{span}\\{x_i\\}\\), an \\(n\\)-dimensional vector space over \\(GF(q^N)\\) (where \\(q\\) is a power of a prime number), the rank metric \\(d(x, y)\\) is defined via the rank norm \\(r(x, q) = \\mathrm{rank}(A(x))\\), where \\begin{align}\nA(x) = \\begin{pmatrix} a_{11} & a_{12} & \\ldots & a_{1n} \\\\ a_{21} & a_{22} & \\ldots & a_{2n} \\\\  a_{N1} & a_{N2} & \\ldots & a_{Nn}~, \\end{pmatrix}\n\\end{align} and \\(x_i = a_{1i} u_1 + a_{2i} u_2 + \\ldots + a_{Ni}u_N \\) for some fixed basis \\(\\{u_i\\}_{i=1}^N\\). ", "parents_code_id": "q-ary_linear\nrank_metric", "parents_detail": "\nGabidulin codes over \\(GF(q^N)\\), when expressed as matrices over \\(GF(q)\\), are rank-metric codes (see Def. 14 in Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333]). The reverse is not always true since Gabidulin codes are not always \\(GF(q^N)\\)-linear (see Rm. 16 in Ref. [Alberto Ravagnani, \u201cRank-metric codes and their duality theory\u201d. 1410.1333]).", "cousins_code_id": "maximum_rank_distance", "cousins_detail": "Gabidulin codes over \\(GF(q^N)\\) with maximum rank-distance, when expressed as matrices over \\(GF(q)\\), are MRD codes.", "_type": "ecc", "_page_id": "c_gabidulin", "_href": "c/gabidulin"}, "c_ipp": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Identifiable parent property (IPP) code", "code_id": "ipp", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "IPP", "introduced": "[H. D. L. Hollmann et al., \u201cOn Codes with the Identifiable Parent Property\u201d, Journal of Combinatorial Theory, Series A 82, 121 (1998). DOI]", "description": "Stub.", "parents_code_id": "ecc_finite", "parents_detail": "", "_type": "ecc", "_page_id": "c_ipp", "_href": "c/ipp"}, "c_alternant": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Guruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Alternant code", "code_id": "alternant", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[H. J. Helgert, \u201cAlternant codes\u201d, Information and Control 26, 369 (1974). DOI]", "description": "Given a length-\\(n\\) GRS code \\(C\\) over \\(GF(q^m)\\), an alternant code is the \\(GF(q)\\)-subfield subcode of the dual of \\(C\\). ", "parents_code_id": "generalized_reed_solomon", "parents_detail": "Alternant codes are subfield subcodes of GRS codes.", "cousin_of_code_id": "css", "cousin_of_detail": "Alternant codes used in the CSS construction yield quantum codes that asymptotically achieve the quantum Gilbert-Varshamov bound [J. Fan et al., \u201cPartially Concatenated Calderbank-Shor-Steane Codes Achieving the Quantum Gilbert-Varshamov Bound Asymptotically\u201d, IEEE Transactions on Information Theory 1 (2022). DOI].", "_type": "ecc", "_page_id": "c_alternant", "_href": "c/alternant"}, "c_ag": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Several sequences of linear AG codes beat the Gilbert-Varshamov bound and/or are asymptotically good [A. Garcia and H. Stichtenoth, \u201cA tower of Artin-Schreier extensions of function fields attaining the Drinfeld-Vladut bound\u201d, Inventiones Mathematicae 121, 211 (1995). DOI][A. Garcia and H. Stichtenoth, \u201cOn the Asymptotic Behaviour of Some Towers of Function Fields over Finite Fields\u201d, Journal of Number Theory 61, 248 (1996). DOI] (see Ref. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.] for details). The rate of any linear AG code satisfies \\begin{align} \\frac{k}{n} \\geq 1 - \\frac{d}{n} - \\frac{1}{\\sqrt{q}-1}~, \\end{align} which comes from the Drinfeld-Vladut bound [S. G. Vla\u0306dut\u0327, V. G. Drinfeld, \u201cNumber of points of an algebraic curve\u201d, Funktsional. Anal. i Prilozhen., 17:1 (1983), 68\u201369; Funct. Anal. Appl., 17:1 (1983), 53\u201354]. Nonlinear AG codes can outperform this bound.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Algebraic-geometry (AG) code", "code_id": "ag", "realizations": "", "protection": "", "notes": "See book by Goppa [V. D. Goppa, Geometry and Codes (Springer Netherlands, 1988). DOI].", "physical": "q-ary_digits", "short_name": "AG", "introduced": "[V. D. Goppa, \u201cCodes Associated with Divisors\u201d, Probl. Peredachi Inf., 13:1 (1977), 33\u201339; Problems Inform. Transmission, 13:1 (1977), 22\u201327][V. D. Goppa, \u201cCodes on algebraic curves\u201d, Dokl. Akad. Nauk SSSR, 259:6 (1981), 1289\u20131290][V. D. Goppa, \u201cAlgebraico-geometric codes\u201d, Izv. Akad. Nauk SSSR Ser. Mat., 46:4 (1982), 762\u2013781; Izv. Math., 21:1 (1983), 75\u201391]", "description": "Binary or \\(q\\)-ary code constructed from an algebraic curve of some genus over a finite field via the evaluation construction, the residue construction, or more general constructions that yield nonlinear codes. Linear AG codes from the first two constructions are also called geometric Goppa codes.\n\nIn alternative conventions (not used here), AG codes are restricted to be linear and/or include evaluation codes defined using algebraic varieties more general than curves. ", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "evaluation\nnonlinear_ag\nresidue", "parent_of_detail": "\n\n", "cousins_code_id": "mds", "cousins_detail": "Near MDS \\([n,k,d]_{GF(p^m)}\\) AG codes exist when \\(n,p,m\\) satisfy certain relations according to the Tsfasman-Vladut bound [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI].", "cousin_of_code_id": "evaluation_varieties", "cousin_of_detail": "Evaluation codes on varieties can also be considered AG codes since they use algebraic geometry in quantifying code bounds. However, early AG constructions all used only one-dimensional varieties, i.e., algebraic curves.", "_type": "ecc", "_page_id": "c_ag", "_href": "c/ag"}, "c_wozencraft": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Wozencraft ensemble code", "code_id": "wozencraft", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. L. Massey, Threshold Decoding. Cambridge, MA: M.I.T. Press, 1963.]", "description": "Stub.", "parents_code_id": "q-ary_linear", "parents_detail": "", "cousin_of_code_id": "justesen", "cousin_of_detail": "Wozencraft ensemble forms the inner codes of Justesen codes.", "_type": "ecc", "_page_id": "c_wozencraft", "_href": "c/wozencraft"}, "c_matrix_product": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Decoder up to half of the minimum distance for NSC codes [F. Hernando, K. Lally, and D. Ruano, \u201cConstruction and decoding of matrix-product codes from nested codes\u201d, Applicable Algebra in Engineering, Communication and Computing 20, 497 (2009). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Matrix-product code", "code_id": "matrix_product", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[T. Blackmore and G. H. Norton, \u201cMatrix-Product Codes over ? q\u201d, Applicable Algebra in Engineering, Communication and Computing 12, 477 (2001). DOI]", "description": "Code constructed using a concatenation procedure that yields a code consisting of all products of codewords in \\(M\\) length-\\(n\\) \\(q\\)-ary codes and an \\(M\\times N\\) \\(q\\)-ary matrix with \\(N\\geq M\\). A prominent subclass is the case with \\(A\\) is non-singular by columns (NSC). ", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "generalized_reed_muller", "parent_of_detail": "Applying a special case of the matrix-product procedure yields GRM codes [T. Blackmore and G. H. Norton, \u201cMatrix-Product Codes over ? q\u201d, Applicable Algebra in Engineering, Communication and Computing 12, 477 (2001). DOI].", "cousin_of_code_id": "galois_true_stabilizer", "cousin_of_detail": "Hermitian self-orthogonal matrix-product codes over \\(GF(q^2)\\) can be used to construct true stabilizer codes [M. Cao and J. Cui, \u201cConstruction of new quantum codes via Hermitian dual-containing matrix-product codes\u201d, Quantum Information Processing 19, (2020). DOI][Xiusheng Liu, Hualu Liu, and Long Yu, \u201cOn New Quantum Codes From Matrix Product Codes\u201d. 1604.05823].", "_type": "ecc", "_page_id": "c_matrix_product", "_href": "c/matrix_product"}, "c_dual_additive": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Dual additive code", "code_id": "dual_additive", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "For any \\(q\\)-ary additive code \\(C\\), the dual additive (or orthogonal additive) code is \\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{n} ~|~ x \\star y=0 \\forall x\\in C\\},\n\\end{align} where the trace inner product is \\(x\\star y = \\sum_{i=1}^n \\text{tr}(x_i y_i)\\) for coordinates \\(x_i,y_i\\), and the trace maps elements of the field \\(GF(q)\\) with \\(q=p^m\\) to elements of \\(GF(p)\\) as \\begin{align}\n  \\text{tr}(\\gamma)=\\sum_{k=0}^{m-1}\\gamma^{p^{k}}~.\n\\end{align}\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called self-orthogonal additive or weakly self-dual additive. A code that contains its dual, \\(C^\\perp \\subseteq C\\), is called dual-containing additive. A code that is equal to its dual, \\(C^\\perp = C\\), is called self-dual additive. A code is dual-containing additive iff its dual is self-orthogonal additive.\n\nFor cases when \\(q\\) is a square, an alternative definition of dual substitutes the trace inner product for the trace-Hermitian inner product, \\(x\\star y \\to \\sum_{i=1}^n \\text{tr}(x_i y^{\\sqrt{q}}_i)\\). Another extension, relevant to certain stabilizer codes and reducing to the trace-Hermitian case for \\(q=4\\), is the trace-alternating inner product, \\begin{align}\n  x\\star y \\to \\sum_{i=1}^{n}\\text{tr}\\left(\\frac{x_{i}y_{i}^{\\sqrt{q}}-x_{i}^{\\sqrt{q}}y_{i}}{\\alpha-\\alpha^{q}}\\right)~,\n\\end{align} where \\(\\{1,\\alpha\\}\\) is a basis of \\(GF(q)\\) over \\(GF(\\sqrt{q})\\). Self-dual additive codes with respect to the trace-Hermitian (trace-alternating) inner product are called trace Hermitian (trace-alternating) self-dual additive; similar definitions hold for self-orthogonal additive and dual-containing additive.", "parents_code_id": "q-ary_additive", "parents_detail": "", "cousins_code_id": "dual", "cousins_detail": "The difference between the definitions of dual linear and dual additive codes is in the trace used in the inner product. Self-dual linear codes are also self-dual additive codes.", "cousin_of_code_id": "galois_stabilizer\noctacode\nstabilizer_over_gf4\nstabilizer_over_gfqsq", "cousin_of_detail": "An additive code of length \\(2n\\) over \\(GF(q)\\) that is self-orthogonal with respect to the trace-symplectic inner product corresponds to symplectic representations of an \\(n\\) Galois-qudit stabilizer group [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]. Moreover, any additive code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code.\nThe octacode is self-dual with respect to the Euclidean inner product.\nThe stabilizer commutation condition for stabilizer codes over \\(GF(4)\\) can equivalently be stated in the representation of stabilizers as quaternary vectors. A pair of \\(n\\)-qubit stabilizers commute iff the trace-Hermitian inner product of their corresponding vectors is zero. Stabilizer codes over \\(GF(4)\\) can thus be constructed from trace-Hermitian self-orthogonal additive quaternary codes.\nThe stabilizer commutation condition for stabilizer codes over \\(GF(q^2)\\) can equivalently be stated in the representation of stabilizers as vectors over \\(GF(q^2)\\). A pair of \\(n\\) Galois-qudit stabilizers commute iff the trace-alternating inner product of their their corresponding vectors is zero. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\).", "_type": "ecc", "_page_id": "c_dual_additive", "_href": "c/dual_additive"}, "c_ternary_golay": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Decoder for the extended ternary Golay code using the tetracode [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Ternary Golay Code", "code_id": "ternary_golay", "realizations": "Code used in football pools with at least one good bet [H. H\u00e4m\u00e4l\u00e4inen and S. Rankinen, \u201cUpper bounds for football pool problems and mixed covering codes\u201d, Journal of Combinatorial Theory, Series A 56, 84 (1991). DOI][A. Barg, \u201cAt the Dawn of the Theory of Codes\u201d, The Mathematical Intelligencer 15, 20 (1993). DOI]. In fact, the code was originally constructed by Juhani Virtakallio and published in the Finnish football pool magazine Veikkaaja [A. Barg, \u201cAt the Dawn of the Theory of Codes\u201d, The Mathematical Intelligencer 15, 20 (1993). DOI][T. M. Thompson, From Error-Correcting Codes Through Sphere Packings To Simple Groups, Mathematical Association of America, 1983.].", "protection": "", "notes": "The automorphism group of the ternary Golay code is the Mathieu group \\(\\mathcal{M}_{11}\\), and the automorphism group of the extended ternary Golay code is the Mathieu group \\(\\mathcal{M}_{12}\\), two of the sporadic simple groups.", "physical": "q-ary_digits", "short_name": "", "introduced": "[M. J. E. Golay, Notes on digital coding, Proc. IEEE, 37 (1949) 657.]", "description": "A \\([11,6,5]_{GF(3)}\\) perfect ternary linear code with connections to various areas of mathematics, e.g., lattices [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI] and sporadic simple groups [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.]. Adding a parity bit to the code results in the \\([12, 6, 6]\\) extended ternary Golay code. Up to equivalence, both codes are unique for their respective parameters.\n\nA generator matrix for the ternary Golay code is \\begin{align}\n\\left(\\begin{array}{cccccccccccc}\n  1 & 0 & 0 & 0 & 0 & | & 1 & 1 & 1 & 2 & 2 & 0 \\\\\n  0 & 1 & 0 & 0 & 0 & | & 1 & 1 & 2 & 1 & 0 & 2 \\\\\n  0 & 0 & 1 & 0 & 0 & | & 1 & 2 & 1 & 0 & 1 & 2 \\\\\n  0 & 0 & 0 & 1 & 0 & | & 1 & 2 & 0 & 1 & 2 & 1 \\\\\n  0 & 0 & 0 & 0 & 1 & | & 1 & 0 & 2 & 2 & 1 & 1 \\\\\n\\end{array}\\right)~.\n\\end{align} ", "parents_code_id": "perfect\nq-ary_quad_residue", "parents_detail": "The ternary Golay code is perfect.\nThe ternary Golay code is a quadratic residue code over \\(GF(3)\\) with residue set \\(Q = \\{1, 3, 4, 5, 9\\} \\) and generator polynomial \\(x^5 + x^4 - x^3 + x^2 - 1\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 16).", "cousins_code_id": "golay\ndual\nprojective\ndivisible", "cousins_detail": "\nThe extended ternary Golay code is self-dual.\nThe extended ternary Golay code admits a projective geometric construction ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 296).\nExtended ternary Golay code is 3-divisible ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 296).", "cousin_of_code_id": "tetracode", "cousin_of_detail": "Extended ternary Golay codewords can be obtained from tetracodewords [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. The tetracode can be used to decode the extended ternary Golay code [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI].", "_type": "ecc", "_page_id": "c_ternary_golay", "_href": "c/ternary_golay"}, "c_hexacode": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Bounded-distance decoder requiring at most 34 real operations [A. Vardy, \u201cEven more efficient bounded-distance decoding of the hexacode, the Golay code, and the Leech lattice\u201d, IEEE Transactions on Information Theory 41, 1495 (1995). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hexacode", "code_id": "hexacode", "realizations": "", "protection": "", "notes": "See corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cHexacode.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CHexa.html].", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]", "description": "The \\([6,3,4]_{GF(4)}\\) self-dual MDS code with generator matrix \\begin{align}\n  \\begin{pmatrix}\n  1 & 0 & 0 & 1 & 1 & \\omega\\\\\n  0 & 1 & 0 & 1 & \\omega & 1\\\\\n  0 & 0 & 1 & \\omega & 1 & 1\n  \\end{pmatrix}~,\n\\end{align} where \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\). Has connections to projective geometry, lattices [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI] and conformal field theory [J. A. Harvey and G. W. Moore, \u201cMoonshine, superconformal symmetry, and quantum error correction\u201d, Journal of High Energy Physics 2020, (2020). DOI; 2003.13700]. ", "parents_code_id": "evaluation\nprojective\nq-ary_quad_residue\ndenniston\nmds", "parents_detail": "The hexacode is an evaluation AG code over \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\) with \\(\\cal X\\) defined by \\(x^2 y + \\omega y^2 z + \\bar{\\omega} z^2 x = 0\\) ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.77).\nColumns of hexacode's generator matrix represent the six homogeneous coordinates of a hyperoval in the projective plane \\(PG(2,4)\\) ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 289).\nThe hexacode is the smallest example of an extended quadratic residue code of Type \\(4^H\\) ([Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI], Sec. 2.4.6).\nA version of the hexacode is recovered for Dennison code parameters \\(i=1\\) and \\(a=2\\) [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI].\n", "cousins_code_id": "stab_5_1_3\ndual\ngolay", "cousins_detail": "Applying the stabilizer-over-\\(GF(4)\\) construction to the hexacode yields a \\([[6,0,4]]\\) quantum code [A. J. Scott, \u201cMultipartite entanglement, quantum-error-correcting codes, and entangling power of quantum evolutions\u201d, Physical Review A 69, (2004). DOI; quant-ph/0310137] corresponding to the six-qubit perfect state. The five-qubit code can be obtained from this code by tracing out a qubit [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nThe hexacode is Euclidean and Hermitian self-dual.\nExtended Golay codewords can be obtained from hexacodewords [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. The hexacode can be used to decode the extended Golay code [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI]. There is also a connection between automoprhisms of the even Golay code and the holomorph of the hexacode [J. A. Harvey and G. W. Moore, \u201cMoonshine, superconformal symmetry, and quantum error correction\u201d, Journal of High Energy Physics 2020, (2020). DOI; 2003.13700].", "_type": "ecc", "_page_id": "c_hexacode", "_href": "c/hexacode"}, "c_tetracode": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Tetracode", "code_id": "tetracode", "realizations": "", "protection": "", "notes": "See corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cTetracode.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CTetra.html].", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]", "description": "The \\([4,2,3]_{GF(3)}\\) self-dual MDS code with generator matrix \\begin{align}\n  \\begin{pmatrix}1 & 0 & 1 & 1\\\\\n  0 & 1 & 1 & 2\n  \\end{pmatrix}~,\n\\end{align} where \\(GF(3) = \\{0,1,2\\}\\). Has connections to lattices [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. ", "parents_code_id": "simplex\nhamming\nmds", "parents_detail": "The tetracode is equivalent to \\(S(3,2)\\).\nThe tetracode is equivalent to the \\(r=2\\) Hamming code.\n", "cousins_code_id": "dual\nternary_golay", "cousins_detail": "The tetracode is self-dual.\nExtended ternary Golay codewords can be obtained from tetracodewords [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. The tetracode can be used to decode the extended ternary Golay code [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI].", "_type": "ecc", "_page_id": "c_tetracode", "_href": "c/tetracode"}, "c_dodecacode": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Dodecacode", "code_id": "dodecacode", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006][Gerald Hoehn, \u201cSelf-dual Codes over the Kleinian Four Group\u201d. math/0005266]", "description": "Self-dual \\([12,6,6]_{GF(4)}\\) code whose codewords are cyclic permutations of \\((\\omega 10100100101)\\), where \\(GF(4)=\\{0,1,\\omega,\\bar{\\omega}\\}\\). ", "parents_code_id": "q-ary_cyclic", "parents_detail": "", "cousins_code_id": "dual", "cousins_detail": "The dodecacode is self-dual.", "_type": "ecc", "_page_id": "c_dodecacode", "_href": "c/dodecacode"}, "c_incidence_matrix": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Incidence-matrix projective code", "code_id": "incidence_matrix", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[E. Prange, The use of coset equivalene in the analysis and decoding of group codes. AIR FORCE CAMBRIDGE RESEARCH LABS HANSCOM AFB MA, 1959.][L. Rudolph, \u201cA class of majority logic decodable codes (Corresp.)\u201d, IEEE Transactions on Information Theory 13, 305 (1967). DOI][E. Prange, \"Some cyclic error-correcting codes with simple decoding algorithms.\" AFCRC-TN-58-156 (1985).]", "description": "Code whose generator matrix is the incidence matrix of points and hyperplanes of a projective spaces. Has been generalized to incidence matrices of other structures ([B. Bagchi and S. P. Inamdar, \u201cProjective Geometric Codes\u201d, Journal of Combinatorial Theory, Series A 99, 128 (2002). DOI][M. Lavrauw, L. Storme, and G. Van de Voorde (2010). Linear codes from projective spaces. In A. Bruen & D. Wehlau (Eds.), Contemporary Mathematics (Vol. 523, pp. 185\u2013202). Providence, RI, USA: American Mathematical Society (AMS).]; [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 14.4). ", "parents_code_id": "projective", "parents_detail": "", "_type": "ecc", "_page_id": "c_incidence_matrix", "_href": "c/incidence_matrix"}, "c_griesmer": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Griesmer code", "code_id": "griesmer", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. H. Griesmer, \u201cA Bound for Error-Correcting Codes\u201d, IBM Journal of Research and Development 4, 532 (1960). DOI][G. Solomon and J. J. Stiffler, \u201cAlgebraically punctured cyclic codes\u201d, Information and Control 8, 170 (1965). DOI][R. R. Varshamov, On the general theory of linear coding, Ph.D. Thesis, Moscow State University, 1959.]", "description": "A \\([n,k,d]\\) binary or \\(q\\)-ary linear code is a Griesmer code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Griesmer bound \\begin{align}\n  n\\geq\\sum_{j=0}^{k-1}\\left\\lceil \\frac{d}{q^{j}}\\right\\rceil ~,\n\\end{align} where \\(\\left\\lceil x\\right\\rceil \\) is the ceiling function, becomes an equality.\n\nAn \\([n,2,d]_q\\) code exists if and only if it is not excluded by the Griesmer bound. Every Griesmer code is generated by its minimum-weight codewords [S. Dodunekov, Optimal linear codes, Ph.D. Thesis, Sofia, 1985.]. ", "parents_code_id": "mds", "parents_detail": "Singleton bound implies the Griesmer bound.", "parent_of_code_id": "denniston\nsimplex", "parent_of_detail": "\nSimplex codes saturate the Griesmer bound ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], Exer. 5.1.11).", "cousins_code_id": "divisible", "cousins_detail": "Griesmer codes over prime fields are divisible [H. N. Ward, \u201cDivisibility of Codes Meeting the Griesmer Bound\u201d, Journal of Combinatorial Theory, Series A 83, 79 (1998). DOI].", "cousin_of_code_id": "anticode\nbch\ngrassmannian\nprojective_reed_muller\nprojective", "cousin_of_detail": "Several anticode (e.g., [B. I. Belov, V. N. Logachev, V. P. Sandimirov, \u201cConstruction of a Class of Linear Binary Codes Achieving the Varshamov-Griesmer Bound\u201d, Probl. Peredachi Inf., 10:3 (1974), 36\u201344; Problems Inform. Transmission, 10:3 (1974), 211\u2013217][R. Hill, \"Optimal Linear Codes in: C. Mitchell (Ed.) Crytography and Coding.\" (1992): 75-104.]) and related [B. I. Belov, \"A conjecture on the Griesmer bound.\" Optimization Methods and Their Applications,(Russian), Sibirsk. Energet. Inst. Sibirsk. Otdel. Akad. Nauk SSSR, Irkutsk 182 (1974): 100-106.] constructions saturate the Griesmer bound; see Refs. [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI][F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for more details.\nThe \\([15,5,7]\\) BCH code extended with a parity check saturates the Griesmer bound ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 157).\nThe binary Grassmannian \\([35,6,16]\\) code, whose points lie on the Grassmannian \\({\\mathbb{G}(2,4)}\\), attains the Griesmer bound [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].\nPRM codes for \\(r=1\\) attain the Griesmer bound for all \\(m\\) [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].\nAcrs corresponding to Griesmer codes are called Griesmer arcs ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], pg. 248). There is a one-to-one correspondence between Griesmer codes and minihypers [N. Hamada and M. Deza, \u201cA characterization of \u03bd\u03bc + 1 + \u03b5, \u03bd\u03bc; t, q-min.hypers and its applications to error-correcting codes and factorial designs\u201d, Journal of Statistical Planning and Inference 22, 323 (1989). DOI][N. Hamada, Characterization of minihypers in a finite projective geometry and its applications to error-correcting codes, Bull. Osaka Women's Univ. 24 (1987), 1-24.]; see Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 14.2.4 and Ref. [J. W. P. Hirschfeld and L. Storme, \u201cThe Packing Problem in Statistics, Coding Theory and Finite Projective Spaces: Update 2001\u201d, Developments in Mathematics 201 (2001). DOI] for more details.", "_type": "ecc", "_page_id": "c_griesmer", "_href": "c/griesmer"}, "c_simplex": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Due to the small size, it can be decoded according to maximum likelihood.\nSome faster decoders for the \\(q=2\\) case: [R. R. Green, \"A serial orthogonal decoder,\" JPL Space Programs Summary, vol. 37\u201339-IV, pp. 247\u2013253, 1966.][A. Ashikhmin and S. Litsyn, \u201cSimple MAP decoding of first order Reed-Muller and Hamming codes\u201d, Proceedings 2003 IEEE Information Theory Workshop (Cat. No.03EX674). DOI]\nA quantum decoder for the \\(q=2\\) case: [A. Barg and S. Zhou, \u201cA quantum decoding algorithm for the simplex code\u201d, in Proceedings of the 36th Annual Allerton Conference on Communication, Control and Computing, Monticello, IL, 23\u201325 September 1998 (UIUC 1998) 359\u2013365].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Simplex code", "code_id": "simplex", "realizations": "", "protection": "", "notes": "See corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cSimplex Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html].", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "Also known as a maximum length feedback shift register code. An \\([n,k,q^{k-1}]_q\\) projective code with \\(n=\\frac{q^k-1}{q-1}\\), denoted as \\(S(q,k)\\). The columns of the generator matrix are in one-to-one correspondence with the elements of the projective space \\(PG(k-1,q)\\), with each column being a chosen representative of the corresponding element. Its dual code is the \\([n,n-k,3]_q\\) \\(q\\)-ary Hamming code. The name of the code comes from the property that, for \\(q=2\\), the codewords form a \\((2^k-1)\\)-simplex of constant edge length if the codewords are interpreted as points in \\(\\mathbb{R}^n\\). ", "parents_code_id": "projective\ngriesmer\nconstant_weight", "parents_detail": "Columns of the simplex code's generator matrix are in one-to-one correspondence with elements of a projective space.\nSimplex codes saturate the Griesmer bound ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], Exer. 5.1.11).\nAll non-zero simplex codewords have a constant weight of \\(q^{k-1}\\).", "parent_of_code_id": "tetracode", "parent_of_detail": "The tetracode is equivalent to \\(S(3,2)\\).", "cousins_code_id": "extended_reed_solomon\nrepetition\nq-ary_hamming\nreed_muller", "cousins_detail": "\\(S(2,k)\\) is an extended RS code [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cSimplex Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html].\n\\(S(2,1)\\) reduces to the repetition code.\nHamming and simplex codes are dual to each other.\nBinary simplex codes can be constructed from the generator matrix of RM\\((1,k)\\) by removing first the all-ones row, and then the all-zero column. Punctured RM codes and simplex codes are interconvertible via expurgation and augmentation ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 31).", "_type": "ecc", "_page_id": "c_simplex", "_href": "c/simplex"}, "c_denniston": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Denniston code", "code_id": "denniston", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI]", "description": "Projective code that is part of a family of \\([2^{a+i}+2^i-2^a,3,2^{a+i}-2^a]_{GF(2^a)}\\) codes for \\(i < a\\) constructed using Denniston arcs. ", "parents_code_id": "projective\ngriesmer", "parents_detail": "Columns of Denniston code generator matrices represent points of a Denniston arc.\n", "parent_of_code_id": "hexacode", "parent_of_detail": "A version of the hexacode is recovered for Dennison code parameters \\(i=1\\) and \\(a=2\\) [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI].", "_type": "ecc", "_page_id": "c_denniston", "_href": "c/denniston"}, "c_projective": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Projective geometry code", "code_id": "projective", "realizations": "", "protection": "Distance \\(d\\) is \\(n\\) minus the maximum number of points that are contained in a hyperplane. For \\(n \\geq 3\\), a code is projective if and only if the distance of its dual code is at least three.", "notes": "See corresponding definition in MinT.", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "Linear \\(q\\)-ary \\([n,k,d]\\) code such that columns of its generator matrix \\(G\\) does not contain any repeated columns or the zero column. That way, each column corresponds to a distinct point in the projective space \\(PG(k-1,q)\\) arising from a \\(k\\)-dimensional vector space over \\(GF(q)\\). If the columns are linearly independent, then the codewords are collectively called an information set. Columns of a code's parity-check matrix can similarly correspond to points in projective space. This formulation yields connections to projective geometry, which can be applied to determine code properties.\n\nRecall that a linear code encodes a message \\(h\\) into a codeword \\(c = hG\\). The \\(i\\)th coordinate of a codeword is given the dot product \\(h \\cdot G_{i}\\) with \\(G_{i}\\) being the \\(i\\)th column of the generator matrix. The zero-coordinate condition \\(h \\cdot x = 0\\) defines a hyperplane of points \\(x\\) with normal vector \\(h\\). Therefore, the Hamming weight of the corresponding codeword is the number of points \\(G_i\\) not contained in said hyperplane.\n\nIn general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], Thm. 1.1; [I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI]). Multisets can also be used to construct parity-check matrices of linear codes.", "parents_code_id": "q-ary_linear", "parents_detail": "Columns of the generator matrix of a projective linear \\([n,k]_q\\) code correspond to distinct nonzero points in projective space. In general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], Thm. 1.1).", "parent_of_code_id": "denniston\nhexacode\nincidence_matrix\nsimplex", "parent_of_detail": "Columns of Denniston code generator matrices represent points of a Denniston arc.\nColumns of hexacode's generator matrix represent the six homogeneous coordinates of a hyperoval in the projective plane \\(PG(2,4)\\) ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 289).\n\nColumns of the simplex code's generator matrix are in one-to-one correspondence with elements of a projective space.", "cousins_code_id": "evaluation_varieties\nextended_reed_solomon\ngriesmer\nanticode", "cousins_detail": "Codewords of an evaluation code of multivariate polynomials up to degree one evaluated at points in projective space yields a projective code.\nColumns of parity-check matrices of doubly extended narrow-sense RS codes consist of points of a normal rational curve [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI; Def. 14.2.6]. Corresponding columns for triply extended RS codes consist of points of a hyperoval [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI; Prop. 17.5].\nAcrs corresponding to Griesmer codes are called Griesmer arcs ([I. N. Landjev, \u201cThe Geometric Approach to Linear Codes\u201d, Developments in Mathematics 247 (2001). DOI], pg. 248). There is a one-to-one correspondence between Griesmer codes and minihypers [N. Hamada and M. Deza, \u201cA characterization of \u03bd\u03bc + 1 + \u03b5, \u03bd\u03bc; t, q-min.hypers and its applications to error-correcting codes and factorial designs\u201d, Journal of Statistical Planning and Inference 22, 323 (1989). DOI][N. Hamada, Characterization of minihypers in a finite projective geometry and its applications to error-correcting codes, Bull. Osaka Women's Univ. 24 (1987), 1-24.]; see Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 14.2.4 and Ref. [J. W. P. Hirschfeld and L. Storme, \u201cThe Packing Problem in Statistics, Coding Theory and Finite Projective Spaces: Update 2001\u201d, Developments in Mathematics 201 (2001). DOI] for more details.\nThere is a relation between anticodes and minihypers ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 295).", "cousin_of_code_id": "hamming\nmds\nprojective_reed_muller\nternary_golay\nq-ary_hamming", "cousin_of_detail": "Columns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(2)^n\\).\nA linear code is MDS (almost MDS) if and only if columns of its parity-check matrix form an \\(n\\)-arc (\\(n\\)-track) in projective space [S. M. Dodunekov and I. N. Landgev, \u201cOn near-MDS codes\u201d, Proceedings of 1994 IEEE International Symposium on Information Theory. DOI][J. W. P. Hirschfeld and L. Storme, \u201cThe Packing Problem in Statistics, Coding Theory and Finite Projective Spaces: Update 2001\u201d, Developments in Mathematics 201 (2001). DOI]. The dual of a MDS code is an MDS code, so MDS codes are projective.\nNonzero codewords of minimum weight of a \\(r\\)th-order \\(q\\)-ary projective RM code correspond to algebraic hypersurfaces of degree \\(r\\) having the largest number of points in the projective space \\(PG(n,q)\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 14.3.3).\nThe extended ternary Golay code admits a projective geometric construction ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 296).\nColumns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(q)^n\\).", "_type": "ecc", "_page_id": "c_projective", "_href": "c/projective"}, "c_generalized_reed_muller": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Generalized RM (GRM) code", "code_id": "generalized_reed_muller", "realizations": "", "protection": "Code parameters for specific \\(m,r\\) are given in Ref. [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 46.", "notes": "See books [E. F. Assmus and J. D. Key, Designs and Their Codes (Cambridge University Press, 1992). DOI][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI][E. F. Assmus, Jr. and J. D. Key, \u201cPolynomial codes and finite geometries,\u201d in Handbook of Coding Theory, eds. V. S. Pless and W. C. Huffman. Amsterdam: Elsevier, 1998, pp. 1269\u20131343.] for details of GRM codes.", "physical": "q-ary_digits", "short_name": "GRM", "introduced": "[T. Kasami, Shu Lin, and W. Peterson, \u201cNew generalizations of the Reed-Muller codes--I: Primitive codes\u201d, IEEE Transactions on Information Theory 14, 189 (1968). DOI][E. Weldon, \u201cNew generalizations of the Reed-Muller codes--II: Nonprimitive codes\u201d, IEEE Transactions on Information Theory 14, 199 (1968). DOI][P. Delsarte, J. M. Goethals, and F. J. Mac Williams, \u201cOn generalized ReedMuller codes and their relatives\u201d, Information and Control 16, 403 (1970). DOI]", "description": "Reed-Muller code GRM\\(_q(r,m)\\) of length \\(n=q^m\\) over \\(GF(q)\\) with \\(0\\leq r\\leq m(q-1)\\). Its codewords are evaluations of the set of all degree-\\(\\leq r\\) polynomials in \\(m\\) variables at a set of distinct points \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) in \\(GF(q)\\).\n\nSince \\(\\beta^q=\\beta\\) for any \\(\\beta\\in GF(q)\\), the above definition is not injective. Replacing each factor in each polynomial as \\(x^q\\to x\\), the above set reduces to the set of all degree-\\(\\leq r\\) polynomials in \\(m\\) variables such that no term has an exponent \\(q\\) or higher on any variable. ", "parents_code_id": "q-ary_linear\nevaluation_polynomial\nmatrix_product", "parents_detail": "\nGRM (PRM) codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine (projective) space over \\(GF(q)\\) ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pgs. 44-46; [S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nApplying a special case of the matrix-product procedure yields GRM codes [T. Blackmore and G. H. Norton, \u201cMatrix-Product Codes over ? q\u201d, Applicable Algebra in Engineering, Communication and Computing 12, 477 (2001). DOI].", "parent_of_code_id": "projective_reed_muller", "parent_of_detail": "", "cousins_code_id": "reed_muller\nq-ary_cyclic\nextended_reed_solomon\nq-ary_ltc", "cousins_detail": "\nGRM codes with nonzero evaluation points are cyclic ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 52).\nGRM codes for univariate polynomials (\\(m=1\\)) reduce to extended RS codes [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].\nGRM codes for \\(r<q\\) can be LTCs in the low- [L. Babai et al., \u201cChecking computations in polylogarithmic time\u201d, Proceedings of the twenty-third annual ACM symposium on Theory of computing - STOC '91 (1991). DOI][S. Arora et al., \u201cProof verification and the hardness of approximation problems\u201d, Journal of the ACM 45, 501 (1998). DOI] and high-error [R. Raz and S. Safra, \u201cA sub-constant error-probability low-degree test, and a sub-constant error-probability PCP characterization of NP\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI][S. Arora and M. Sudan, \u201cImproved low-degree testing and its applications\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI] regimes.", "cousin_of_code_id": "q-ary_hamming", "cousin_of_detail": "Hamming codes are dual to first-order GRM codes ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 45).", "_type": "ecc", "_page_id": "c_generalized_reed_muller", "_href": "c/generalized_reed_muller"}, "c_projective_reed_muller": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Projective RM (PRM) code", "code_id": "projective_reed_muller", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "PRM", "introduced": "[G. Lachaud, \u201cThe parameters of projective Reed\u2013M\u00fcller codes\u201d, Discrete Mathematics 81, 217 (1990). DOI][A. B. Sorensen, \u201cProjective Reed-Muller codes\u201d, IEEE Transactions on Information Theory 37, 1567 (1991). DOI]", "description": "Reed-Muller code for nonzero points \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) whose leftmost nonzero coordinate is one, corresponding to an evaluation code of polynomials over projective coordinates. PRM codes PRM\\(_q(r,m)\\) for \\(r<q\\) are injective evaluation codes with parameters [G. Lachaud, \u201cNumber of points of plane sections and linear codes defined on algebraic varieties\u201d, Arithmetic, Geometry, and Coding Theory. DOI] \\begin{align}\n  \\left[ q^m+q^{m-1}\\cdots +1, {m+r \\choose r},(q+1-r)q^{m-1} \\right]~.\n\\end{align} ", "parents_code_id": "generalized_reed_muller", "parents_detail": "", "cousins_code_id": "projective\ngriesmer", "cousins_detail": "Nonzero codewords of minimum weight of a \\(r\\)th-order \\(q\\)-ary projective RM code correspond to algebraic hypersurfaces of degree \\(r\\) having the largest number of points in the projective space \\(PG(n,q)\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 14.3.3).\nPRM codes for \\(r=1\\) attain the Griesmer bound for all \\(m\\) [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].", "_type": "ecc", "_page_id": "c_projective_reed_muller", "_href": "c/projective_reed_muller"}, "c_schubert": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Schubert code", "code_id": "schubert", "realizations": "", "protection": "Minimum distance bounds computed in Refs. [Hao Chen, \u201cOn the minimum distances of Schubert codes\u201d, IEEE Transactions on Information Theory 46, 1535 (2000). DOI][L. Guerra and R. Vincenti, \u201cOn the Linear Codes Arising from Schubert Varieties\u201d, Designs, Codes and Cryptography 33, 173 (2004). DOI][S. R. Ghorpade and M. A. Tsfasman, \u201cSchubert varieties, linear codes and enumerative combinatorics\u201d, Finite Fields and Their Applications 11, 684 (2005). DOI].", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[S. R. Ghorpade and G. Lachaud, \u201cHigher Weights of Grassmann Codes\u201d, Coding Theory, Cryptography and Related Areas 122 (2000). DOI][Hao Chen, \u201cOn the minimum distances of Schubert codes\u201d, IEEE Transactions on Information Theory 46, 1535 (2000). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Schubert variety. ", "parents_code_id": "flag_variety", "parents_detail": "Schubert codes are flag-variety evaluation codes with the flag variety being a Schubert variety.", "cousins_code_id": "grassmannian", "cousins_detail": "Schubert varieties are subvarieties of Grassmannians, and Schubert codes were initially constructed as a generalization of Grassmannian codes.", "_type": "ecc", "_page_id": "c_schubert", "_href": "c/schubert"}, "c_serge": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Serge-variety RM-type code", "code_id": "serge", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[M. Gonz\u00e1lez-Sarabia, C. Renter\u0131\u0301a, and H. Tapia-Recillas, \u201cReed-Muller-Type Codes Over the Segre Variety\u201d, Finite Fields and Their Applications 8, 511 (2002). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Serge variety. ", "parents_code_id": "evaluation_polynomial", "parents_detail": "Serge-variety RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a Serge variety.", "_type": "ecc", "_page_id": "c_serge", "_href": "c/serge"}, "c_ruled_surface": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Ruled-surface code", "code_id": "ruled_surface", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[S. H. Hansen, \u201cError-Correcting Codes from Higher-Dimensional Varieties\u201d, Finite Fields and Their Applications 7, 530 (2001). DOI][Chris Lomont, \u201cError Correcting Codes on Algebraic Surfaces\u201d. math/0309123]", "description": "Evaluation code of polynomials evaluated on points lying on a ruled surface. ", "parents_code_id": "evaluation_polynomial", "parents_detail": "Ruled-surface codes are polynomial evaluation codes with \\(\\cal X\\) being a ruled surface.", "_type": "ecc", "_page_id": "c_ruled_surface", "_href": "c/ruled_surface"}, "c_complete_intersections": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Complete-intersection RM-type code", "code_id": "complete_intersections", "realizations": "", "protection": "Distance bounds formulated in Ref. [L. Gold, J. Little, and H. Schenck, \u201cCayley\u2013Bacharach and evaluation codes on complete intersections\u201d, Journal of Pure and Applied Algebra 196, 91 (2005). DOI].", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[I. M. Duursma, C. Renter\u00eda, and H. Tapia-Recillas, \u201cReed-Muller Codes on Complete Intersections\u201d, Applicable Algebra in Engineering, Communication and Computing 11, 455 (2001). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a complete intersection. ", "parents_code_id": "evaluation_polynomial", "parents_detail": "Complete-intersection RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a complete intersection.", "_type": "ecc", "_page_id": "c_complete_intersections", "_href": "c/complete_intersections"}, "c_quadric": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quadric code", "code_id": "quadric", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. Wolfmann, \u201cCodes projectifs a deux ou trois poids associfs aux hyperquadriques d'une geometrie finie\u201d, Discrete Mathematics 13, 185 (1975). DOI][Y. Aubry, \u201cReed-Muller codes associated to projective algebraic varieties\u201d, Lecture Notes in Mathematics 4 (1992). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a quadric hypersurface. ", "parents_code_id": "flag_variety", "parents_detail": "Quadric codes are flag-variety evaluation codes with the flag variety being a quadric hypersurface.", "_type": "ecc", "_page_id": "c_quadric", "_href": "c/quadric"}, "c_toric_classical": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hansen toric code", "code_id": "toric_classical", "realizations": "", "protection": "Parameters of toric RM-type codes and various generalizations have been determined in Refs. [Diego Ruano, \u201cOn the Parameters of r-dimensional Toric Codes\u201d. math/0512285][John Little and Hal Schenck, \u201cToric surface codes and Minkowski sums\u201d. math/0507598][Eliseo Sarmiento, Maria Vaz Pinto, and Rafael H. Villarreal, \u201cThe minimum distance of parameterized codes on projective tori\u201d. 1009.4966][Hiram H. Lopez, Carlos Renteria, and Rafael H. Villarreal, \u201cAffine cartesian codes\u201d. 1202.0085][Peter Beelen and Mrinmoy Datta, \u201cGeneralized Hamming weights of affine cartesian codes\u201d. 1706.02114][Delio Jaramillo, Maria Vaz Pinto, and Rafael H. Villarreal, \u201cEvaluation codes and their basic parameters\u201d. 1907.13217].", "notes": "See Ref. [Delio Jaramillo, Maria Vaz Pinto, and Rafael H. Villarreal, \u201cEvaluation codes and their basic parameters\u201d. 1907.13217] for various examples and implementations in Magma.", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. P. Hansen, \u201cToric Surfaces and Error-correcting Codes\u201d, Coding Theory, Cryptography and Related Areas 132 (2000). DOI][David Joyner, \u201cToric codes over finite fields\u201d. math/0208155]", "description": "Evaluation code of a linear space of polynomials evaluated on points lying on an affine or projective toric variety. If the space is taken to be all polynomials up to some degree, the code is called a toric RM-type code of that degree. ", "parents_code_id": "evaluation_polynomial", "parents_detail": "Hansen toric codes are polynomial evaluation codes with \\(\\cal X\\) being a toric variety.", "_type": "ecc", "_page_id": "c_toric_classical", "_href": "c/toric_classical"}, "c_grassmannian": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Grassmannian code", "code_id": "grassmannian", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[C. T. Ryan, An application of Grassmannian varieties to coding theory. Congr. Numer. 57 (1987) 257\u2013271.][C.T. Ryan, Projective codes based on Grassmann varieties, Congr. Numer. 57, 273\u2013279 (1987).][C. T. Ryan and K. M. Ryan, \u201cThe minimum weight of the Grassmann codes C(k,n),\u201d, Discrete Applied Mathematics 28, 149 (1990). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Grassmannian \\({\\mathbb{G}}(\\ell,m)\\). ", "parents_code_id": "flag_variety", "parents_detail": "Grassmannian codes are flag-variety evaluation codes with the flag variety being a Grassmannian.", "cousins_code_id": "griesmer", "cousins_detail": "The binary Grassmannian \\([35,6,16]\\) code, whose points lie on the Grassmannian \\({\\mathbb{G}(2,4)}\\), attains the Griesmer bound [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].", "cousin_of_code_id": "schubert", "cousin_of_detail": "Schubert varieties are subvarieties of Grassmannians, and Schubert codes were initially constructed as a generalization of Grassmannian codes.", "_type": "ecc", "_page_id": "c_grassmannian", "_href": "c/grassmannian"}, "c_deligne_lusztig": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Deligne-Lusztig code", "code_id": "deligne_lusztig", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[S. H. Hansen, \u201cError-Correcting Codes from Higher-Dimensional Varieties\u201d, Finite Fields and Their Applications 7, 530 (2001). DOI][S.H. Hansen, The geometry of Deligne-Lusztig varieties: Higher dimensional AG codes, Ph.D. Thesis, University of Aarhus, 1999.][S. H. Hansen, \u201cCanonical bundles of Deligne-Lusztig varieties\u201d, manuscripta mathematica 98, 363 (1999). DOI][J. P. Hansen, \u201cDeligne-Lusztig varieties and group codes\u201d, Lecture Notes in Mathematics 63 (1992). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Deligne-Lusztig variety. ", "parents_code_id": "evaluation_polynomial", "parents_detail": "Deligne-Lusztig codes are polynomial evaluation codes with \\(\\cal X\\) a Deligne-Lusztig variety.", "_type": "ecc", "_page_id": "c_deligne_lusztig", "_href": "c/deligne_lusztig"}, "c_flag_variety": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Flag-variety code", "code_id": "flag_variety", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[F. Rodier, \u201cCodes from flag varieties over a finite field\u201d, Journal of Pure and Applied Algebra 178, 203 (2003). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a flag variety. ", "parents_code_id": "evaluation_polynomial", "parents_detail": "Flag-variety codes are polynomial evaluation codes with \\(\\cal X\\) being a flag variety.", "parent_of_code_id": "grassmannian\nhermitian_hypersurface\nquadric\nschubert", "parent_of_detail": "Grassmannian codes are flag-variety evaluation codes with the flag variety being a Grassmannian.\nHermitian-hypersurface codes are flag-variety evaluation codes with the flag variety being a Hermitian hypersurface.\nQuadric codes are flag-variety evaluation codes with the flag variety being a quadric hypersurface.\nSchubert codes are flag-variety evaluation codes with the flag variety being a Schubert variety.", "_type": "ecc", "_page_id": "c_flag_variety", "_href": "c/flag_variety"}, "c_hermitian_hypersurface": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hermitian-hypersurface code", "code_id": "hermitian_hypersurface", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[I. M. Chakravarti, \u201cFamilies of Codes with Few Distinct Weights from Singular and Non-Singular Hermitian Varieties and Quadrics in Projective Geometries and Hadamard Difference Sets and Designs Associated with Two-Weight Codes\u201d, Coding Theory and Design Theory 35 (1990). DOI]", "description": "Evaluation code of polynomials evaluated on points lying on a Hermitian hypersurface. ", "parents_code_id": "flag_variety", "parents_detail": "Hermitian-hypersurface codes are flag-variety evaluation codes with the flag variety being a Hermitian hypersurface.", "cousins_code_id": "hermitian", "cousins_detail": "Hermitian-hypersurface codes reduce to Hermitian codes of polynomials when the hypersurface is a curve.", "_type": "ecc", "_page_id": "c_hermitian_hypersurface", "_href": "c/hermitian_hypersurface"}, "c_residue": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Residue AG code", "code_id": "residue", "realizations": "Improvements over the McEliece public-key cryptosystem to linear AG codes on curves of arbitrary genus [H. Janwa and O. Moreno, \u201c[]\u201d, Designs, Codes and Cryptography 8, 293 (1996). DOI]. Only the subfield subcode proposal remains resilient to attacks ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 15.7.5.3).\nAlgebraic secret-sharing schemes [H. Chen and R. Cramer, \u201cAlgebraic Geometric Secret Sharing Schemes and Secure Multi-Party Computations over Small Fields\u201d, Lecture Notes in Computer Science 521 (2006). DOI].", "protection": "Riemann-Roch theorem yields code length \\(n\\), dimension \\(k\\), and a lower bound on distance in terms of features of \\(L\\) and genus of the curve \\(\\cal X\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Corr. 15.3.13). Distance bounds can also be derived from how an algebraic curve \\(\\cal X\\) is embedded in the ambient projective space [A. Couvreur, \u201cThe dual minimum distance of arbitrary-dimensional algebraic\u2013geometric codes\u201d, Journal of Algebra 350, 84 (2012). DOI; 0905.2345].", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "Also called a differential code. Linear \\(q\\)-ary code defined using a set of points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) in \\(GF(q)\\) lying on an algebraic curve \\(\\cal X\\) and a linear space \\(\\Omega\\) of certain rational differential forms \\(\\omega\\). Codewords are evaluations of residues of the differential forms in the specified points, \\begin{align}\n  \\left(\\text{Res}_{P_{1}}(\\omega),\\text{Res}_{P_{2}}(\\omega),\\cdots,\\text{Res}_{P_{n}}(\\omega)\\right)\\quad\\quad\\forall\\omega\\in\\Omega~.\n\\end{align} The code is denoted as \\(C_{\\Omega}({\\cal X},{\\cal P},D)\\), where the divisor \\(D\\) determines which rational rational differential forms to use. ", "parents_code_id": "ag\nevaluation", "parents_detail": "\nAny residue AG code of differential forms can be equivalently stated as an evaluation AG code of functions ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Lemma 15.3.10; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.72). In addition, evaluation and residue AG codes are dual to each other ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 313; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).", "parent_of_code_id": "cartier\nshimura", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_residue", "_href": "c/residue"}, "c_goppa": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Algebraic decoding algorithms [N. Patterson, \u201cThe algebraic decoding of Goppa codes\u201d, IEEE Transactions on Information Theory 21, 203 (1975). DOI]. If \\( \\text{deg} G(x) = 2t \\) , then there exists a \\(t\\)-correcting algebraic decoding algorithm for \\( \\Gamma(L,G) \\).\nSugiyama et al. modification of the extended Euclidean algorithm [Y. Sugiyama et al., \u201cA method for solving key equation for decoding goppa codes\u201d, Information and Control 27, 87 (1975). DOI][R. McEliece, The Theory of Information and Coding (Cambridge University Press, 2002). DOI].\nGuruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI].\nBinary Goppa codes can be decoded using a RS-based decoder [Daniel J. Bernstein, \"Understanding binary-Goppa decoding.\" Cryptology ePrint Archive (2022).].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Classical Goppa code", "code_id": "goppa", "realizations": "Initial version of the McEliece public-key cryptosystem [R. J. McEliece, A public-key cryptosystem based on algebraic coding theory, Technical report, Jet Propulsion Lab. DSN Progress Report (1978).][H. Janwa and O. Moreno, \u201cMcEliece public key cryptosystems using algebraic-geometric codes\u201d, Designs, Codes and Cryptography 8, (1996). DOI] and its variation by Niederreiter [H. Niederreiter (1986). Knapsack-type cryptosystems and algebraic coding theory. Problems of Control and Information Theory. Problemy Upravlenija I Teorii Informacii. 15: 159\u2013166.] where the generator matrix is replaced by the parity check matrix. Some of these were proven to be insecure since the public key exposes algebraic structure of code [V. M. SIDELNIKOV and S. O. SHESTAKOV, \u201cOn insecurity of cryptosystems based on generalized Reed-Solomon codes\u201d, Discrete Mathematics and Applications 2, (1992). DOI].", "protection": "The length \\( n = |L| \\) , dimension \\( k \\geq n-mr \\) where \\( r = \\text{deg} G(x) \\), and the minimum distance \\( d \\geq r +1 \\).", "notes": "GAP function GoppaCode(G,L) takes in a polynomial \\(G\\) that satisfies the necessary conditions for a Goppa code and a list \\(L\\) that contains elements in \\(GF(q)\\) that are not roots of \\(G\\). It returns a Goppa code.", "physical": "q-ary_digits", "short_name": "", "introduced": "[V. D. Goppa, \"A new class of linear error-correcting codes\", Probl. Peredach. Inform., vol. 6, no. 3, pp. 24-30, Sept. 1970.][V. D. Goppa, \"Rational representation of codes and (Lg) codes\", Probl. Peredach. Inform., vol. 7, no. 3, pp. 41-49, Sept. 1971.][E. Berlekamp, \u201cGoppa codes\u201d, IEEE Transactions on Information Theory 19, 590 (1973). DOI]", "description": "Let \\( G(x) \\) be a polynomial describing a projective-plane curve with coefficients from \\( GF(q^m) \\) for some fixed integer \\(m\\). Let \\( L \\) be a finite subset of the extension field \\( GF(q^m) \\) where \\(q\\) is prime, meaning \\( L  = \\{\\alpha_1, \\cdots, \\alpha_n\\} \\) is a subset of nonzero elements of \\( GF(q^m) \\). A Goppa code \\( \\Gamma(L,G) \\) is an \\([n,k,d]_q\\) linear code consisting of all vectors \\(a = a_1, \\cdots, a_n\\) such that \\( R_a(x) =0 \\) modulo \\(G(x)\\), where \\( R_a(x) = \\sum_{i=1}^n \\frac{a_i}{z - \\alpha_i} \\).\n\nGoppa codes are residue AG codes ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.28). Their duals are evaluation codes that are sometimes called geometric Reed Solomon codes ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.71). ", "parents_code_id": "generalized_reed_solomon\ncartier", "parents_detail": "Goppa codes are \\(GF(q)\\)-subfield subcode of the dual of the GRS code over \\(GF(q^m)\\) with evaluation points \\(\\alpha_i\\) and factors \\(v_i=G(\\alpha_i)^{-1}\\) ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], pg. 523; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nGoppa codes are Cartier codes from a curve of genus zero [Alain Couvreur, \u201cCodes and the Cartier Operator\u201d. 1206.4728].", "cousins_code_id": "q-ary_ltc", "cousins_detail": "Goppa codes are locally testable [T. Kaufman and S. Litsyn, \u201cAlmost Orthogonal Linear Codes are Locally Testable\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI].", "cousin_of_code_id": "binary_quantum_goppa\nq-ary_bch", "cousin_of_detail": "Classical Goppa codes are used to construct their quantum versions.\nNarrow-sense BCH codes are Goppa codes with \\(L=\\{1,\\alpha^{-1},\\cdots,\\alpha^{1-n}\\}\\) and \\(G(x)=x^{\\delta-1}\\) ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], pg. 522).", "_type": "ecc", "_page_id": "c_goppa", "_href": "c/goppa"}, "c_cartier": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Cartier codes share similar asymptotic properties as subfield subcodes of residue AG codes, with both families admitting sequences of codes that achieve the Gilbert-Varshamov bound.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Cartier code", "code_id": "cartier", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[Alain Couvreur, \u201cCodes and the Cartier Operator\u201d. 1206.4728]", "description": "Subcode of a certain residue AG code that is constructed using the Cartier operator.", "parents_code_id": "residue", "parents_detail": "", "parent_of_code_id": "goppa", "parent_of_detail": "Goppa codes are Cartier codes from a curve of genus zero [Alain Couvreur, \u201cCodes and the Cartier Operator\u201d. 1206.4728].", "_type": "ecc", "_page_id": "c_cartier", "_href": "c/cartier"}, "c_shimura": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "TVZ codes exceed the asymptotic Gilbert-Varshamov (GV) bound [M. A. Tsfasman, S. G. Vl\u0103dutx, and T. Zink, \u201cModular curves, Shimura curves, and Goppa codes, better than Varshamov-Gilbert bound\u201d, Mathematische Nachrichten 109, 21 (1982). DOI] (see also Ref. [Y. Ihara. \"Some remarks on the number of rational points of algebraic curves over finite fields.\" J. Fac. Sci. Univ. Tokyo Sect. IA Math., 28:721-724 (1982),1981.]). Roughly speaking, this breakthrough result implies that AG codes can outperform random codes. Such families of codes are optimal.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Tsfasman-Vladut-Zink (TVZ) code", "code_id": "shimura", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "TVZ", "introduced": "[M. A. Tsfasman, S. G. Vl\u0103dutx, and T. Zink, \u201cModular curves, Shimura curves, and Goppa codes, better than Varshamov-Gilbert bound\u201d, Mathematische Nachrichten 109, 21 (1982). DOI]", "description": "Member of a family of residue AG codes where \\(\\cal X\\) is either a reduction of a Shimura curve or an elliptic curve of varying genus.", "parents_code_id": "residue", "parents_detail": "", "_type": "ecc", "_page_id": "c_shimura", "_href": "c/shimura"}, "c_plane_curve": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Generalization of the Peterson algorithm for BCH codes [J. Justesen et al., \u201cConstruction and decoding of a class of algebraic geometry codes\u201d, IEEE Transactions on Information Theory 35, 811 (1989). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Plane-curve code", "code_id": "plane_curve", "realizations": "", "protection": "Bezout's theorem yields parameters \\([n,k,d]\\), which depend on the polynomial used to define the plane curve as well as the maximum degree of the polynomials used for evaluation ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], pg. 883). Distance bounds can be derived from how the plane curve is embedded in the ambient projective space ([A. Couvreur, \u201cThe dual minimum distance of arbitrary-dimensional algebraic\u2013geometric codes\u201d, Journal of Algebra 350, 84 (2012). DOI; 0905.2345], Thm. 4.1).", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. Justesen et al., \u201cConstruction and decoding of a class of algebraic geometry codes\u201d, IEEE Transactions on Information Theory 35, 811 (1989). DOI]", "description": "Evaluation AG code of bivariate polynomials of some finite maximum degree, evaluated at points lying on an affine plane curve. ", "parents_code_id": "evaluation", "parents_detail": "Plane-curve codes are evaluation AG codes of bivariate polynomials with \\(\\cal X\\) being an affine plane curve ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.27).", "_type": "ecc", "_page_id": "c_plane_curve", "_href": "c/plane_curve"}, "c_elliptic": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Elliptic code", "code_id": "elliptic", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "Evaluation AG code of rational functions evaluated on points lying on an elliptic curve, i.e., a curve of genus one. ", "parents_code_id": "evaluation", "parents_detail": "Elliptic codes are evaluation AG codes with \\(\\cal X\\) being an elliptic curve, i.e., curve of genus one ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).", "cousins_code_id": "mds", "cousins_detail": "Elliptic codes can be MDS ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Ex. 15.5.3; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 310; [M. Tsfasman, S. Vl\u01cedu\u0163, and D. Nogin. Algebraic geometric codes: basic notions. Vol. 139. American Mathematical Society, 2022.], Sec. 4.4.2).", "_type": "ecc", "_page_id": "c_elliptic", "_href": "c/elliptic"}, "c_hermitian": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "For polynomial evaluations up to degree \\(D\\): if \\(D < q + 1 \\), \\(k = \\frac{(D+1)(D+2)}{2}\\), and if \\(D \\geq q + 1 \\), \\(k = (q+1)D - \\frac{q(q-1)}{2} + 1 \\). ", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Unique decoding using syndromes and error locator ideals for polynomial evaluations. Note that Hermitian codes are linear codes so we can compute the syndrome of a received vector. Moreover, akin to the error-locator ideals found in decoding Reed-Solomon codes, for the multivariate case we must define an error locator ideal \\(\\Lambda \\) such that the variety of this ideal over \\(\\mathbb{F}^{2}_{q}\\) is exactly the set of errors. The Sakata algorithm uses these two ingredients to get a unique decoding procedure [S. Sakata, \u201cFinding a minimal set of linear recurring relations capable of generating a given finite two-dimensional array\u201d, Journal of Symbolic Computation 5, 321 (1988). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hermitian code", "code_id": "hermitian", "realizations": "", "protection": "Distance determined by properties of the Hermitian curve, the underlying field, and the functions used [K. Yang and P. V. Kumar, \u201cOn the true minimum distance of Hermitian codes\u201d, Lecture Notes in Mathematics 99 (1992). DOI]; see Ref. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Sec. 5.3, for an example. For evaluations of polynomials up to degree \\(D\\), the Hermitian code protects against at least \\(n - (q+1)D\\) errors whenever \\(D < q + 1 \\). If \\(D \\geq q+1 \\), the Hermitian code protects against at least \\(n-k - \\frac{q(q-1)}{2} + 1\\) errors.", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[H. Stichtenoth, \u201c\ufffdber die Automorphismengruppe eines algebraischen Funktionenk\ufffdrpers von Primzahlcharakteristik\u201d, Archiv der Mathematik 24, 527 (1973). DOI][H. Tiersma, \u201cRemarks on codes from Hermitian curves (Corresp.)\u201d, IEEE Transactions on Information Theory 33, 605 (1987). DOI]", "description": "Evaluation AG code of rational functions evaluated on points lying on a Hermitian curve \\(H(x,y) = x^{q+1}  + y^{q+1} - 1\\) over \\(\\mathbb{F}_q = GF(q)\\) in either affine or projective space. Hermitian codes directly improve over RS codes in the sense that RS codes have length at most \\(q\\) while Hermitian codes have length \\(q^3 + 1\\).\n\nHermitian codes of polynomials of total degree at most \\(D\\) can come in affine and epicyclic flavours, depending on whether the evaluations are over the affine plane or the bicyclic plane. The affine codes have length \\(q^3 - q\\) while epicyclic codes have length \\((q-2)(q+1)^2\\). More precisely, fix \\(r, D\\) and let \\begin{align}\n  M_D = \\left\\{f(x,y,z) = \\sum_{i+j \\leq D = D}a_{i,j}x^{i}y^{j}z^{D - (i+j)}\\right\\}\n\\end{align} be the message space of degree-\\(D\\) polynomials and \\begin{align}\n  S = \\{(x:y:z) \\in PG(2,q) \\mid H(x:y:z) = 0 \\}~,\n\\end{align} where \\(H(x:y:z) = x^{q+1} + y^{q+1} - z^{q+1}\\) is the homogenized Hermitian curve over the projective plane. The Hermitian code \\( C \\) over is \\begin{align}\nC = \\{(f(\\alpha_i))_{\\alpha_i \\in S}, \\: f \\in M_D \\}~.\n\\end{align}\n\nThe form \\(H(u,v,w) = u^{q+1} + v^{q+1} - w^{q+1}\\) is the Fermat version of the Hermitian curve. Substituting \\(u = x+z\\), \\(v = x+y\\), and \\(w = x+y+z \\) yields \\(H(x,y,z) = x^{q+1} - y^{q}z - yz^{q} \\), the Stichtenoth version of the curve. In affine coordinates, the Stichtenoth form of the curve is \\begin{align}\n  f(x,y) = x^{q+1} - y^{q} - y = N(x) - \\text{tr}(y)~,\n\\end{align} where \\(N(x) := x^{(q^{n}-1)/(q-1)}\\) and \\(\\text{tr} := 1 + x^{q} + \\ldots + x^{q^n}\\) are the field norm and trace of \\(GF(F_{q^n}\\), respectively. The Fermat version can be written as \\(H(u,v,w) = u\\overline{u} + v\\overline{v} - w\\overline{w}\\), where the conjugation map \\(\\overline{u} = u^{q}\\) is an isomorphism of \\(\\mathbb{F}_q \\). In fact, when the field of evaluations \\(\\mathbb{F}_{q^2}\\) is viewed as a quadratic extension of \\(\\mathbb{F}_q\\) then the conjugation map is an \\(\\mathbb{F}_q\\)-isomorphism that permutes the roots of the quadratic irreducible polynomial used to generate \\(\\mathbb{F}_{q^2}\\) from \\( \\mathbb{F}_q[x]\\).", "parents_code_id": "generalized_reed_solomon\nevaluation", "parents_detail": "Hermitian codes are concatenated GRS codes [T. Yaghoobian and I. F. Blake, \u201cHermitian codes as generalized Reed-Solomon codes\u201d, Designs, Codes and Cryptography 2, 5 (1992). DOI].\nHermitian codes are evaluation AG codes with \\(\\cal X\\) being a Hermitian curve ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.74). This curve is maximal, meaning that Hermitian codes are evaluation AG codes with maximum possible length given a fixed genus.", "cousin_of_code_id": "hermitian_hypersurface", "cousin_of_detail": "Hermitian-hypersurface codes reduce to Hermitian codes of polynomials when the hypersurface is a curve.", "_type": "ecc", "_page_id": "c_hermitian", "_href": "c/hermitian"}, "c_evaluation": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Generalization of plane-curve decoder [A. N. Skorobogatov and S. G. Vladut, \u201cOn the decoding of algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 36, 1051 (1990). DOI][V. Yu. Krachkovskii, \"Decoding of codes on algebraic curves,\" (in Russian), Conference Odessa, 1988.]. Another decoder [S. C. Porter, B.-Z. Shen, and R. Pellikaan, \u201cDecoding geometric Goppa codes using an extra place\u201d, IEEE Transactions on Information Theory 38, 1663 (1992). DOI] was later showed to be equivalent in Ref. [D. Ehrhard, \u201cDecoding Algebraic-Geometric Codes by solving a key equation\u201d, Lecture Notes in Mathematics 18 (1992). DOI]. Application of several algorthims in parallel can be used to decode up to half the minimum distance [R. Pellikaan, \u201cOn a decoding algorithm for codes on maximal curves\u201d, IEEE Transactions on Information Theory 35, 1228 (1989). DOI][S. Vladut, \u201cOn the decoding of algebraic-geometric codes over F/sub q/ for q&amp;lt;or=16\u201d, IEEE Transactions on Information Theory 36, 1461 (1990). DOI]. Computational procedure implementing these decoders is based on an extension of the Berlekamp-Massey algorithm by Sakata [S. Sakata, \u201cFinding a minimal set of linear recurring relations capable of generating a given finite two-dimensional array\u201d, Journal of Symbolic Computation 5, 321 (1988). DOI][S. Sakata, \u201cExtension of the Berlekamp-Massey algorithm to N dimensions\u201d, Information and Computation 84, 207 (1990). DOI][S. Sakata, \u201cDecoding binary 2-D cyclic codes by the 2-D Berlekamp-Massey algorithm\u201d, IEEE Transactions on Information Theory 37, 1200 (1991). DOI].\nDecoder based on majority voting of unknown syndromes [G.-L. Feng and T. R. N. Rao, \u201cDecoding algebraic-geometric codes up to the designed minimum distance\u201d, IEEE Transactions on Information Theory 39, 37 (1993). DOI] decodes up to half of the minimum distance [D. Ehrhard, \u201cAchieving the designed error capacity in decoding algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 39, 743 (1993). DOI].\nList decoders generalizing Sudan's RS decoder by Shokrollahi-Wasserman [M. A. Shokrollahi and H. Wasserman, \u201cList decoding of algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 45, 432 (1999). DOI] and Guruswami-Sudan [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Evaluation AG code", "code_id": "evaluation", "realizations": "", "protection": "Riemann-Roch theorem yields code length \\(n\\), dimension \\(k\\), and a lower bound on distance in terms of features of \\(L\\) and genus of the curve \\(\\cal X\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.12). The order or Feng-Rao bound, a generalization of the shift bound for cyclic codes, gives a lower bound on the distance of evaluation AG codes [G.-L. Feng and T. R. N. Rao, \u201cDecoding algebraic-geometric codes up to the designed minimum distance\u201d, IEEE Transactions on Information Theory 39, 37 (1993). DOI][R. Pellikaan, \u201cThe shift bound for cyclic, Reed-Muller and geometric Goppa codes\u201d, Arithmetic, Geometry, and Coding Theory. DOI][P. Beelen, \u201cThe order bound for general algebraic geometric codes\u201d, Finite Fields and Their Applications 13, 665 (2007). DOI]. Connection to semigroups yields another bound [T. Johnsen, S. Manshadi, and N. Monzavi, \u201cA determination of the parameters of a large class of Goppa codes\u201d, IEEE Transactions on Information Theory 40, 1678 (1994). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.].", "notes": "See Refs. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.][T. Hoholdt and R. Pellikaan, \u201cOn the decoding of algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 41, 1589 (1995). DOI][P. Beelen and T. H\u00f8holdt, \u201cThe Decoding of Algebraic Geometry Codes\u201d, Series on Coding Theory and Cryptology 49 (2008). DOI][W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI][R. E. Blahut, Algebraic Codes on Lines, Planes, and Curves (Cambridge University Press, 2001). DOI] for surveys and overviews of decoders.", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "Also called a function code. Evaluation code over \\(GF(q)\\) on a set of points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) in \\(GF(q)\\) lying on an algebraic curve \\(\\cal X\\) whose corresponding vector space \\(L\\) of functions \\(f\\) consists of certain polynomials or rational functions. Codewords are evaluations of all functions at the specified points, \\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right) \\quad\\quad\\forall f\\in L~.\n\\end{align} The code is denoted as \\(C_L({\\cal X},{\\cal P},D)\\), where the divisor \\(D\\) (of degree less than \\(n\\)) determines which rational functions to use by prescribing features associated with their zeroes and poles. The original motivation for evaluation codes, which are generalizations of RS codes that expand both the types of functions used as well as the available evaluation points, was to increase code length while maintaining good distance and size.\n\nThe algebraic curve \\(\\cal X\\) used for this construction is the set of zeroes of a nontrivial polynomial that is both smooth and irreducible over any field extension of \\(GF(q)\\). The curve can be defined over affine space or projective space, which contains the affine coordinates as a subset and which can yield an increase in length. If evaluations are made over projective coordinates, then the codewords are evaluations of homogeneous polynomials, and there are relations between such polynomials with polynomials over affine space. See Refs. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.][M. Tomlinson et al., Error-correction Coding and Decoding (Springer International Publishing, 2017). DOI] for more details.\n\nIn the case of polynomial functions \\(f\\), evaluation AG codes reduce to polynomial evaluation codes on algebraic curves. In the general case of rational functions, which are ratios of two polynomials, one can select such features for both the numerator and denominator polynomials. Zeroes of the denominator polynomial are called poles of the rational function, and their multiplicities correspond to orders of the poles. A bookkeeping device for this data is the divisor \\(D\\), and the corresponding vector space of functions defined using the curve \\(\\cal X\\) and the divisor is the Riemann-Roch space \\(L=L(D)\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 313).", "parents_code_id": "q-ary_linear\nag\nevaluation_varieties", "parents_detail": "The degree of the divisor for evaluation AG codes is restricted to be less than \\(n\\). When there is no restriction, any \\(q\\)-ary linear code can be formulated as an evaluation AG code [R. Pellikan, B.-Z. Shen, and G. J. M. van Wee, \u201cWhich linear codes are algebraic-geometric?\u201d, IEEE Transactions on Information Theory 37, 583 (1991). DOI].\n\nEvaluation AG codes are evaluation codes of rational functions \\(f\\) for which \\(\\cal X\\) is an algebraic curve, i.e., an algebraic variety of dimension one [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.].", "parent_of_code_id": "elliptic\ngeneralized_reed_solomon\nhermitian\nhexacode\nklein_quartic\nplane_curve\nresidue", "parent_of_detail": "Elliptic codes are evaluation AG codes with \\(\\cal X\\) being an elliptic curve, i.e., curve of genus one ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nGRS (RS) codes are in one-to-one correspondence with evaluation AG codes of univariate polynomials \\(f\\) with \\(\\cal X\\) being the projective (affine) line ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.24; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nHermitian codes are evaluation AG codes with \\(\\cal X\\) being a Hermitian curve ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.74). This curve is maximal, meaning that Hermitian codes are evaluation AG codes with maximum possible length given a fixed genus.\nThe hexacode is an evaluation AG code over \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\) with \\(\\cal X\\) defined by \\(x^2 y + \\omega y^2 z + \\bar{\\omega} z^2 x = 0\\) ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.77).\nKlein-quartic codes are evaluation AG codes with \\(\\cal X\\) being the Klein quartic ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.75).\nPlane-curve codes are evaluation AG codes of bivariate polynomials with \\(\\cal X\\) being an affine plane curve ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.27).\nAny residue AG code of differential forms can be equivalently stated as an evaluation AG code of functions ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Lemma 15.3.10; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Thm. 2.72). In addition, evaluation and residue AG codes are dual to each other ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 313; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).", "cousin_of_code_id": "evaluation_polynomial", "cousin_of_detail": "Evaluation AG codes are evaluation codes on algebraic curves. Polynomial evaluation codes are evaluation codes of polynomials. Evaluation AG codes of polynomials are equivalent to polynomial evaluation codes on algebraic curves.", "_type": "ecc", "_page_id": "c_evaluation", "_href": "c/evaluation"}, "c_klein_quartic": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Klein-quartic code", "code_id": "klein_quartic", "realizations": "", "protection": "Dimension \\(k=8\\) and distance \\(d \\geq 13\\). Concatenation with the \\([4,3,2]\\) single parity check code, conversion to a binary code by expressing \\(GF(8)\\) elements as vectors over \\(GF(2)\\), and puncturing yields a \\([91,24,25]\\) binary code that held the world record for codes of length 91 [A. M. Barg, G. L. Katsman, M. A. Tsfasman, \u201cAlgebraic-Geometric Codes from Curves of Small Genus\u201d, Probl. Peredachi Inf., 23:1 (1987), 42\u201346; Problems Inform. Transmission, 23:1 (1987), 34\u201338].", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[J. Hansen, \u201cCodes on the Klein quartic, ideals, and decoding (Corresp.)\u201d, IEEE Transactions on Information Theory 33, 923 (1987). DOI]", "description": "Evaluation AG code over \\(GF(8)\\) of rational functions evaluated on points lying in the Klein quartic, which is defined by the equation \\(x^3 y + y^3 z + z^3 x = 0\\) ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.75). ", "parents_code_id": "evaluation", "parents_detail": "Klein-quartic codes are evaluation AG codes with \\(\\cal X\\) being the Klein quartic ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ex. 2.75).", "_type": "ecc", "_page_id": "c_klein_quartic", "_href": "c/klein_quartic"}, "c_q-ary_quad_residue": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(q\\)-ary quadratic-residue (QR) code", "code_id": "q-ary_quad_residue", "realizations": "", "protection": "", "notes": "Introduction of quadratic-residue codes in Refs. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI].", "physical": "q-ary_digits", "short_name": "\\(q\\)-ary QR", "introduced": "", "description": "Member of a quadruple of cyclic \\(q\\)-ary codes of prime length \\(n\\) where \\(q\\) is prime and a quadratic residue modulo \\(n\\). The codes are constructed using quadratic residues and nonresidues of \\(n\\).\n\nThe roots of the generator polynomial \\(r(x)\\) of the first code (see Cyclic-to-polynomial correspondence) are all of the inequivalent quadratic residues of \\(n\\), and the second code's generator polynomial is \\((x-1)r(x)\\). The roots of the generator polynomial \\(a(x)\\) of the third code are all inequivalent nonresidues of \\(n\\), and the fourth code's generator polynomial is \\((x-1)a(x)\\). The codes corresponding to polynomials \\(r,a\\) are often called augmented quadratic-residue codes, while the remaining codes are called expurgated. ", "parents_code_id": "q-ary_duadic", "parents_detail": "QR codes are duadic codes of prime length satisfying certain relations [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].", "parent_of_code_id": "hexacode\nternary_golay", "parent_of_detail": "The hexacode is the smallest example of an extended quadratic residue code of Type \\(4^H\\) ([Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI], Sec. 2.4.6).\nThe ternary Golay code is a quadratic residue code over \\(GF(3)\\) with residue set \\(Q = \\{1, 3, 4, 5, 9\\} \\) and generator polynomial \\(x^5 + x^4 - x^3 + x^2 - 1\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 16).", "cousin_of_code_id": "binary_quad_residue", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_q-ary_quad_residue", "_href": "c/q-ary_quad_residue"}, "c_q-ary_duadic": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(q\\)-ary duadic code", "code_id": "q-ary_duadic", "realizations": "", "protection": "", "notes": "Reviews of duadic codes [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI].", "physical": "q-ary_digits", "short_name": "", "introduced": "[V. Pless, \u201cQ-codes\u201d, Journal of Combinatorial Theory, Series A 43, 258 (1986). DOI][V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI][J. J. Rushanan, Topics in Integral Matrices and Abelian Group Codes, California Institute of Technology, 1986. DOI][M. Smid, \u201cDuadic codes (Corresp.)\u201d, IEEE Transactions on Information Theory 33, 432 (1987). DOI]", "description": "Member of a pair of cyclic linear binary codes that satisfy certain relations, depending on whether the pair is even-like or odd-like duadic. Duadic codes exist only when \\(q\\) is a square modulo \\(n\\) [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].\n\nDuadic codes come in two pairs, an even-like duadic pair and an odd-like duadic pair. All codewords in the respective pairs are even-like, i.e., \\(\\sum_i c_i = 0\\), or odd-like, i.e., \\(\\sum_i c_i \\neq 0\\). A code with all even-like (odd-like) codewords is called even-like (odd-like).\n\nDuadic code pairs can be defined in terms of their idempotent generators (see Cyclic-to-polynomial correspondence). A pair of even-like codes \\(C_1\\) and \\(C_2\\) with respective idempotents \\(e_1\\) and \\(e_2\\) is an even-like duadic pair if (1) \\(e_1(x)+e_2(x)=1-\\frac{1}{n}(1+x+x^2+\\cdots+x^{n-1})\\) and (2) there exists a multiplier \\(\\mu\\) such that \\(C_1 \\mu=C_2\\) and \\(C_2 \\mu=C_1\\).\n\nThere is an odd-like duadic pair \\(\\{D_1,D_2\\}\\) associated with the even-like pair \\(\\{C_1, C_2\\}\\), where \\(1-e_2(x)\\) generates \\(D_1\\) and \\(1-e_1(x)\\) generates \\(D_2\\). The even-pair codes are \\([n,\\frac{n-1}{2}]_q\\) codes while the odd-pair codes are \\([n,\\frac{n+1}{2}]_q\\) codes.", "parents_code_id": "q-ary_cyclic", "parents_detail": "", "parent_of_code_id": "q-ary_quad_residue", "parent_of_detail": "QR codes are duadic codes of prime length satisfying certain relations [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].", "cousin_of_code_id": "binary_duadic", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_q-ary_duadic", "_href": "c/q-ary_duadic"}, "c_q-ary_bch": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Primitive BCH codes are asymptotically bad [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.; pg.\u00a0269].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) [E. Berlekamp, \u201cNonbinary BCH decoding (Abstr.)\u201d, IEEE Transactions on Information Theory 14, 242 (1968). DOI][J. Massey, \u201cShift-register synthesis and BCH decoding\u201d, IEEE Transactions on Information Theory 15, 122 (1969). DOI][E. R. Berlekamp, Algebraic Coding Theory, McGraw-Hill, 1968] and modification by Burton [H. Burton, \u201cInversionless decoding of binary BCH codes\u201d, IEEE Transactions on Information Theory 17, 464 (1971). DOI]; see also [W. W. Peterson and E. J. Weldon, Error-correcting codes. MIT press 1972.][R. Gallager, Information Theory and Reliable Communication (Springer Vienna, 1972). DOI].\nGorenstein-Peterson-Zierler decoder with runtime of order \\(O(n^3)\\) [W. Peterson, \u201cEncoding and error-correction procedures for the Bose-Chaudhuri codes\u201d, IEEE Transactions on Information Theory 6, 459 (1960). DOI][D. Gorenstein and N. Zierler, \u201cA Class of Error-Correcting Codes in $p^m $ Symbols\u201d, Journal of the Society for Industrial and Applied Mathematics 9, 207 (1961). DOI] (see exposition in Ref. [R.E. Blahut, Theory and practice of error-control codes, Addison-Wesley 1983.]).\nSugiyama et al. modification of the extended Euclidean algorithm [Y. Sugiyama et al., \u201cA method for solving key equation for decoding goppa codes\u201d, Information and Control 27, 87 (1975). DOI][R. McEliece, The Theory of Information and Coding (Cambridge University Press, 2002). DOI].\nGuruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI] and modification by Koetter-Vardy for soft-decision decoding [R. Koetter and A. Vardy, \u201cAlgebraic soft-decision decoding of reed-solomon codes\u201d, IEEE Transactions on Information Theory 49, 2809 (2003). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Bose\u2013Chaudhuri\u2013Hocquenghem (BCH) code", "code_id": "q-ary_bch", "realizations": "DVDs, disk drives, and two-dimensional bar codes [S. Zhu, Z. Sun, and X. Kai, \u201cA Class of Narrow-Sense BCH Codes\u201d, IEEE Transactions on Information Theory 65, 4699 (2019). DOI].", "protection": "By the BCH bound, BCH code with designed distance \\(\\delta\\) has true minimum distance \\(d\\geq\\delta\\). BCH codes with different designed distances may coincide, and the largest possible designed distance for a given code is the Bose distance; the true distance may still be larger than that. ", "notes": "See books [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.][S. Lin and D. J. Costello, Error Control Coding, 2nd ed. Englewood Cliffs, NJ: Prentice-Hall, 2004.][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI] for expositions on BCH codes and code tables.\nSee Kaiserslautern database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.\nSee corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cCyclic Codes (BCH-Bound).\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CCyclic-BCHBound.html].", "physical": "q-ary_digits", "short_name": "BCH", "introduced": "[D. Gorenstein and N. Zierler, \u201cA Class of Error-Correcting Codes in $p^m $ Symbols\u201d, Journal of the Society for Industrial and Applied Mathematics 9, 207 (1961). DOI]", "description": "Cyclic \\(q\\)-ary code, with \\(n\\) and \\(q\\) relatively coprime, whose zeroes are consecutive powers of a primitive \\(n\\)th root of unity \\(\\alpha\\). More precisely, the generator polynomial of a BCH code of designed distance \\(\\delta\\geq 1\\) is the lowest-degree monic polynomial with zeroes \\(\\{\\alpha^b,\\alpha^{b+1},\\cdots,\\alpha^{b+\\delta-2}\\}\\) for some \\(b\\geq 0\\). BCH codes are called narrow-sense when \\(b=1\\), and are called primitive when \\(n=q^r-1\\) for some \\(r\\geq 2\\).\n\nThe code dimension is related to the multiplicative order of \\(q\\) modulo \\(n\\), i.e., the smallest integer \\(m\\) such that \\(n\\) divides \\(q^m-1\\). The dimension of a BCH code is at least \\(n-m(\\delta-1)\\). The field \\(GF(q^m)\\) is the smallest field containing the above root of unity \\(\\alpha\\), and is the splitting field of the polynomial \\(x^n-1\\) (see Cyclic-to-polynomial correspondence). ", "parents_code_id": "generalized_reed_solomon\nq-ary_cyclic", "parents_detail": "BCH codes are subfield subcodes of GRS codes.\n", "cousins_code_id": "goppa\nq-ary_ltc", "cousins_detail": "Narrow-sense BCH codes are Goppa codes with \\(L=\\{1,\\alpha^{-1},\\cdots,\\alpha^{1-n}\\}\\) and \\(G(x)=x^{\\delta-1}\\) ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], pg. 522).\nDuals of BCH codes are locally testable [T. Kaufman and S. Litsyn, \u201cAlmost Orthogonal Linear Codes are Locally Testable\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI].", "cousin_of_code_id": "bch\ngalois_bch\nquantum_bch\nreed_solomon", "cousin_of_detail": "\n\nBCH codes are used to construct qubit BCH codes via the CSS and stabilizer-over-\\(GF(4)\\) constructions.\nNarrow-sense RS codes are BCH codes ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Remark 15.3.21; [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thms. 5.2.1 and 5.2.3). Moreover, an RS code can be represented as a union of cosets, with each coset being an interleaver of several binary BCH codes [A. Vardy and Y. Be'ery, \u201cBit-level soft-decision decoding of Reed-Solomon codes\u201d, IEEE Transactions on Communications 39, 440 (1991). DOI].", "_type": "ecc", "_page_id": "c_q-ary_bch", "_href": "c/q-ary_bch"}, "c_q-ary_cyclic": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Meggitt decoder [J. Meggitt, \u201cError correcting codes and their implementation for data transmission systems\u201d, IEEE Transactions on Information Theory 7, 234 (1961). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Cyclic linear \\(q\\)-ary code", "code_id": "q-ary_cyclic", "realizations": "", "protection": "Shift bound [J. van Lint and R. Wilson, \u201cOn the minimum distance of cyclic codes\u201d, IEEE Transactions on Information Theory 32, 23 (1986). DOI] gives a lower bound on the distance of cyclic \\(q\\)-ary codes.", "notes": "See Ch. 7 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for an exposition on cyclic codes.", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "A \\(q\\)-ary code of length \\(n\\) is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword. A cyclic code is called primitive when \\(n=q^r-1\\) for some \\(r\\geq 2\\). A shortened cyclic code is obtained from a cyclic code by taking only codewords with the first \\(j\\) zero entries, and deleting those zeroes. ", "parents_code_id": "cyclic\nq-ary_linear\ngroup", "parents_detail": "\n\nA length-\\(n\\) cyclic \\(q\\)-ary linear code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).", "parent_of_code_id": "q-ary_bch\ndodecacode\nq-ary_duadic\nq-ary_parity_check", "parent_of_detail": "\n\n\nSince permutations preserve coordinate sums, the cyclic permutation of a parity-check codeword is another codeword.", "cousins_code_id": "q-ary_ltc", "cousins_detail": "Cyclic linear codes cannot be \\(c^3\\)-LTCs [L. Babai, A. Shpilka, and D. Stefankovic, \u201cLocally Testable Cyclic Codes\u201d, IEEE Transactions on Information Theory 51, 2849 (2005). DOI]. Codeword symmetries are in general an obstruction to achieving such LTCs [M. Sudan, \u201cInvariance in Property Testing\u201d, Property Testing 211 (2010). DOI].", "cousin_of_code_id": "galois_css\ngeneralized_reed_muller\nquantum_mds\nreed_solomon\nq-ary_hamming", "cousin_of_detail": "Galois CSS codes can be constructed using self-orthogonal \\(q\\)-ary cyclic codes [Yongsheng Tang et al., \u201cNew quantum codes from dual-containing cyclic codes over finite rings\u201d. 1608.06674].\nGRM codes with nonzero evaluation points are cyclic ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 52).\nQuantum MDS codes can be constructed from \\(q\\)-ary cyclic codes using the Hermitian construction [G. G. La Guardia, \u201cNew Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 57, 5551 (2011). DOI].\nIf the length divides \\(q-1\\), then it is possible to construct a cyclic RS code.\nHamming codes are equivalent to cyclic codes when \\(q\\) and \\(r\\) are relatively prime ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 194).", "_type": "ecc", "_page_id": "c_q-ary_cyclic", "_href": "c/q-ary_cyclic"}, "c_meir": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Meir code", "code_id": "meir", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[O. Meir, \u201cCombinatorial construction of locally testable codes\u201d, Proceedings of the fortieth annual ACM symposium on Theory of computing (2008). DOI]", "description": "Locally testable \\([[n,k,d]]_q\\) code with query complexity \\(\\text{poly}(\\log k)\\) and rejection ratio \\(R/n = 1/\\text{poly}(\\log k)\\). Code construction is probabilistic and combinatorial. ", "parents_code_id": "q-ary_ltc", "parents_detail": "Meir codes stand out in that they are based on a combinatorial construction, while other LTCs often use algebraic tools.", "cousins_code_id": "random", "cousins_detail": "", "_type": "ecc", "_page_id": "c_meir", "_href": "c/meir"}, "c_q-ary_ltc": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(q\\)-ary linear LTC", "code_id": "q-ary_ltc", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "A \\(q\\)-ary linear code \\(C\\) of length \\(n\\) that is a \\((u,R)\\)-LTC with query complexity \\(u\\) and soundness \\(R>0\\). More technically, the code is a \\((u,R)\\)-LTC if the rows of its parity-check matrix \\(H\\in GF(q)^{r\\times n}\\) have weight at most \\(u\\) and if \\begin{align}\n  \\frac{1}{r}|H x| \\geq \\frac{R}{n} D(x,C)\n\\end{align} holds for any \\(q\\)-ary string \\(x\\), where \\(D(x,C)\\) is the \\(q\\)-ary Hamming distance between \\(x\\) and the closest codeword to \\(x\\) [A. Leverrier, V. Londe, and G. Z\u00e9mor, \u201cTowards local testability for quantum coding\u201d, Quantum 6, 661 (2022). DOI; 1911.03069; Def. 11]. ", "parents_code_id": "q-ary_linear\nltc", "parents_detail": "\n", "parent_of_code_id": "bs-ltc\nmeir", "parent_of_detail": "\nMeir codes stand out in that they are based on a combinatorial construction, while other LTCs often use algebraic tools.", "cousin_of_code_id": "q-ary_bch\ngoppa\nq-ary_cyclic\nexpander_lifted_product\ngeneralized_reed_muller\nq-ary_linear\nreed_solomon", "cousin_of_detail": "Duals of BCH codes are locally testable [T. Kaufman and S. Litsyn, \u201cAlmost Orthogonal Linear Codes are Locally Testable\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI].\nGoppa codes are locally testable [T. Kaufman and S. Litsyn, \u201cAlmost Orthogonal Linear Codes are Locally Testable\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI].\nCyclic linear codes cannot be \\(c^3\\)-LTCs [L. Babai, A. Shpilka, and D. Stefankovic, \u201cLocally Testable Cyclic Codes\u201d, IEEE Transactions on Information Theory 51, 2849 (2005). DOI]. Codeword symmetries are in general an obstruction to achieving such LTCs [M. Sudan, \u201cInvariance in Property Testing\u201d, Property Testing 211 (2010). DOI].\nClassical codes resulting from the expander lifted-product construction are one of the first two families of \\(c^3\\)-LTCs.\nGRM codes for \\(r<q\\) can be LTCs in the low- [L. Babai et al., \u201cChecking computations in polylogarithmic time\u201d, Proceedings of the twenty-third annual ACM symposium on Theory of computing - STOC '91 (1991). DOI][S. Arora et al., \u201cProof verification and the hardness of approximation problems\u201d, Journal of the ACM 45, 501 (1998). DOI] and high-error [R. Raz and S. Safra, \u201cA sub-constant error-probability low-degree test, and a sub-constant error-probability PCP characterization of NP\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI][S. Arora and M. Sudan, \u201cImproved low-degree testing and its applications\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI] regimes.\nLinear \\(q\\)-ary codes with distances \\(\\frac{1}{2}n-\\sqrt{t n}\\) for some \\(t\\) are called almost-orthogonal and are locally testable with query complexity of order \\(O(t)\\) [T. Kaufman and S. Litsyn, \u201cAlmost Orthogonal Linear Codes are Locally Testable\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI]. This was later improved to codes with distance \\(\\frac{1}{2}n-O(n^{1-\\gamma})\\) for any positive \\(\\gamma\\) [T. Kaufman and M. Sudan, \u201cSparse Random Linear Codes are Locally Decodable and Testable\u201d, 48th Annual IEEE Symposium on Foundations of Computer Science (FOCS'07) (2007). DOI], provided that the number of codewords is polynomial in \\(n\\).\nRS codes can be used to construct LTCs encoding \\(k\\) bits with length \\(k \\text{polylog}(k)\\) and query complexity \\(\\text{polylog}(k)\\) [E. Ben-Sasson and M. Sudan, \u201cShort PCPs with Polylog Query Complexity\u201d, SIAM Journal on Computing 38, 551 (2008). DOI].", "_type": "ecc", "_page_id": "c_q-ary_ltc", "_href": "c/q-ary_ltc"}, "c_bs-ltc": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Ben-Sasson-Sudan code", "code_id": "bs-ltc", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "", "introduced": "[E. Ben-Sasson and M. Sudan, \u201cSimple PCPs with poly-log rate and query complexity\u201d, Proceedings of the thirty-seventh annual ACM symposium on Theory of computing - STOC '05 (2005). DOI]", "description": "Locally testable \\([[n,k/2,d]]_{2^m}\\) code with \\(k\\) a power of two, \\(n = k \\log^{c} k\\), and query complexity \\(\\log^{c}k\\) for some universal constant \\(c\\). ", "parents_code_id": "q-ary_ltc", "parents_detail": "", "_type": "ecc", "_page_id": "c_bs-ltc", "_href": "c/bs-ltc"}, "c_interleaved_reed_solomon": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Decoder that corrects up to \\(1-\\frac{2k+n}{3n}\\) fraction of random errors [D. Bleichenbacher, A. Kiayias, and M. Yung, \u201cDecoding interleaved Reed\u2013Solomon codes over noisy channels\u201d, Theoretical Computer Science 379, 348 (2007). DOI].\nDecoder that corrects up to \\(1-(\\frac{k}{n})^{2/3}\\) fraction of random errors [D. Coppersmith and M. Sudan, \u201cReconstructing curves in three (and higher) dimensional space from noisy data\u201d, Proceedings of the thirty-fifth ACM symposium on Theory of computing - STOC '03 (2003). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Interleaved RS (IRS) code", "code_id": "interleaved_reed_solomon", "realizations": "The cross-interleaved RS (CIRC), an IRS code using two shortened RS codes and two forms of interleaving, was used for compact discs (CDs) [Odaka K., Sako Y., Iwamoto I., Doi T.; Vries L.B.; SONY: Error correctable data transmission method (Patent US4413340) filing date May 21, 1980.] (see Ref. [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Sec. 5.6 and Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 4).", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "IRS", "introduced": "", "description": "A modification of RS codes where multiple polynomials are used to define each codeword. Each codeword \\(\\mu\\) of a \\(t\\)-interleaved RS code is a string of values of the corresponding set \\(\\{f_\\mu^{(1)},f_\\mu^{(2)},\\cdots,f_\\mu^{(t)}\\}\\) of \\(t\\) polynomials at the points \\(\\alpha_i\\). The vector codewords can be arranged in an array whose rows are ordinary RS codes for each polynomial \\(f^{j}\\), yielding the encoding \\begin{align}\n\\mu\\to\\left(\n\\begin{array}{cccc}\n  f_{\\mu}^{(1)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(1)}\\left(\\alpha_{2}\\right) & \\cdots & f_{\\mu}^{(1)}\\left(\\alpha_{n}\\right)\\\\\n  f_{\\mu}^{(2)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(2)}\\left(\\alpha_{2}\\right) &  & f_{\\mu}^{(2)}\\left(\\alpha_{n}\\right)\\\\\n  \\vdots &  & \\ddots & \\vdots\\\\\n  f_{\\mu}^{(t)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(t)}\\left(\\alpha_{2}\\right) & \\cdots & f_{\\mu}^{(t)}\\left(\\alpha_{n}\\right)\n\\end{array}\\right)~.\n\\end{align} ", "parents_code_id": "q-ary_linear", "parents_detail": "IRS codes are linear over \\(GF(q)\\) but not necessarily over \\(GF(q^t)\\).", "parent_of_code_id": "parvaresh_vardy\nreed_solomon", "parent_of_detail": "PV codes are IRS codes with specific algebraic relations between the codeword polynomials that allow for efficient list decoding.\nAn IRS code utilizing one polynomial \\(f\\) reduces to an RS code.", "_type": "ecc", "_page_id": "c_interleaved_reed_solomon", "_href": "c/interleaved_reed_solomon"}, "c_extended_reed_solomon": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Extended GRS code", "code_id": "extended_reed_solomon", "realizations": "", "protection": "", "notes": "See corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cExtended Reed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html].", "physical": "q-ary_digits", "short_name": "", "introduced": "", "description": "A GRS code with an additional parity-check coordinate with corresponding evaluation point of zero. In other words, an \\([n+1,k,n-k+2]_q\\) GRS code whose polynomials are evaluated at the points \\((\\alpha_1,\\cdots,\\alpha_n,0)\\). The case when \\(n=q-1\\), multipliers \\(v_i=1\\), and \\(\\alpha_i\\) are \\(i-1\\)st powers of a primitive \\(n\\)th root of unity is an extended narrow-sense RS code.\n\nAn \\([q-1,k,q-k]_q\\) narrow-sense RS code can be extended twice by adding two evaluation points (of which one can be zero) to yield a \\([q+1,k,q-k+2]_q\\) doubly extended narrow-sense RS code. ", "parents_code_id": "generalized_reed_solomon", "parents_detail": "Extended GRS codes can be thought of as GRS codes that include an evaluation point of zero.", "cousins_code_id": "mds", "cousins_detail": "An MDS GRS code can be extended to an MDS code ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thm. 5.3.4). Extended and doubly extended narrow-sense RS codes are MDS ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thms. 5.3.2 and 5.3.4), and there is an equivalence between the two for odd prime \\(q\\) [S. Ball, \u201cOn sets of vectors of a finite vector space in which every subset of basis size is a basis\u201d, Journal of the European Mathematical Society 733 (2012). DOI].", "cousin_of_code_id": "generalized_reed_muller\nprojective\nsimplex", "cousin_of_detail": "GRM codes for univariate polynomials (\\(m=1\\)) reduce to extended RS codes [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349].\nColumns of parity-check matrices of doubly extended narrow-sense RS codes consist of points of a normal rational curve [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI; Def. 14.2.6]. Corresponding columns for triply extended RS codes consist of points of a hyperoval [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI; Prop. 17.5].\n\\(S(2,k)\\) is an extended RS code [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cSimplex Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html].", "_type": "ecc", "_page_id": "c_extended_reed_solomon", "_href": "c/extended_reed_solomon"}, "c_folded_reed_solomon": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Guruswami and Rudra [Venkatesan Guruswami and Atri Rudra, \u201cExplicit Codes Achieving List Decoding Capacity: Error-correction with Optimal Redundancy\u201d. cs/0511072][Atri Rudra. List Decoding and Property Testing of Error Correcting Codes. PhD thesis, University of Washington, 8 2007.] achieved list-decoding up to \\(1-\\frac{k}{n}-\\epsilon\\) fraction of errors using the Parvaresh-Vardy algorithm [F. Parvaresh and A. Vardy, \u201cCorrecting Errors Beyond the Guruswami-Sudan Radius in Polynomial Time\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI]; see Ref. [V. Guruswami, \u201cLinear-Algebraic List Decoding of Folded Reed-Solomon Codes\u201d, 2011 IEEE 26th Annual Conference on Computational Complexity (2011). DOI; 1106.0436] for a randomized construction.\nFolded RS codes, concatenated with suitable inner codes, can be efficiently list-decoded up to the Blokh-Zyablov bound [Venkatesan Guruswami and Atri Rudra, \u201cExplicit Codes Achieving List Decoding Capacity: Error-correction with Optimal Redundancy\u201d. cs/0511072][V. Guruswami and A. Rudra, \u201cBetter Binary List Decodable Codes Via Multilevel Concatenation\u201d, IEEE Transactions on Information Theory 55, 19 (2009). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Folded RS (FRS) code", "code_id": "folded_reed_solomon", "realizations": "", "protection": "", "notes": "See the book [V. Guruswami, A. Rudra, and M. Sudan. Essential coding theory. Draft available at this URL (2012).] for an introduction to FRS codes.\nA class of FRS codes can be used in the Yamakawa-Zhandry quantum algorithm [Takashi Yamakawa and Mark Zhandry, \u201cVerifiable Quantum Advantage without Structure\u201d. 2204.02063].", "physical": "q-ary_digits", "short_name": "FRS", "introduced": "[V. Y. Krachkovsky, \u201cReed-solomon codes for correcting phased error bursts\u201d, IEEE Transactions on Information Theory 49, 2975 (2003). DOI]", "description": "A linear \\([n/m,k]_{q^m}\\) code that is a modification of an \\([n,k]_q\\) RS code such that evaluations are grouped to yield a code with smaller length. In this case, the evaluation points are all powers of a generating field element \\(\\gamma\\), \\(\\alpha_i=\\gamma^i\\). Each codeword \\(\\mu\\) of an \\(m\\)-folded RS code is a string of \\(n/m\\) symbols, with each symbol being a string of values of a polynomial \\(f_\\mu\\) at consecutive powers of \\(\\gamma\\), \\begin{align}\n\\begin{split}\n  \\mu\\to&\\Big(\\left(f_{\\mu}(\\alpha^{0}),\\cdots,f_{\\mu}(\\alpha^{m-1})\\right),\\left(f_{\\mu}(\\alpha^{m}),\\cdots,f_{\\mu}(\\alpha^{2m-1})\\right)\\cdots\\\\&\\cdots,\\left(f_{\\mu}(\\alpha^{n-m}),\\cdots,f_{\\mu}(\\alpha^{n-1})\\right)\\Big)~.\n\\end{split}\n\\end{align} ", "parents_code_id": "q-ary_linear", "parents_detail": "", "parent_of_code_id": "reed_solomon", "parent_of_detail": "An FRS code with no extra grouping (\\(m=1\\)) reduces to an RS code.", "cousin_of_code_id": "parvaresh_vardy", "cousin_of_detail": "The specific relations imposed on the polynomials of PV codes allow for them to be expressed in a similar way as FRS codes, but with more redundancy. Folded RS codes can be list-decoded up to a higher fraction of errors.", "_type": "ecc", "_page_id": "c_folded_reed_solomon", "_href": "c/folded_reed_solomon"}, "c_parvaresh_vardy": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "PV codes can be list-decoded up to \\(1-(t k/n)^{1/(t+1)}\\) fraction of errors. This result improves over the Guruswami-Sudan algorithm for ordinary RS codes, which list-decodes up to \\(1-\\sqrt{k/n}\\) fraction of errors.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Parvaresh-Vardy (PV) code", "code_id": "parvaresh_vardy", "realizations": "", "protection": "", "notes": "", "physical": "q-ary_digits", "short_name": "PV", "introduced": "[F. Parvaresh and A. Vardy, \u201cCorrecting Errors Beyond the Guruswami-Sudan Radius in Polynomial Time\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI]", "description": "Also called a correlated RS code. An IRS code with additional algebraic relations (a.k.a. correlations) between the codeword polynomials \\(\\{f^{(j)}\\}_{j=1}^{t}\\). These relations yielded a list decoder that achieves list-decoding capacity. ", "parents_code_id": "interleaved_reed_solomon", "parents_detail": "PV codes are IRS codes with specific algebraic relations between the codeword polynomials that allow for efficient list decoding.", "cousins_code_id": "folded_reed_solomon", "cousins_detail": "The specific relations imposed on the polynomials of PV codes allow for them to be expressed in a similar way as FRS codes, but with more redundancy. Folded RS codes can be list-decoded up to a higher fraction of errors.", "_type": "ecc", "_page_id": "c_parvaresh_vardy", "_href": "c/parvaresh_vardy"}, "c_generalized_reed_solomon": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "The decoding process of GRS codes reduces to the solution of a polynomial congruence equation, usually referred to as the key equation. Decoding schemes are based on applications of the Euclid algorithm to solve the key equation.\nBerlekamp-Massey decoder with runtime of order \\(O(n^2)\\) [E. Berlekamp, \u201cNonbinary BCH decoding (Abstr.)\u201d, IEEE Transactions on Information Theory 14, 242 (1968). DOI][J. Massey, \u201cShift-register synthesis and BCH decoding\u201d, IEEE Transactions on Information Theory 15, 122 (1969). DOI][E. R. Berlekamp, Algebraic Coding Theory, McGraw-Hill, 1968].\nGuruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI] and modification by Koetter-Vardy for soft-decision decoding [R. Koetter and A. Vardy, \u201cAlgebraic soft-decision decoding of reed-solomon codes\u201d, IEEE Transactions on Information Theory 49, 2809 (2003). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Generalized RS (GRS) code", "code_id": "generalized_reed_solomon", "realizations": "Commonly used in mass storage systems such as CDs, DVDs, QR codes etc.\nVarious cloud storage systems [H. Dau et al., \u201cRepairing Reed-Solomon Codes With Multiple Erasures\u201d, IEEE Transactions on Information Theory 64, 6567 (2018). DOI; 1612.01361].\nPublic-key cryptosystems generalizing those that used Goppa codes [R. J. McEliece, A public-key cryptosystem based on algebraic coding theory, Technical report, Jet Propulsion Lab. DSN Progress Report (1978).][H. Janwa and O. Moreno, \u201cMcEliece public key cryptosystems using algebraic-geometric codes\u201d, Designs, Codes and Cryptography 8, (1996). DOI][H. Niederreiter (1986). Knapsack-type cryptosystems and algebraic coding theory. Problems of Control and Information Theory. Problemy Upravlenija I Teorii Informacii. 15: 159\u2013166.], some of which were proven to be insecure [V. M. SIDELNIKOV and S. O. SHESTAKOV, \u201cOn insecurity of cryptosystems based on generalized Reed-Solomon codes\u201d, Discrete Mathematics and Applications 2, (1992). DOI]. More recent works focus on methods to mask the algebraic structure using subcodes of GRS codes [T. P. Berger and P. Loidreau, \u201cHow to Mask the Structure of Codes for a Cryptographic Use\u201d, Designs, Codes and Cryptography 35, 63 (2005). DOI]. For example, a key-recovery attack was developed in Ref. [Alain Couvreur et al., \u201cDistinguisher-Based Attacks on Public-Key Cryptosystems Using Reed-Solomon Codes\u201d. 1307.6458] for a variant of masking method proposed in Ref. [Marco Baldi et al., \u201cEnhanced public key security for the McEliece cryptosystem\u201d. 1108.2462].", "protection": "The code can detect \\(n-k\\) errors, and can correct errors \\( \\left\\lfloor (n-k)/2\\right\\rfloor  \\) errors.", "notes": "", "physical": "q-ary_digits", "short_name": "GRS", "introduced": "", "description": "An \\([n,k,n-k+1]_q\\) linear code that is a modification of the RS code where codeword polynomials are multiplied by additional prefactors. Each message \\(\\mu\\) is encoded into a string of values of the corresponding polynomial \\(f_\\mu\\) at the points \\(\\alpha_i\\), multiplied by a corresponding nonzero factor \\(v_i \\in GF(q)\\), \\begin{align}\n  \\mu\\to\\left( v_{1}f_{\\mu}\\left(\\alpha_{1}\\right),v_{2}f_{\\mu}\\left(\\alpha_{2}\\right),\\cdots,v_{n}f_{\\mu}\\left(\\alpha_{n}\\right)\\right)~.\n\\end{align} ", "parents_code_id": "evaluation\nevaluation_polynomial", "parents_detail": "GRS (RS) codes are in one-to-one correspondence with evaluation AG codes of univariate polynomials \\(f\\) with \\(\\cal X\\) being the projective (affine) line ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.24; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nGRS (RS) codes are in one-to-one correspondence with univariate polynomial evaluation codes with \\(\\cal X\\) being the projective (affine) line ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.24; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).", "parent_of_code_id": "alternant\nq-ary_bch\ngoppa\nextended_reed_solomon\nhermitian\nreed_solomon", "parent_of_detail": "Alternant codes are subfield subcodes of GRS codes.\nBCH codes are subfield subcodes of GRS codes.\nGoppa codes are \\(GF(q)\\)-subfield subcode of the dual of the GRS code over \\(GF(q^m)\\) with evaluation points \\(\\alpha_i\\) and factors \\(v_i=G(\\alpha_i)^{-1}\\) ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], pg. 523; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nExtended GRS codes can be thought of as GRS codes that include an evaluation point of zero.\nHermitian codes are concatenated GRS codes [T. Yaghoobian and I. F. Blake, \u201cHermitian codes as generalized Reed-Solomon codes\u201d, Designs, Codes and Cryptography 2, 5 (1992). DOI].\nA GRS code for which all multipliers \\(v_i\\) are unity reduces to an RS code.", "cousins_code_id": "mds\ndistributed_storage", "cousins_detail": "GRS codes have distance \\(n-k+1\\), saturating the Singleton bound.\nGRS codes are used in various cloud storage systems [H. Dau et al., \u201cRepairing Reed-Solomon Codes With Multiple Erasures\u201d, IEEE Transactions on Information Theory 64, 6567 (2018). DOI; 1612.01361].", "cousin_of_code_id": "bch\ngalois_grs", "cousin_of_detail": "Binary BCH codes are subfield subcodes of GRS codes.\nHermitian self-orthogonal GRS codes are used to construct Galois-qudit GRS codes in the Hermitian construction.", "_type": "ecc", "_page_id": "c_generalized_reed_solomon", "_href": "c/generalized_reed_solomon"}, "c_reed_solomon": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Generic Reed-Solomon codes achieve list-decoding capacity [Joshua Brakensiek, Sivakanth Gopi, and Visu Makam, \u201cGeneric Reed-Solomon codes achieve list-decoding capacity\u201d. 2206.05256].", "features_magic_scaling_exponent": "", "features_encoders": "Bit-serial encoder [E. Berlekamp, \u201cBit-serial Reed - Solomon encoders\u201d, IEEE Transactions on Information Theory 28, 869 (1982). DOI].\n\\([n,k,n-k+1]\\) RS code requires an order \\(O(n^2)\\) operations while encoding if a straightforward matrix multiplication is employed and \\(k=\\mathcal{O}(n)\\). Using the FFT algorithm, complexity of evaluating a polynomial at \\(n\\) roots of unity becomes \\(O(n\\log n)\\). The FFT can be generalized to finite fields and rings, which is referred as Number-theoretic Transform (NTT). However, for some values of \\(n\\), which can not be factorized into small primes or do not have \\(n\\) roots of unity, the FFT algorithm fails. Independently developed by [Y. Wang and X. Zhu, \u201cA fast algorithm for the Fourier transform over finite fields and its VLSI implementation\u201d, IEEE Journal on Selected Areas in Communications 6, 572 (1988). DOI][D. G. Cantor, \u201cOn arithmetical algorithms over finite fields\u201d, Journal of Combinatorial Theory, Series A 50, 285 (1989). DOI] and generalized in Ref. [J. von zur Gathen and J. Gerhard, Modern Computer Algebra (Cambridge University Press, 2013). DOI], the additive FFT solves this problem by evaluating the polynomial at \\(n-1\\) roots of unity when \\(n\\) is power of 2.", "features_decoders": "Although using iFFT has its counterpart iNNT for finite fields, the decoding is usually standard polynomial interpolation in \\(k=\\mathcal{O}(n\\log^2 n)\\). However, in erasure decoding, encoded values are only erased in \\(r\\) points, which is a specific case of polynomial interpolation and can be done in \\(\\mathcal{O}(n\\log n)\\) by computing product of the received polynomial and an erasure locator polynomial and using long division to find an original polynomial. The long division step can be omitted to increase speed further by only dividing the derivative of the product polynomial, and derivative of erasure locator polynomial evaluated at erasure locations.\nBerlekamp-Massey decoder with runtime of order \\(O(n^2)\\) [J. Massey, \u201cShift-register synthesis and BCH decoding\u201d, IEEE Transactions on Information Theory 15, 122 (1969). DOI][E. R. Berlekamp, Algebraic Coding Theory, McGraw-Hill, 1968].\nGorenstein-Peterson-Zierler decoder with runtime of order \\(O(n^3)\\) [W. Peterson, \u201cEncoding and error-correction procedures for the Bose-Chaudhuri codes\u201d, IEEE Transactions on Information Theory 6, 459 (1960). DOI][D. Gorenstein and N. Zierler, \u201cA Class of Error-Correcting Codes in $p^m $ Symbols\u201d, Journal of the Society for Industrial and Applied Mathematics 9, 207 (1961). DOI] (see exposition in Ref. [R.E. Blahut, Theory and practice of error-control codes, Addison-Wesley 1983.]).\nBerlekamp-Welch decoder with runtime of order \\(O(n^3)\\) [E. R. Berlekamp and L. Welch, Error Correction of Algebraic Block Codes. U.S. Patent, Number 4,633,470 1986.] (see exposition in Ref. [P. Gemmell and M. Sudan, \u201cHighly resilient correctors for polynomials\u201d, Information Processing Letters 43, 169 (1992). DOI]), assuming that \\(t \\geq (n+k)/2\\).\nGao decoder using extended Euclidean algorithm [S. Gao, \u201cA New Algorithm for Decoding Reed-Solomon Codes\u201d, Communications, Information and Network Security 55 (2003). DOI].\nFast-Fourier-transform decoder with runtime of order \\(O(n \\text{polylog}n)\\) [I. Reed et al., \u201cThe fast decoding of Reed-Solomon codes using Fermat theoretic transforms and continued fractions\u201d, IEEE Transactions on Information Theory 24, 100 (1978). DOI].\nList decoders try to find a low-degree bivariate polynomial \\(Q(x,y)\\) such that evaluation of \\(Q\\) at \\((\\alpha_i,y_i)\\) is zero. By choosing proper degrees, it can be shown such polynomial exists by drawing an analogy between evaluation of \\(Q(\\alpha_i,y_i)\\) and solving a homogenous linear equation (interpolation). Once this is done, one lists roots of \\(y\\) that agree at \\(\\geq t\\) points. The breakthrough Sudan list-decoding algorithm corrects up to \\(1-\\sqrt{2R}\\) fraction of errors [M. Sudan, \u201cDecoding of Reed Solomon Codes beyond the Error-Correction Bound\u201d, Journal of Complexity 13, 180 (1997). DOI]. Roth and Ruckenstein proposed a modified key equation that allows for correction of more than \\(\\left\\lfloor (n-k)/2 \\right\\rfloor\\) errors [R. M. Roth and G. Ruckenstein, \u201cEfficient decoding of Reed-Solomon codes beyond half the minimum distance\u201d, IEEE Transactions on Information Theory 46, 246 (2000). DOI]. The Guruswami-Sudan algorithm improved the Sudan algorithm to \\(1-\\sqrt{R}\\) [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI]; see Ref. [V. Guruswami and A. Rudra, \u201cLimits to List Decoding Reed\u2013Solomon Codes\u201d, IEEE Transactions on Information Theory 52, 3642 (2006). DOI] for bounds. A further modification by Koetter and Vardy is used for soft-decision decoding [R. Koetter and A. Vardy, \u201cAlgebraic soft-decision decoding of reed-solomon codes\u201d, IEEE Transactions on Information Theory 49, 2809 (2003). DOI] (see also Ref. [A. Vardy and Y. Be'ery, \u201cBit-level soft-decision decoding of Reed-Solomon codes\u201d, IEEE Transactions on Communications 39, 440 (1991). DOI]).", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Reed-Solomon (RS) code", "code_id": "reed_solomon", "realizations": "RS Product Code (RSPC) was used in DVDs (see Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 4).\nDSL technologies and their variants against impluse noise [D. Zhang, K. Ho-Van, and T. Le-Ngoc, \u201cImpulse noise detection techniques for retransmission to reduce delay in DSL systems\u201d, 2012 IEEE International Conference on Communications (ICC) (2012). DOI].\nCryptographic primitives based on the hardness of decoding RS codes for more than \\(1-\\sqrt{k/n}+\\epsilon\\) errors. This is equivalent to the polynomial reconstruction problem [A. Kiayias and M. Yung, \u201cCryptographic Hardness Based on the Decoding of Reed-Solomon Codes\u201d, Automata, Languages and Programming 232 (2002). DOI].\nRS codes as outer codes concatenated with convolutional codes are used indirectly in space exploration programs such as Voyager and Galileo. RS codes were part of a temetry channel coding standard issued by the Consultative Committee for Space Data Systems (see Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 3).\nThe ubiquity of RS codes has yielded off-the-shelf VLSI intergrated-circuit decoding hardware [D. V. Sarwate and N. R. Shanbhag, \u201cHigh-speed architectures for Reed-Solomon decoders\u201d, IEEE Transactions on Very Large Scale Integration (VLSI) Systems 9, 641 (2001). DOI] (see also Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 5 and 10).\nAutomatic repeat request (ARQ) data transmission protocols (see Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 7).\nSlow-frequency-hop spread-spectrum transmission (see Ref. [S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Chs. 8-9).\nCoded sharding designs in blockchains to increase efficiency [Songze Li et al., \u201cPolyShard: Coded Sharding Achieves Linearly Scaling Efficiency and Security Simultaneously\u201d. 1809.10361].\nPrivate Information Retrieval [B. Sasidharan and E. Viterbo, \u201cPrivate Data Access in Blockchain Systems Employing Coded Sharding\u201d, 2021 IEEE International Symposium on Information Theory (ISIT) (2021). DOI].\nUsed in QR-Codes to retrieve damaged barcodes [International Organization for Standardization, Information Technology: Automatic Identification and Data Capture Techniques-QR Code 2005 Bar Code Symbology Specification, 2nd ed., IEC18004 (ISO, 2006).].\nWireless communication systems such as 3G, DVB, and WiMAX [I. Shakeel et al., \u201cReed-Solomon coding for cooperative wireless communication\u201d, 21st Annual IEEE International Symposium on Personal, Indoor and Mobile Radio Communications (2010). DOI].\nCorrecting pooled testing results for SARS-CoV-2 [N. Shental et al., \u201cEfficient high-throughput SARS-CoV-2 testing to detect asymptomatic carriers\u201d, Science Advances 6, (2020). DOI].", "protection": "Since each polynomial \\(f_{\\mu}\\) is of degree less than \\(k\\), it can be determined from its values at \\(k\\) points. This means that RS codes can correct erasures on up to \\(n-k\\) registers. The resulting distance, \\(d=n-k+1\\), saturates the Singleton bound.", "notes": "See Kaiserslautern database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.\nSee corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cReed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon.html].\nPopular summary in Quanta Magazine.", "physical": "q-ary_digits", "short_name": "RS", "introduced": "[K. A. Bush, \u201cOrthogonal Arrays of Index Unity\u201d, The Annals of Mathematical Statistics 23, 426 (1952). DOI][I. S. Reed and G. Solomon, \u201cPolynomial Codes Over Certain Finite Fields\u201d, Journal of the Society for Industrial and Applied Mathematics 8, 300 (1960). DOI]", "description": "An \\([n,k,n-k+1]_q\\) linear code based on polynomials over \\(GF(q)\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct points in \\(GF(q)\\). An RS code encodes a message \\(\\mu=\\{\\mu_0,\\cdots,\\mu_{k-1}\\}\\) into \\(\\{f_\\mu(\\alpha_1),\\cdots,f_\\mu(\\alpha_n)\\}\\) using a message-dependent polynomial \\begin{align}\nf_\\mu(x)=\\mu_0+\\mu_1 x + \\cdots + \\mu_{k-1}x^{k-1}.\n\\end{align} In other words, each message \\(\\mu\\) is encoded into a string of values of the corresponding polynomial \\(f_\\mu\\) at the points \\(\\alpha_i\\), \\begin{align}\n  \\mu\\to\\left( f_{\\mu}\\left(\\alpha_{1}\\right),f_{\\mu}\\left(\\alpha_{2}\\right),\\cdots,f_{\\mu}\\left(\\alpha_{n}\\right)\\right) \\,.\n\\end{align}\n\nAn RS code with length \\(n=q-1\\) whose points \\(\\alpha_i\\) are \\(i-1\\)st powers of a primitive \\(n\\)th root of unity is a narrow-sense RS code. In an alternative convention (not used here), the primitive-root case is called an RS code, and the general-root case is a generalized RS code. ", "parents_code_id": "generalized_reed_solomon\ninterleaved_reed_solomon\nfolded_reed_solomon", "parents_detail": "A GRS code for which all multipliers \\(v_i\\) are unity reduces to an RS code.\nAn IRS code utilizing one polynomial \\(f\\) reduces to an RS code.\nAn FRS code with no extra grouping (\\(m=1\\)) reduces to an RS code.", "parent_of_code_id": "q-ary_parity_check", "parent_of_detail": "RS codes for \\(k=n-1\\) are parity-check codes [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cExtended Reed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html].", "cousins_code_id": "mds\nq-ary_bch\nq-ary_cyclic\ntensor\nq-ary_ltc", "cousins_detail": "RS codes have distance \\(n-k+1\\), saturating the Singleton bound. If \\(k \\leq p\\), then all linear MDS codes \\( [n,k,n-k+1]_{p^m} \\) are RS codes [S. Ball, \u201cOn sets of vectors of a finite vector space in which every subset of basis size is a basis\u201d, Journal of the European Mathematical Society 733 (2012). DOI].\nNarrow-sense RS codes are BCH codes ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Remark 15.3.21; [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thms. 5.2.1 and 5.2.3). Moreover, an RS code can be represented as a union of cosets, with each coset being an interleaver of several binary BCH codes [A. Vardy and Y. Be'ery, \u201cBit-level soft-decision decoding of Reed-Solomon codes\u201d, IEEE Transactions on Communications 39, 440 (1991). DOI].\nIf the length divides \\(q-1\\), then it is possible to construct a cyclic RS code.\nTensor codes constructed from RS codes are robustly testable [A. Polishchuk and D. A. Spielman, \u201cNearly-linear size holographic proofs\u201d, Proceedings of the twenty-sixth annual ACM symposium on Theory of computing - STOC '94 (1994). DOI].\nRS codes can be used to construct LTCs encoding \\(k\\) bits with length \\(k \\text{polylog}(k)\\) and query complexity \\(\\text{polylog}(k)\\) [E. Ben-Sasson and M. Sudan, \u201cShort PCPs with Polylog Query Complexity\u201d, SIAM Journal on Computing 38, 551 (2008). DOI].", "cousin_of_code_id": "quantum_secret_sharing\nconvolutional\ngalois_polynomial\njustesen\nmaximum_rank_distance\npolynomial\nrank_modulation", "cousin_of_detail": "The classical information in this code is encoded using a Reed-Solomon code.\nConvolutional codes are often used in concatenation with Reed-Solomon codes for communication [T. Halonen, J. Romero, and J. Melero, editors , GSM, GPRS and EDGE Performance (Wiley, 2003). DOI].\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.\nAn RS code is the outer code of Justesen codes.\nMRD rank-metric codes can be thought of as matrix analogues of MDS Reed-Solomon codes as both constructions utilize a Vandermonde matrix [R. Koetter and F. R. Kschischang, \u201cCoding for Errors and Erasures in Random Network Coding\u201d, IEEE Transactions on Information Theory 54, 3579 (2008). DOI].\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.\nRS codes can be used to design rank modulation codes [A. Mazumdar, A. Barg, and G. Zemor, \u201cConstructions of rank modulation codes\u201d, 2011 IEEE International Symposium on Information Theory Proceedings (2011). DOI].", "_type": "ecc", "_page_id": "c_reed_solomon", "_href": "c/reed_solomon"}, "c_binary_permutation": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary permutation-based code", "code_id": "binary_permutation", "realizations": "", "protection": "", "notes": "", "physical": "groups", "short_name": "", "introduced": "[I. F. Blake, G. Cohen, and M. Deza, \u201cCoding with permutations\u201d, Information and Control 43, 1 (1979). DOI][P. J. Cameron, \u201cPermutation codes\u201d, European Journal of Combinatorics 31, 482 (2010). DOI]", "description": "Stub.", "parents_code_id": "group_classical", "parents_detail": "", "cousin_of_code_id": "rank_modulation", "cousin_of_detail": "Binary permutation-based codes also encode messages into permutations but protect against errors with the Hamming distance.", "_type": "ecc", "_page_id": "c_binary_permutation", "_href": "c/binary_permutation"}, "c_group_linear": {"logical": "groups", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Linear code over \\(G\\)", "code_id": "group_linear", "realizations": "", "protection": "", "notes": "", "physical": "groups", "short_name": "", "introduced": "[F. R. Kschischang, P. G. de Buda, and S. Pasupathy, \u201cBlock coset codes for M-ary phase shift keying\u201d, IEEE Journal on Selected Areas in Communications 7, 900 (1989). DOI][G. D. Forney, \u201cGeometrically uniform codes\u201d, IEEE Transactions on Information Theory 37, 1241 (1991). DOI][H.-A. Loeliger, \u201cSignal sets matched to groups\u201d, IEEE Transactions on Information Theory 37, 1675 (1991). DOI]", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates over a group \\(G\\) such that the codewords form a subgroup of \\(G^n\\).", "parents_code_id": "group_classical", "parents_detail": "", "cousins_code_id": "binary_linear\nq-ary_linear\npoints_into_lattices\nrings_linear\nlinear\ngroup_gkp", "cousins_detail": "Linear codes over \\(G=GF(2)\\) are binary linear codes since fields are abelian groups under addition.\nLinear codes over \\(G=GF(q)\\) are \\(q\\)-ary linear codes since fields are abelian groups under addition.\nLinear codes over \\(G=\\mathbb{R}\\) are lattices.\nLinear codes over \\(G=R\\) are linear codes over \\(R\\) since rings are abelian groups under addition.\nSince linear codes over \\(G\\) for abelian (non-Abelian) groups are closed under addition (multiplication), such codes can be thought of as linear codes over groups.\n", "_type": "ecc", "_page_id": "c_group_linear", "_href": "c/group_linear"}, "c_group_classical": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Group-based code", "code_id": "group_classical", "realizations": "", "protection": "", "notes": "", "physical": "groups", "short_name": "", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates labeled by elements of a group \\(G\\). The number of codewords may be infinite for infinite groups, so various restricted versions have to be constructed in practice.", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "binary_permutation\ngroup_linear\nrank_modulation", "parent_of_detail": "\n\nGroup-based codes whose alphabet is based on the permutation group \\(S_n\\) are rank-modulation codes.", "cousins_code_id": "bits_into_bits\nq-ary_digits_into_q-ary_digits\nanalog\nrings_into_rings\ngroup_quantum", "cousins_detail": "Group-based codes whose alphabet is based on the field \\(GF(2)\\), taken to be an abelian under addition, are binary codes.\nGroup-based codes whose alphabet is based on the field \\(GF(q)\\), taken to be an abelian under addition, are \\(q\\)-ary codes.\nGroup-based codes whose alphabet is based on the reals \\(\\mathbb{R}\\), taken to be an abelian group under addition, are analog codes.\nGroup-based codes whose alphabet is based on the ring \\(R\\), taken to be an abelian group under addition, are codes over \\(R\\).\n", "_type": "ecc", "_page_id": "c_group_classical", "_href": "c/group_classical"}, "c_rank_modulation": {"logical": "q-ary_digits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Rank modulation codes with code distance \\(d=\\Theta(n^{1+\\epsilon})\\) for \\(\\epsilon\\in[0,1]\\) achieve a rate of \\(1-\\epsilon\\) [A. Barg and A. Mazumdar, \u201cCodes in permutations and error correction for rank modulation\u201d, 2010 IEEE International Symposium on Information Theory (2010). DOI].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Rank-modulation Gray code (RMGC)", "code_id": "rank_modulation", "realizations": "Electronic devices where charges can either increase in an individual cell or decrease in a block of adjacent cells, e.g., flash memories [Anxiao Jiang et al., \u201cRank Modulation for Flash Memories\u201d, IEEE Transactions on Information Theory 55, 2659 (2009). DOI].", "protection": "Protects against errors in the Kendall tau distance on the space of permutations. The Kendall distance between permutations \\(\\sigma\\) and \\(\\pi\\) is defined as the minimum number of adjacent transpositions required to change \\(\\sigma\\) into \\(\\pi\\). ", "notes": "", "physical": "groups", "short_name": "RMGC", "introduced": "[H. Chadwick and L. Kurz, \u201cRank permutation group codes based on Kendall's correlation statistic\u201d, IEEE Transactions on Information Theory 15, 306 (1969). DOI][Anxiao Jiang, M. Schwartz, and J. Bruck, \u201cError-correcting codes for rank modulation\u201d, 2008 IEEE International Symposium on Information Theory (2008). DOI]", "description": "Also known as a code in permutations. A family of codes that encode a finite set of size \\(M\\) into a group \\(S_n\\) of permutations of \\([n]=(1,2,...,n)\\). They can be derived from Lee-metric codes, Reed-Solomon codes [A. Mazumdar, A. Barg, and G. Zemor, \u201cConstructions of rank modulation codes\u201d, 2011 IEEE International Symposium on Information Theory Proceedings (2011). DOI], quadratic residue codes and most binary codes. ", "parents_code_id": "group_classical", "parents_detail": "Group-based codes whose alphabet is based on the permutation group \\(S_n\\) are rank-modulation codes.", "cousins_code_id": "gray\nreed_solomon\nbinary_permutation", "cousins_detail": "The rank-modulation Gray code is an extension of the original binary Gray code to a code on the permutation group [Anxiao Jiang et al., \u201cRank Modulation for Flash Memories\u201d, IEEE Transactions on Information Theory 55, 2659 (2009). DOI].\nRS codes can be used to design rank modulation codes [A. Mazumdar, A. Barg, and G. Zemor, \u201cConstructions of rank modulation codes\u201d, 2011 IEEE International Symposium on Information Theory Proceedings (2011). DOI].\nBinary permutation-based codes also encode messages into permutations but protect against errors with the Hamming distance.", "_type": "ecc", "_page_id": "c_rank_modulation", "_href": "c/rank_modulation"}, "c_ldgm": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Certain LDGM codes come close to achieving Shannon capacity [J. Garcia-Frias and Wei Zhong, \u201cApproaching Shannon performance by iterative decoding of linear codes with low-density generator matrix\u201d, IEEE Communications Letters 7, 266 (2003). DOI].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Low-density generator-matrix (LDGM) code", "code_id": "ldgm", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "LDGM", "introduced": "", "description": "Binary or \\(q\\)-ary linear code with a sparse generator matrix. More precisely, a member of an infinite family of \\([n,k,d]\\) codes for which the number of nonzero entries in each row and column of the generator matrix are both bounded by a constant as \\(n\\to\\infty\\). The dual of an LDGM code has a sparse parity-check matrix and is called an LDPC code. ", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "fountain", "parent_of_detail": "", "cousin_of_code_id": "ldpc\nparity_check\nq-ary_parity_check", "cousin_of_detail": "LDPC and LDGM codes are dual to each other.\nConcatenated SPCs are LDGM [T. R. Oenning and Jaekyun Moon, \u201cA low-density generator matrix interpretation of parallel concatenated single bit parity codes\u201d, IEEE Transactions on Magnetics 37, 737 (2001). DOI].\nConcatenated parity-check codes are LDGM [T. R. Oenning and Jaekyun Moon, \u201cA low-density generator matrix interpretation of parallel concatenated single bit parity codes\u201d, IEEE Transactions on Magnetics 37, 737 (2001). DOI].", "_type": "ecc", "_page_id": "c_ldgm", "_href": "c/ldgm"}, "c_linear": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Linear code", "code_id": "linear", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "A code whose set of codewords is closed under addition and multiplication by elements of its alphabet, which can be either a field or a ring. In other words, for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any alphabet elements \\(\\alpha,\\beta\\). This extra structure yields much information about their properties, making them a large and well-studied subset of codes. ", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "divisible\ndual\nevaluation_varieties\ngroup\nq-ary_linear\nbinary_linear\nldgm\nldpc\nrings_linear", "parent_of_detail": "\n\n\n\n\n\n\n\n", "cousins_code_id": "stabilizer", "cousins_detail": "Linear (stabilizer) codes form a large and well-studied subset of all classical (quantum) codes because features such as decoding and level of protection are typically easier to determine than those of nonlinear (non-stabilizer) codes.", "cousin_of_code_id": "points_into_lattices\ngroup_linear", "cousin_of_detail": "Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.\nSince linear codes over \\(G\\) for abelian (non-Abelian) groups are closed under addition (multiplication), such codes can be thought of as linear codes over groups.", "_type": "ecc", "_page_id": "c_linear", "_href": "c/linear"}, "c_evaluation_polynomial": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Polynomial evaluation code", "code_id": "evaluation_polynomial", "realizations": "", "protection": "", "notes": "See Refs. [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349][Delio Jaramillo, Maria Vaz Pinto, and Rafael H. Villarreal, \u201cEvaluation codes and their basic parameters\u201d. 1907.13217] for reviews.", "physical": "", "short_name": "", "introduced": "", "description": "Evaluation code of polynomials at points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) on an algebraic variety \\(\\cal X\\). Codewords \\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right)\n\\end{align} are evaluations of a linear space \\(L\\) of polynomials \\(f\\). If the space is taken to be all polynomials up to some degree, the code is called a Reed-Muller-type code or RM-type code of that degree.\n\nOne can specify the space \\(L\\) by the number of variables input into the polynomials as well as the polynomials' maximum degree. One can additionally select only polynomials that have zeroes at certain points with certain multiplicities. A bookkeeping device for this data is the divisor \\(D\\), and the corresponding vector space of polynomials defined using the variety \\(\\cal X\\) and the divisor is the Riemann-Roch space \\(L=L(D)\\) ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 313). ", "parents_code_id": "evaluation_varieties", "parents_detail": "Polynomial evaluation codes are evaluation codes of polynomials \\(f\\) for which \\(\\cal X\\) is an algebraic variety.", "parent_of_code_id": "complete_intersections\ndeligne_lusztig\nflag_variety\ngeneralized_reed_muller\ngeneralized_reed_solomon\ntoric_classical\nreed_muller\nruled_surface\nserge", "parent_of_detail": "Complete-intersection RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a complete intersection.\nDeligne-Lusztig codes are polynomial evaluation codes with \\(\\cal X\\) a Deligne-Lusztig variety.\nFlag-variety codes are polynomial evaluation codes with \\(\\cal X\\) being a flag variety.\nGRM (PRM) codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine (projective) space over \\(GF(q)\\) ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pgs. 44-46; [S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nGRS (RS) codes are in one-to-one correspondence with univariate polynomial evaluation codes with \\(\\cal X\\) being the projective (affine) line ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 15.3.24; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], Ch. 3.2; [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nHansen toric codes are polynomial evaluation codes with \\(\\cal X\\) being a toric variety.\nRM codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine binary space ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pgs. 44-46; [S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\nRuled-surface codes are polynomial evaluation codes with \\(\\cal X\\) being a ruled surface.\nSerge-variety RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a Serge variety.", "cousins_code_id": "evaluation", "cousins_detail": "Evaluation AG codes are evaluation codes on algebraic curves. Polynomial evaluation codes are evaluation codes of polynomials. Evaluation AG codes of polynomials are equivalent to polynomial evaluation codes on algebraic curves.", "_type": "ecc", "_page_id": "c_evaluation_polynomial", "_href": "c/evaluation_polynomial"}, "c_dual": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Dual linear code", "code_id": "dual", "realizations": "", "protection": "The dual of an \\([n,k,d] \\) code is an \\([n,n-k,d']\\) code, where \\(d'\\) is not always related to \\(d\\). The generator matrix of \\(C^\\perp\\) is the parity check matrix of \\(C\\), and visa versa.", "notes": "See books [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI] for more on self-dual codes.\nSee Refs. [S. Bouyuklieva, \u201cSome optimal self-orthogonal and self-dual codes\u201d, Discrete Mathematics 287, 1 (2004). DOI][M. Harada, \u201cBinary extremal self-dual codes of length 60 and related codes\u201d, Designs, Codes and Cryptography 86, 1085 (2017). DOI; 1706.01694] for constructions of binary self-dual codes.\nSee Tables of Self-Dual Codes for a database of self-dual codes over \\(GF(2)\\), \\(GF(3)\\), \\(GF(4)\\) (Euclidean or Hermitian), \\(GF(5)\\), and \\(GF(7)\\). See also Ref. [P. Gaborit and A. Otmani, \u201cExperimental constructions of self-dual codes\u201d, Finite Fields and Their Applications 9, 372 (2003). DOI].", "physical": "", "short_name": "", "introduced": "[W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI]", "description": "For any \\([n,k]\\) binary or \\(q\\)-ary linear code \\(C\\), the dual (or orthogonal) code, \\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{n} ~|~ x\\cdot y=0 \\forall x\\in C\\},\n\\end{align} where the ordinary, standard, or Euclidean inner product is \\(x\\cdot y = \\sum_{i=1}^n x_i y_i\\) for coordinates \\(x_i,y_i\\).\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called self-orthogonal or weakly self-dual. A code that contains its dual, \\(C^\\perp \\subseteq C\\), is called dual-containing. A code that is equal to its dual, \\(C^\\perp = C\\), is called self-dual. The dual of a dual code is the original code. A code is dual-containing iff its dual is self-orthogonal.\n\nThe dual code \\(C^\\perp\\) is the row space of the parity check matrix of \\(C\\). The dual code is the kernel of the encoding map for \\(C\\), and \\(\\dim C^\\perp = n-k\\).\n\nFor cases when \\(q\\) is a square, an alternative definition of dual substitutes the Euclidean inner product for the Hermitian inner product, \\(x\\cdot y \\to \\sum_{i=1}^n x_i y^{\\sqrt{q}}_i\\). More general inner products can also be considered [Y. Fan and L. Zhang, \u201cGalois self-dual constacyclic codes\u201d, Designs, Codes and Cryptography 84, 473 (2016). DOI]. Self-dual codes with respect to the Hermitian inner product are called Hermitian self-dual; similar definitions hold for self-orthogonal and dual-containing as well as other inner products.", "parents_code_id": "linear", "parents_detail": "", "cousins_code_id": "divisible", "cousins_detail": "Binary self-dual codes are singly-even.", "cousin_of_code_id": "css\ndodecacode\ndual_additive\ngolay\nhadamard\nhexacode\nmajorana_stab\nmds\nqubit_stabilizer\nreed_muller\nstabilizer_over_gf4\nternary_golay\ntetracode\ngalois_true_stabilizer", "cousin_of_detail": "CSS codes for which \\(C_X=C_Z \\equiv C\\) are called self-orthogonal since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\).\nThe dodecacode is self-dual.\nThe difference between the definitions of dual linear and dual additive codes is in the trace used in the inner product. Self-dual linear codes are also self-dual additive codes.\nThe extended Golay code is self-dual.\nThe Hadamard code is the dual of the extended Hamming Code.\nThe hexacode is Euclidean and Hermitian self-dual.\nClassical self-orthogonal codes can be used to construct Majorana stabilizer codes [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a self-orthogonal classical code. A self-orthogonal classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\).\nA linear binary or \\(q\\)-ary \\([n,k,n-k+1]\\) code is MDS if and only if its dual \\([n,n-k,k+1]\\) is MDS ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 1.9.13).\nSymplectic representations of stabilizer group elements form a linear code over \\(GF(2)\\) that is self-orthogonal with respect to the symplectic inner product ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.6).\nThe codes RM\\((r,m)\\) and RM\\((m-r-1,m)\\) are dual to each other.\nIf the classical additive code of quaternary vectors corresponding a stabilizer code over \\(GF(4)\\) is linear, then the code is self-orthogonal with respect to both the trace-Hermitian and Hermitian inner products ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.4.1). In other words, the extra trace operation can be removed from the definition of inner product.\nThe extended ternary Golay code is self-dual.\nThe tetracode is self-dual.\nHermitian self-orthogonal linear codes over \\(GF(q^2)\\) yield true stabilizer codes via either the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI], Corr. 1) or the stabilizer-over-\\(GF(q^2)\\) construction (showing self-orthogonality under the trace-alternating inner product; see Ref. [Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19 or Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.8).", "_type": "ecc", "_page_id": "c_dual", "_href": "c/dual"}, "c_ldpc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Achieve capacity on the binary symmetric channel under maximum-likelihood decoding [D. J. C. MacKay, \u201cGood error-correcting codes based on very sparse matrices\u201d, IEEE Transactions on Information Theory 45, 399 (1999). DOI][R. Gallager, \u201cLow-density parity-check codes\u201d, IEEE Transactions on Information Theory 8, 21 (1962). DOI][Venkatesan Guruswami, \u201cIterative Decoding of Low-Density Parity Check Codes (A Survey)\u201d. cs/0610022]. Some LDPC codes achieve capacity for smaller block lengths under belief-propagation decoding [Shrinivas Kudekar, Tom Richardson, and Ruediger Urbanke, \u201cSpatially Coupled Ensembles Universally Achieve Capacity under Belief Propagation\u201d. 1201.2999]. Random LDPC codes achieve list-decoding capacity [Jonathan Mosheiff et al., \u201cLDPC Codes Achieve List Decoding Capacity\u201d. 1909.06430].", "features_magic_scaling_exponent": "", "features_encoders": "Almost linear-time encoder based on transforming parity-check matrix into upper triangular form [T. J. Richardson and R. L. Urbanke, \u201cEfficient encoding of low-density parity-check codes\u201d, IEEE Transactions on Information Theory 47, 638 (2001). DOI].", "features_decoders": "Message-passing algorithm called belief propagation (BP) [R. Gallagher, Low-density parity check codes. 1963. PhD thesis, MIT Cambridge, MA.][S. Lin and D. J. Costello, Error Control Coding, 2nd ed. Englewood Cliffs, NJ: Prentice-Hall, 2004.].\nLinear programming [J. Feldman, \u201cLP Decoding\u201d, Encyclopedia of Algorithms 1177 (2016). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Low-density parity-check (LDPC) code", "code_id": "ldpc", "realizations": "5G NR cellular communication for the traffic channel [M. V. Patil, S. Pawar, and Z. Saquib, \u201cCoding Techniques for 5G Networks: A Review\u201d, 2020 3rd International Conference on Communication System, Computing and IT Applications (CSCITA) (2020). DOI].\nWiMAX (IEEE 802.16e) [LDPC coding for OFDMA PHY. 802.16REVe Sponsor Ballot Recirculation comment, July 2004. IEEE C802.16e04/141r2].\nSatellite transmission of digital television [R. Purnamasari, H. Wijanto, and I. Hidayat, \u201cDesign and implementation of LDPC(Low Density Parity Check) coding technique on FPGA (Field Programmable Gate Array) for DVB-S2 (Digital Video Broadcasting-Satellite)\u201d, 2014 IEEE International Conference on Aerospace Electronics and Remote Sensing Technology (2014). DOI].", "protection": "With high probability, random LDPC codes have constant distance [R. Gallagher, Low-density parity check codes. 1963. PhD thesis, MIT Cambridge, MA.].", "notes": "See Kaiserslautern database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit representatives of several classes of LDPC codes, including \\(q\\)-ary, WiMAX, multi-edge, and spatially-coupled.\nSee pretty-good-codes database [G. Liva, F. Steiner. \u201cpretty-good-codes.org: Online library of good channel codes\u201d, URL: http://pretty-good-codes.org/] for explicit representatives and benchmarking.\nSee Ref. [A. Shokrollahi, \u201cLDPC Codes: An Introduction\u201d, Coding, Cryptography and Combinatorics 85 (2004). DOI] for a review of LDPC codes circa 2005.\nCodes have been benchmarked using AFF3CT toolbox [A. Cassagne et al., \u201cAFF3CT: A Fast Forward Error Correction Toolbox!\u201d, SoftwareX 10, 100345 (2019). DOI].", "physical": "", "short_name": "LDPC", "introduced": "[R. Gallager, \u201cLow-density parity-check codes\u201d, IEEE Transactions on Information Theory 8, 21 (1962). DOI][R. Gallagher, Low-density parity check codes. 1963. PhD thesis, MIT Cambridge, MA.]", "description": "Also known as Gallager codes. Binary or \\(q\\)-ary linear code with a sparse parity-check matrix. More precisely, a member of an infinite family of \\([n,k,d]\\) codes for which the number of nonzero entries in each row and column of the parity-check matrix are both bounded by a constant as \\(n\\to\\infty\\). An LDPC code is \\((j,k)\\)-regular if the parity-check matrix has a fixed number of \\(j\\) nonzero entries in each row and \\(k\\) entries in each column; otherwise, the LDPC code is irregular. The dual of an LDPC code has a sparse generator matrix and is called an LDGM code.\n\nA parity check is performed by taking the inner product of a row of the parity-check matrix with a codeword that has been affected by a noise channel. A parity check yields either zero (no error) or one (error) for binary codes, while yielding zero (no error) or a nonzero field element (error) for \\(q\\)-ary codes. Despite the fact that there is more than one nonzero outcome, \\(q\\)-ary linear codes with sparse parity-check matrices are also called LDPC codes. ", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "tornado", "parent_of_detail": "", "cousins_code_id": "ldgm\ntensor", "cousins_detail": "LDPC and LDGM codes are dual to each other.\nTensor products of random LDPC codes are robustly testable [I. Dinur, M. Sudan, and A. Wigderson, \u201cRobust Local Testability of Tensor Products of LDPC Codes\u201d, Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques 304 (2006). DOI][E. Ben-Sasson and M. Viderman, \u201cTensor Products of Weakly Smooth Codes Are Robust\u201d, Lecture Notes in Computer Science 290 (2008). DOI].", "cousin_of_code_id": "qldpc\ntornado", "cousin_of_detail": "\nTornado codes are similar to LDPC codes, but they use a highly irregular weight distribution for the underlying graphs [A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI].", "_type": "ecc", "_page_id": "c_ldpc", "_href": "c/ldpc"}, "c_ltc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Locally testable code (LTC)", "code_id": "ltc", "realizations": "", "protection": "", "notes": "LTCs first appeared implicitly in works on probabilistically checkable proofs (PCPs) [M. Blum, M. Luby, and R. Rubinfeld, \u201cSelf-testing/correcting with applications to numerical problems\u201d, Journal of Computer and System Sciences 47, 549 (1993). DOI][L. Babai, L. Fortnow, and C. Lund, \u201cNon-deterministic exponential time has two-prover interactive protocols\u201d, Computational Complexity 1, 3 (1991). DOI][C. Lund et al., \u201cAlgebraic methods for interactive proof systems\u201d, Journal of the ACM 39, 859 (1992). DOI][L. Babai et al., \u201cChecking computations in polylogarithmic time\u201d, Proceedings of the twenty-third annual ACM symposium on Theory of computing - STOC '91 (1991). DOI][S. Arora and S. Safra, \u201cProbabilistic checking of proofs\u201d, Journal of the ACM 45, 70 (1998). DOI][S. Arora et al., \u201cProof verification and the hardness of approximation problems\u201d, Journal of the ACM 45, 501 (1998). DOI]; see Ref. [O. Goldreich, \u201cShort Locally Testable Codes and Proofs: A Survey in Two Parts\u201d, Property Testing 65 (2010). DOI] for a review.", "physical": "", "short_name": "LTC", "introduced": "[L. Babai et al., \u201cChecking computations in polylogarithmic time\u201d, Proceedings of the twenty-third annual ACM symposium on Theory of computing - STOC '91 (1991). DOI][Sanjeev Arora. Probabilistic checking of proofs and hardness of approximation problems. UC Berkeley, 1994.][R. Rubinfeld and M. Sudan, \u201cRobust Characterizations of Polynomials with Applications to Program Testing\u201d, SIAM Journal on Computing 25, 252 (1996). DOI][Katalin Friedl and Madhu Sudan, \u201cSome Improvements to Total Degree Tests\u201d. 1307.3975]", "description": "Code for which one can efficiently check whether a given string is a codeword or is far from a codeword. Efficiency of the verification is quantified by the code's query complexity \\(u\\), while effectiveness is quantified by the code's soundness \\(R\\).\n\nTypically, one looks at how \\(R\\) scales with increasing code size for infinite families of codes, defining LTC families as those for which the soundness is asymptotically constant. Such LTC families with asymptotically constant distance, rate, and query complexity are called \\(c^3\\)-LTCs. The first two such families are classical codes arising from the expander lifted-product quantum code construction and left-right Cayley complex codes.\n\nA technical definition for codes over binary alphabets is provided as follows; for general alphabets, see Ref. [O. Goldreich, \u201cShort Locally Testable Codes and Proofs: A Survey in Two Parts\u201d, Property Testing 65 (2010). DOI]. The idea behind LTCs is to be able to reliably test whether a given bit-string \\(x\\) is in the code by only sampling subsets of \\(u\\) bits. To have something to check against, we first have to define a collection of length-\\(u\\) subsets \\(S\\) of bit locations that are called allowed local views. A code is LTC if the following two conditions are satisfied [Irit Dinur et al., \u201cLocally Testable Codes with constant rate, distance, and locality\u201d. 2111.04808; Thm. 1.1].\n\nFirst, if \\(x\\) is a codeword, then all of its restrictions \\(x|_S\\) to the subsets \\(S\\) are allowed local views, \\begin{align}\n  x\\in C \\Rightarrow x|_S \\in \\{\\text{allowed local views}\\}~.\n\\end{align} This guarantees that codewords can indeed be determined from this limited sampling procedure.\n\nSecond, the probability that a given restriction is not an allowed local view is lower-bounded by the relative distance to the code, \\begin{align}\n  \\text{Pr}_S (x|_S\\text{ not allowed local view}) \\geq \\frac{R}{n} D(x,C)~,\n\\end{align} where \\(D(x,C)\\) is the Hamming distance between \\(x\\) and the closest codeword to \\(x\\). This condition ensures that strings \\(x\\) can be deemed to be not in the codespace with high probability, i.e., with probability increasing as \\(x\\) gets farther from the code.", "parents_code_id": "ecc_finite", "parents_detail": "", "parent_of_code_id": "binary_ltc\nq-ary_ltc", "parent_of_detail": "\n", "cousins_code_id": "qltc", "cousins_detail": "", "cousin_of_code_id": "balanced", "cousin_of_detail": "Random low-rate unbiased linear codes are LTCs [S. Kopparty and S. Saraf, \u201cLocal list-decoding and testing of random linear codes from high error\u201d, Proceedings of the 42nd ACM symposium on Theory of computing - STOC '10 (2010). DOI].", "_type": "ecc", "_page_id": "c_ltc", "_href": "c/ltc"}, "c_ecc_finite": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Capacity-achieving Guessing Random Additive Noise Decoding (GRAND) [K. R. Duffy, J. Li, and M. Medard, \u201cCapacity-Achieving Guessing Random Additive Noise Decoding\u201d, IEEE Transactions on Information Theory 65, 4023 (2019). DOI; 1802.07010].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Finite-dimensional error-correcting code (ECC)", "code_id": "ecc_finite", "realizations": "", "protection": "A code corrects errors associated with a noise channel if it is possible to recover any codeword after its coordinates have been changed after going through the channel. More technically, an error-correcting code \\((u,\\mathcal{E})\\) is an encoder function \\(u:[1\\cdots K]\\to[1\\cdots N]\\) with a set of correctable errors \\(E:[1\\cdots N]\\to [1\\cdots M]\\) with the following property: there exists a decoder function \\(d:[1\\cdots M]\\to [1\\cdots K]\\) such that for all \\(E\\in\\cal{E}\\) and states \\(x\\in[1\\cdots K]\\), \\(d(E(e(x)))=x\\) [D. Gottesman. Surviving as a quantum computer in a classical world].", "notes": "The modern theory of error-correcting codes is rooted in the foundational work of C. Shannon [C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI], but error-correcting codes have been used prior to that work [A. Barg, \u201cAt the Dawn of the Theory of Codes\u201d, The Mathematical Intelligencer 15, 20 (1993). DOI].", "physical": "", "short_name": "Finite ECC", "introduced": "[C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI]", "description": "A code is a subset of a set or alphabet, with each element called a codeword. An error-correcting code consists of \\(K\\) codewords over an alphabet with \\(N\\) elements such that it is possible to recover the codewords from errors \\(E\\) from some error set \\(\\mathcal{E}\\).\n\nA common family of codes are the block codes, intended to encode a piece, or block, of a data stream. A block code encodes strings of length \\(k\\), where each character in the string an element of some fixed alphabet \\(\\Sigma\\), into strings of length \\(n\\). In other words, a block code encoding is a map from \\(\\Sigma^k\\) to \\(\\Sigma^n\\), where \\(N = |\\Sigma|^n\\), \\(K=|\\Sigma|^k\\), and \\(|\\Sigma|\\) is the number of elements in the alphabet.", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "bits_into_bits\ndistributed_storage\nq-ary_digits_into_q-ary_digits\nipp\nltc\nmatrices_into_matrices\nquasi_cyclic\nrings_into_rings\nweighed_covering", "parent_of_detail": "\n\n\n\n\n\n\n\n", "cousin_of_code_id": "qecc_finite", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_ecc_finite", "_href": "c/ecc_finite"}, "c_group": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Group code", "code_id": "group", "realizations": "", "protection": "", "notes": "See Ch. 16 of Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI] and pg. 58 of Ref. [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI] for introductions to group codes.\nNot all abelian group codes are for cyclic groups (cyclic codes) or for elementary abelian \\( p \\) groups (e.g. Reed Muller codes [S. D. Berman, \u201cSemisimple cyclic and Abelian codes. II\u201d, Cybernetics 3, 17 (1970). DOI]). For example, there is a binary code with parameters \\( [45,13,16] \\) which is an abelian group code for the group \\( G = \\mathbb{Z}_3 \\times \\mathbb{Z}_{15} \\). ", "physical": "", "short_name": "", "introduced": "", "description": "An \\( [n,k] \\) binary or \\(q\\)-ary code based on a finite group \\( G \\) of size \\(n \\). A group code for an abelian group is called an abelian group code.\n\nThe code is a \\( k \\)-dimensional linear subspace of the group algebra of \\( G\\) with coefficients in the field \\(GF(q) = \\mathbb{F}_q\\) with \\(q\\) elements. To be precise, the code must be closed under permutations corresponding to the elements of the group \\( G \\); therefore, \\( G \\) must be a subgroup of the permutation automorphism group of the code, which is defined as the group of permutations of the physical bits that preserve the code space. This leads us to the formal definition of a group code: a group code is an ideal in the group algebra \\( \\mathbb{F}_q G \\).", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "q-ary_cyclic\nbinary_cyclic\nreed_muller", "parent_of_detail": "A length-\\(n\\) cyclic \\(q\\)-ary linear code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).\nA length-\\(n\\) cyclic binary linear code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).\nConsider a binary vector space of dimension \\( m \\). Under addition, this forms a finite group with \\( 2^m \\) elements known as an elementary abelian 2-group -- the direct product of \\( m \\) two-element cyclic groups \\( \\mathbb{Z}_2 \\times \\dots \\times \\mathbb{Z}_2 \\). Denote this group by \\( G_m \\). Let \\( J \\) be the Jacobson radical of the group algebra \\( \\mathbb{F}_2 G_m \\), where \\(\\mathbb{F}_2=GF(2)\\). RM\\((r,m)\\) codes correspond to the ideal \\( J^{m-r} \\). The length of the code is \\( |G_m| = 2^m \\), the distance is \\( 2^{m-r} \\), and the dimension is \\( \\sum_{i=0}^r {m \\choose i} \\). A similar construction exists for choices of a prime \\( p\\neq 2 \\).", "_type": "ecc", "_page_id": "c_group", "_href": "c/group"}, "c_random": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Typical random codes (TRC) or typical random linear codes (TLC) refer to codes in the respective ensemble that satisfy a certain minimum distance. The relative fraction of typical codes in the ensemble approaches one as \\(N\\) goes to infinity [C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI] (see also Ref. [A. Barg and G. D. Forney, \u201cRandom codes: minimum distances and error exponents\u201d, IEEE Transactions on Information Theory 48, 2568 (2002). DOI]). Asymptotically, given distance \\(d\\), the maximum rate for a TRC is given by \\(R=\\frac{1}{2}R_{GV}(\\delta)\\) where \\(R_{GV}\\) is the Gilbert\u2013Varshamov (GV) bound \\(R_{GV}=1-h(\\delta)\\), and \\(h(\\delta)=h(\\frac{d}{n})\\) is the binary entropy function. The maximum rate for a TLC is given by \\(R=R_{GV}(d)\\), meaning that TLCs achieve the asymoptic GV bound.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Ball-collision decoding [D. J. Bernstein, T. Lange, and C. Peters, \u201cSmaller Decoding Exponents: Ball-Collision Decoding\u201d, Advances in Cryptology \u2013 CRYPTO 2011 743 (2011). DOI].\nFiniasz and Sendrier (FS-ISD) decoding [M. Finiasz and N. Sendrier, \u201cSecurity Bounds for the Design of Code-Based Cryptosystems\u201d, Advances in Cryptology \u2013 ASIACRYPT 2009 88 (2009). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Random code", "code_id": "random", "realizations": "Distributed storage systems [Yunfeng Lin, Ben Liang, and Baochun Li, \u201cPriority Random Linear Codes in Distributed Storage Systems\u201d, IEEE Transactions on Parallel and Distributed Systems 20, 1653 (2009). DOI].", "protection": "", "notes": "Shannon's pioneering work [C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI] analyzes the distance distribution of the code given a rate. Given \\(N\\) and the rate \\(R\\), the minimum distance of a TRC is given by the GV bound \\(d=N\\delta_{GV}(2R)\\), where \\(\\delta_{GV} = h^{-1}(1-R)\\), \\(0\\le R \\le 1\\), and \\(\\delta_{GV}(x)=0\\) for all other \\(R\\). For a TLC, the minimum distance is given by \\(d=N\\delta_{GV}(R)\\).", "physical": "", "short_name": "", "introduced": "[C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI]", "description": "Code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes, to codes whose multi-step construction is deterministic with the exception of a single step.\n\nTypically, random codes are selected with uniform distribution from some ensemble of codes. For example, a random binary code is a set of \\(2^{K}\\) codewords with length \\(N\\) chosen uniformly from the ensemble of all \\(2^N\\) bit-strings. Each bit in the codeword is randomly chosen between 0 and 1 with equal probability. For another example, a random binary linear code is generated from a random chosen \\(K\\) generators of length \\(N\\), where each bit of the generators is randomly chosen between 0 and 1 with equal probability. Equivalently, a random binary linear code is defined by a randomly generated \\(K\\) by \\(N\\) generator matrix, where each entry is randomly chosen between 0 and 1 with equal probability.\n\nIn both of the above random code constructions, the ensemble size scales exponentially with \\(N\\). A common convention is to think of the resulting code constructions as effectively explicit (as opposed to random) in cases where the ensemble size is independent of \\(N\\) or even when the size scales polynomially with \\(N\\).", "parents_code_id": "ecc", "parents_detail": "", "cousin_of_code_id": "expander_lifted_product\nfountain\ngs-ltc\njustesen\nmeir\nquantum_random", "cousin_of_detail": "Expander lifted-product codes are quantum CSS codes that utilize short classical codes in their construction which need to satisfy some properties (Ref. [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654], Lemma 10). It is shown that such codes exist, but they are not explicitly constructed. Such codes can be obtained by repeated random sampling or by performing a search of all codes of desired length. Nevertheless, since the length of the desired short codes does not scale with \\(n\\), this construction is effectively explicit.\n\n\nThe required inner codes are obtained by random sampling from the Wozencraft ensemble, whose length scales logarithmically with \\(n\\).\n\n", "_type": "ecc", "_page_id": "c_random", "_href": "c/random"}, "c_evaluation_varieties": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Evaluation code", "code_id": "evaluation_varieties", "realizations": "", "protection": "Properties of \\(\\cal X\\) can be used to bound the code dimension \\(k\\) and distance \\(d\\). The order or Feng-Rao bound gives a lower bound on the distance of evaluation codes [O. Geil, \u201cEvaluation Codes from an Affine Variety Code Perspective\u201d, Series on Coding Theory and Cryptology 153 (2008). DOI][Gui-Liang Feng et al., \u201cSimplified understanding and efficient decoding of a class of algebraic-geometric codes\u201d, IEEE Transactions on Information Theory 40, 981 (1994). DOI][G.-L. Feng and T. R. N. Rao, \u201cDecoding algebraic-geometric codes up to the designed minimum distance\u201d, IEEE Transactions on Information Theory 39, 37 (1993). DOI][J. Fitzgerald and R. F. Lax, \u201c[]\u201d, Designs, Codes and Cryptography 13, 147 (1998). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]; see Ref. [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Ch. 4 and Ref. [John B. Little, \u201cAlgebraic geometry codes from higher dimensional varieties\u201d. 0802.2349] for more discussion.", "notes": "", "physical": "", "short_name": "", "introduced": "[S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI]", "description": "Code whose codewords are evaluations of functions at certain fixed points. Code properties can be inferred from the structure of the functions and the underlying geometric object containing the points, often using results from algebraic geometry.\n\nLet \\(\\cal{X}\\) be a geometric object that contains a subset \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right) \\) consisting of \\(n\\) points \\(P_j\\). Let \\(L\\) be a vector space over \\(GF(q)\\) of functions \\(f\\) that take values in \\(GF(q)\\). Each \\(f\\in L\\) yields a codeword of an evaluation code \\(C_L({\\cal X},{\\cal P})\\) of the form \\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right) \\quad\\quad\\forall f\\in L~.\n\\end{align} This is a linear binary or \\(q\\)-ary code since the functions \\(f\\) take values in \\(GF(q)\\) and form a vector space.\n\nExamples of geometric objects \\(\\cal X\\) include affine or projective spaces over \\(GF(q)\\) as well as subsets of those spaces determined by some constraints. Prominent subsets are algebraic varieties, i.e., sets of solutions of systems of polynomial equations in either affine or projective space. The functions \\(f\\) are typically polynomials or rational functions.", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "evaluation\nevaluation_polynomial", "parent_of_detail": "Evaluation AG codes are evaluation codes of rational functions \\(f\\) for which \\(\\cal X\\) is an algebraic curve, i.e., an algebraic variety of dimension one [T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.].\nPolynomial evaluation codes are evaluation codes of polynomials \\(f\\) for which \\(\\cal X\\) is an algebraic variety.", "cousins_code_id": "q-ary_linear\nag", "cousins_detail": "Evaluation codes are defined using polynomial or rational functions evaluated on a subset of affine or projective space. Given access to more general structures (i.e., morphisms of algebras), any \\(q\\)-ary linear code can be formulated as an evaluation code ([T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.], Sec. 4.1; [M. Tsfasman, S. Vl\u01cedu\u0163, and D. Nogin. Algebraic geometric codes: basic notions. Vol. 139. American Mathematical Society, 2022.], Prop. 1.1.4).\nEvaluation codes on varieties can also be considered AG codes since they use algebraic geometry in quantifying code bounds. However, early AG constructions all used only one-dimensional varieties, i.e., algebraic curves.", "cousin_of_code_id": "projective", "cousin_of_detail": "Codewords of an evaluation code of multivariate polynomials up to degree one evaluated at points in projective space yields a projective code.", "_type": "ecc", "_page_id": "c_evaluation_varieties", "_href": "c/evaluation_varieties"}, "c_mds": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Maximum distance separable (MDS) code", "code_id": "mds", "realizations": "The McEliece Public Key Cryptosystem [McEliece, R.J.: A public-key cryptosystem based on algebraic coding theory. DSN Progress Report pp. 114\u2013116 (1978).] uses algebraic coding theory to secure communications against eavesdropping attack, in which private keys are generator matrices of linear codes, i.e., \\(G\\). Public Keys shared to outside world are scrambled and permutated versions of \\(G\\), i.e., \\(G^\\prime=SGP\\). Data to be encrypted, \\(u\\), is multiplied by public key and added intentional errors \\(e\\), i.e., \\(x=uG^\\prime+e\\). Upon receiving encrypted data, private key owner can apply inverse permutation \\(P^{-1}\\) to \\(x\\), decode the scrambled message given the presence of \\(e\\) errors, and finally unscramble to obtain \\(u\\). Security parameters of the system are \\(n\\) and \\(e\\), hence MDS codes, such as GRS codes may provide the same security level for shorter key sizes, and the private key owner can decode arguably fast enough using known decoding algorithms.\nAutomatic repeat request (ARQ) data transmission protocols ([S. B. Wicker and V. K. Bhargava, Reed-solomon Codes and Their Applications (IEEE, 1999). DOI], Ch. 7).", "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error-correction properties.", "notes": "", "physical": "", "short_name": "MDS", "introduced": "[R. Singleton, \u201cMaximum distance&amp;lt;tex&amp;gt;q&amp;lt;/tex&amp;gt;-nary codes\u201d, IEEE Transactions on Information Theory 10, 116 (1964). DOI]", "description": "A \\([n,k,d]_q\\) \\(q\\)-ary linear code is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Singleton bound \\begin{align}\nd \\leq n-k+1\n\\end{align} becomes an equality. A code is called almost MDS (AMDS) when \\(d=n-k\\). A bound for general \\(q\\)-ary codes can also be formulated; see Thm. 1.9.10 in Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI]. A code is near MDS (NMDS) if the code and its dual are mode AMDS.\n\nThe codes \\( [n,1,n]_q, [n,n-1,2]_q, [n,n,1]_q \\) for any \\(q\\) are MDS codes. These are called the trivial MDS codes. The only binary MDS codes are the trivial ones. ", "parents_code_id": "locally_recoverable", "parents_detail": "MDS codes are most efficient in terms of minimizing storage overhead for handling erasures. They are locally recoverable with locality \\(k\\).", "parent_of_code_id": "griesmer\nhexacode\nparity_check\ntetracode\nq-ary_parity_check", "parent_of_detail": "Singleton bound implies the Griesmer bound.\n\n\n\n", "cousins_code_id": "dual\nprojective", "cousins_detail": "A linear binary or \\(q\\)-ary \\([n,k,n-k+1]\\) code is MDS if and only if its dual \\([n,n-k,k+1]\\) is MDS ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 1.9.13).\nA linear code is MDS (almost MDS) if and only if columns of its parity-check matrix form an \\(n\\)-arc (\\(n\\)-track) in projective space [S. M. Dodunekov and I. N. Landgev, \u201cOn near-MDS codes\u201d, Proceedings of 1994 IEEE International Symposium on Information Theory. DOI][J. W. P. Hirschfeld and L. Storme, \u201cThe Packing Problem in Statistics, Coding Theory and Finite Projective Spaces: Update 2001\u201d, Developments in Mathematics 201 (2001). DOI]. The dual of a MDS code is an MDS code, so MDS codes are projective.", "cousin_of_code_id": "ag\nelliptic\nextended_reed_solomon\ngeneralized_reed_solomon\nmatrix_computation\nmaximum_rank_distance\nquantum_mds\nreed_solomon", "cousin_of_detail": "Near MDS \\([n,k,d]_{GF(p^m)}\\) AG codes exist when \\(n,p,m\\) satisfy certain relations according to the Tsfasman-Vladut bound [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI].\nElliptic codes can be MDS ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Ex. 15.5.3; [M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 310; [M. Tsfasman, S. Vl\u01cedu\u0163, and D. Nogin. Algebraic geometric codes: basic notions. Vol. 139. American Mathematical Society, 2022.], Sec. 4.4.2).\nAn MDS GRS code can be extended to an MDS code ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thm. 5.3.4). Extended and doubly extended narrow-sense RS codes are MDS ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thms. 5.3.2 and 5.3.4), and there is an equivalence between the two for odd prime \\(q\\) [S. Ball, \u201cOn sets of vectors of a finite vector space in which every subset of basis size is a basis\u201d, Journal of the European Mathematical Society 733 (2012). DOI].\nGRS codes have distance \\(n-k+1\\), saturating the Singleton bound.\nThe first matrix multiplication code encoded each entry of the matrices to be multiplied into an MDS code [K. Lee et al., \u201cSpeeding Up Distributed Machine Learning Using Codes\u201d, IEEE Transactions on Information Theory 64, 1514 (2018). DOI; 1512.02673].\nMRD codes are matrix-code analogues of MDS codes.\n\nRS codes have distance \\(n-k+1\\), saturating the Singleton bound. If \\(k \\leq p\\), then all linear MDS codes \\( [n,k,n-k+1]_{p^m} \\) are RS codes [S. Ball, \u201cOn sets of vectors of a finite vector space in which every subset of basis size is a basis\u201d, Journal of the European Mathematical Society 733 (2012). DOI].", "_type": "ecc", "_page_id": "c_mds", "_href": "c/mds"}, "c_covering": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Covering code", "code_id": "covering", "realizations": "Data compression both with or without compression [G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering Codes, Elsevier (1997).].\nFootball-pool problem: finding the smallest number of bets on a set of matches needed to guarantee at least one bet has at most \\(\\rho\\) errors [H. Hamalainen et al., \u201cFootball Pools--A Game for Mathematicians\u201d, The American Mathematical Monthly 102, 579 (1995). DOI][A. Barg, \u201cAt the Dawn of the Theory of Codes\u201d, The Mathematical Intelligencer 15, 20 (1993). DOI].", "protection": "", "notes": "See book [G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, \"Covering codes\". Elsevier, 1997.] for an expositions on covering codes.", "physical": "", "short_name": "", "introduced": "", "description": "A code \\(C\\) in a metric space is covering if the union of balls of some radius centered at the codewords covers the entire space. For example, a \\(q\\)-ary code \\(C\\) is \\(\\rho\\)-covering if \\(\\forall v \\in GF(q)^{n}\\), there is a codeword \\(c \\in C\\) such that the Hamming distance \\(D(c,v)\\leq \\rho\\).\n\nThe covering radius \\(\\rho(C)\\) is the smallest non-negative integer \\(\\rho\\) such that \\(C\\) is \\(\\rho\\)-covering, i.e. \\begin{align}\n  \\rho(C)=\\max_{{v\\in GF(q)^{n}}}\\min_{{c\\in C}}d(v,c)~.\n\\end{align} For a linear code \\([n,k]_q\\), the covering radius is the minimum number of columns of the code's parity check matrix which cover \\(GF(q)^{n-k}\\).\n\nThe covering radius satisfies various inequalities. A code \\(C\\) with distance \\(d\\) satisfies the relation \\begin{align}\n  \\rho(C)\\geq \\frac{|d-1|}{2}~. \\label{eq:perfect-ref}\n\\end{align} Linear \\([n,k]_q\\) codes also satisfy the redundancy bound \\begin{align}\n  \\rho(C)\\leq n-k\n\\end{align} and the sphere covering bound \\begin{align}\n  \\rho(C)\\leq \\min{\\left(p~\\bigg\\rvert \\sum_{i=0}^{p} {n \\choose i}(q-1)^{i}|C| \\geq q^{n}\\right)}~. \\label{eq:spherepacking-perfect-label}\n\\end{align} A code is perfect iff it satisfies Eqs. \\(\\eqref{eq:perfect-ref}\\) and \\(\\eqref{eq:spherepacking-perfect-label}\\) with equality.\n\nIn general, finding the covering radius of a given code is difficult. Complexity analysis as well as an extensive study on bounds can be found in Ref. [G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering Codes, Elsevier (1997).].", "parents_code_id": "weighed_covering", "parents_detail": "An \\(m\\)-weighed covering code for \\(m_j=1\\) is a covering code of covering radius at most \\(r\\) ([G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.], Ch. 13).", "parent_of_code_id": "perfect", "parent_of_detail": "Perfect codes are covering codes with minimum number of codewords", "_type": "ecc", "_page_id": "c_covering", "_href": "c/covering"}, "c_quasi_perfect": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quasi-perfect code", "code_id": "quasi_perfect", "realizations": "", "protection": "Correct errors of weight \\(t\\) as well as some errors of weight \\(t+1\\).", "notes": "", "physical": "", "short_name": "", "introduced": "", "description": "Perfect codes \\((n,K,d)_q\\) are those for which balls of Hamming radius \\(t=\\left\\lfloor (d-1)/2\\right\\rfloor\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings. Quasi-perfect codes are those for which balls of Hamming radius \\(t\\) are disjoint, while balls of radius \\(t+1\\) cover the space with possible overlaps. In other words, any \\(q\\)-ary string is at most \\(t+1\\) bit flips away from a codeword of a quasi-perfect code. ", "parents_code_id": "weighed_covering", "parents_detail": "A quasi-perfect code is an \\(m\\)-weighed covering code for \\(r=t+1\\), \\(m_0=m_1=\\cdots=m_{t+1}=1\\), and \\(m_t=m_{t+1}=1/\\left\\lfloor (n+1)(t+1) \\right\\rfloor\\) ([G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.], Ch. 13).", "parent_of_code_id": "nearly_perfect\nzetterberg", "parent_of_detail": "Nearly perfect codes are quasi-perfect ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 533).\nZetterberg codes are quasi-perfect, with each \\(n\\)-bit string at most three bit-flips away from a codeword [S. M. Dodunekov and J. E. M. Nilsson, \u201cAlgebraic decoding of the Zetterberg codes\u201d, IEEE Transactions on Information Theory 38, 1570 (1992). DOI].", "cousin_of_code_id": "bch", "cousin_of_detail": "Only double error-correcting BCH codes \\([2^m-1,n-2m,5]\\) are quasi-perfect [D. Gorenstein, W. W. Peterson, and N. Zierler, \u201cTwo-error correcting Bose-Chaudhuri codes are quasi-perfect\u201d, Information and Control 3, 291 (1960). DOI][T. Helleseth, \u201cNo primitive binary&amp;lt;tex&amp;gt;t&amp;lt;/tex&amp;gt;-error-correcting BCH code with&amp;lt;tex&amp;gt;t &amp;gt; 2&amp;lt;/tex&amp;gt;is quasi-perfect (Corresp.)\u201d, IEEE Transactions on Information Theory 25, 361 (1979). DOI] (see also Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 9).", "_type": "ecc", "_page_id": "c_quasi_perfect", "_href": "c/quasi_perfect"}, "c_perfect": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Perfect code", "code_id": "perfect", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "An \\((n,K,2t+1)_q\\) binary or \\(q\\)-ary code is perfect if parameters \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the Hamming (a.k.a. sphere-packing) bound \\begin{align}\n\\sum_{j=0}^{t}(q-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align} becomes an equality. For example, for a binary \\(q=2\\) code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\). Perfect codes are those for which balls of Hamming radius \\(t\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings.\n\nAny perfect linear code is either a repetition code, a Hamming code, or a binary or ternary Golay code [K. Lindstr\u00f6m, \u201cAll nearly perfect codes are known\u201d, Information and Control 35, 40 (1977). DOI]. If \\(q\\) is a prime power, any distance-three code is either a Hamming code or a nonlinear code with the same parameters; see Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], pg. 100, for more details.\n\nFor binary codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit, \\begin{align}\n\\frac{k}{n}\\leq 1-h(t/n),\n\\end{align} where \\(h\\) is the binary entropy function.", "parents_code_id": "covering\nnearly_perfect", "parents_detail": "Perfect codes are covering codes with minimum number of codewords\nPerfect codes are nearly perfect codes, and \\(t+1\\) divides \\(n-t\\) for such codes. In addition, any perfect code can be extended to a nearly perfect code.", "parent_of_code_id": "golay\nhamming\nternary_golay\nq-ary_hamming", "parent_of_detail": "The Golay code is perfect.\n\nThe ternary Golay code is perfect.\n", "cousin_of_code_id": "homological_classical\nquantum_perfect\nrepetition", "cousin_of_detail": "A family of homology codes saturate the asymptotic Hamming bound [H. Bombin and M. A. Martin-Delgado, \u201cHomological error correction: Classical and quantum codes\u201d, Journal of Mathematical Physics 48, 052105 (2007). DOI; quant-ph/0605094].\nA classical (quantum) perfect code saturates the classical (quantum) Hamming bound.\nRepetition codes are perfect for odd \\(n\\).", "_type": "ecc", "_page_id": "c_perfect", "_href": "c/perfect"}, "c_weighed_covering": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Weighed-covering code", "code_id": "weighed_covering", "realizations": "", "protection": "", "notes": "See book [G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.] for an expositions on weighed covering codes and generalized sphere-packing bounds.\nSee book [J. H. van Lint, Introduction to Coding Theory (Springer Berlin Heidelberg, 1992). DOI], Table 7.5.18 for tables of codes with particular weighed coverings.", "physical": "", "short_name": "", "introduced": "", "description": "A binary or \\(q\\)-ary code for which balls of some radius centered at its codewords provide a weighted covering of the Hamming space.\n\nLet the outer or weight distribution of a \\(q\\)-ary string \\(x\\) with respect to a \\(q\\)-ary code \\(C\\) be \\(A(x) = \\left( A_0(x),A_1(x),\\cdots,A_n(x) \\right)\\), where \\begin{align}\n  A_j(x) = \\left|\\{ c \\in C~\\text{such that}~ D(c,x)=j \\}\\right|~,\n\\end{align} and \\(D\\) is the Hamming distance. Given a tuple \\(m=(m_1,m_2,\\cdots,m_n)\\) of rational numbers, the \\(m\\)-density of the code at \\(x\\) is \\begin{align}\n  \\theta(x) = \\sum_{j=0}^n m_j A_j(x)~.\n\\end{align}\n\nA code is an \\(m\\)-weighed covering if \\(\\theta(x)\\geq1\\) for all strings \\(x\\in GF(q)^n\\). The \\(m\\)-covering radius \\(r\\) is the largest \\(j\\) for which \\(m_j\\) is nonzero.", "parents_code_id": "ecc_finite", "parents_detail": "", "parent_of_code_id": "covering\nquasi_perfect", "parent_of_detail": "An \\(m\\)-weighed covering code for \\(m_j=1\\) is a covering code of covering radius at most \\(r\\) ([G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.], Ch. 13).\nA quasi-perfect code is an \\(m\\)-weighed covering code for \\(r=t+1\\), \\(m_0=m_1=\\cdots=m_{t+1}=1\\), and \\(m_t=m_{t+1}=1/\\left\\lfloor (n+1)(t+1) \\right\\rfloor\\) ([G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, Covering codes. Elsevier, 1997.], Ch. 13).", "_type": "ecc", "_page_id": "c_weighed_covering", "_href": "c/weighed_covering"}, "c_nearly_perfect": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Nearly perfect code", "code_id": "nearly_perfect", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[J. M. Goethals and S. L. Snover, \u201cNearly perfect binary codes\u201d, Discrete Mathematics 3, 65 (1972). DOI][N. V. Semakov, V. A. Zinov'ev, G. V. Zaitsev, \u201cUniformly Packed Codes\u201d, Probl. Peredachi Inf., 7:1 (1971), 38\u201350; Problems Inform. Transmission, 7:1 (1971), 30\u201339]", "description": "An \\((n,K,2t+1)\\) binary code is nearly perfect if parameters \\(n\\), \\(K\\), and \\(t\\) are such that the Johnson bound \\begin{align}\n  \\frac{{n \\choose t}\\left(\\frac{n-t}{t+1}-\\left\\lfloor \\frac{n-t}{t+1}\\right\\rfloor \\right)}{\\left\\lfloor \\frac{n}{t+1}\\right\\rfloor }+\\sum_{j=0}^{t}{n \\choose j}\\leq2^{n}/K\n\\end{align} becomes an equality ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Sec. 2.3.5; see also Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 17). All nearly perfect binary codes are either perfect, or correspond to either punctured Preparata codes or one of the \\(2^r-2,2^{2^r-2-r},3)\\) codes for \\(r\\geq 3\\) [Kauko Lindstr\u00f6m. \"The nonexistence of unknown nearly perfect binary codes.\" PhD diss., Turun yliopisto, 1975.].\n\nSimilar definitions can be made for \\(q\\)-ary codes, but all nearly perfect \\(q\\)-ary codes must be perfect [K. Lindstrom and M. J. Aaltonen, \"The nonexistence of nearly perfect nonbinary codes for 1 =< e =< 10\", Ann. Univ. Turku, Ser. A I, No. 172, 1976.][K. Lindstr\u00f6m, \u201cAll nearly perfect codes are known\u201d, Information and Control 35, 40 (1977). DOI].", "parents_code_id": "quasi_perfect", "parents_detail": "Nearly perfect codes are quasi-perfect ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 533).", "parent_of_code_id": "perfect\nrepetition\nparity_check", "parent_of_detail": "Perfect codes are nearly perfect codes, and \\(t+1\\) divides \\(n-t\\) for such codes. In addition, any perfect code can be extended to a nearly perfect code.\n\n", "cousin_of_code_id": "golay\nhamming", "cousin_of_detail": "The extended Golay code is nearly perfect.\nShortened Hamming codes \\([2^r-2,2^r-r-2,3]\\) are nearly perfect ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 533).", "_type": "ecc", "_page_id": "c_nearly_perfect", "_href": "c/nearly_perfect"}, "c_cyclic": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Cyclic code", "code_id": "cyclic", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[E. Prange, Cyclic Error-Correcting Codes in Two Symbols, TN-57-/03, (September 1957)][E. Prange, Some cyclic error-correcting codes with simple decoding algorithms, TN-58-156, (April 1958)][E. Prange, The use of coset equivalence in the analysis and decoding of group codes, TN-59-/64, (1959)][E. Prange, An algorithm for factoring xn - I over a finite field. TN-59-/75, (October 1959)][W. W. Peterson and E. J. Weldon, Error-correcting codes. MIT press 1972.]", "description": "A code of length \\(n\\) over an alphabet is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword.\n\nCyclic-to-polynomial correspondence\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCyclic-to-polynomial correspondence: Binary and \\(q\\)-ary cyclic codes and their properties can be naturally formulated using the theory of polynomials. Cyclic codes correspond to ideals in a particular polynomial ring. Codewords \\(c_1 c_2 \\cdots c_n\\) of a \\(q\\)-ary Galois-field code can be thought of as coefficients in a polynomial \\(c_1+c_2 x+\\cdots+c_n x^{n-1}\\) in the set of polynomials with \\(q\\)-ary coefficients, \\(\\mathbb{F}_q[x]\\) with \\(\\mathbb{F}_q=GF(q)\\). Polynomials corresponding to codewords of a linear cyclic code form an ideal (i.e., are closed under multiplication and addition) in the ring \\(\\mathbb{F}_q[x]/(x^n-1)\\) (i.e., the set of equivalence classes of polynomials congruent modulo \\(x^n-1\\)). Multiplication of a codeword polynomial \\(c(x)\\) by \\(x\\) in such a ring corresponds to a cyclic shift of the corresponding codeword string.\n\nCodeword polynomials of a cyclic code can be generated, via multiplication, by a generator polynomial \\(g(x)\\). A particular generator polynomial \\(e(x)\\) has the additional property of being idempotent, i.e., \\(e(x)^2=e(x)\\). Given a generator polynomial, the corresponding check polynomial \\(h(x)=(x^n-1)/g(x)\\) yields zero when multiplying a codeword polynomial. Its coefficients correspond to the code's parity check matrix.\n\nSince the generator polynomial \\(g(x)\\) is a polynomial over \\(GF(q)\\), it can be factorized over some potentially larger splitting field (just like \\(x^2+1\\) can be factorized over the complex numbers but not the reals). Whenever \\(q\\) and \\(n\\) are relatively prime, cyclic codes can also be defined in terms of roots of \\(g(x)\\). Such roots are called zeroes of the code, and they are all powers of a primitive \\(n\\)th root of unity because \\(g(x)\\) is a divisor of \\(x^n-1\\). Since the generator polynomial generates all codeword polynomials \\(c(x)\\) by multiplication by \\(x\\), its zeroes are also zeroes of those polynomials.", "parents_code_id": "quasi_cyclic", "parents_detail": "Quasi-cyclic codes with \\(\\ell=1\\) are cyclic.", "parent_of_code_id": "q-ary_cyclic\nbinary_cyclic", "parent_of_detail": "\n", "cousin_of_code_id": "octacode\nquantum_cyclic", "cousin_of_detail": "The octacode is a cyclic code over \\(\\mathbb{Z}_4\\) with generator polynomial \\(x^2+3x^2+2x+3\\) extended by a parity check [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI].\n", "_type": "ecc", "_page_id": "c_cyclic", "_href": "c/cyclic"}, "c_skew_cyclic": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Only given for skew-BCH codes, adapted froom standard BCH codes.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Skew-cyclic code", "code_id": "skew_cyclic", "realizations": "Not directly implemented, but BCH codes form a subclass, and are used in DVD, solid state drive storage, etc.", "protection": "", "notes": "Computer algebra software is used to find most codes of this type. Ref. [Delphine Boucher, Willi Geiselmann, and F\u00e9lix Ulmer, \u201cSkew-cyclic codes\u201d. math/0604603] gives several examples of codes, which have slightly improved minimum distance for some \\((n,k)\\) codes.", "physical": "", "short_name": "", "introduced": "[Delphine Boucher, Willi Geiselmann, and F\u00e9lix Ulmer, \u201cSkew-cyclic codes\u201d. math/0604603]", "description": "A classical code \\(C\\) of length \\(n\\) over an alphabet \\(R\\) is skew-cyclic if there exists an automorphism, \\(\\theta\\), of \\(R\\), such that for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the skew-cyclically shifted string \\(\\theta(c_n) \\theta(c_1) \\cdots \\theta(c_{n-1})\\in C\\). We say that \\(C\\) is a \\(\\theta\\)-cyclic code over \\(R\\).", "parents_code_id": "quasi_cyclic", "parents_detail": "Under certain conditions, there is an equivalent quasi-cyclic code for every skew-cyclic code [I. Siap et al., \u201cSkew cyclic codes of arbitrary length\u201d, International Journal of Information and Coding Theory 2, 10 (2011). DOI].", "cousin_of_code_id": "skew-cyclic_galois_css", "cousin_of_detail": "Skew-cyclic CSS codes are constructed from classical skew-cylic codes.", "_type": "ecc", "_page_id": "c_skew_cyclic", "_href": "c/skew_cyclic"}, "c_quasi_cyclic": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quasi-cyclic code", "code_id": "quasi_cyclic", "realizations": "", "protection": "", "notes": "A database of quasi-cyclic codes with searchable parameters such as block length and dimension is constructed and displayed here.", "physical": "", "short_name": "", "introduced": "[R. Townsend and E. Weldon, \u201cSelf-orthogonal quasi-cyclic codes\u201d, IEEE Transactions on Information Theory 13, 183 (1967). DOI]", "description": "A code \\(C\\) of length \\(n\\) over an alphabet is quasi-cyclic if, for each codeword \\(c_1 \\cdots c_{\\ell} c_{\\ell+1} \\cdots c_n\\), the string \\(c_{n-\\ell+1} \\cdots c_n c_1 \\cdots c_{n-\\ell}\\) where each entry is cyclically shifted by \\(\\ell\\) increments is also a codeword.\n\nThe generator of an \\([mn_0,mk_0]\\) quasi-cyclic linear code is representable as a block matrix of \\(m \\times m\\) circulant matrices [Thomas A. Gulliver, Construction of quasi-cyclic codes, Thesis, University of New Brunswick, 1989.].", "parents_code_id": "ecc_finite", "parents_detail": "", "parent_of_code_id": "cyclic\nskew_cyclic", "parent_of_detail": "Quasi-cyclic codes with \\(\\ell=1\\) are cyclic.\nUnder certain conditions, there is an equivalent quasi-cyclic code for every skew-cyclic code [I. Siap et al., \u201cSkew cyclic codes of arbitrary length\u201d, International Journal of Information and Coding Theory 2, 10 (2011). DOI].", "cousin_of_code_id": "quantum_quasi_cyclic", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_quasi_cyclic", "_href": "c/quasi_cyclic"}, "c_parallel_concatenated": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Parallel concatenated code", "code_id": "parallel_concatenated", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "", "description": "Stub.", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "tanner", "parent_of_detail": "", "cousins_code_id": "concatenated", "cousins_detail": "", "_type": "ecc", "_page_id": "c_parallel_concatenated", "_href": "c/parallel_concatenated"}, "c_generalized_concatenated": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Generalized concatenated code", "code_id": "generalized_concatenated", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "", "description": "Stub.", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "concatenated\njustesen\npolar\ntensor", "parent_of_detail": "\nJustesen codes can be considered as a generalized concatenation of a Reed-Solomon outer code with \\(N\\) distinct binary inner codes.\nPolar codes can be represented as generalized concatenations of their kernels.\n", "_type": "ecc", "_page_id": "c_generalized_concatenated", "_href": "c/generalized_concatenated"}, "c_concatenated": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Generalized minimum-distance decoding [G. Forney, \u201cGeneralized minimum distance decoding\u201d, IEEE Transactions on Information Theory 12, 125 (1966). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Concatenated code", "code_id": "concatenated", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[G. D. Forney, Jr (1966). Concatenated Codes. MIT Press, Cambridge, MA.]", "description": "Also called a serially concatenated code [A. Barg and G. Zemor, \u201cConcatenated Codes: Serial and Parallel\u201d, IEEE Transactions on Information Theory 51, 1625 (2005). DOI]. Stub.", "parents_code_id": "generalized_concatenated", "parents_detail": "", "cousins_code_id": "quantum_concatenated", "cousins_detail": "", "cousin_of_code_id": "parallel_concatenated", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_concatenated", "_href": "c/concatenated"}, "c_codes_with_availability": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Availability code", "code_id": "codes_with_availability", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Stub.", "parents_code_id": "parallel_recovery", "parents_detail": "", "_type": "ecc", "_page_id": "c_codes_with_availability", "_href": "c/codes_with_availability"}, "c_parallel_recovery": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Parallel-recovery code", "code_id": "parallel_recovery", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Stub.", "parents_code_id": "sequential_recovery", "parents_detail": "", "parent_of_code_id": "codes_with_availability", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_parallel_recovery", "_href": "c/parallel_recovery"}, "c_distributed_storage": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Distributed-storage code", "code_id": "distributed_storage", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "", "description": "Designed to encode information into spatial nodes such that it is possible to recover said information after failure of some nodes by accessing the remaining nodes with minimal bandwidth. Stub.", "parents_code_id": "ecc_finite", "parents_detail": "", "parent_of_code_id": "locally_recoverable\nregenerating", "parent_of_detail": "\n", "cousin_of_code_id": "fountain\ngeneralized_reed_solomon", "cousin_of_detail": "There are proposals [Megasthenis Asteris and Alexandros G. Dimakis, \u201cRepairable Fountain Codes\u201d. 1401.0734][Michael G. Luby et al., \u201cLiquid Cloud Storage\u201d. 1705.07983] adapting fountain codes to distributed storage systems.\nGRS codes are used in various cloud storage systems [H. Dau et al., \u201cRepairing Reed-Solomon Codes With Multiple Erasures\u201d, IEEE Transactions on Information Theory 64, 6567 (2018). DOI; 1612.01361].", "_type": "ecc", "_page_id": "c_distributed_storage", "_href": "c/distributed_storage"}, "c_sequential_recovery": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Sequential-recovery code", "code_id": "sequential_recovery", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Stub.", "parents_code_id": "locally_recoverable", "parents_detail": "", "parent_of_code_id": "parallel_recovery", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_sequential_recovery", "_href": "c/sequential_recovery"}, "c_locally_recoverable": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The rate \\(r\\) of an \\((n,k,r)\\) LRC code satisfies \\begin{align} \\frac{k}{n}\\leq\\frac{r}{r+1}~. \\end{align}", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Locally recoverable code (LRC)", "code_id": "locally_recoverable", "realizations": "An \\((18,14,7)\\) LRC code has beed used in the Windows Azure cloud storage system [C. Huang, H. Simitci, Y. Xu, A. Ogus, B. Calder, P. Gopalan, J. Li, and S. Yekhanin. Erasure coding in Windows Azure Storage. In Proc. USENIX Annual Technical Conference (ATC), pgs. 15-26, Boston, Massachusetts, June 2012.]; see also Sec. 31.3.1.2 in Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI].", "protection": "The distance, \\(d\\), of an \\((n,k,r)\\) LRC code satisfies \\begin{align} d\\leq n-k-\\left \\lceil\\frac{k}{r}\\right \\rceil+2~,\\label{eq:gen-singleton} \\end{align} where \\(r\\leq k\\). When \\(k=r\\), the bound on the distance gives the Singleton bound. The generalized Singleton bound \\(\\eqref{eq:gen-singleton}\\) does not account for \\(q\\)-ary alphabet size. A more generalized bound (including the non-linear case) is given in Ref. [V. R. Cadambe and A. Mazumdar, \u201cBounds on the Size of Locally Recoverable Codes\u201d, IEEE Transactions on Information Theory 61, 5787 (2015). DOI].", "notes": "", "physical": "", "short_name": "LRC", "introduced": "", "description": "Any code for which, given a codeword \\(x\\) and coordinate \\(i\\), \\(x_i\\) can be recovered from (at most \\(r\\)) other coordinates of \\(x\\). An \\(r\\)-locally recoverable code of length \\(n\\) and dimension \\(k\\) is denoted as an \\((n,k,r)\\) LRC code.\n\nMore technically, a \\(q\\)-ary code \\(C\\) with length \\(n\\) is \\(r\\)-locally recoverable, or has locality \\(r\\), if \\(\\forall i \\in [n]\\), there exists \\(I_i \\subset [n]\\setminus i\\) such that \\(|I_i|\\leq r\\), and the projection of the set \\(\\mathcal{C}(i,a)=\\{x\\in C : x_i=a\\}\\) on to the coordinates in \\(I_i\\), i.e., \\(\\mathcal{C}_{I_i}(i,a)\\) is disjoint from \\(\\mathcal{C}_{I_i}(i,a^\\prime)\\) where \\(a\\neq a^\\prime\\).\n\nThe definition can be generalized to \\(t\\)-LRC code, if every coordinate is recoverable from \\(t\\) disjoint subsets of coordinates. A study on the parameters of \\(t\\)-LRC codes, together with known bounds, can be found in Ref. [I. Tamo, A. Barg, and A. Frolov, \u201cBounds on the Parameters of Locally Recoverable Codes\u201d, IEEE Transactions on Information Theory 62, 3070 (2016). DOI].", "parents_code_id": "distributed_storage", "parents_detail": "", "parent_of_code_id": "batch\nmds\nsequential_recovery", "parent_of_detail": "A systematic batch code with restricted size of reconstruction sets can recover any query of \\(t\\) information symbols with recovery sets of size \\(r\\) [V. Skachek, \u201cBatch and PIR Codes and Their Connections to Locally Repairable Codes\u201d, Network Coding and Subspace Designs 427 (2018). DOI][A.-E. Riet, V. Skachek, and E. K. Thomas, \u201cBatch Codes for Asynchronous Recovery of Data\u201d, IEEE Transactions on Information Theory 68, 1545 (2022). DOI].\nMDS codes are most efficient in terms of minimizing storage overhead for handling erasures. They are locally recoverable with locality \\(k\\).\n", "_type": "ecc", "_page_id": "c_locally_recoverable", "_href": "c/locally_recoverable"}, "c_balanced": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Efficient encoder [D. Knuth, \u201cEfficient balanced codes\u201d, IEEE Transactions on Information Theory 32, 51 (1986). DOI].", "features_decoders": "Efficient decoder [D. Knuth, \u201cEfficient balanced codes\u201d, IEEE Transactions on Information Theory 32, 51 (1986). DOI][S. Al-Bassam and B. Bose, \u201cOn balanced codes\u201d, IEEE Transactions on Information Theory 36, 406 (1990). DOI][K. A. Schouhamer Immink and J. H. Weber, \u201cVery Efficient Balanced Codes\u201d, IEEE Journal on Selected Areas in Communications 28, 188 (2010). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Balanced code", "code_id": "balanced", "realizations": "Balanced length-eight code, known as a 6b/8b encoding, used for balancing direct current in a communications system [K. A. S. Immink. Codes for mass data storage systems. Shannon Foundation Publisher, 2004.]", "protection": "Can detect unidirectional errors, such as a zero going to a one.", "notes": "", "physical": "", "short_name": "", "introduced": "[D. Knuth, \u201cEfficient balanced codes\u201d, IEEE Transactions on Information Theory 32, 51 (1986). DOI]", "description": "An even-length-\\(n\\) binary or \\(q\\)-ary code whose nonzero codewords all have a Hamming weight of \\(n/2\\). A code is \\(\\epsilon\\)-balanced if the relative weight (i.e., weight divided by \\(n\\)) of all nonzero codewords lies in the interval \\([\\frac{1-\\epsilon}{2},\\frac{1+\\epsilon}{2}]\\). A code is \\(\\gamma\\)-unbiased if the relative weight lies in the interval \\((\\frac{1}{2}-\\frac{1}{n^{\\gamma}},\\frac{1}{2}+\\frac{1}{n^{\\gamma}})\\). ", "parents_code_id": "constant_weight", "parents_detail": "", "parent_of_code_id": "hadamard", "parent_of_detail": "Each Hadamard codeword has length \\(2^m\\) and Hamming weight of \\(2^{m-1}\\), making this code balanced.", "cousins_code_id": "ltc", "cousins_detail": "Random low-rate unbiased linear codes are LTCs [S. Kopparty and S. Saraf, \u201cLocal list-decoding and testing of random linear codes from high error\u201d, Proceedings of the 42nd ACM symposium on Theory of computing - STOC '10 (2010). DOI].", "cousin_of_code_id": "ta-shma", "cousin_of_detail": "Ta-Shma codes are \\(\\epsilon\\)-balanced.", "_type": "ecc", "_page_id": "c_balanced", "_href": "c/balanced"}, "c_divisible": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Divisible code", "code_id": "divisible", "realizations": "", "protection": "", "notes": "See Ref. [K. Betsumiya and A. Munemasa, \u201cOn triply even binary codes\u201d, Journal of the London Mathematical Society 86, 1 (2012). DOI; 1012.4134] for an introduction to triply even binary linear codes and their construction from doubly even codes.", "physical": "", "short_name": "", "introduced": "[H. N. Ward, \u201cDivisible codes\u201d, Archiv der Mathematik 36, 485 (1981). DOI]", "description": "A linear binary or \\(q\\)-ary code is \\(\\Delta\\)-divisible if the Hamming weight of each of its codewords is divisible by divisor \\(\\Delta\\). A \\(2\\)-divisible (\\(4\\)-divisible) code is called even (doubly even) [Sascha Kurz, \u201cDivisible Codes\u201d. 2112.11763]. A code is called singly even if all codewords are even and at least one has weight equal to 2 modulo 4.", "parents_code_id": "linear", "parents_detail": "", "parent_of_code_id": "constant_weight\nreed_muller\nparity_check", "parent_of_detail": "Codes whose codewords have a constant weight of \\(m\\) are automatically \\(m\\)-divisible.\nAn RM\\((r,m)\\) code is \\(2^{\\left\\lceil m/r\\right\\rceil-1}\\)-divisible, according to McEliece's theorem [R. J. McEliece, \u201cOn periodic sequences from GF(q)\u201d, Journal of Combinatorial Theory, Series A 10, 80 (1971). DOI][R. J. McEliece, \u201cWeight congruences for p-ary cyclic codes\u201d, Discrete Mathematics 3, 177 (1972). DOI].\nBinary SPCs are two-divisible.", "cousin_of_code_id": "dual\ngriesmer\nquantum_divisible\nternary_golay", "cousin_of_detail": "Binary self-dual codes are singly-even.\nGriesmer codes over prime fields are divisible [H. N. Ward, \u201cDivisibility of Codes Meeting the Griesmer Bound\u201d, Journal of Combinatorial Theory, Series A 83, 79 (1998). DOI].\nQuantum divisible codes are constructed via the CSS construction using a divisible linear binary code.\nExtended ternary Golay code is 3-divisible ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 296).", "_type": "ecc", "_page_id": "c_divisible", "_href": "c/divisible"}, "c_constant_weight": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Constant-weight code", "code_id": "constant_weight", "realizations": "Radio-network frequency hopping [D. H. Smith, L. A. Hughes, and S. Perkins, \u201cA New Table of Constant Weight Codes of Length Greater than 28\u201d, The Electronic Journal of Combinatorics 13, (2006). DOI].", "protection": "", "notes": "Tables of binary constant-weight codes for \\(n \\leq 28\\) [A. E. Brouwer et al., \u201cA new table of constant weight codes\u201d, IEEE Transactions on Information Theory 36, 1334 (1990). DOI] and \\(n > 28\\) [D. H. Smith, L. A. Hughes, and S. Perkins, \u201cA New Table of Constant Weight Codes of Length Greater than 28\u201d, The Electronic Journal of Combinatorics 13, (2006). DOI].\nSee book [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for (Johnson) bounds on the size of constant-weight codes.", "physical": "", "short_name": "", "introduced": "", "description": "Also known as an \\(m\\)-in-\\(n\\) or \\({n \\choose m}\\) code. A linear binary or \\(q\\)-ary code whose codewords all have the same Hamming weight. ", "parents_code_id": "divisible", "parents_detail": "Codes whose codewords have a constant weight of \\(m\\) are automatically \\(m\\)-divisible.", "parent_of_code_id": "balanced\none_hot\nsimplex\nweight_two", "parent_of_detail": "\n\nAll non-zero simplex codewords have a constant weight of \\(q^{k-1}\\).\n", "cousins_code_id": "constant_excitation", "cousins_detail": "Constant-weight codes are classical analogues of qubit constant-excitation codes.", "cousin_of_code_id": "points_into_spheres", "cousin_of_detail": "Any \\((n,K,d)\\) code of constant weight \\(w\\) can be converted into an \\((n-1,K,\\frac{nd}{nw-w^2})\\) spherical code [T. Ericson, and V. Zinoviev, eds. Codes on Euclidean spheres. Elsevier, 2001.; Example 1.2.2].", "_type": "ecc", "_page_id": "c_constant_weight", "_href": "c/constant_weight"}, "c_rings_into_rings": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Ring code", "code_id": "rings_into_rings", "realizations": "", "protection": "", "notes": "", "physical": "rings", "short_name": "", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates over a ring \\(R\\).", "parents_code_id": "ecc_finite", "parents_detail": "", "parent_of_code_id": "rings_linear", "parent_of_detail": "", "cousin_of_code_id": "group_classical", "cousin_of_detail": "Group-based codes whose alphabet is based on the ring \\(R\\), taken to be an abelian group under addition, are codes over \\(R\\).", "_type": "ecc", "_page_id": "c_rings_into_rings", "_href": "c/rings_into_rings"}, "c_q-ary_over_zq": {"logical": "rings", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(q\\)-ary code over \\(\\mathbb{Z}_q\\)", "code_id": "q-ary_over_zq", "realizations": "", "protection": "", "notes": "", "physical": "rings", "short_name": "", "introduced": "", "description": "A linear code encoding \\(K\\) states (codewords) in \\(n\\) coordinates over the ring \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\).", "parents_code_id": "rings_linear", "parents_detail": "", "parent_of_code_id": "quaternary_over_z4", "parent_of_detail": "", "cousin_of_code_id": "psk", "cousin_of_detail": "Concatenating linear codes over \\(\\mathbb{Z}_q\\) with \\(q\\)-ary PSK yields a natural non-binary way of digitizing the analog AGWN channel [Massey, J. L. \"Convolutional codes over rings.\" Fourth Joint Swedish-Soviet International Workshop on Information Theory. 1989.][Massey, J. L. \"Ring convolutional codes for phase modulation.\" presented at the IEEE Int. Symp. on Information Theory, San Diego, CA, Jan. 14-19. 1990.].", "_type": "ecc", "_page_id": "c_q-ary_over_zq", "_href": "c/q-ary_over_zq"}, "c_quaternary_over_z4": {"logical": "rings", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quaternary code over \\(\\mathbb{Z}_4\\)", "code_id": "quaternary_over_z4", "realizations": "", "protection": "", "notes": "Code Database, including quasi-cyclic and quasi-twisted codes [Nuh Aydin, Yiang Lu, and Vishad R. Onta, \u201cAn Updated Database of $\\mathbb{Z}_4$ Codes\u201d. 2208.06832].", "physical": "rings", "short_name": "", "introduced": "", "description": "A linear code encoding \\(K\\) states (codewords) in \\(n\\) coordinates over the ring \\(\\mathbb{Z}_4\\) of integers modulo 4.", "parents_code_id": "q-ary_over_zq", "parents_detail": "", "parent_of_code_id": "octacode\nreed_muller", "parent_of_detail": "\nRM codes are images of ring-linear quaternary codes under the Gray map ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 6.3).", "_type": "ecc", "_page_id": "c_quaternary_over_z4", "_href": "c/quaternary_over_z4"}, "c_octacode": {"logical": "rings", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Octacode", "code_id": "octacode", "realizations": "", "protection": "", "notes": "", "physical": "rings", "short_name": "", "introduced": "[J. H. Conway and N. J. A. Sloane, \u201cSelf-dual codes over the integers modulo 4\u201d, Journal of Combinatorial Theory, Series A 62, 30 (1993). DOI][J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI][E. M. Rains and N. J. A. Sloane, \u201cSelf-Dual Codes\u201d. math/0208001]", "description": "The unique self-dual linear code of length 8 over \\(\\mathbb{Z}_4\\) with generator matrix \\begin{align}\n  \\begin{pmatrix}\n  3 & 3 & 2 & 3 & 1 & 0 & 0 & 0\\\\\n  3 & 0 & 3 & 2 & 3 & 1 & 0 & 0\\\\\n  3 & 0 & 0 & 3 & 2 & 3 & 1 & 0\\\\\n  3 & 0 & 0 & 0 & 3 & 2 & 3 & 1\n  \\end{pmatrix}\\,.\n\\end{align} ", "parents_code_id": "quaternary_over_z4", "parents_detail": "", "cousins_code_id": "cyclic\nhamming\ndual_additive", "cousins_detail": "The octacode is a cyclic code over \\(\\mathbb{Z}_4\\) with generator polynomial \\(x^2+3x^2+2x+3\\) extended by a parity check [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI].\nThe octacode reduces modulo-two to the \\([8,4,4]\\) Hamming code [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI].\nThe octacode is self-dual with respect to the Euclidean inner product.", "_type": "ecc", "_page_id": "c_octacode", "_href": "c/octacode"}, "c_rings_linear": {"logical": "rings", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(R\\)-linear code", "code_id": "rings_linear", "realizations": "", "protection": "", "notes": "", "physical": "rings", "short_name": "", "introduced": "", "description": "A code of length \\(n\\) over a ring \\(R\\) is \\(R\\)-linear if it is a submodule of \\(R^n\\).", "parents_code_id": "rings_into_rings\nlinear", "parents_detail": "\n", "parent_of_code_id": "q-ary_over_zq", "parent_of_detail": "", "cousin_of_code_id": "group_linear", "cousin_of_detail": "Linear codes over \\(G=R\\) are linear codes over \\(R\\) since rings are abelian groups under addition.", "_type": "ecc", "_page_id": "c_rings_linear", "_href": "c/rings_linear"}, "c_convolutional": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Depends on the polynomials used. Using puncturing removal [L. Sari, \u201cEffects of Puncturing Patterns on Punctured Convolutional Codes\u201d, TELKOMNIKA (Telecommunication, Computing, Electronics and Control) 10, (2012). DOI] the rate for the code can be increased from \\(\\frac{1}{t}\\) to \\(\\frac{s}{t}\\), where \\(t\\) is the number of output bits, and \\(s\\) depends on the puncturing done. This is done by deleting some pieces of the encoder output such that the most-likely decoders remain effective", "features_magic_scaling_exponent": "", "features_encoders": "Evaluation on the generator polynomials. Can be implemented with a small number of XOR gates", "features_decoders": "Decoders based on the Viterbi algorithm (trellis decoding) were developed first, which result in the most-likely codeword for the encoded bits [A. Viterbi, \u201cError bounds for convolutional codes and an asymptotically optimum decoding algorithm\u201d, IEEE Transactions on Information Theory 13, 260 (1967). DOI]. Following, other trellis decoders such as the BCJR decoding algorithm [L. Bahl et al., \u201cOptimal decoding of linear codes for minimizing symbol error rate (Corresp.)\u201d, IEEE Transactions on Information Theory 20, 284 (1974). DOI] were developed later.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Convolutional code", "code_id": "convolutional", "realizations": "A type of convolutional code used in Real-time Application networks [S. I. Mrutu, A. Sam, and N. H. Mvungi, \u201cForward Error Correction Convolutional Codes for RTAs' Networks: An Overview\u201d, International Journal of Computer Network and Information Security 6, 19 (2014). DOI].\nMobile and radio communications (3G networks) use convolutional codes concatenated with Reed-Solomon codes to obtain suitable performance [T. Halonen, J. Romero, and J. Melero, editors , GSM, GPRS and EDGE Performance (Wiley, 2003). DOI].\nA convolutional code with rate 1/2 was used for deep-space and satellite communication [Butman, Deutsch, and Miller. Performance of concatenated codes for deep space missions. 1981.]", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[Peter Elias. Coding for noisy channels. IRE Convention Records, 3(4):37\u201346, 1955.]", "description": "Classical codes that are formed using generator polynomials over the finite field with two elements. The encoder slides across contiguous subsets of the input bit-string (like a convolutional neural network) evaluating the polynomials on that window to obtain a number of parity bits. These parity bits are the encoded information. There are many ways to formulate these codes", "parents_code_id": "bits_into_bits", "parents_detail": "", "cousins_code_id": "quantum_convolutional\nreed_solomon", "cousins_detail": "Quantum analogue of convolutional codes\nConvolutional codes are often used in concatenation with Reed-Solomon codes for communication [T. Halonen, J. Romero, and J. Melero, editors , GSM, GPRS and EDGE Performance (Wiley, 2003). DOI].", "_type": "ecc", "_page_id": "c_convolutional", "_href": "c/convolutional"}, "c_tanner": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "For a short code \\(C_0\\) with rate \\(R_0\\), the Tanner code has rate \\(R \\geq 2R_0-1\\). If \\(C_0\\) satisfies the Gilbert-Varshamov bound, the rate \\(R \\geq \\delta = 1-2h(\\delta_0)\\), where \\(\\delta\\) (\\(\\delta_0\\)) is the relative distance of the Tanner code (\\(C_0\\)), and \\(h\\) is the binary entropy function.", "features_magic_scaling_exponent": "", "features_encoders": "Quadratic algorithm: This technique works for all linear block codes and encodes using matrix multiplication [J. D. Lafferty and D. N. Rockmore, \u201cSpectral techniques for expander codes\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI].\nUsing the non-Abelian Fast Fourier Transform and exploiting the symmetry of the underlying graph, an encoding algorithm that requires \\(O(n^{4/3})\\) has been devised in [J. D. Lafferty and D. N. Rockmore, \u201cSpectral techniques for expander codes\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI].\nA modified construction yields codes that may be encoded in linear time yet maintain similar performance [D. A. Spielman, \u201cLinear-time encodable and decodable error-correcting codes\u201d, IEEE Transactions on Information Theory 42, 1723 (1996). DOI].", "features_decoders": "Parallel decoding algorithm corrects a fraction \\(\\delta_0^2/48\\) of errors for Tanner codes [M. Sipser and D. A. Spielman, \u201cExpander codes\u201d, IEEE Transactions on Information Theory 42, 1710 (1996). DOI]. A modification of said algorithm improves the fraction to \\(\\delta_0^2/4\\) with no extra cost to complexity [G. Zemor, \u201cOn expander codes\u201d, IEEE Transactions on Information Theory 47, 835 (2001). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Tanner code", "code_id": "tanner", "realizations": "", "protection": "Tanner Codes protect against noise on classical bit strings. If \\(C_0\\) is an \\([d, d-t,d'> d(\\gamma_0 +\\frac{\\lambda}{d})]_2\\) code and G is an \\((N, M, 2, d, \\rho,\\alpha)\\)- expander where \\(\\rho = \\gamma_0 (\\gamma_0 +\\frac{\\lambda}{d})\\), then the Tanner Code \\(T(G, C_0)\\) has rate \\(1-\\frac{M}{N}t\\) and relative distance \\(\\geq \\gamma_0(\\gamma_0+\\frac{\\lambda}{d})\\).", "notes": "", "physical": "bits", "short_name": "", "introduced": "[R. Tanner, \u201cA recursive approach to low complexity codes\u201d, IEEE Transactions on Information Theory 27, 533 (1981). DOI]", "description": "Binary linear code defined on edges on a regular graph \\(G\\) such that each subsequence of bits corresponding to edges in the neighborhood any vertex belong to some short binary linear code \\(C_0\\). Expansion properties of the underlying graph can yield efficient decoding algorithms.\n\nMore technically, let \\(G(V,E)\\) be a \\(\\Delta\\)-regular (not necessarily bipartite) graph with number of vertices \\(|V| = n \\) and number of edges \\(|E| = N = n\\Delta/2\\). Let \\(C_0\\) be a linear binary code of length \\(\\Delta\\) and rate \\(R_0\\). The Tanner code \\(T(G,C_0)\\), whose bits are placed on edges of the graph, consists of the following codewords: \\begin{align}\n\\left\\{ c \\in GF(2)^{n}\\,\\text{s.t. }\\forall v\\in V,\\left.c\\right|_{N(v)}\\in C_{0}\\right\\} ~,\n\\end{align} where \\(\\left.c\\right|_{N(v)}\\) is the subsequence formed by the \\(\\Delta\\) bits located on the neighbors \\(N(v)\\) of the vertex \\(v\\). The dimension of \\(T\\) is at least \\(N -n(\\Delta -\\Delta R_0) = N(2R_0-1)\\geq 0\\) whenever \\(R_0 \\geq \\frac{1}{2}\\). ", "parents_code_id": "binary_linear\nparallel_concatenated", "parents_detail": "\n", "parent_of_code_id": "expander", "parent_of_detail": "", "cousin_of_code_id": "dhlv\nexpander_lifted_product\nquantum_tanner", "cousin_of_detail": "Tanner codes are used in constructing quantum DHLV codes.\nExpander lifted-product codes are products of \\(q\\)-ary Tanner codes defined on expander graphs.\nTanner codes are used in constructing quantum Tanner codes.", "_type": "ecc", "_page_id": "c_tanner", "_href": "c/tanner"}, "c_levenshtein": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Levenshtein code", "code_id": "levenshtein", "realizations": "", "protection": "Levenshtein codes meet the Plotkin bound \\(K\\leq 2\\left\\lfloor\\frac{d}{2d-n}\\right\\rfloor\\), where \\(K\\) is the number of codewords, \\(d\\) is the distance, and \\(n\\) is the length, and with the assumption that the Hadamard matrices for such parameters exist. The general proof depends on the correctness of Hadamard's conjecture [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.].", "notes": "", "physical": "bits", "short_name": "", "introduced": "[V.I. Levenshtein, Application of Hadamard matrices to a problem in coding theory, Problems of Cybernetics, vol. 5, GIFML, Moscow, 1961, 125\u2013136.]", "description": "Binary codes constructed from combining two codes \\(A'\\) constructed out of Hadamard matrices.\n\nLet \\(H_n\\) be a normalized Hadamard matrix. The generator matrix for an \\((n-1,n,n/2)\\) code \\(A_n\\) is obtained by taking \\(H_n\\), replacing the +1's by 0's and the -1's by 1's, and deleting the first column. Taking only the codewords of \\(A_n\\) which begin with 0 and deleting the leading 0 yields the generator matrix of an \\((n-2,n/2,n/2)\\) code \\(A_n'\\).\n\nNext, apply the following way of combining codes. Suppose we have an \\((n_1,M_1,d_1)\\) code \\(C_1\\) and an \\((n_2,M_2,d_2)\\) code \\(C_2\\). The combined \\((an_1+bn_2,\\min(M_1,M_2),ad_1+bd_2)\\) code \\(a C_1\\bigoplus b C_2\\) may be constructed by pasting \\(a\\) copies of \\(C_1\\) and \\(b\\) copies of \\(C_2\\) together and omitting the last \\(|M_1-M_2|\\) rows. Applying this to construct a Levenshtein code with length \\(n\\) and distance \\(d\\), define \\(k=\\lfloor d/(2d-n)\\rfloor\\), \\(a=d(2k+1)-n(k+1)\\), and \\(b=kn-d(2k-1)\\). If \\(n\\) is even, construct \\(\\frac{a}{2}A_{4k}'\\bigoplus\\frac{b}{2}A_{4k+4}'\\). If \\(n\\) is odd and \\(k\\) is even, construct \\(aA_{2k}\\bigoplus\\frac{b}{2}A_{4k+4}'\\). If \\(n\\) is odd and \\(k\\) is odd, construct \\(\\frac{a}{2}A_{4k}'\\bigoplus b A_{2k+2}\\).", "parents_code_id": "bits_into_bits", "parents_detail": "", "_type": "ecc", "_page_id": "c_levenshtein", "_href": "c/levenshtein"}, "c_polar": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Supports reliable transmission at rates \\(K/N\\) approaching the Shannon capacity of the channel under the successive cancellation decoder [E. Arikan, \u201cChannel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels\u201d, IEEE Transactions on Information Theory 55, 3051 (2009). DOI].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Successive cancellation (SC) decoder [E. Arikan, \u201cChannel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels\u201d, IEEE Transactions on Information Theory 55, 3051 (2009). DOI].\nSuccessive cancellation list (SCL) decoder [I. Tal and A. Vardy, \u201cList Decoding of Polar Codes\u201d, IEEE Transactions on Information Theory 61, 2213 (2015). DOI] and a modification utilizing sequence repetition (SR-List) [Yuqing Ren et al., \u201cA Sequence Repetition Node-Based Successive Cancellation List Decoder for 5G Polar Codes: Algorithm and Implementation\u201d. 2205.08857].\nSoft cancellation (SCAN) decoder [U. U. Fayyaz and J. R. Barry, \u201cLow-Complexity Soft-Output Decoding of Polar Codes\u201d, IEEE Journal on Selected Areas in Communications 32, 958 (2014). DOI][U. U. Fayyaz and J. R. Barry, \u201cPolar codes for partial response channels\u201d, 2013 IEEE International Conference on Communications (ICC) (2013). DOI].\nBelief propagation (BP) decoder [E. Arkan, \u201cA performance comparison of polar codes and Reed-Muller codes\u201d, IEEE Communications Letters 12, 447 (2008). DOI].\nNoisy quantum gate-vased decoder [Srikar Kasi et al., \u201cDecoding Polar Codes via Noisy Quantum Gates: Quantum Circuits and Insights\u201d. 2210.10854].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Polar code", "code_id": "polar", "realizations": "Code control channels for the 5G NR (New Radio) interfaces [3rd Generation Partnership Project (3GPP), Technical specification group radio access network, 3GPP TS 38.212 V.15.0.0, 2017.].", "protection": "Protects against various types of noise in the communication channel, for instance, errors, erasures, or other types of noise. Distance plays no role in the analysis of its properties, and is much lower than the largest possible value given \\(K,N\\).", "notes": "For more details, see Ch. 32 of Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI].\nSee Kaiserslautern database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.\nSee pretty-good-codes database [G. Liva, F. Steiner. \u201cpretty-good-codes.org: Online library of good channel codes\u201d, URL: http://pretty-good-codes.org/] for explicit representatives and benchmarking.\nCodes have been benchmarked using AFF3CT toolbox [A. Cassagne et al., \u201cAFF3CT: A Fast Forward Error Correction Toolbox!\u201d, SoftwareX 10, 100345 (2019). DOI].", "physical": "bits", "short_name": "", "introduced": "[E. Arikan, \u201cChannel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels\u201d, IEEE Transactions on Information Theory 55, 3051 (2009). DOI]", "description": "In its basic version, a binary linear polar code encodes \\(K\\) message bits into \\(N=2^n\\) bits. The linear transformation that defines the code is given by the matrix \\(G^{(n)}=B_N G^{\\otimes n}\\), where \\(B_N\\) is a certain \\(N\\times N\\) permutation matrix, and \\(G^{\\otimes n}\\) is the \\(n\\)th Kronecker power of the \\(2\\times 2\\) kernel matrix \\(G=\\left[\\begin{smallmatrix}1 & 0\\\\ 1 & 1 \\end{smallmatrix}\\right]\\). To encode \\(K\\) message bits, one forms an \\(N\\)-vector \\(u\\) in which \\(K\\) coordinates represent the message bits. The remaining \\(N-K\\) coordinates are set to some fixed values and are said to be frozen. The codeword \\(x \\in \\{0,1\\}^N\\) is obtained as \\(x=u G^{\\otimes n}\\).\n\nThe choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.\n\nThere are multiple variants of the above basic construction, in particular relying on other kernel matrices. The codes can be defined for nonbinary alphabets, and they can be adjusted to support tasks such as lossless and lossy compression, successive refinement, communication over the mulitple access channel, communication over the wiretap channel, and many others.", "parents_code_id": "generalized_concatenated", "parents_detail": "Polar codes can be represented as generalized concatenations of their kernels.", "cousins_code_id": "reed_muller\npolar_for_quantum", "cousins_detail": "RM codes rely on the same generator matrix, but place message bits in different coordinates.\nQuantum-classical polar codes generalize polar codes for transmission through channels with quantum output.", "cousin_of_code_id": "quantum_polar", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_polar", "_href": "c/polar"}, "c_justesen": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The first asymptotically good codes. Rate is \\(R_m=k/n=K/2N\\geq R\\) and the relative minumum distance satisfy \\(\\delta_m=d_m/n\\geq 0.11(1-2R)\\), where \\(K=\\left\\lceil 2NR\\right\\rceil\\) for asymptotic rate \\(0<R<1/2\\); see pg. 311 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.].\n\nThe code can be improved and extend the range of \\(R\\) from 0 to 1 by puncturing, i.e., by erasing \\(s\\) digits from each inner codeword. This yields a code of length \\(n=(2m-s)N\\) and rate \\(R=mk/(2m-s)N\\). The lower bound of the distance of the punctured code approaches \\(d_m/n=(1-R/r)H^{-1}(1-r)\\) as \\(m\\) goes to infinity, where \\(r\\) is the maximum of 1/2 and the solution to \\(R=r^2/(1+\\log(1-h^{-1}(1-r)))\\), and \\(h\\) is the binary entropy function.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Generalized minimum distance decoding [J. Justesen, \u201cClass of constructive asymptotically good algebraic codes\u201d, IEEE Transactions on Information Theory 18, 652 (1972). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Justesen code", "code_id": "justesen", "realizations": "Generating small-bias sample spaces, i.e., probability distributions that parity functions cannot typically distinguish from the uniform distribution [J. Naor and M. Naor, \u201cSmall-bias probability spaces: efficient constructions and applications\u201d, Proceedings of the twenty-second annual ACM symposium on Theory of computing - STOC '90 (1990). DOI].", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[J. Justesen, \u201cClass of constructive asymptotically good algebraic codes\u201d, IEEE Transactions on Information Theory 18, 652 (1972). DOI]", "description": "Binary linear code resulting from generalized concatenation of a Reed-Solomon (RS) outer code with multiple inner codes sampled from the Wozencraft ensemble, i.e., \\(N\\) distinct binary inner codes of dimension \\(m\\) and length \\(2m\\). Justesen codes are parameterized by \\(m\\), with length \\(n=2mN\\) and dimension \\(k=mK\\), where \\((N=2^m-1,K)\\) is the RS outer code over \\(GF(2^m)\\).", "parents_code_id": "binary_linear\ngeneralized_concatenated", "parents_detail": "\nJustesen codes can be considered as a generalized concatenation of a Reed-Solomon outer code with \\(N\\) distinct binary inner codes.", "cousins_code_id": "reed_solomon\nwozencraft\nrandom", "cousins_detail": "An RS code is the outer code of Justesen codes.\nWozencraft ensemble forms the inner codes of Justesen codes.\nThe required inner codes are obtained by random sampling from the Wozencraft ensemble, whose length scales logarithmically with \\(n\\).", "_type": "ecc", "_page_id": "c_justesen", "_href": "c/justesen"}, "c_tornado": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Come arbitrarily close to the capacity of the binary erasure channel.", "features_magic_scaling_exponent": "", "features_encoders": "Linear-time encoder.", "features_decoders": "Linear-time decoder.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Tornado code", "code_id": "tornado", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[J. W. Byers et al., \u201cA digital fountain approach to reliable distribution of bulk data\u201d, ACM SIGCOMM Computer Communication Review 28, 56 (1998). DOI][M. G. Luby et al., \u201cPractical loss-resilient codes\u201d, Proceedings of the twenty-ninth annual ACM symposium on Theory of computing - STOC '97 (1997). DOI][M. G. Luby et al., \u201cEfficient erasure correcting codes\u201d, IEEE Transactions on Information Theory 47, 569 (2001). DOI]", "description": "Stub.", "parents_code_id": "binary_linear\nldpc", "parents_detail": "\n", "cousins_code_id": "fountain\nldpc", "cousins_detail": "Tornado codes, the precursor to fountain codes, are much slower to encode and decode in the low-rate regime applicable to scalable data transmission [Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7\u201312). IEEE.][A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI].\nTornado codes are similar to LDPC codes, but they use a highly irregular weight distribution for the underlying graphs [A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI].", "cousin_of_code_id": "raptor", "cousin_of_detail": "Tornado codes, which can be used as a pre-code for raptor codes, also use a multi-layer approach where redundant symbols are created by one code for another code to use as input.", "_type": "ecc", "_page_id": "c_tornado", "_href": "c/tornado"}, "c_vt_single_deletion": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Rate-\\(1\\) code, with \\(\\log n+1\\) bits of redundancy when \\(a=0\\). Nearly optimal.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Decoder based on checksums \\(\\sum_{i=1}^n i~x_i^{\\prime}\\) of corrupted codewords \\(x_i^{\\prime}\\) [V. I. Levenshtein, Binary codes capable of correcting deletions, insertions and reversals (translated to English), Soviet Physics Dokl., 10(8), 707-710 (1966).][V. I. Levenshtein, Binary codes capable of correcting spurious insertions and deletions of one (translated to English), Prob. Inf. Transmission, 1(1), 8-17 (1965).].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary Varshamov-Tenengolts (VT) code", "code_id": "vt_single_deletion", "realizations": "", "protection": "Corrects a single asymmetric error (a \\(0\\) mapped to a \\(1\\)), a single deletion, or a single insertion of an arbitrary bit in an arbitrary position for any choice of \\(a\\).", "notes": "", "physical": "bits", "short_name": "Binary VT", "introduced": "[R. R. Varshamov and G. M. Tenengolts, Codes which correct single asymmetric errors (translated to English), Autom. Remote Control, 26(2), 286-290 (1965)][V. I. Levenshtein, Binary codes capable of correcting deletions, insertions and reversals (translated to English), Soviet Physics Dokl., 10(8), 707-710 (1966).]", "description": "Nearly optimal binary deletion-correcting code. Given integers \\(n\\geq 1\\) and \\(a\\in\\{0,1,\\dots,n\\}\\), the associated binary Varshamov-Tenengolts code \\(C_{n,a}\\) corresponds to the set\n\n\\begin{align}\nC_{n,a}=\\left\\{x\\in\\{0,1\\}^n: \\sum_{i=1}^n i~x_i = a\\mod (n+1) \\right\\}.\n\\end{align}", "parents_code_id": "bits_into_bits", "parents_detail": "", "cousins_code_id": "binary_linear", "cousins_detail": "By adapting a construction of Tenengolts [G. M. Tenengolts, Class of codes correcting bit loss and errors in the preceding bit (translated to English), Automation and Remote Control, 37(5), 797\u2013802 (1976).], binary VT codes can be modified to yield slightly longer linear codes [N. J. A. Sloane, \u201cOn Single-Deletion-Correcting Codes\u201d. math/0207197].", "_type": "ecc", "_page_id": "c_vt_single_deletion", "_href": "c/vt_single_deletion"}, "c_binary_linear": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "A family of linear codes \\(C_i = [n_i,k_i,d_i]\\) is asymptotically good if the asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Decoding an arbitary linear binary code is \\(NP\\)-complete [E. Berlekamp, R. McEliece, and H. van Tilborg, \u201cOn the inherent intractability of certain coding problems (Corresp.)\u201d, IEEE Transactions on Information Theory 24, 384 (1978). DOI].\nSlepian's standard-array decoding [D. Slepian, \u201cSome Further Theory of Group Codes\u201d, Bell System Technical Journal 39, 1219 (1960). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Linear binary code", "code_id": "binary_linear", "realizations": "", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set for which no two elements of the set add up to a codeword.\n\nLinear codes admit a parity check matrix \\(H\\), whose columns make up a set of parity checks, i.e., a maximal linearly independent set of vectors that are in the kernel of \\(G\\). It follows that \\begin{align}\n  G H^{\\text{T}} = 0 \\mod 2~.\n\\end{align}\n\nThe decision problem corresponding to finding the minimum distance is also \\(NP\\)-complete [A. Vardy, \u201cThe intractability of computing the minimum distance of a code\u201d, IEEE Transactions on Information Theory 43, 1757 (1997). DOI], and approximating the weight enumerator is \\(\\#P\\)-complete [M. N. Vyalyi, \u201cHardness of approximating the weight enumerator of a binary linear code\u201d. cs/0304044].", "notes": "Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by A. E. Brouwer [Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.], are maintained by M. Grassl at this website.", "physical": "bits", "short_name": "", "introduced": "", "description": "An \\((n,2^k,d)\\) linear code is denoted as \\([n,k]\\) or \\([n,k,d]\\), where \\(d\\) is the code's distance. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword. A code that is not linear is called nonlinear.\n\nLinear codes can be defined in terms of a generator matrix \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a message \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its standard or systematic form \\(G = [I_k~A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) binary matrix. ", "parents_code_id": "bits_into_bits\nlinear", "parents_detail": "\n", "parent_of_code_id": "binary_ltc\nbinary_cyclic\nfibonacci_model\nfountain\nhomological_classical\njustesen\nreed_muller\nta-shma\ntanner\ntornado\nweight_two", "parent_of_detail": "\n\n\n\n\n\n\n\n\n\n", "cousins_code_id": "binary_ltc", "cousins_detail": "Linear binary codes with distances \\(\\frac{1}{2}n-\\sqrt{t n}\\) for some \\(t\\) are called almost-orthogonal and are locally testable with query complexity of order \\(O(t)\\) [T. Kaufman and S. Litsyn, \u201cAlmost Orthogonal Linear Codes are Locally Testable\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI]. This was later improved to codes with distance \\(\\frac{1}{2}n-O(n^{1-\\gamma})\\) for any positive \\(\\gamma\\) [T. Kaufman and M. Sudan, \u201cSparse Random Linear Codes are Locally Decodable and Testable\u201d, 48th Annual IEEE Symposium on Foundations of Computer Science (FOCS'07) (2007). DOI], provided that the number of codewords is polynomial in \\(n\\).", "cousin_of_code_id": "bpsk\nvt_single_deletion\ncss\neaqecc\neastab\ngroup_linear\nconstruction_a\nqubit_stabilizer\nparity_check", "cousin_of_detail": "Concatenating binary linear codes with BPSK yields a standard way of digitizing the analog AGWN channel [A. Lapidoth, A Foundation in Digital Communication (Cambridge University Press, 2017). DOI; Ch. 29].\nBy adapting a construction of Tenengolts [G. M. Tenengolts, Class of codes correcting bit loss and errors in the preceding bit (translated to English), Automation and Remote Control, 37(5), 797\u2013802 (1976).], binary VT codes can be modified to yield slightly longer linear codes [N. J. A. Sloane, \u201cOn Single-Deletion-Correcting Codes\u201d. math/0207197].\nConstruction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\).\nAny linear binary code can be used to construct an EAQECC.\nAny linear binary code can be used to construct an EA stabilizer code.\nLinear codes over \\(G=GF(2)\\) are binary linear codes since fields are abelian groups under addition.\nEach binary linear code yields a mod-two lattice code.\nQubit stabilizer codes are quantum analogues of binary linear codes.\nAny \\([n,k,d]\\) code with odd distance can be extended to an \\([n+1,k,d+1]\\) code by adding a bit storing the sum of codeword coordinates.", "_type": "ecc", "_page_id": "c_binary_linear", "_href": "c/binary_linear"}, "c_ta-shma": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Unique and list decoders [Fernando Granha Jeronimo et al., \u201cUnique Decoding of Explicit $\u03b5$-balanced Codes Near the Gilbert-Varshamov Bound\u201d. 2011.05500].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Ta-Shma zigzag code", "code_id": "ta-shma", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[A. Ta-Shma, \u201cExplicit, almost optimal, epsilon-balanced codes\u201d, Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing (2017). DOI]", "description": "Member of a family of \\(\\epsilon\\)-balanced codes that nearly achieves the asymptotic Gilbert-Varshamov bound. The codes have relative distance \\(\\frac{1}{2}-\\frac{\\epsilon}{2}\\) and rate of order \\(\\Omega (\\epsilon^{2+\\beta})\\) for \\(\\beta\\to 0\\) as \\(n\\to\\infty\\) [Fernando Granha Jeronimo et al., \u201cUnique Decoding of Explicit $\u03b5$-balanced Codes Near the Gilbert-Varshamov Bound\u201d. 2011.05500]. ", "parents_code_id": "binary_linear", "parents_detail": "", "cousins_code_id": "balanced", "cousins_detail": "Ta-Shma codes are \\(\\epsilon\\)-balanced.", "_type": "ecc", "_page_id": "c_ta-shma", "_href": "c/ta-shma"}, "c_luby_transform": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Sum-product algorithm, often called a peeling decoder [T. Richardson and R. Urbanke, Modern Coding Theory (Cambridge University Press, 2008). DOI][David J. C. MacKay. 2002. Information Theory, Inference & Learning Algorithms. Cambridge University Press, USA], similar to belief propagation [J. Pearl, \u201cReverend Bayes on Inference Engines: A Distributed Hierarchical Approach\u201d, Probabilistic and Causal Inference 129 (2022). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Luby transform (LT) code", "code_id": "luby_transform", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "LT", "introduced": "[M. Luby, \u201cLT codes\u201d, The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. Proceedings.. DOI]", "description": "Erasure codes based on fountain codes. They improve on random linear fountain codes by having a much more efficient encoding and decoding algorithm.\n\nLT codes can be constructed as follows. First, randomly choose a degree \\(d_n\\) from a degree distribution depending on total size \\(K\\). Then, randomly choose \\(d_n\\) distinct source packets and let the packet to be transmitted \\(\\hat{p}_n\\) be the bitwise sum of the chosen input packets. This forms a graph connecting encoded packets to source packets. ", "parents_code_id": "raptor", "parents_detail": "Raptor codes using a trivial pre-code are LT codes. Typically, Raptor codes have constant-sized more overhead but are faster to decode.", "_type": "ecc", "_page_id": "c_luby_transform", "_href": "c/luby_transform"}, "c_anticode": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Anticode", "code_id": "anticode", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[P. G. Farrell, \u201cLinear binary anticodes\u201d, Electronics Letters 6, 419 (1970). DOI][P. G. Farrell and A. Farrag, \u201cFurther properties of linear binary anticodes\u201d, Electronics Letters 10, 340 (1974). DOI]", "description": "Code for which the distance between any two codewords is less than or equal to some value \\(\\delta\\) called the maximum distance. Anticodes can be used to construct codes that saturate the Griesmer bound; see Refs. [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI][F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for more details.", "parents_code_id": "bits_into_bits", "parents_detail": "", "cousins_code_id": "griesmer", "cousins_detail": "Several anticode (e.g., [B. I. Belov, V. N. Logachev, V. P. Sandimirov, \u201cConstruction of a Class of Linear Binary Codes Achieving the Varshamov-Griesmer Bound\u201d, Probl. Peredachi Inf., 10:3 (1974), 36\u201344; Problems Inform. Transmission, 10:3 (1974), 211\u2013217][R. Hill, \"Optimal Linear Codes in: C. Mitchell (Ed.) Crytography and Coding.\" (1992): 75-104.]) and related [B. I. Belov, \"A conjecture on the Griesmer bound.\" Optimization Methods and Their Applications,(Russian), Sibirsk. Energet. Inst. Sibirsk. Otdel. Akad. Nauk SSSR, Irkutsk 182 (1974): 100-106.] constructions saturate the Griesmer bound; see Refs. [J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI][I. N. Landjev, \u201cLinear codes over finite fields and finite projective geometries\u201d, Discrete Mathematics 213, 211 (2000). DOI][F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for more details.", "cousin_of_code_id": "projective", "cousin_of_detail": "There is a relation between anticodes and minihypers ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 295).", "_type": "ecc", "_page_id": "c_anticode", "_href": "c/anticode"}, "c_fountain": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Random linear fountain codes approach the Shannon limit as the file size \\(K\\) increases. However, they do not have a fixed encoding rate.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Invert the fragment generator matrix resulting from the continuous encoding process. If exactly \\(K\\) packets are received, then the probability of decoding correctly is \\(0.289\\). Extra packets increase this probability exponentially. The decoding runtime is dominated by the matrix inversion step, which takes order \\(O(n^3)\\) time.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Fountain code", "code_id": "fountain", "realizations": "Designed for servers sending data to many recipients, such as during broadcasting or file distribution [A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI][E. Baik, A. Pande, and P. Mohapatra, \u201cCross-layer coordination for efficient contents delivery in LTE eMBMS traffic\u201d, 2012 IEEE 9th International Conference on Mobile Ad-Hoc and Sensor Systems (MASS 2012) (2012). DOI].", "protection": "Designed to protect against erasures during broadcasting of information by a sender to multiple receivers.", "notes": "Review on fountain codes can be found in Refs. [D. J. C. MacKay, \u201cFountain codes\u201d, IEE Proceedings - Communications 152, 1062 (2005). DOI][Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7\u201312). IEEE.].", "physical": "bits", "short_name": "", "introduced": "[J. W. Byers et al., \u201cA digital fountain approach to reliable distribution of bulk data\u201d, ACM SIGCOMM Computer Communication Review 28, 56 (1998). DOI]", "description": "Code based on the idea of generating an endless stream of custom encoded packets for the receiver. The code is designed so that the receiver can recover the original transmission of size \\(Kl\\) bits after receiving at least \\(K\\) packets each of \\(l\\) bits.\n\nThe simplest example of a fountain code is the random linear fountain code. Take some message of size \\(Kl\\) and split into \\(K\\) packets, \\(p_0, p_1, ..., p_K\\). For each packet \\(\\hat{p}_n\\) to be transmitted do the following: Generate \\(K\\) random bits \\(G_{nk}\\) and let \\(\\hat{p}_n\\) be the bitwise sum of the source packets when \\(G_{nk}\\) is 1, \\begin{align}\n\\hat{p}_n = \\sum_{k=1}^K p_k G_{kn}~.\n\\end{align} Error correction can then be applied to each packet. ", "parents_code_id": "binary_linear\nldgm", "parents_detail": "\n", "parent_of_code_id": "raptor", "parent_of_detail": "", "cousins_code_id": "random\ndistributed_storage", "cousins_detail": "\nThere are proposals [Megasthenis Asteris and Alexandros G. Dimakis, \u201cRepairable Fountain Codes\u201d. 1401.0734][Michael G. Luby et al., \u201cLiquid Cloud Storage\u201d. 1705.07983] adapting fountain codes to distributed storage systems.", "cousin_of_code_id": "tornado", "cousin_of_detail": "Tornado codes, the precursor to fountain codes, are much slower to encode and decode in the low-rate regime applicable to scalable data transmission [Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7\u201312). IEEE.][A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI].", "_type": "ecc", "_page_id": "c_fountain", "_href": "c/fountain"}, "c_batch": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Batch code", "code_id": "batch", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[Y. Ishai et al., \u201cBatch codes and their applications\u201d, Proceedings of the thirty-sixth annual ACM symposium on Theory of computing - STOC '04 (2004). DOI]", "description": "Binary code designed for minimizing the total amount of storage and the worst-case maximal load on any devices in a distributed system.\n\nAn \\((n,N,k,m,t)\\) batch code encodes a length-\\(n\\) string \\(x_1,\\cdots,x_n\\) into an \\(m\\)-tuple of strings of total length \\(N\\) (are also called buckets), such that for each \\(k\\)-tuple of distinct indices \\(i_1,i_2,...,i_k\\), the entries \\(x_{i_1},...,x_{i_k}\\) can be decoded by reading at most \\(t\\)-symbols from each bucket. If each bucket of a batch code contains a single symbol, then the \\((n,N,k,m)\\) batch code is primitive.\n\nA multi-user generalization of batch code is named multiset batch code. If, for any multiset \\(i_1, i_2, ..., i_k \\in [n]\\), there is a partition of buckets into subsets \\(S_1, ..., S_k \\subset [m]\\) such that each \\(x_{i_j}\\) can be recovered by reading at most one symbol from each bucket in \\(S_j\\), then the \\((n, N, k, m)\\) code is a multiset batch code.\n\nCombining two batch codes \\(C_1\\) and \\(C_2\\), which are \\((n_1,N_1,k_1,m_1)\\) and \\((n_2,N_2,k_2,m_2)\\) batch codes respectively, yields a composite batch code \\(C_1\\otimes C_2\\), which is an \\((n_1, m_1N_2, k_1 k_2, m_1 m_2)\\) batch code.", "parents_code_id": "bits_into_bits\nlocally_recoverable", "parents_detail": "\nA systematic batch code with restricted size of reconstruction sets can recover any query of \\(t\\) information symbols with recovery sets of size \\(r\\) [V. Skachek, \u201cBatch and PIR Codes and Their Connections to Locally Repairable Codes\u201d, Network Coding and Subspace Designs 427 (2018). DOI][A.-E. Riet, V. Skachek, and E. K. Thomas, \u201cBatch Codes for Asynchronous Recovery of Data\u201d, IEEE Transactions on Information Theory 68, 1545 (2022). DOI].", "_type": "ecc", "_page_id": "c_batch", "_href": "c/batch"}, "c_homological_classical": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Graph homology code", "code_id": "homological_classical", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[H. Bombin and M. A. Martin-Delgado, \u201cHomological error correction: Classical and quantum codes\u201d, Journal of Mathematical Physics 48, 052105 (2007). DOI; quant-ph/0605094]", "description": "This code's properties are derived from the size two chain complex associated with a particular graph. Given a connected simplicial (no self loops or muliedges) graph \\(G = (V, E)\\), which is not a tree, with incidence matrix \\(\\Gamma\\) we can construct a code by choosing a parity check matrix which consists of all the linearly independent rows of \\(\\Gamma\\). This is a \\([n,k,d]\\) code with \\(n = |E|\\), \\(k = 1 - \\mathcal{X}(G) = 1-|V|+|E|\\), where \\( \\mathcal{X}(G)\\) is the euler characteristic of the graph. The code distance is equal to the shortest size of a cycle, guaranteed to exist since \\(G\\) is not a tree. ", "parents_code_id": "binary_linear", "parents_detail": "", "cousins_code_id": "perfect\ncss", "cousins_detail": "A family of homology codes saturate the asymptotic Hamming bound [H. Bombin and M. A. Martin-Delgado, \u201cHomological error correction: Classical and quantum codes\u201d, Journal of Mathematical Physics 48, 052105 (2007). DOI; quant-ph/0605094].\nCSS codes can also be constructed using homology techniques but for manifolds of dimension two or greater.", "_type": "ecc", "_page_id": "c_homological_classical", "_href": "c/homological_classical"}, "c_raptor": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Raptor codes can be decoded using inactivation decoding [F. Lazaro, G. Liva, and G. Bauch, \u201cInactivation Decoding of LT and Raptor Codes: Analysis and Code Design\u201d, IEEE Transactions on Communications 1 (2017). DOI; 1706.05814], a combination of belief-propogation and Gaussian elimination decoding.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Raptor (RAPid TORnado) code", "code_id": "raptor", "realizations": "Two versions of Raptor codes have been standardized by IETF: R10 and the more recent RaptorQ. RaptorQ is used in mobile multimedia broadcasts as specified in ETSI technical specifications. It is also used in the mobile Next Gen TV standard.\nRaptor codes are useful in scenarios where erasure (i.e. weak signal or noisy channel) is common, such as in military or disaster scenarios.", "protection": "As a type of fountain code, a Raptor code is designed to correct erasures. The error probability of Raptor codes is measured in terms of its overhead, which is how many additional symbols are received above the dimension of the input \\(k\\). This relationship can vary widely depending on the input pre-code and degree distribution. For a well-designed degree distribution, the error probability of a Raptor code is directly related to the error probability of the pre-code's decoder. In other words, if there is a linear time decoder for the pre-code that has subexponentially small error probability, then the Raptor code's error probability will decrease exponentially with increasing overhead (past the \\(n-k\\) overhead symbols necessary for the pre-code).", "notes": "There is an open source RaptorQ implementation in Java and Rust.", "physical": "bits", "short_name": "Raptor", "introduced": "[A. Shokrollahi, \u201cRaptor codes\u201d, IEEE Transactions on Information Theory 52, 2551 (2006). DOI][Petar Maymounkov, Online codes, Technical report, New York University, 2002.]", "description": "Raptor codes are concatenated erasure codes with two layers: an outer pre-code and a Luby-Transform (LT) inner code. The pre-code is a linear binary erasure code, which is applied first to the input to create some redundant data. The LT code is then applied to the intermediate symbols from the pre-code to generate final output symbols to be transmitted.\n\nThe parameters for a Raptor code are \\( (k, C, \\Omega(x)) \\), with \\(C\\) being the pre-code with dimension \\( k \\), and \\( \\Omega(x) \\) being the degree distribution for the LT code.\n\nThe times to encode and decode source blocks are both linear. The space requirement is \\(1/R \\), where \\(R\\) is the rate of the pre-code. Raptor codes with the simplest output distribution (LT code) are called pre-code-only (PCO).", "parents_code_id": "fountain", "parents_detail": "", "parent_of_code_id": "luby_transform", "parent_of_detail": "Raptor codes using a trivial pre-code are LT codes. Typically, Raptor codes have constant-sized more overhead but are faster to decode.", "cousins_code_id": "tornado", "cousins_detail": "Tornado codes, which can be used as a pre-code for raptor codes, also use a multi-layer approach where redundant symbols are created by one code for another code to use as input.", "_type": "ecc", "_page_id": "c_raptor", "_href": "c/raptor"}, "c_reed_muller": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Achieves capacity of the binary erasure channel [S. Kudekar et al., \u201cReed\u2013Muller Codes Achieve Capacity on Erasure Channels\u201d, IEEE Transactions on Information Theory 63, 4298 (2017). DOI] and of the binary memoryless symmetric (BMS) channel under bitwise maximum-a-posteriori decoding [Galen Reeves and Henry D. Pfister, \u201cReed-Muller Codes Achieve Capacity on BMS Channels\u201d. 2110.14631].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Reed decoder with \\(r+1\\)-step majority decoding corrects \\(\\frac{1}{2}(2^{m-r}-1)\\) errors [D. E. Muller, \u201cApplication of Boolean algebra to switching circuit design and to error detection\u201d, Transactions of the I.R.E. Professional Group on Electronic Computers EC-3, 6 (1954). DOI] (see also Ch. 13 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.]).\nSequential code-reduction decoding [L. Rudolph and C. Hartmann, \u201cDecoding by sequential code reduction\u201d, IEEE Transactions on Information Theory 19, 549 (1973). DOI].\nFirst-order (\\(r=1\\)) RM codes admit specialized decoders [E.C. Posner, Combinatorial Structures in Planetary Reconnaissance in Error Correcting Codes, ed. H.B. Mann, Wiley, NY 1968.].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Reed-Muller (RM) code", "code_id": "reed_muller", "realizations": "Deep-space communication, including the Mariner 9 spacecraft [J. L. Massey, \u201cDeep-space communications and coding: A marriage made in heaven\u201d, Advanced Methods for Satellite and Deep Space Communications 1. DOI][E.C. Posner, Combinatorial Structures in Planetary Reconnaissance in Error Correcting Codes, ed. H.B. Mann, Wiley, NY 1968.].", "protection": "", "notes": "See Chs. 13-15 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for details of RM codes and their variants.\nSee Ref. [E. Berlekamp and L. Welch, \u201cWeight distributions of the cosets of the (32,6) Reed-Muller code\u201d, IEEE Transactions on Information Theory 18, 203 (1972). DOI] for the weight distribution of the \\(2^{26}\\) cosets of the \\((32,6)\\) first-order RM code, obtained in part by hand computation.", "physical": "bits", "short_name": "RM", "introduced": "[D. E. Muller, \u201cApplication of Boolean algebra to switching circuit design and to error detection\u201d, Transactions of the I.R.E. Professional Group on Electronic Computers EC-3, 6 (1954). DOI][I. Reed, \u201cA class of multiple-error-correcting codes and the decoding scheme\u201d, Transactions of the IRE Professional Group on Information Theory 4, 38 (1954). DOI][N. Mitani, On the transmission of numbers in a sequential computer, delivered at the National Convention of the Inst. of Elect. Engineers of Japan, November 1951.]", "description": "Member of the RM\\((r,m)\\) family of linear binary codes derived from multivariate polynomials. The code parameters are \\([2^m,\\sum_{j=0}^{r} {m \\choose j},2^{m-r}]\\), where \\(r\\) is the order of the code satisfying \\(0\\leq r\\leq m\\). Punctured RM codes RM\\(^*(r,m)\\) are obtained from RM codes by deleting one or more coordinates from each codeword.\n\nGenerator matrices of RM codes are constructed using the \\((u|u+v)\\) construction by starting from the \\(2^m\\)-dimensional matrix \\(F^{(m)}=\\left(\\begin{smallmatrix}1 & 0\\\\\n1 & 1\n\\end{smallmatrix}\\right)^{\\otimes m}\\), labeling its rows top-to-bottom from \\(0\\) to \\(2^m-1\\), converting the labels to binary strings of length \\(m\\), and deleting all rows whose labels have a Hamming weight less than \\(m-r\\). The recursive nature of the tensor product in the matrix \\(F^{(m)}\\) implies that RM\\((r,m)\\) is a subcode of RM\\((r+1,m)\\).\n\nAnother way to generate RM codewords is to list all outcomes of all polynomials of \\(m\\) binary variables of degree at most \\(r\\) [Emmanuel Abbe, Amir Shpilka, and Min Ye, \u201cReed-Muller Codes: Theory and Algorithms\u201d. 2002.03317] (see also Ch. 13 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.]).", "parents_code_id": "evaluation_polynomial\nbinary_linear\nquaternary_over_z4\ndivisible\ngroup", "parents_detail": "RM codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine binary space ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pgs. 44-46; [S. G. Vl\u00e9duts and Y. I. Manin, \u201cLinear codes and modular curves\u201d, Journal of Soviet Mathematics 30, 2611 (1985). DOI][T. H\u00f8holdt, J.H. Van Lint, and R. Pellikaan, 1998. Algebraic geometry codes. Handbook of coding theory, 1 (Part 1), pp.871-961.]).\n\nRM codes are images of ring-linear quaternary codes under the Gray map ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Sec. 6.3).\nAn RM\\((r,m)\\) code is \\(2^{\\left\\lceil m/r\\right\\rceil-1}\\)-divisible, according to McEliece's theorem [R. J. McEliece, \u201cOn periodic sequences from GF(q)\u201d, Journal of Combinatorial Theory, Series A 10, 80 (1971). DOI][R. J. McEliece, \u201cWeight congruences for p-ary cyclic codes\u201d, Discrete Mathematics 3, 177 (1972). DOI].\nConsider a binary vector space of dimension \\( m \\). Under addition, this forms a finite group with \\( 2^m \\) elements known as an elementary abelian 2-group -- the direct product of \\( m \\) two-element cyclic groups \\( \\mathbb{Z}_2 \\times \\dots \\times \\mathbb{Z}_2 \\). Denote this group by \\( G_m \\). Let \\( J \\) be the Jacobson radical of the group algebra \\( \\mathbb{F}_2 G_m \\), where \\(\\mathbb{F}_2=GF(2)\\). RM\\((r,m)\\) codes correspond to the ideal \\( J^{m-r} \\). The length of the code is \\( |G_m| = 2^m \\), the distance is \\( 2^{m-r} \\), and the dimension is \\( \\sum_{i=0}^r {m \\choose i} \\). A similar construction exists for choices of a prime \\( p\\neq 2 \\).", "parent_of_code_id": "hamming", "parent_of_detail": "Hamming codes are equivalent to RM\\(^*(r-2,r)\\).", "cousins_code_id": "bch\ndual\nbinary_duadic\nbinary_cyclic\nparity_check\nbinary_ltc", "cousins_detail": "RM\\((r,m)\\) codes are subcodes of BCH codes of designed distance \\(2^{m-r}-1\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 13).\nThe codes RM\\((r,m)\\) and RM\\((m-r-1,m)\\) are dual to each other.\nCertain punctured RM codes such as RM\\(^*(2,5)\\) are duadic; see Ref. [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Table 6.2.\nPunctured RM codes are cyclic ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 13, Thm. 11), making RM codes extended cyclic codes. RM codes with nonzero evaluation points are cyclic ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 52).\nRM\\((m-1,m)\\) are parity-check codes.\nRM codes can be LTCs in the low- [N. Alon et al., \u201cTesting Reed\u2013Muller Codes\u201d, IEEE Transactions on Information Theory 51, 4032 (2005). DOI][T. Kaufman and D. Ron, \u201cTesting Polynomials over General Fields\u201d, SIAM Journal on Computing 36, 779 (2006). DOI] and high-error [Alex Samorodnitsky, \u201cLow-degree tests at large distances\u201d. math/0604353] regimes.", "cousin_of_code_id": "barnes_wall\ngeneralized_reed_muller\nhadamard\nmajorana_stab\npolar\nquantum_reed_muller\nquantum_divisible\nsimplex", "cousin_of_detail": "BW lattice codes are lattice analogues of RM codes in that both can be constructed recursively via a \\(|u|u+v|\\) construction [E. L. Cusack, \u201cError control codes for QAM signalling\u201d, Electronics Letters 20, 62 (1984). DOI][G. D. Forney, \u201cCoset codes. I. Introduction and geometrical classification\u201d, IEEE Transactions on Information Theory 34, 1123 (1988). DOI].\n\nFor any Hamming code \\([2^m,2^m-m-1,3]\\), the dual Hadamard code, when augmented with a bit that is always 0, gives the RM\\((1,m)\\) code. In general, RM\\((1,m)\\) is related to the duals of the Hamming code, and when RM\\((1,m)\\) is self-dual, it is directly related to the Hamming code.\nMajorana stabilizer codes can be constructed by self-orthogonal RM codes [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code.\nRM codes rely on the same generator matrix, but place message bits in different coordinates.\n\nQuantum divisible codes can be constructed out of first-order RM codes.\nBinary simplex codes can be constructed from the generator matrix of RM\\((1,k)\\) by removing first the all-ones row, and then the all-zero column. Punctured RM codes and simplex codes are interconvertible via expurgation and augmentation ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 31).", "_type": "ecc", "_page_id": "c_reed_muller", "_href": "c/reed_muller"}, "c_expander": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The rate is \\(1 - m/n\\) where \\(n\\) is the number of left nodes and \\(m\\) is the number of right nodes in the bipartite expander graph.", "features_magic_scaling_exponent": "", "features_encoders": "Multiplication by generator matrix with runtime \\(O(n^2)\\)", "features_decoders": "Decoding can be done in \\(O(n)\\) runtime using a greedy flip algorithm. The algorithm consists of flipping a bit of the received word if it will result in a greater number of satisfied parity checks. This is repeated until a codeword is reached.", "features_transversal_gates": "", "features_fault_tolerance": "The flip decoding algorithm is fault tolerant against parity check errors [D. A. Spielman, \u201cLinear-time encodable and decodable error-correcting codes\u201d, IEEE Transactions on Information Theory 42, 1723 (1996). DOI]; see also course notes by M. Sudan.", "name": "Expander code", "code_id": "expander", "realizations": "", "protection": "Bit flip errors of weight at most \\((d-1)/2\\) where \\(d\\) is the distance of the code and is linear in \\(n\\), the number of physical bits.", "notes": "", "physical": "bits", "short_name": "", "introduced": "[M. Sipser and D. A. Spielman, \u201cExpander codes\u201d, IEEE Transactions on Information Theory 42, 1710 (1996). DOI]", "description": "Expander codes are binary linear codes whose parity check matrices are derived from the adjacency matrix of bipartite expander graphs. In particular, the rows of the parity check matrix correspond to the right nodes of the bipartite graph and the columns correspond to the left nodes. The codespace is equivalent to all subsets of the left nodes in the graph that have an even number of edges going into every right node of the graph. Since the expander graph is only left regular, these codes do not qualify as LDPC codes.\n\nExpander codes are important because they admit efficient encoding and decoding algorithms and are asymptotically good (i.e., their rate and normalized distance are constant). The rate and distance of the expander code depend on specific parameters of the corresponding graph. A (\\(n, m, D, \\gamma, \\alpha\\)) bipartite expander graph is defined as a \\(D\\)-left-regular graph with \\(n\\) left nodes, and \\(m\\) right nodes such that for any subset of left nodes \\(S\\) of size at most \\(\\gamma n\\) the neighborhood \\(N(S)\\) is at least of size \\(\\alpha|S|\\). Given a (\\(n, m, D, \\gamma, (1-\\epsilon)D\\)) expander graph, the corresponding expander code has rate of \\(1 - m/n\\) and a distance of at least \\(2(1-\\epsilon)\\gamma n\\) for any \\(\\epsilon < 1/2\\). Explicit constructions for expander graphs with any ratio \\(n/m\\) are known where \\(D = \\text{polylog}(n/m)\\), \\(\\gamma = \\Omega(1/D)\\) and arbitrary \\(\\epsilon\\) [M. Capalbo et al., \u201cRandomness conductors and constant-degree lossless expanders\u201d, Proceedings of the thiry-fourth annual ACM symposium on Theory of computing - STOC '02 (2002). DOI]. ", "parents_code_id": "tanner", "parents_detail": "", "cousin_of_code_id": "lr-cayley-complex\nquantum_expander", "cousin_of_detail": "Left-right Cayley complex codes can be viewed as Tanner-like codes on expander graphs, but with bits defined on squares and constraints on edges (as opposed to edges and vertices, respectively, for expander codes). Expander codes are also typically not locally testable [E. Ben-Sasson, P. Harsha, and S. Raskhodnikova, \u201cSome 3CNF properties are hard to test\u201d, Proceedings of the thirty-fifth ACM symposium on Theory of computing - STOC '03 (2003). DOI].\n", "_type": "ecc", "_page_id": "c_expander", "_href": "c/expander"}, "c_fibonacci_model": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "An efficient algorithm base on minimum-weight perfect matching [G. M. Nixon and B. J. Brown, \u201cCorrecting Spanning Errors With a Fractal Code\u201d, IEEE Transactions on Information Theory 67, 4504 (2021). DOI; 2002.11738], which can correct high-weight errors that span the lattice, with failure rate decaying super-exponentially with \\(L\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Fibonacci code", "code_id": "fibonacci_model", "realizations": "", "protection": "Protects against small weight errors and string-like errors. The code distance is more than \\(L\\), but the exact value is unknown. ", "notes": "", "physical": "bits", "short_name": "", "introduced": "[G. M. Nixon and B. J. Brown, \u201cCorrecting Spanning Errors With a Fractal Code\u201d, IEEE Transactions on Information Theory 67, 4504 (2021). DOI; 2002.11738]", "description": "The code is defined on an \\(L\\times L/2\\) lattice with one bit on each site, where \\(L=2^N\\) for an integer \\(N\\geq 2\\). The codewords are defined to satisfy the condition that, for each lattice site \\((x,y)\\), the bits on \\((x,y)\\), \\((x+1,y)\\), \\((x-1,y)\\) and \\((x,y+1)\\) (where the lattice is taken to be periodic in both directions) contain an even numbers of \\(1\\)'s. The codewords can be generated using a one-dimensional cellular automaton of length \\(L\\) (periodic). The \\(2^L\\) possible initial states correspond to the \\(2^L\\) codewords. For each generation, the state of each cell is the xor sum of that cell and its two neighbors in the previous generation. After \\(L/2-1\\) generations, the entire history generated by the automaton corresponds to a codeword, where the initial state is the first row of the lattice, the first generation is the second row, etc. ", "parents_code_id": "binary_linear", "parents_detail": "", "cousins_code_id": "haah_cubic", "cousins_detail": "The Fibonacci code is designed to mimic the fractal properties of (quantum) Haah cubic code so that studying the former can help us toward the development of an efficient algorithm for the latter.", "_type": "ecc", "_page_id": "c_fibonacci_model", "_href": "c/fibonacci_model"}, "c_bits_into_bits": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "For few-bit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.\nGiven a received string \\(x\\) and an error bound \\(e\\), a list decoder returns a list of all codewords that are at most \\(e\\) from \\(x\\) in Hamming distance. The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary code", "code_id": "bits_into_bits", "realizations": "", "protection": "A binary code \\(C\\) corrects \\(t\\) errors in the Hamming distance if \\begin{align}\n  \\forall x \\in C~,~D(x,x+y) < D(x' , x+y)\n\\end{align} for all codewords \\(x' \\neq x\\) and all \\(y\\) such that \\(|y|=t\\), where \\(D\\) is the Hamming distance and \\(|y| = D(y,0) \\). A code corrects \\(t\\) errors if and only if \\(d \\geq 2t+1\\), i.e., a code corrects errors on \\(t \\leq \\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates. In addition, a code detects errors on up to \\(d-1\\) coordinates, and corrects erasure errors on up to \\(d-1\\) coordinates.\n\nPerformance of binary codes can also be measured with respect to deletions and insertions of bits into the codewords. In this case, the metric measuring distance of an error word to the nearest codeword is the deletion distance: given vectors \\(u,v\\), this distance is one-half the smallest number of deletions and insertions needed to change \\(u\\) to \\(v\\). A code \\(C\\) corrects \\(e\\) delections if all codewords are separated by at least \\(e+1\\) in the deletion distance [N. J. A. Sloane, \u201cOn Single-Deletion-Correcting Codes\u201d. math/0207197]. ", "notes": "", "physical": "bits", "short_name": "", "introduced": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) binary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)\\). The distance is the minimum Hamming distance between a pair of distinct codewords.", "parents_code_id": "ecc_finite", "parents_detail": "", "parent_of_code_id": "anticode\nbatch\nvt_single_deletion\nconvolutional\ngray\nlevenshtein\nbinary_linear", "parent_of_detail": "\n\n\n\n\n\n", "cousin_of_code_id": "fock_state\ngroup_classical\nmovassagh_ouyang\npoints_into_spheres", "cousin_of_detail": "Fock-state code distance is a natural extension of Hamming distance between binary strings.\nGroup-based codes whose alphabet is based on the field \\(GF(2)\\), taken to be an abelian under addition, are binary codes.\nMovassagh-Ouyang codes are constructed from classical binary codes.\nAny binary \\((n,K,d)\\) code can be converted into an \\((n,K,4d/n)\\) spherical code via a component-wise antipodal mapping \\(0\\to +1\\) and \\(1 \\to -1\\) [T. Ericson, and V. Zinoviev, eds. Codes on Euclidean spheres. Elsevier, 2001.; Example 1.2.1].", "_type": "ecc", "_page_id": "c_bits_into_bits", "_href": "c/bits_into_bits"}, "c_binary_duadic": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary duadic code", "code_id": "binary_duadic", "realizations": "", "protection": "Since duadic codes are cyclic, the BCH bound can be used to determine their minimum distance.", "notes": "Reviews of duadic codes [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI].", "physical": "bits", "short_name": "", "introduced": "[J. Leon, J. Masley, and V. Pless, \u201cDuadic Codes\u201d, IEEE Transactions on Information Theory 30, 709 (1984). DOI]", "description": "Member of a pair of cyclic linear binary codes that satisfy certain relations, depending on whether the pair is even-like or odd-like duadic. Duadic codes exist for lengths \\(n\\) that are products of powers of primes, with each prime being \\(\\pm 1\\) modulo \\(8\\) [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].\n\nDuadic codes come in two pairs, an even-like duadic pair and an odd-like duadic pair. All codewords in the respective pairs are even-like, i.e., \\(\\sum_i c_i = 0\\), or odd-like, i.e., \\(\\sum_i c_i = 1\\). A code with all even-like (odd-like) codewords is called even-like (odd-like).\n\nDuadic code pairs can be defined in terms of their idempotent generators (see Cyclic-to-polynomial correspondence). A pair of even-like codes \\(C_1\\) and \\(C_2\\) with respective idempotents \\(e_1\\) and \\(e_2\\) is an even-like duadic pair if (1) \\(e_1(x)+e_2(x)=1-\\frac{1}{n}(1+x+x^2+\\cdots+x^{n-1})\\) and (2) there exists a multiplier \\(\\mu\\) such that \\(C_1 \\mu=C_2\\) and \\(C_2 \\mu=C_1\\).\n\nThere is an odd-like duadic pair \\(\\{D_1,D_2\\}\\) associated with the even-like pair \\(\\{C_1, C_2\\}\\), where \\(1-e_2(x)\\) generates \\(D_1\\) and \\(1-e_1(x)\\) generates \\(D_2\\). The even-pair codes are \\([n,\\frac{n-1}{2}]\\) codes while the odd-pair codes are \\([n,\\frac{n+1}{2}]\\) codes.", "parents_code_id": "binary_cyclic", "parents_detail": "", "parent_of_code_id": "binary_quad_residue", "parent_of_detail": "QR codes are duadic codes of prime length satisfying certain relations [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].", "cousins_code_id": "q-ary_duadic", "cousins_detail": "", "cousin_of_code_id": "reed_muller", "cousin_of_detail": "Certain punctured RM codes such as RM\\(^*(2,5)\\) are duadic; see Ref. [W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Table 6.2.", "_type": "ecc", "_page_id": "c_binary_duadic", "_href": "c/binary_duadic"}, "c_binary_quad_residue": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary quadratic-residue (QR) code", "code_id": "binary_quad_residue", "realizations": "", "protection": "", "notes": "Introduction of quadratic-residue codes in Refs. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI].", "physical": "bits", "short_name": "Binary QR", "introduced": "", "description": "Member of a quadruple of cyclic binary codes of prime length \\(n=8m\\pm 1\\) for \\(m\\geq 1\\) constructed using quadratic residues and nonresidues of \\(n\\).\n\nThe roots of the generator polynomial \\(r(x)\\) of the first code (see Cyclic-to-polynomial correspondence) are all of the inequivalent quadratic residues of \\(n\\), and the second code's generator polynomial is \\((x-1)r(x)\\). The roots of the generator polynomial \\(a(x)\\) of the third code are all inequivalent nonresidues of \\(n\\), and the fourth code's generator polynomial is \\((x-1)a(x)\\). The codes corresponding to polynomials \\(r,a\\) are often called augmented quadratic-residue codes, while the remaining codes are called expurgated. ", "parents_code_id": "binary_duadic", "parents_detail": "QR codes are duadic codes of prime length satisfying certain relations [V. Pless, \u201cDuadic Codes and Generalizations\u201d, Eurocode \u201992 3 (1993). DOI].", "parent_of_code_id": "golay", "parent_of_detail": "The Golay code is a binary quadratic residue code with generator polynomial \\(r(x)\\) over \\(GF(2)\\) with length \\(n=23\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 16).", "cousins_code_id": "q-ary_quad_residue", "cousins_detail": "", "cousin_of_code_id": "hamming", "cousin_of_detail": "\\([7,4,3]\\) Hamming code is a quadratic-residue code [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.].", "_type": "ecc", "_page_id": "c_binary_quad_residue", "_href": "c/binary_quad_residue"}, "c_bch": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Peterson decoder with runtime of order \\(O(n^3)\\) [W. Peterson, \u201cEncoding and error-correction procedures for the Bose-Chaudhuri codes\u201d, IEEE Transactions on Information Theory 6, 459 (1960). DOI][S. Arimoto, \"Encoding and decoding of p-ary group codes and the correction system,\" Information Processing in Japan (in Japanese), vol. 2, pp. 320-325, Nov. 1961.] (see exposition in Ref. [R.E. Blahut, Theory and practice of error-control codes, Addison-Wesley 1983.]).\nBerlekamp-Massey decoder with runtime of order \\(O(n^2)\\) [J. Massey, \u201cShift-register synthesis and BCH decoding\u201d, IEEE Transactions on Information Theory 15, 122 (1969). DOI][E. R. Berlekamp, Algebraic Coding Theory, McGraw-Hill, 1968] and modification by Burton [H. Burton, \u201cInversionless decoding of binary BCH codes\u201d, IEEE Transactions on Information Theory 17, 464 (1971). DOI]; see also [W. W. Peterson and E. J. Weldon, Error-correcting codes. MIT press 1972.][R. Gallager, Information Theory and Reliable Communication (Springer Vienna, 1972). DOI].\nSugiyama et al. modification of the extended Euclidean algorithm [Y. Sugiyama et al., \u201cA method for solving key equation for decoding goppa codes\u201d, Information and Control 27, 87 (1975). DOI][R. McEliece, The Theory of Information and Coding (Cambridge University Press, 2002). DOI].\nGuruswami-Sudan list decoder [V. Guruswami and M. Sudan, \u201cImproved decoding of Reed-Solomon and algebraic-geometric codes\u201d, Proceedings 39th Annual Symposium on Foundations of Computer Science (Cat. No.98CB36280). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary BCH code", "code_id": "bch", "realizations": "Satellite communication [Cheung, K-M., and F. Pollara. \"Phobos lander coding system: Software and analysis.\" The Telecommunications and Data Acquisition Report (1988).]", "protection": "By the BCH bound, BCH code with designed distance \\(\\delta\\) has true distance \\(d\\geq\\delta\\). BCH codes with different designed distances may coincide, and the largest possible designed distance for a given code is the Bose distance; the true distance may still be larger than that. ", "notes": "See books [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.][S. Lin and D. J. Costello, Error Control Coding, 2nd ed. Englewood Cliffs, NJ: Prentice-Hall, 2004.][W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI] for expositions on BCH codes and code tables.\nSee Kaiserslautern database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.\nSee corresponding MinT database entry [Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cCyclic Codes (BCH-Bound).\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CCyclic-BCHBound.html].", "physical": "bits", "short_name": "", "introduced": "[R. C. Bose and D. K. Ray-Chaudhuri, \u201cOn a class of error correcting binary group codes\u201d, Information and Control 3, 68 (1960). DOI][R. C. Bose and D. K. Ray-Chaudhuri, \u201cFurther results on error correcting binary group codes\u201d, Information and Control 3, 279 (1960). DOI][A. Hocquenghem, Codes correcteurs d'Erreurs, Chiffres (Paris), vol.2, pp.147-156, 1959.]", "description": "Cyclic binary code of odd length \\(n\\) whose zeroes are consecutive powers of a primitive \\(n\\)th root of unity \\(\\alpha\\) (see Cyclic-to-polynomial correspondence). More precisely, the generator polynomial of a BCH code of designed distance \\(\\delta\\geq 1\\) is the lowest-degree monic polynomial with zeroes \\(\\{\\alpha^b,\\alpha^{b+1},\\cdots,\\alpha^{b+\\delta-2}\\}\\) for some \\(b\\geq 0\\). BCH codes are called narrow-sense when \\(b=1\\), and are called primitive when \\(n=2^r-1\\) for some \\(r\\geq 2\\).\n\nThe code dimension is related to the multiplicative order of \\(2\\) modulo \\(n\\), i.e., the smallest integer \\(m\\) such that \\(n\\) divides \\(2^m-1\\). The dimension of a BCH code with \\(\\delta=2t+1\\) is at least \\(n-mt\\). The field \\(GF(2^m)\\) is the smallest field containing the above root of unity \\(\\alpha\\), and is the splitting field of the polynomial \\(x^n-1\\) (see Cyclic-to-polynomial correspondence). ", "parents_code_id": "binary_cyclic", "parents_detail": "", "parent_of_code_id": "golay\nhamming", "parent_of_detail": "The Golay code is equivalent to a BCH code with Bose distance 5 ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 20).\nBinary Hamming codes are binary primitive narrow-sense BCH codes ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Corr. 5.1.5). Binary Hamming codes are cyclic ([R. Hill. A First Course In Coding Theory. Oxford University Press, 1988.], Thm. 12.22).", "cousins_code_id": "quasi_perfect\nq-ary_bch\ngeneralized_reed_solomon\ngriesmer", "cousins_detail": "Only double error-correcting BCH codes \\([2^m-1,n-2m,5]\\) are quasi-perfect [D. Gorenstein, W. W. Peterson, and N. Zierler, \u201cTwo-error correcting Bose-Chaudhuri codes are quasi-perfect\u201d, Information and Control 3, 291 (1960). DOI][T. Helleseth, \u201cNo primitive binary&amp;lt;tex&amp;gt;t&amp;lt;/tex&amp;gt;-error-correcting BCH code with&amp;lt;tex&amp;gt;t &amp;gt; 2&amp;lt;/tex&amp;gt;is quasi-perfect (Corresp.)\u201d, IEEE Transactions on Information Theory 25, 361 (1979). DOI] (see also Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 9).\n\nBinary BCH codes are subfield subcodes of GRS codes.\nThe \\([15,5,7]\\) BCH code extended with a parity check saturates the Griesmer bound ([J. Bierbrauer, Introduction to Coding Theory (Chapman and Hall/CRC, 2016). DOI], pg. 157).", "cousin_of_code_id": "quantum_bch\nreed_muller\nq-ary_hamming", "cousin_of_detail": "Binary BCH codes are used to construct a subset of qubit BCH codes via the CSS construction.\nRM\\((r,m)\\) codes are subcodes of BCH codes of designed distance \\(2^{m-r}-1\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 13).\nSome narrow sense BCH codes of length \\(n=(q^r-1)/(q-1)\\) such that \\(\\text{gcd}(r,q-1)=1\\) are \\(q\\)-ary Hamming codes ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Thm. 5.1.4).", "_type": "ecc", "_page_id": "c_bch", "_href": "c/bch"}, "c_zetterberg": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The rate is given by \\(1-\\frac{4s}{n}\\), which is asymptotically good, with a minimum distance of 5.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Kallquist first described an algebraic decoding theorem [P. Kallquist, \"Decoding of Zetterberg codes,\" in Proc. Fourth Joint Swedish-Soviet Workshop on Inform. Theory, Gotland, Sweden, Aug. 27-Sept. 1, 1989, p. 305-300]. A faster version was later provided in Ref. [S. M. Dodunekov and J. E. M. Nilsson, \u201cAlgebraic decoding of the Zetterberg codes\u201d, IEEE Transactions on Information Theory 38, 1570 (1992). DOI] and further modified in Ref. [M.-H. Jing et al., \u201cA Result on Zetterberg Codes\u201d, IEEE Communications Letters 14, 662 (2010). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Zetterberg code", "code_id": "zetterberg", "realizations": "Code used to provide better protection of data transmission with its double error correcting capacity [J. Meggitt, \u201cError correcting codes and their implementation for data transmission systems\u201d, IEEE Transactions on Information Theory 7, 234 (1961). DOI].", "protection": "Correct at least all weight-2 errors.", "notes": "", "physical": "bits", "short_name": "", "introduced": "[L.-H. Zetterberg, \u201cCyclic codes from irreducible polynomials for correction of multiple errors\u201d, IEEE Transactions on Information Theory 8, 13 (1962). DOI]", "description": "Family of binary cyclic \\([2^{2s}+1,2^{2s}-4s+1]\\) codes with distance \\(d>5\\) generated by the minimal polynomial \\(g_s(x)\\) of \\(\\alpha\\) over \\(GF(2)\\), where \\(\\alpha\\) is a primitive \\(n\\)th root of unity in the field \\(GF(2^{4s})\\). They are quasi-perfect codes and are one of the best known families of double-error correcting binary linear codes", "parents_code_id": "binary_cyclic\nquasi_perfect", "parents_detail": "\nZetterberg codes are quasi-perfect, with each \\(n\\)-bit string at most three bit-flips away from a codeword [S. M. Dodunekov and J. E. M. Nilsson, \u201cAlgebraic decoding of the Zetterberg codes\u201d, IEEE Transactions on Information Theory 38, 1570 (1992). DOI].", "_type": "ecc", "_page_id": "c_zetterberg", "_href": "c/zetterberg"}, "c_binary_cyclic": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Meggitt decoder [J. Meggitt, \u201cError correcting codes and their implementation for data transmission systems\u201d, IEEE Transactions on Information Theory 7, 234 (1961). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Cyclic linear binary code", "code_id": "binary_cyclic", "realizations": "", "protection": "Shift bound [J. van Lint and R. Wilson, \u201cOn the minimum distance of cyclic codes\u201d, IEEE Transactions on Information Theory 32, 23 (1986). DOI] gives a lower bound on the distance of cyclic binary codes.", "notes": "See Ch. 7 of Ref. [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.] for an exposition on cyclic codes.", "physical": "bits", "short_name": "", "introduced": "", "description": "A binary code of length \\(n\\) is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword. A cyclic code is called primitive when \\(n=2^r-1\\) for some \\(r\\geq 2\\). A shortened cyclic code is obtained from a cyclic code by taking only codewords with the first \\(j\\) zero entries, and deleting those zeroes. ", "parents_code_id": "cyclic\nbinary_linear\ngroup", "parents_detail": "\n\nA length-\\(n\\) cyclic binary linear code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).", "parent_of_code_id": "bch\nbinary_duadic\none_hot\nrepetition\nparity_check\nzetterberg", "parent_of_detail": "\n\n\n\nSince permutations preserve parity, the cyclic permutation of an SPC codeword is another codeword.\n", "cousins_code_id": "binary_ltc", "cousins_detail": "Cyclic linear codes cannot be \\(c^3\\)-LTCs [L. Babai, A. Shpilka, and D. Stefankovic, \u201cLocally Testable Cyclic Codes\u201d, IEEE Transactions on Information Theory 51, 2849 (2005). DOI]. Codeword symmetries are in general an obstruction to achieving such LTCs [M. Sudan, \u201cInvariance in Property Testing\u201d, Property Testing 211 (2010). DOI].", "cousin_of_code_id": "majorana_stab\nreed_muller", "cousin_of_detail": "Cyclic binary linear codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also self-orthogonal [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459].\nPunctured RM codes are cyclic ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 13, Thm. 11), making RM codes extended cyclic codes. RM codes with nonzero evaluation points are cyclic ([M. A. Tsfasman and S. G. Vl\u0103du\u0163, Algebraic-geometric Codes (Springer Netherlands, 1991). DOI], pg. 52).", "_type": "ecc", "_page_id": "c_binary_cyclic", "_href": "c/binary_cyclic"}, "c_golay": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Majority decoding for the extended Golay code [J.-M. Goethals, \u201cOn the Golay perfect binary code\u201d, Journal of Combinatorial Theory, Series A 11, 178 (1971). DOI].\nDecoder for the extended Golay code using the hexacode [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI].\nBoth Golay codes have a trellis representation and can thus be decoded using trellis decoding [A. J. VITERBI, \u201cError Bounds for Convolutional Codes and an Asymptotically Optimum Decoding Algorithm\u201d, The Foundations of the Digital Wireless World 41 (2009). DOI][B. Honary and G. Markarian, \u201cNew simple encoder and trellis decoder for Golay codes\u201d, Electronics Letters 29, 2170 (1993). DOI].\nBounded-distance decoder requiring at most 121 real operations [A. Vardy, \u201cEven more efficient bounded-distance decoding of the hexacode, the Golay code, and the Leech lattice\u201d, IEEE Transactions on Information Theory 41, 1495 (1995). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Golay code", "code_id": "golay", "realizations": "Used in the Voyager 1 and 2 spacecraft [E. C. Stone, \u201cThe Voyager 2 encounter with Uranus\u201d, Journal of Geophysical Research: Space Physics 92, 14873 (1987). DOI].\nRadio communications [E. E. Johnson. An Efficient Golay Codec For MIL-STD-188-141A and FED-STD-1045. Department of Electrical and Computer Engineering, New Mexico State University, 1991.].", "protection": "", "notes": "The automorphism group of the Golay code is the Mathieu group \\(\\mathcal{M}_{23}\\), and the automorphism group of the extended Golay code is the Mathieu group \\(\\mathcal{M}_{24}\\), two of the sporadic simple groups.", "physical": "bits", "short_name": "", "introduced": "[M. J. E. Golay, Notes on digital coding, Proc. IEEE, 37 (1949) 657.]", "description": "A \\([23, 12, 7]\\) perfect binary linear code with connections to various areas of mathematics, e.g., lattices [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI] and sporadic simple groups [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.]. Adding a parity bit to the code results in the \\([24, 12, 8]\\) extended Golay code. Up to equivalence, both codes are unique for their respective parameters.\n\nTo construct the Golay code, one can use the great dodecahedron to generate codewords by placing message bits on the faces and calculating the parity bits that live on the 12 vertices of the inner icosahedron. ", "parents_code_id": "perfect\nbinary_quad_residue\nbch", "parents_detail": "The Golay code is perfect.\nThe Golay code is a binary quadratic residue code with generator polynomial \\(r(x)\\) over \\(GF(2)\\) with length \\(n=23\\) ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 16).\nThe Golay code is equivalent to a BCH code with Bose distance 5 ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], Ch. 20).", "cousins_code_id": "nearly_perfect\ndual", "cousins_detail": "The extended Golay code is nearly perfect.\nThe extended Golay code is self-dual.", "cousin_of_code_id": "hexacode\nternary_golay", "cousin_of_detail": "Extended Golay codewords can be obtained from hexacodewords [J. H. Conway and N. J. A. Sloane, Sphere Packings, Lattices and Groups (Springer New York, 1999). DOI]. The hexacode can be used to decode the extended Golay code [V. Pless, \u201cDecoding the Golay codes\u201d, IEEE Transactions on Information Theory 32, 561 (1986). DOI]. There is also a connection between automoprhisms of the even Golay code and the holomorph of the hexacode [J. A. Harvey and G. W. Moore, \u201cMoonshine, superconformal symmetry, and quantum error correction\u201d, Journal of High Energy Physics 2020, (2020). DOI; 2003.13700].\n", "_type": "ecc", "_page_id": "c_golay", "_href": "c/golay"}, "c_bsghsv-ltc": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Ben-Sasson-Goldreich-Harsha-Sudan-Vadhan (BGHSV) code", "code_id": "bsghsv-ltc", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "BGHSV", "introduced": "[E. Ben-Sasson et al., \u201cRobust pcps of proximity, shorter pcps and applications to coding\u201d, Proceedings of the thirty-sixth annual ACM symposium on Theory of computing - STOC '04 (2004). DOI]", "description": "Locally testable \\([[n,k,d]]\\) code with \\(n = k^{1+\\epsilon}\\) and query complexity of order \\(O(1/\\epsilon)\\) for any \\(\\epsilon > 0\\). ", "parents_code_id": "binary_ltc", "parents_detail": "", "_type": "ecc", "_page_id": "c_bsghsv-ltc", "_href": "c/bsghsv-ltc"}, "c_gs-ltc": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Goldreich-Sudan code", "code_id": "gs-ltc", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[O. Goldreich and M. Sudan, \u201cLocally testable codes and PCPs of almost-linear length\u201d, Journal of the ACM 53, 558 (2006). DOI]", "description": "Locally testable \\([[n,k,d]]\\) code with \\(n = k^{1+O(1/u)}\\) and distance \\(\\Omega(n)\\) for query complexity \\(u\\). The same work also presented a probabilistic construction of codes of size \\(k^{1+o(1)}\\). ", "parents_code_id": "binary_ltc", "parents_detail": "Goldreich-Sudan codes resulted from what is often referred to as the first systematic study of LTCs.", "cousins_code_id": "random", "cousins_detail": "", "_type": "ecc", "_page_id": "c_gs-ltc", "_href": "c/gs-ltc"}, "c_bssvw-ltc": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Ben-Sasson-Sudan-Vadhan-Wigderson (BSVW) code", "code_id": "bssvw-ltc", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "BSVW", "introduced": "[E. Ben-Sasson et al., \u201cRandomness-efficient low degree tests and short PCPs via epsilon-biased sets\u201d, Proceedings of the thirty-fifth ACM symposium on Theory of computing - STOC '03 (2003). DOI]", "description": "Locally testable \\([[n,k,d]]\\) code with \\(n = k \\cdot 2^{\\tilde{O}(\\sqrt{\\log k})}\\) and asymptotically constant query complexity. ", "parents_code_id": "binary_ltc", "parents_detail": "", "_type": "ecc", "_page_id": "c_bssvw-ltc", "_href": "c/bssvw-ltc"}, "c_kmrs-ltc": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Kopparty-Meir-Ron-Zewi-Saraf (KMRS) code", "code_id": "kmrs-ltc", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "KMRS", "introduced": "[S. Kopparty et al., \u201cHigh-Rate Locally Correctable and Locally Testable Codes with Sub-Polynomial Query Complexity\u201d, Journal of the ACM 64, 1 (2017). DOI][S. Gopi et al., \u201cLocally Testable and Locally Correctable Codes approaching the Gilbert-Varshamov Bound\u201d, IEEE Transactions on Information Theory 64, 5813 (2018). DOI]", "description": "Member of a family of locally testable binary linear codes with constant rate, constant relative distance, and subpolynomial query complexity \\(u = (\\log n)^{O(\\log \\log n)}\\)). Later work by Gopi, Kopparty, Oliveira, Ron-Zewi, and Saraf [S. Gopi et al., \u201cLocally Testable and Locally Correctable Codes approaching the Gilbert-Varshamov Bound\u201d, IEEE Transactions on Information Theory 64, 5813 (2018). DOI] showed that related concatenated codes achieve the Gilbert-Varshamov bound. ", "parents_code_id": "binary_ltc", "parents_detail": "", "_type": "ecc", "_page_id": "c_kmrs-ltc", "_href": "c/kmrs-ltc"}, "c_long": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Long code", "code_id": "long", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[J. H\u00e5stad, \u201cSome optimal inapproximability results\u201d, Journal of the ACM 48, 798 (2001). DOI][M. Bellare, O. Goldreich, and M. Sudan, \u201cFree Bits, PCPs, and Nonapproximability---Towards Tight Results\u201d, SIAM Journal on Computing 27, 804 (1998). DOI]", "description": "Locally testable \\([[2^{2^k},k,d]]\\) code. The encoder maps a \\(k\\)-bit string into a codeword that consists of the values of all Boolean functions on the \\(k\\)-bit string. The code is not practical, but is useful for certain probabilistically checkable proof (PCP) constructions [Prahladh Harsha et al., \u201cLimits of Approximation Algorithms: PCPs and Unique Games (DIMACS Tutorial Lecture Notes)\u201d. 1002.3864]. ", "parents_code_id": "binary_ltc", "parents_detail": "", "parent_of_code_id": "hadamard", "parent_of_detail": "The Hadamard code is a subcode of the long code and can be obtained by restricting the long-code construction to only linear functions.", "_type": "ecc", "_page_id": "c_long", "_href": "c/long"}, "c_binary_ltc": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary linear LTC", "code_id": "binary_ltc", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "", "description": "A binary linear code \\(C\\) of length \\(n\\) that is a \\((u,R)\\)-LTC with query complexity \\(u\\) and soundness \\(R>0\\). More technically, the code is a \\((u,R)\\)-LTC if the rows of its parity-check matrix \\(H\\in GF(2)^{r\\times n}\\) have weight at most \\(u\\) and if \\begin{align}\n  \\frac{1}{r}|H x| \\geq \\frac{R}{n} D(x,C)\n\\end{align} holds for any bitstring \\(x\\), where \\(D(x,C)\\) is the Hamming distance between \\(x\\) and the closest codeword to \\(x\\) [A. Leverrier, V. Londe, and G. Z\u00e9mor, \u201cTowards local testability for quantum coding\u201d, Quantum 6, 661 (2022). DOI; 1911.03069; Def. 11]. ", "parents_code_id": "binary_linear\nltc", "parents_detail": "\n", "parent_of_code_id": "bsghsv-ltc\nbssvw-ltc\ndinur\ngs-ltc\nhadamard\nkmrs-ltc\nlr-cayley-complex\nlong", "parent_of_detail": "\n\n\nGoldreich-Sudan codes resulted from what is often referred to as the first systematic study of LTCs.\nThe Hadamard code is the first code to be identified as locally testable [M. Blum, M. Luby, and R. Rubinfeld, \u201cSelf-testing/correcting with applications to numerical problems\u201d, Journal of Computer and System Sciences 47, 549 (1993). DOI].\n\nLeft-right Cayley complex codes yield one of the first two families of \\(c^3\\)-LTCs.\n", "cousin_of_code_id": "binary_cyclic\nbinary_linear\nreed_muller", "cousin_of_detail": "Cyclic linear codes cannot be \\(c^3\\)-LTCs [L. Babai, A. Shpilka, and D. Stefankovic, \u201cLocally Testable Cyclic Codes\u201d, IEEE Transactions on Information Theory 51, 2849 (2005). DOI]. Codeword symmetries are in general an obstruction to achieving such LTCs [M. Sudan, \u201cInvariance in Property Testing\u201d, Property Testing 211 (2010). DOI].\nLinear binary codes with distances \\(\\frac{1}{2}n-\\sqrt{t n}\\) for some \\(t\\) are called almost-orthogonal and are locally testable with query complexity of order \\(O(t)\\) [T. Kaufman and S. Litsyn, \u201cAlmost Orthogonal Linear Codes are Locally Testable\u201d, 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS'05). DOI]. This was later improved to codes with distance \\(\\frac{1}{2}n-O(n^{1-\\gamma})\\) for any positive \\(\\gamma\\) [T. Kaufman and M. Sudan, \u201cSparse Random Linear Codes are Locally Decodable and Testable\u201d, 48th Annual IEEE Symposium on Foundations of Computer Science (FOCS'07) (2007). DOI], provided that the number of codewords is polynomial in \\(n\\).\nRM codes can be LTCs in the low- [N. Alon et al., \u201cTesting Reed\u2013Muller Codes\u201d, IEEE Transactions on Information Theory 51, 4032 (2005). DOI][T. Kaufman and D. Ron, \u201cTesting Polynomials over General Fields\u201d, SIAM Journal on Computing 36, 779 (2006). DOI] and high-error [Alex Samorodnitsky, \u201cLow-degree tests at large distances\u201d. math/0604353] regimes.", "_type": "ecc", "_page_id": "c_binary_ltc", "_href": "c/binary_ltc"}, "c_dinur": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Dinur code", "code_id": "dinur", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[I. Dinur, \u201cThe PCP theorem by gap amplification\u201d, Journal of the ACM 54, 12 (2007). DOI]", "description": "Member of infinite family of locally testable \\([[n,n/\\text{polylog}(n),d]]\\) codes with vanishing rate. Code construction relies on a construction utilizing tensor-product codes [Eli Ben-Sasson and Madhu Sudan, \u201cRobust Locally Testable Codes and Products of Codes\u201d. cs/0408066]. ", "parents_code_id": "binary_ltc", "parents_detail": "", "_type": "ecc", "_page_id": "c_dinur", "_href": "c/dinur"}, "c_lr-cayley-complex": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Left-right Cayley complex code", "code_id": "lr-cayley-complex", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "[Irit Dinur et al., \u201cLocally Testable Codes with constant rate, distance, and locality\u201d. 2111.04808]", "description": "Binary code constructed on a left-right Cayley complex using a pair of base codes \\(C_A,C_B\\) and an expander graph such that codewords for a fixed graph vertex are codewords of the tensor code \\(C_A \\otimes C_B\\). A family of such codes is one of the first \\(c^3\\)-LTCs. ", "parents_code_id": "binary_ltc", "parents_detail": "Left-right Cayley complex codes yield one of the first two families of \\(c^3\\)-LTCs.", "cousins_code_id": "tensor\nexpander\nbalanced_product\nquantum_tanner", "cousins_detail": "Left-right Cayley complex codewords for a fixed graph vertex are codewords of a tensor code.\nLeft-right Cayley complex codes can be viewed as Tanner-like codes on expander graphs, but with bits defined on squares and constraints on edges (as opposed to edges and vertices, respectively, for expander codes). Expander codes are also typically not locally testable [E. Ben-Sasson, P. Harsha, and S. Raskhodnikova, \u201cSome 3CNF properties are hard to test\u201d, Proceedings of the thirty-fifth ACM symposium on Theory of computing - STOC '03 (2003). DOI].\nLeft-right Cayley complexes can be obtained via a balanced product of \\(G\\)-graphs [Irit Dinur et al., \u201cLocally Testable Codes with constant rate, distance, and locality\u201d. 2111.04808].\nApplying the CSS construction to two left-right Cayley complex codes yields quantum Tanner codes, and one can simultaneously prove a linear distance for the quantum code and local testability for one of its constituent classical codes [Anthony Leverrier and Gilles Z\u00e9mor, \u201cQuantum Tanner codes\u201d. 2202.13641].", "_type": "ecc", "_page_id": "c_lr-cayley-complex", "_href": "c/lr-cayley-complex"}, "c_hadamard": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hadamard code", "code_id": "hadamard", "realizations": "", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "", "description": "Also known as a Walsh code or Walsh-Hadamard code. An \\([2^k,k,2^{k-1}]\\) balanced binary code dual to an extended Hamming Code.", "parents_code_id": "binary_ltc\nlong\nbalanced", "parents_detail": "The Hadamard code is the first code to be identified as locally testable [M. Blum, M. Luby, and R. Rubinfeld, \u201cSelf-testing/correcting with applications to numerical problems\u201d, Journal of Computer and System Sciences 47, 549 (1993). DOI].\nThe Hadamard code is a subcode of the long code and can be obtained by restricting the long-code construction to only linear functions.\nEach Hadamard codeword has length \\(2^m\\) and Hamming weight of \\(2^{m-1}\\), making this code balanced.", "cousins_code_id": "dual\nhamming\nreed_muller", "cousins_detail": "The Hadamard code is the dual of the extended Hamming Code.\nThe Hadamard code is the dual of the extended Hamming Code. Conversely, the shortened Hadamard code is the dual of the Hamming Code.\nFor any Hamming code \\([2^m,2^m-m-1,3]\\), the dual Hadamard code, when augmented with a bit that is always 0, gives the RM\\((1,m)\\) code. In general, RM\\((1,m)\\) is related to the duals of the Hamming code, and when RM\\((1,m)\\) is self-dual, it is directly related to the Hamming code.", "_type": "ecc", "_page_id": "c_hadamard", "_href": "c/hadamard"}, "c_repetition": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "Suppose each bit has probability \\(p\\) of being received correctly, independent for each bit. The probability that a repetition code is received correctly is \\(\\sum_{k=0}^{(n-1)/2}\\frac{n!}{k!(n-k)!}p^{n-k}(1-p)^{k}\\). If \\(\\frac{1}{2}\\leq p\\), then people can always increase the probability of success by increasing the number of physical bit \\(n\\).", "features_rate": "Code rate is \\(\\frac{1}{n}\\), code distance is \\(n\\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Calculate the Hamming weight \\(d_H\\) of the code. If \\(d_H\\leq \\frac{n-1}{2}\\), decode the code as 0. If \\(d_H\\geq \\frac{n+1}{2}\\), decode the code as 1.\nAutomaton-like decoders for the repetition code on a 2D lattice, otherwise known as the classical 2D Ising model, were developed by Toom [A. L. Toom, \u201cNonergodic Multidimensional System of Automata\u201d, Probl. Peredachi Inf., 10:3 (1974), 70\u201379; Problems Inform. Transmission, 10:3 (1974), 239\u2013246][L. F. Gray, \u201cToom\u2019s Stability Theorem in Continuous Time\u201d, Perplexing Problems in Probability 331 (1999). DOI]. An automaton by Gacs yields a decoder for a 1D lattice [P. G\u00e1cs, \u201c[]\u201d, Journal of Statistical Physics 103, 45 (2001). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "Triple modular redundancy (TMR) error-correction protocol [R. E. Lyons and W. Vanderkulk, \u201cThe Use of Triple-Modular Redundancy to Improve Computer Reliability\u201d, IBM Journal of Research and Development 6, 200 (1962). DOI]; see Ref. [Steven M. Girvin, \u201cIntroduction to Quantum Error Correction and Fault Tolerance\u201d. 2111.08894] for a pedagogical explanation.", "name": "Repetition code", "code_id": "repetition", "realizations": "Repetition codes, in conjunction with other codes, were used in magnetic disks [T. Klove and M. Miller, \u201cThe Detection of Errors After Error-Correction Decoding\u201d, IEEE Transactions on Communications 32, 511 (1984). DOI].", "protection": "Detects errors on up to \\(\\frac{n-1}{2}\\) coordinates, corrects erasure errors on up to \\(\\frac{n-1}{2}\\) coordinates. The generator matrix is \\(G=\\left[\\begin{smallmatrix}1 & 1&\\cdots& 1 & 1 \\end{smallmatrix}\\right]\\).", "notes": "", "physical": "bits", "short_name": "", "introduced": "", "description": "\\([n,1,n]\\) binary linear code encoding one bit of information into an \\(n\\)-bit string. The length \\(n\\) needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a \\((n,1)\\)-Hamming code.", "parents_code_id": "binary_cyclic\nnearly_perfect", "parents_detail": "\n", "cousins_code_id": "perfect\nquantum_repetition\nhamming", "cousins_detail": "Repetition codes are perfect for odd \\(n\\).\n\nThe triple repetition code \\([3,1,3]\\) is the smallest Hamming code.", "cousin_of_code_id": "self_correct\nsimplex\nparity_check\ndfour", "cousin_of_detail": "The repetition code associated with the 2D classical Ising model is a self-correcting classical memory [B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643; Sec. V.A].\n\\(S(2,1)\\) reduces to the repetition code.\nBinary SPCs and repetition codes are dual to each other.\nThe four-bit repetition code yields the \\(D_4\\) lattice code via the mod-two lattice construction.", "_type": "ecc", "_page_id": "c_repetition", "_href": "c/repetition"}, "c_gray": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Efficient encoder for binary reflected Gray code [J. R. Bitner, G. Ehrlich, and E. M. Reingold, \u201cEfficient generation of the binary reflected gray code and its applications\u201d, Communications of the ACM 19, 517 (1976). DOI].", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Gray code", "code_id": "gray", "realizations": "Three-dimensional imaging [G. Sansoni et al., \u201cThree-dimensional imaging based on Gray-code light projection: characterization of the measuring algorithm and development of a measuring system for industrial applications\u201d, Applied Optics 36, 4463 (1997). DOI].\nBroadcasting and communication [S. L. Johnsson and C.-T. Ho, \u201cOptimum broadcasting and personalized communication in hypercubes\u201d, IEEE Transactions on Computers 38, 1249 (1989). DOI].", "protection": "", "notes": "See Refs. [C. Savage, \u201cA Survey of Combinatorial Gray Codes\u201d, SIAM Review 39, 605 (1997). DOI][L. S. Barasch, S. Lakshmivarahan, and S. K. Dhall, \u201cGeneralized Gray Codes and Their Properties\u201d, Mathematics for Large Scale Computing 203 (2020). DOI][Torsten M\u00fctze, \u201cCombinatorial Gray codes-an updated survey\u201d. 2202.01280] reviews of various Gray codes.", "physical": "bits", "short_name": "", "introduced": "[Gray, Frank. \"Pulse code communication.\" United States Patent Number 2632058 (1953).][E. N. Gilbert, \u201cGray Codes and Paths on the n-Cube\u201d, Bell System Technical Journal 37, 815 (1958). DOI][J. T. Joichi, D. E. White, and S. G. Williamson, \u201cCombinatorial Gray Codes\u201d, SIAM Journal on Computing 9, 130 (1980). DOI]", "description": "The first Gray code [Gray, Frank. \"Pulse code communication.\" United States Patent Number 2632058 (1953).], now called the binary reflected Gray code, is a trivial code that orders length-\\(n\\) binary strings such that nearest-neighbor strings differ by only one digit.\n\nA simple example is the case \\(n=2\\), also known as the Gray map, which produces the ordering \\(0\\to 00\\), \\(1\\to 01\\), \\(2\\to 11\\), and \\(3\\to 10\\). The Gray map differs in the last two numbers from the usual binary expansion of the natural numbers, which maps \\(0\\to 00\\), \\(1\\to 01\\), \\(2\\to 10\\), and \\(3\\to 11\\).\n\nLayout out the Gray-map output strings counterclockwise on the corners of a 1D square, gray codes have been generalized such that nearest-neighbor strings differ by only one digit when the strings are arranged in higher-dimensional hypercubes [E. N. Gilbert, \u201cGray Codes and Paths on the n-Cube\u201d, Bell System Technical Journal 37, 815 (1958). DOI]. Further generalizations called combinatorial Gray codes [J. T. Joichi, D. E. White, and S. G. Williamson, \u201cCombinatorial Gray Codes\u201d, SIAM Journal on Computing 9, 130 (1980). DOI] refer to methods to generate organize combinatorial objects such that successive objects differ in some particular way. Particular \\(q\\)-ary extensions [Yicong Zhou et al., \u201c(n, k, p)-Gray code for image systems\u201d, IEEE Transactions on Cybernetics 43, 515 (2013). DOI] of Gray codes may be useful in digital imaging and signal processing.", "parents_code_id": "bits_into_bits", "parents_detail": "", "cousin_of_code_id": "psk\nqam\nrank_modulation", "cousin_of_detail": "1D Gray codes are often concatenated with PSKs so that the Hamming distance between the bitstrings encoded into the points is a discretized version of the Euclidean distance between the points.\n2D Gray codes are often concatenated with \\(n=1\\) lattice-based QAM codes so that the Hamming distance between the bitstrings encoded into the points is a discretized version of the Euclidean distance between the points.\nThe rank-modulation Gray code is an extension of the original binary Gray code to a code on the permutation group [Anxiao Jiang et al., \u201cRank Modulation for Flash Memories\u201d, IEEE Transactions on Information Theory 55, 2659 (2009). DOI].", "_type": "ecc", "_page_id": "c_gray", "_href": "c/gray"}, "c_parity_check": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The code rate is \\(\\frac{n}{n+1}\\to 1\\) as \\(n\\to\\infty\\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "If the receiver finds that the parity information of a codeword disagrees with the parity bit, then the receiver will discard the information and request a resend.\nWagner's rule yields a procedure that is linear in \\(n\\) [R. Silverman and M. Balser, \u201cCoding for constant-data-rate systems\u201d, Transactions of the IRE Professional Group on Information Theory 4, 50 (1954). DOI] (see [A. Lapidoth, A Foundation in Digital Communication (Cambridge University Press, 2017). DOI; Sec. 29.7.2] for a description).", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Single parity-check (SPC) code", "code_id": "parity_check", "realizations": "Can be realized on almost every communication device. SPCs are some of the earliest error-correcting codes ([Encyclopedia of Computer Science and Technology, Second Edition Volume I (CRC Press, 2017). DOI], Ch. 27).", "protection": "This code cannot protect information, it can only detect 1-bit error.", "notes": "", "physical": "bits", "short_name": "", "introduced": "", "description": "Also known as a sum-zero or even-weight code. An \\([n,n-1,2]\\) linear binary code whose codewords consist of the message string appended with a parity-check bit such that the parity (i.e., sum over all coordinates of each codeword) is zero. If the Hamming weight of a message is odd (even), then the parity bit is one (zero). This code requires only one extra bit of overhead and is therefore inexpensive.", "parents_code_id": "binary_cyclic\nnearly_perfect\nmds\ndivisible", "parents_detail": "Since permutations preserve parity, the cyclic permutation of an SPC codeword is another codeword.\n\n\nBinary SPCs are two-divisible.", "cousins_code_id": "repetition\nq-ary_parity_check\nbinary_linear\nldgm", "cousins_detail": "Binary SPCs and repetition codes are dual to each other.\n\nAny \\([n,k,d]\\) code with odd distance can be extended to an \\([n+1,k,d+1]\\) code by adding a bit storing the sum of codeword coordinates.\nConcatenated SPCs are LDGM [T. R. Oenning and Jaekyun Moon, \u201cA low-density generator matrix interpretation of parallel concatenated single bit parity codes\u201d, IEEE Transactions on Magnetics 37, 737 (2001). DOI].", "cousin_of_code_id": "classical_product\nreed_muller\ndfour", "cousin_of_detail": "SPC codes are used as component codes in classical-product code constructions.\nRM\\((m-1,m)\\) are parity-check codes.\nThe \\([4,3,2]\\) SPC code yields the \\(D_4\\) lattice code via the mod-two lattice construction.", "_type": "ecc", "_page_id": "c_parity_check", "_href": "c/parity_check"}, "c_hamming": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Asymptotic rate \\(k/n = 1-\\frac{\\log n}{n} \\to 1\\) and normalized distance \\(d/n \\to 0\\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hamming code", "code_id": "hamming", "realizations": "Commonly used when error rates are very low, for example, computer RAM or integrated circuits [R. Hentschke et al., \u201cAnalyzing area and performance penalty of protecting different digital modules with Hamming code and triple modular redundancy\u201d, Proceedings. 15th Symposium on Integrated Circuits and Systems Design. DOI].\nHamming-code based matrix embedding used in steganography [Crandall, Ron. \"Some notes on steganography.\" Posted on steganography mailing list 1998 (1998): 1-6.][A. Westfeld, \u201cF5\u2014A Steganographic Algorithm\u201d, Information Hiding 289 (2001). DOI].", "protection": "Can detect 1-bit and 2-bit errors, and can correct 1-bit errors.", "notes": "See Kaiserslautern database [Michael Helmling, Stefan Scholl, Florian Gensheimer, Tobias Dietz, Kira Kraft, Stefan Ruzika, and Norbert Wehn. Database of Channel Codes and ML Simulation Results. URL, 2022.] for explicit codes.", "physical": "bits", "short_name": "", "introduced": "[C. E. Shannon, \u201cA Mathematical Theory of Communication\u201d, Bell System Technical Journal 27, 379 (1948). DOI][R. W. Hamming, \u201cError Detecting and Error Correcting Codes\u201d, Bell System Technical Journal 29, 147 (1950). DOI][M. J. E. Golay, Notes on digital coding, Proc. IEEE, 37 (1949) 657.]", "description": "An infinite family of perfect linear codes with parameters \\((2^r-1,2^r-r-1, 3)\\) for \\(r \\geq 2\\). Their \\(r \\times (2^r-1) \\) parity check matrix \\(H\\) has all possible non-zero \\(r\\)-bit strings as its columns.\n\nA generator matrix for the \\([7,4,3]\\) Hamming code is \\begin{align}\n\\left(\\begin{array}{ccccccccccc}\n  1 & 0 & 0 & 0 & 1 & 1 & 0\\\\\n  0 & 1 & 0 & 0 & 1 & 0 & 1\\\\\n  0 & 0 & 1 & 0 & 0 & 1 & 1\\\\\n  0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\\right)~.\n\\end{align} ", "parents_code_id": "perfect\nreed_muller\nbch", "parents_detail": "\nHamming codes are equivalent to RM\\(^*(r-2,r)\\).\nBinary Hamming codes are binary primitive narrow-sense BCH codes ([W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes (Cambridge University Press, 2003). DOI], Corr. 5.1.5). Binary Hamming codes are cyclic ([R. Hill. A First Course In Coding Theory. Oxford University Press, 1988.], Thm. 12.22).", "parent_of_code_id": "tetracode", "parent_of_detail": "The tetracode is equivalent to the \\(r=2\\) Hamming code.", "cousins_code_id": "projective\nbinary_quad_residue\nquantum_hamming\nq-ary_hamming\nnearly_perfect", "cousins_detail": "Columns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(2)^n\\).\n\\([7,4,3]\\) Hamming code is a quadratic-residue code [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.].\n\n\nShortened Hamming codes \\([2^r-2,2^r-r-2,3]\\) are nearly perfect ([F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977.], pg. 533).", "cousin_of_code_id": "eeight\nhadamard\noctacode\nrepetition\nquantum_hamming_css\nsteane", "cousin_of_detail": "The \\([8,4,4]\\) Hamming code yields the \\(E_8\\) lattice code via the mod-two lattice construction.\nThe Hadamard code is the dual of the extended Hamming Code. Conversely, the shortened Hadamard code is the dual of the Hamming Code.\nThe octacode reduces modulo-two to the \\([8,4,4]\\) Hamming code [Self-dual Codes and Invariant Theory (Springer-Verlag, 2006). DOI].\nThe triple repetition code \\([3,1,3]\\) is the smallest Hamming code.\nQuantum Hamming codes result from applying the CSS construction to Hamming codes.\nThe Steane code is constructed from a classical Hamming code.", "_type": "ecc", "_page_id": "c_hamming", "_href": "c/hamming"}, "c_weight_two": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Weight-two code", "code_id": "weight_two", "realizations": "Two-in-five, also known as the two-out-of-five code, was used in the United States Postal Service's POSTNET barcode system as well as the Postal Alpha-numeric Encoding Technique (PLANET).\nTwo-in-five code forms the numerical part of the Code 39 barcode encoding.\nTwo-in-five code was used on early IBM computers [J. Svigals, \u201cIBM 7070 data processing system\u201d, Papers presented at the the March 3-5, 1959, western joint computer conference on XX - IRE-AIEE-ACM '59 (Western) (1959). DOI][T. M. Thompson, From Error-Correcting Codes Through Sphere Packings To Simple Groups, Mathematical Association of America, 1983.].", "protection": "", "notes": "See Ch. 19 of book [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI] on weight-two codes.", "physical": "bits", "short_name": "", "introduced": "[R. W. Hamming, Letter, April 5, 1978.]", "description": "A length-\\(n\\) binary code whose codewords all have Hamming weight two. Such codes provide slightly extra redundancy for storage of small-scale information such as ZIP codes or decimal digits.\n\nFor example, the two-in-five code has a size 10, thereby providing an encoding for the decimal digits 0 through 9. Such a code detects some single bit-flips as well as unidirectional errors using the fact that each codeword is weight-two. The code fails for any sequence of flips that maintains the constant weight. ", "parents_code_id": "constant_weight\nbinary_linear", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_weight_two", "_href": "c/weight_two"}, "c_one_hot": {"logical": "bits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "One-hot code", "code_id": "one_hot", "realizations": "The bi-quinary code, a combination of one-hot 1-in-2 and 1-in-5 one-hot codes to encode decimal digits, was used in several early computers ([Encyclopedia of Computer Science and Technology, Second Edition Volume I (CRC Press, 2017). DOI], Ch. 27).\nMarking the state of a finite automaton [S. Devadas and A. R. Newton, \u201cDecomposition and factorization of sequential finite state machines\u201d, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems 8, 1206 (1989). DOI].\nUsed in machine-learning based classification tasks because one-hot encodings, as opposed to integer encodings, do not presume an order [K. Potdar, T. S., and C. D., \u201cA Comparative Study of Categorical Variable Encoding Techniques for Neural Network Classifiers\u201d, International Journal of Computer Applications 175, 7 (2017). DOI].", "protection": "", "notes": "", "physical": "bits", "short_name": "", "introduced": "", "description": "Also known as an \\(1\\)-in-\\(n\\) code. A length-\\(n\\) binary code whose codewords are those with Hamming weight one. The reverse of this code, where all codewords have Hamming weight \\(n-1\\) is called a one-cold code. ", "parents_code_id": "constant_weight\nbinary_cyclic", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_one_hot", "_href": "c/one_hot"}, "c_metrological": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Metrological code", "code_id": "metrological", "realizations": "", "protection": "Physical noise can cause logical errors along one of the three axes, i.e., either logical-\\(X\\), \\(Y\\), or \\(Z\\), depending on what basis is used. Codes protect against logical errors along the remaining two axes.\n\nA metrological code defined in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits) has distance \\(d\\) if the above conditions are satisfied for an error set \\(\\cal E\\) consisting of errors supported on \\(d-1\\) subsystems of less.", "notes": "", "physical": "", "short_name": "", "introduced": "[Philippe Faist et al., \u201cTime-energy uncertainty relation for noisy quantum metrology\u201d. 2207.13707]", "description": "Linear subspace of a Hilbert space whose basis states satisfy only a part of the Knill-Laflamme conditions. The satisfied part of the conditions ensures that the code can be used for local parameter estimation.\n\nLetting \\(\\Pi = U U^\\dagger\\) be the codespace projector for encoding isometry \\(U\\) and projecting a pair of errors \\(E_i,E_j\\) from an error set \\(\\cal E\\) into the two-dimensional codespace yields \\begin{align}\n  \\Pi E_{i}^{^{\\dagger}}E_{j}\\Pi=c_{ij}\\,\\Pi+x_{ij}\\overline{X}+y_{ij}\\overline{Y}+z_{ij}\\overline{Z}\n\\end{align} with error-matrix element \\(c_{ij}\\) and logical-error coefficients \\begin{align}\n  \\left\\{ x,y,z\\right\\} _{ij}={\\textstyle \\frac{1}{2}}\\text{Tr}\\left(\\left\\{ \\overline{X},\\overline{Y},\\overline{Z}\\right\\} E_{i}^{^{\\dagger}}E_{j}\\right)~.\n\\end{align} If all three logical-error coefficients are zero, then the Knill-Laflamme conditions are satisfied, and the code is a QECC. If only one of the three coefficients is zero, then the code is the more general metrological code.", "parents_code_id": "quantum_into_quantum", "parents_detail": "", "parent_of_code_id": "qecc", "parent_of_detail": "Metrological codes satisfy the Knill-Laflamme conditions conditions only partially, and codes that satisfy them fully are QECCs.", "cousins_code_id": "metopt\ncovariant\nqubit_stabilizer", "cousins_detail": "Error-corrected sensing codes are required to satisfy the Knill-Laflamme conditions, while metrological codes need only satisfy the conditions partially.\nAny time-covariant QECC, i.e., a code admitting a continuous-parameter \\(U(1)\\) family of gates, is automatically a metrological code.\nA joint \\(+1\\) and \\(-1\\) eigenstate of a set of stabilizer can form a metrological stabilizer code [Philippe Faist et al., \u201cTime-energy uncertainty relation for noisy quantum metrology\u201d. 2207.13707].", "_type": "ecc", "_page_id": "c_metrological", "_href": "c/metrological"}, "c_oecc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Subsystem quantum error-correcting code", "code_id": "oecc", "realizations": "", "protection": "Necessary and sufficient [M. A. Nielsen and D. Poulin, \u201cAlgebraic and information-theoretic conditions for operator quantum error correction\u201d, Physical Review A 75, (2007). DOI; quant-ph/0506069] error-correction conditions are, for all errors \\(E_a,E_b\\) in an error set \\(\\cal{E}\\), \\begin{align}\nP E^{\\dagger}_a E_b P = I_{\\mathsf{A}} \\otimes g_{ab}^{\\mathsf{B}}\n\\end{align} where \\(P\\) is a projector onto the codespace \\(\\mathsf{C}\\), and \\(g_{ab}^{\\mathsf{B}}\\) is an arbitrary operator on the gauge subsystem. ", "notes": "", "physical": "", "short_name": "Subsystem QECC", "introduced": "[D. Kribs, R. Laflamme, and D. Poulin, \u201cUnified and Generalized Approach to Quantum Error Correction\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0412076][David W. Kribs et al., \u201cOperator quantum error correction\u201d. quant-ph/0504189]", "description": "A subsystem code, also known as an operator QECC or gauge QECC, encodes information in a subsystem \\(\\mathsf{A}\\) of the code space \\(\\mathsf{C}\\), which is part of the system Hilbert space \\(\\mathsf{H}\\), as \\begin{align}\n\\mathsf{H}=\\mathsf{C} \\oplus \\mathsf{C}^{\\perp} = \\mathsf{A} \\otimes \\mathsf{B} \\oplus \\mathsf{C}^{\\perp}~.\n\\end{align} Following an error, it is sufficient to revert back to the original state modulo a transformation on the auxiliary or gauge subsystem \\(\\mathsf{B}\\). The subsystem \\(\\mathsf{B}\\) therefore gives additional freedom to the error correction process, and is said to encode gauge qubits when its dimension is a power of two. While strictly speaking all operator QECCs are also ordinary QECCs, the attachment of a subsystem to a code allows for a wider variety of encoding procedures, fault-tolerant logical operations, and efficient error-correction protocols. ", "parents_code_id": "oaecc\nquantum_into_quantum", "parents_detail": "\n", "parent_of_code_id": "qudit_subsystem_stabilizer\nsubsystem_stabilizer", "parent_of_detail": "\n", "cousins_code_id": "qecc", "cousins_detail": "A subsystem code reduces to an ordinary error-correcting code when the gauge subsystem is trivial, \\(\\mathsf{B} = \\mathbb{C}\\). Conversely, any QECC with a tensor-product logical subspace can be turned into a subsystem code by treating a logical tensor factor as a gauge subsystem.", "cousin_of_code_id": "eaoecc", "cousin_of_detail": "Entanglement-assisted operator QECCs are subsystem QECCs utilizing pre-shared entanglement.", "_type": "ecc", "_page_id": "c_oecc", "_href": "c/oecc"}, "c_quantum_into_quantum": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum code", "code_id": "quantum_into_quantum", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Code designed for transmission of quantum information through a quantum channel for the purposes of robust storage, communication, or sensing. Transmission can be performed with side information or entanglement. ", "parents_code_id": "eacq", "parents_detail": "", "parent_of_code_id": "eaqecc\neaoecc\nmetrological\noecc", "parent_of_detail": "\n\n\n", "_type": "ecc", "_page_id": "c_quantum_into_quantum", "_href": "c/quantum_into_quantum"}, "c_eaqecc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Entanglement-assisted (EA) QECC", "code_id": "eaqecc", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "EAQECC", "introduced": "[T. A. Brun, I. Devetak, and M.-H. Hsieh, \u201cCatalytic Quantum Error Correction\u201d, IEEE Transactions on Information Theory 60, 3073 (2014). DOI; quant-ph/0608027][T. Brun, I. Devetak, and M.-H. Hsieh, \u201cCorrecting Quantum Errors with Entanglement\u201d, Science 314, 436 (2006). DOI; quant-ph/0610092]", "description": "QECC whose encoding and decoding utilizes pre-shared entanglement between sender and receiver.", "parents_code_id": "eacq\nquantum_into_quantum", "parents_detail": "\n", "parent_of_code_id": "eastab", "parent_of_detail": "", "cousins_code_id": "qecc\nqudits_into_qudits\nbinary_linear\nq-ary_linear", "cousins_detail": "EA-QECCs are QECCs utilizing pre-shared entanglement.\nPure modular-qudit codes can be used to make EA-QECCs with the same distance and dimension; see Thm. 10 of Ref. [M. Grassl, F. Huber, and A. Winter, \u201cEntropic Proofs of Singleton Bounds for Quantum Error-Correcting Codes\u201d, IEEE Transactions on Information Theory 68, 3942 (2022). DOI; 2010.07902].\nAny linear binary code can be used to construct an EAQECC.\nAny linear \\(q\\)-ary code can be used to construct an EAQECC.", "cousin_of_code_id": "metopt", "cousin_of_detail": "Metrologically optimal codes can be thought of as being entanglement-assisted because they require error-free ancillas for optimal local parameter estimation, and the estimation procedure uses an entangling gate.", "_type": "ecc", "_page_id": "c_eaqecc", "_href": "c/eaqecc"}, "c_eaoecc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Entanglement-assisted (EA) operator QECC", "code_id": "eaoecc", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "EAOQECC", "introduced": "[M.-H. Hsieh, I. Devetak, and T. Brun, \u201cGeneral entanglement-assisted quantum error-correcting codes\u201d, Physical Review A 76, (2007). DOI; 0708.2142][T. A. Brun, I. Devetak, and M.-H. Hsieh, \u201cGeneral entanglement-assisted quantum error-correcting codes\u201d, 2007 IEEE International Symposium on Information Theory (2007). DOI]", "description": "Subsystem QECC whose encoding and decoding utilizes pre-shared entanglement between sender and receiver.", "parents_code_id": "eacq\nquantum_into_quantum", "parents_detail": "\n", "cousins_code_id": "oecc", "cousins_detail": "Entanglement-assisted operator QECCs are subsystem QECCs utilizing pre-shared entanglement.", "_type": "ecc", "_page_id": "c_eaoecc", "_href": "c/eaoecc"}, "c_quantum_convolutional": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum convolutional code", "code_id": "quantum_convolutional", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[G. D. Forney, M. Grassl, and S. Guha, \u201cConvolutional and Tail-Biting Quantum Error-Correcting Codes\u201d, IEEE Transactions on Information Theory 53, 865 (2007). DOI; quant-ph/0511016]", "description": "Stub.", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "cousin_of_code_id": "convolutional\nquantum_reed_muller", "cousin_of_detail": "Quantum analogue of convolutional codes\nQuantum convolutional codes can be derived from Quantum Reed-Muller codes [Salah A. Aly, Andreas Klappenecker, and Pradeep Kiran Sarvepalli, \u201cQuantum Convolutional Codes Derived From Reed-Solomon and Reed-Muller Codes\u201d. quant-ph/0701037].", "_type": "ecc", "_page_id": "c_quantum_convolutional", "_href": "c/quantum_convolutional"}, "c_eastab": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Entanglement-assisted (EA) stabilizer code", "code_id": "eastab", "realizations": "", "protection": "", "notes": "See Ref. [Gaojun Luo et al., \u201cHow Much Entanglement Does a Quantum Code Need?\u201d. 2207.05647] for code tables and bounds on performance.", "physical": "", "short_name": "EA stabilizer", "introduced": "[T. A. Brun, I. Devetak, and M.-H. Hsieh, \u201cCatalytic Quantum Error Correction\u201d, IEEE Transactions on Information Theory 60, 3073 (2014). DOI; quant-ph/0608027][T. Brun, I. Devetak, and M.-H. Hsieh, \u201cCorrecting Quantum Errors with Entanglement\u201d, Science 314, 436 (2006). DOI; quant-ph/0610092]", "description": "Constructed using a variation of the stabilizer formalism designed to utilize pre-shared entanglement between sender and receiver. An EA stabilizer code is denoted as \\([[n,k;c]]\\) or \\([[n,k,d;c]]\\), where \\(d\\) is the code's distance, and \\(c\\) is the number of required pre-shared maximally entangled Bell states.' ", "parents_code_id": "eaqecc\nqubit_stabilizer", "parents_detail": "\nEntanglement-assisted stabilizer codes are stabilizer codes utilizing pre-shared entanglement.", "parent_of_code_id": "quantum_polar", "parent_of_detail": "Quantum polar codes are CSS codes used in an entanglement generation scheme that generally requires entanglement assistance. However, a variant exists that does not require entanglement assisstance [J. M. Renes et al., \u201cEfficient Quantum Polar Codes Requiring No Preshared Entanglement\u201d, IEEE Transactions on Information Theory 61, 6395 (2015). DOI; 1307.1136].", "cousins_code_id": "binary_linear\nq-ary_linear\ncss", "cousins_detail": "Any linear binary code can be used to construct an EA stabilizer code.\nAny linear quaternary (\\(q=4\\)) code can be used to construct an EA stabilizer code.\nAs opposed to CSS codes, EA stabilizer codes can be constructed from any linear binary code.", "_type": "ecc", "_page_id": "c_eastab", "_href": "c/eastab"}, "c_xs_stabilizer": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "XS stabilizer code", "code_id": "xs_stabilizer", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[X. Ni, O. Buerschaper, and M. Van den Nest, \u201cA non-commuting stabilizer formalism\u201d, Journal of Mathematical Physics 56, 052201 (2015). DOI; 1404.5327]", "description": "A type of stabilizer code where stabilizer generators are elements of the group \\( \\{\\alpha I, X, \\sqrt{Z}]\\}^{\\otimes n} \\), with \\( \\sqrt{Z} = \\text{diag} (1, i)\\). The codespace is a joint \\(+1\\) eigenspace of a set of stabilizer generators, which need not commute to define a valid codespace. ", "parents_code_id": "xp_stabilizer", "parents_detail": "The XP stabilizer formalism reduces to the XS formalism at \\(N=4\\).", "cousins_code_id": "topological_abelian", "cousins_detail": "Twisted quantum double models for the groups \\(\\mathbb{Z}_2^k\\) can be realized as XS stabilizer codes.", "_type": "ecc", "_page_id": "c_xs_stabilizer", "_href": "c/xs_stabilizer"}, "c_eth": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "An explicit universal recovery channel for the ETH code is given in [N. Bao and N. Cheng, \u201cEigenstate thermalization hypothesis and approximate quantum error correction\u201d, Journal of High Energy Physics 2019, (2019). DOI; 1906.03669].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Eigenstate thermalization hypothesis (ETH) code", "code_id": "eth", "realizations": "", "protection": "Approximately protects against erasure errors at known locations. Translation invariance alone is sufficient for good approximate error-correcting properties in a many-body spectrum, including in integrable models [F. G. S. L. Brand\u00e3o et al., \u201cQuantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains\u201d, Physical Review Letters 123, (2019). DOI; 1710.04631]. The ETH code generated from the spectrum of the translation-invariant 1D Heisenberg spin chain [F. G. S. L. Brand\u00e3o et al., \u201cQuantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains\u201d, Physical Review Letters 123, (2019). DOI; 1710.04631] has recovery infidelity (against the erasure of a constant number of sites) scale as \\(\\epsilon_\\text{worst}=O(1/n)\\) [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].", "notes": "", "physical": "qubits", "short_name": "ETH", "introduced": "[F. G. S. L. Brand\u00e3o et al., \u201cQuantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains\u201d, Physical Review Letters 123, (2019). DOI; 1710.04631]", "description": "Also called a thermodynamic code [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]. An \\(n\\)-qubit approximate code whose codespace is formed by eigenstates of a translationally-invariant quantum many-body system which satisfies the Eigenstate Thermalization Hypothesis (ETH). ETH ensures that codewords cannot be locally distinguished in the thermodynamic limit. Relevant many-body systems include 1D non-interacting spin chains, Motzkin chains, or Heisenberg models.\n\nETH requires that for ordered energy eigenstates \\(|E_l\\rangle\\) and any local observable \\(O\\), \\begin{align}\n|\\langle E_l|O|E_l\\rangle-\\langle E_{l+1}|O|E_{l+1}\\rangle|\\leq\\exp(-cn)\n\\end{align} for a constant \\(c\\). This implies that energy eigenstates around some energy \\(\\bar E\\) are approximately locally indistinguishable from one another, as their reduced density matrices on any subsystem are both approximately thermal at energy \\(\\bar E\\). In this way, global information is protected from local measurements by the environment as \\(n\\to\\infty\\). ", "parents_code_id": "hamiltonian\napproximate_qecc", "parents_detail": "ETH codewords are eigenstates of a local Hamiltonian whose eigenstates satisfy ETH.\nETH codes approximately protect against erasures in the thermodynamic limit.", "cousins_code_id": "topological", "cousins_detail": "ETH codewords, like topological codewords, are locally indistinguishable.", "cousin_of_code_id": "covariant", "cousin_of_detail": "ETH codes consisting of Dicke states are approximately \\(U(1)\\)-covariant and nearly saturate certain covariance-performance bounds [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360].", "_type": "ecc", "_page_id": "c_eth", "_href": "c/eth"}, "c_qubits_into_qubits": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder. For few-qubit codes (\\(n\\) is small), maximum-likelihood decoding can be based by creating a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Qubit code", "code_id": "qubits_into_qubits", "realizations": "", "protection": "A convenient and often considered error set is the Pauli error or Pauli string basis. For a single qubit, this set consists of products of powers of the Pauli matrices \\begin{align}\n  X=\\begin{pmatrix}0 & 1\\\\\n  1 & 0\n  \\end{pmatrix}\\,\\,\\text{ and }\\,\\,Z=\\begin{pmatrix}1 & 0\\\\\n  0 & -1\n  \\end{pmatrix}~.\n\\end{align} For multiple qubits, error set elements are tensor products of elements of the single-qubit error set.\n\nThe Pauli error set is a unitary and Hermitian basis for linear operators on the multi-qubit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a prototypical nice error basis [E. Knill, \u201cNon-binary Unitary Error Bases and Quantum Codes\u201d. quant-ph/9608048]. The distance associated with this set is often the minimum weight of a Pauli string that implements a nontrivial logical operation in the code. The minimum weight of a Pauli error that has a non-zero expectation value for some code basis state is called the diagonal distance [Upendra S. Kapshikar, \u201cThe Diagonal Distance of CWS Codes\u201d. 2107.11286]. Codes whose distance is greater than the diagonal distance are degenerate. ", "notes": "There is a relation between one-way entanglement distillation protocols and QECCs [C. H. Bennett et al., \u201cMixed-state entanglement and quantum error correction\u201d, Physical Review A 54, 3824 (1996). DOI; quant-ph/9604024].", "physical": "qubits", "short_name": "", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2^n\\)-dimensional (i.e., \\(n\\)-qubit) Hilbert space. Usually denoted as \\(((n,K))\\) or \\(((n,K,d))\\), where \\(d\\) is the code's distance. ", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "cws\nmovassagh_ouyang\nxp_stabilizer", "parent_of_detail": "\n\n", "cousin_of_code_id": "fermions\nfock_state\ngroup_quantum\nspins_into_spins", "cousin_of_detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation [A. Y. Kitaev, \u201cUnpaired Majorana fermions in quantum wires\u201d, Physics-Uspekhi 44, 131 (2001). DOI; cond-mat/0010440], codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations.\nFock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators [Victor V. Albert, private communication, 2016]. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations [Steven M. Girvin, \u201cIntroduction to Quantum Error Correction and Fault Tolerance\u201d. 2111.08894].\nGroup quantum codes whose physical spaces are constructed using the group \\(\\mathbb{Z}_2\\) are qubit codes.\nSpin codes with spin \\(\\ell=1/2\\) correspond to qubit codes.", "_type": "ecc", "_page_id": "c_qubits_into_qubits", "_href": "c/qubits_into_qubits"}, "c_qubit_stabilizer": {"logical": "qubits", "features_code_capacity_threshold": "Bounds on code capacity thresholds using maximum-likelihood (ML) decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][A. A. Kovalev and L. P. Pryadko, \u201cFault tolerance of quantum low-density parity check codes with sublinear distance scaling\u201d, Physical Review A 87, (2013). DOI; 1208.2317][Alexey A. Kovalev and Leonid P. Pryadko, \u201cSpin glass reflection of the decoding transition for quantum error correcting codes\u201d. 1311.7688][C. T. Chubb and S. T. Flammia, \u201cStatistical mechanical models for quantum codes with correlated noise\u201d, Annales de l\u2019Institut Henri Poincar\u00e9 D 8, 269 (2021). DOI; 1809.10704].", "features_general_gates": "Logical gates implemented via constant-depth quantum circuits of \\(D\\)-dimensional geometrically local stabilizer codes lie in the \\(D\\)th level of the Clifford hierarchy [S. Bravyi and R. K\u00f6nig, \u201cClassification of Topologically Protected Gates for Local Stabilizer Codes\u201d, Physical Review Letters 110, (2013). DOI; 1206.1609].\nWith pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].", "features_threshold": "Computational thresholds against stochastic local noise can be achieved through repeated use of concatenatenation, and can rely on the same small code in every level [E. Knill, R. Laflamme, and W. H. Zurek, \u201cResilient quantum computation: error models and thresholds\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 454, 365 (1998). DOI; quant-ph/9702058][Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129][J. Preskill, \u201cReliable quantum computers\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 454, 385 (1998). DOI; quant-ph/9705031][Panos Aliferis, Daniel Gottesman, and John Preskill, \u201cQuantum accuracy threshold for concatenated distance-3 codes\u201d. quant-ph/0504218]. The resulting code is highly degenerate, with all but an exponentially small fraction of generators having small weights. Circuit and measurement designs have to take case of the few stabilizer generators with large weights in order to be fault tolerant.", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Circuits consisting of CNOT, Hadamard, and phase gates using algorithm based on the Gottesman-Knill theorem [S. Aaronson and D. Gottesman, \u201cImproved simulation of stabilizer circuits\u201d, Physical Review A 70, (2004). DOI; quant-ph/0406196].\nCircuits obtained by first constructing the CWS form of the code [I. Chuang et al., \u201cCodeword stabilized quantum codes: Algorithm and structure\u201d, Journal of Mathematical Physics 50, 042109 (2009). DOI; 0803.3232][A. Cross et al., \u201cCodeword Stabilized Quantum Codes\u201d, IEEE Transactions on Information Theory 55, 433 (2009). DOI; 0708.1021]. These consist of \\(n\\) Hadamard gates, a classical encoder which takes at most \\(n\\) CX gates for a single-qubit encoding code, and at most \\(n(n-1)/2\\) CZ gates to create the needed graph state.\nDissipative preparation, for which codespace is steady-state space of a Lindbladian [J. Dengis, R. K\u00f6nig, and F. Pastawski, \u201cAn optimal dissipative encoder for the toric code\u201d, New Journal of Physics 16, 013023 (2014). DOI; 1310.1036].\nLindbladian-based dissipative encoding [Juan Pablo Paz and Wojciech Hubert Zurek, \u201cContinuous Error Correction\u201d. quant-ph/9707049][J. Dengis, R. K\u00f6nig, and F. Pastawski, \u201cAn optimal dissipative encoder for the toric code\u201d, New Journal of Physics 16, 013023 (2014). DOI; 1310.1036] that does not give a speedup, in terms of scaling with \\(n\\), over circuit-based encoders [R. K\u00f6nig and F. Pastawski, \u201cGenerating topological order: No speedup by dissipation\u201d, Physical Review B 90, (2014). DOI; 1310.1037].", "features_decoders": "The structure of stabilizer codes allows for syndrome-based decoding, where errors are corrected based on the results of stabilizer measurements (syndromes). The size of the circuit extracting the syndrome depends on the weight of its corresponding stabilizer generator. Maximum-likelihood decoding is \\(NP\\)-complete in general [M.-H. Hsieh and F. Le Gall, \u201cNP-hardness of decoding quantum error-correction codes\u201d, Physical Review A 83, (2011). DOI; 1009.1319][Kuo, Kao-Yueh, and Chung-Chin Lu. \"On the hardness of decoding quantum stabilizer codes under the depolarizing channel.\" 2012 International Symposium on Information Theory and its Applications. IEEE, 2012.]. Degenerate maximum-likelihood decoding is \\(\\#P\\)-complete in general [Pavithran Iyer and David Poulin, \u201cHardness of decoding quantum stabilizer codes\u201d. 1310.3235], although can be polynomial-time for specific codes like the surface code [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883].\nTrellis decoder, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) [H. Ollivier and J.-P. Tillich, \u201cTrellises for stabilizer codes: Definition and uses\u201d, Physical Review A 74, (2006). DOI; quant-ph/0512041].\nQuantum extension of GRAND decoder [Diogo Cruz, Francisco A. Monteiro, and Bruno C. Coutinho, \u201cQuantum Error Correction via Noise Guessing Decoding\u201d. 2208.02744].\nDeep neural-network probabilistic decoder [S. Krastanov and L. Jiang, \u201cDeep Neural Network Probabilistic Decoder for Stabilizer Codes\u201d, Scientific Reports 7, (2017). DOI; 1705.09334].", "features_transversal_gates": "", "features_fault_tolerance": "With pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].\nFault-tolerant error correction scheme by Shor [Peter W. Shor, \u201cFault-tolerant quantum computation\u201d. quant-ph/9605011], which is based on repeated measurements. A modification uses adaptive measurements [Theerapat Tansuwannont and Kenneth R. Brown, \u201cAdaptive syndrome measurements for Shor-style error correction\u201d. 2208.05601].\nGeneralization of Steane error correction stabilizer codes [Yoder, Theodore., DSpace@MIT Practical Fault-Tolerant Quantum Computation (2018); Sec. 3.6].\nFault-tolerant error correction scheme by Knill (a.k.a. telecorrection [C. M. Dawson, H. L. Haselgrove, and M. A. Nielsen, \u201cNoise thresholds for optical cluster-state quantum computation\u201d, Physical Review A 73, (2006). DOI; quant-ph/0601066]), which is based on teleportation [E. Knill, \u201cQuantum computing with realistically noisy devices\u201d, Nature 434, 39 (2005). DOI; quant-ph/0410199][E. Knill, \u201cScalable Quantum Computation in the Presence of Large Detected-Error Rates\u201d. quant-ph/0312190].", "name": "Qubit stabilizer code", "code_id": "qubit_stabilizer", "realizations": "", "protection": "Detects errors on up to \\(d-1\\) qubits, and corrects erasure errors on up to \\(d-1\\) qubits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).\n\nA stabilizer code is geometrically local if the support of the stabilizer generators is bounded by a ball of size independent of \\(n\\). There is an upper bound of \\(d \\leq O(L^{D-1})\\) on the distance [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983] of geometrically local stabilizer codes arranged in a \\(D\\)-dimensional lattice of length \\(L\\) with \\(n=L^D\\). ", "notes": "Tables of bounds and examples of stabilizer codes for various \\(n\\) and \\(k\\), based on algorithms developed in Ref. [M. Grassl, \u201cSearching for linear codes with large minimum distance\u201d, Discovering Mathematics with Magma 287. DOI], are maintained by M. Grassl at this website.\nStabilizer error-recovery circuits can be simulated efficiently using dedicated software (e.g., STIM [C. Gidney, \u201cStim: a fast stabilizer circuit simulator\u201d, Quantum 5, 497 (2021). DOI; 2103.02202]).", "physical": "qubits", "short_name": "", "introduced": "[A. R. Calderbank et al., \u201cQuantum Error Correction and Orthogonal Geometry\u201d, Physical Review Letters 78, 405 (1997). DOI; quant-ph/9605005][Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052]", "description": "Also called a Pauli stabilizer code. An \\(((n,2^k,d))\\) qubit stabilizer code is denoted as \\([[n,k]]\\) or \\([[n,k,d]]\\), where \\(d\\) is the code's distance. Logical subspace is the joint eigenspace of commuting Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace of a set of \\(2^{n-k}\\) commuting Pauli operators which do not contain \\(-I\\). The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation in the code.\n\nEach stabilizer code can be represented by a \\((n-k) \\times 2n\\) check matrix (a.k.a. stabilizer generator matrix) \\(H=(A|B)\\), where each row \\((a|b)\\) is the binary symplectic representation of an element from a set of generating elements of the stabilizer group. The check matrix can be brought into standard form via Gaussian elimination [M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum Information (Cambridge University Press, 2012). DOI].\n\nThe stabilizer commutation condition can equivalently be stated in the symplectic representation. A pair of \\(n\\)-qubit stabilizers with symplectic representations \\((a|b)\\) and \\((a^{\\prime}|b^{\\prime})\\) commute iff their symplectic inner product is zero, \\begin{align}\n  a \\cdot b^{\\prime} + a^{\\prime}\\cdot b = \\sum_{j=1}^{n} a_j b^{\\prime}_j + a^{\\prime}_i b_i = 0~.\n\\end{align} Symplectic representations of stabilizer group elements thus form a self-orthogonal subspace of \\(GF(2)^{2n}\\) with respect to the symplectic inner product.", "parents_code_id": "stabilizer\ncws\nxp_stabilizer\nquantum_lego", "parents_detail": "\nIf the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code.\nThe XP stabilizer formalism reduces to the Pauli formalism at \\(N=2\\).\nQubit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qubit repetition code, single-qubit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state.", "parent_of_code_id": "css\nclifford-deformed_surface\ncrystalline_dynamic_gen\neastab\nfusion\nhaah_cubic\nmajorana_stab\nmatching\nhappy\nquantum_convolutional\nquantum_bch\nrbh\nstabilizer_over_gf4\ntfim\nxyz_product\nquantum_hamming", "parent_of_detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) self-orthogonal CSS code, with the mapping preserving geometric locality of a code up to a constant factor [S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791].\n\n\nEntanglement-assisted stabilizer codes are stabilizer codes utilizing pre-shared entanglement.\nThe resource states in FBQC are small stabilizer states, and after fusion measurements, the outputs are stabilizers (conditioned on measurement outcomes.\n\nThe Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438][S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791]. However, Pauli- and Majorana-based stabilizer codes have different notions of locality [A. Y. Kitaev, \u201cUnpaired Majorana fermions in quantum wires\u201d, Physics-Uspekhi 44, 131 (2001). DOI; cond-mat/0010440] and are thus useful for different physical platforms.\n\nThe HaPPY code is a stabilizer code because it is defined by a contracted network of stabilizer tensors; see Thm. 6 in Ref. [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\n\nqubit BCH codes constructed via the CSS construction are CSS codes, and the rest are stabilizer codes over \\(GF(4)\\).\n\n\n\n\n", "cousins_code_id": "binary_linear\ndual\nhamiltonian\nqudit_stabilizer", "cousins_detail": "Qubit stabilizer codes are quantum analogues of binary linear codes.\nSymplectic representations of stabilizer group elements form a linear code over \\(GF(2)\\) that is self-orthogonal with respect to the symplectic inner product ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.6).\nCodespace is the ground-state space of the code Hamiltonian, which consists of an equal linear combination of stabilizer generators and which can be made into a commuting projector Hamiltonian.\nModular-qudit stabilizer codes for prime-dimensional qudits \\(q=p\\) inherit most of the features of qubit stabilizer codes, including encoding an integer number of qudits and a Pauli group with a unique number of generators. Conversely, qubit codes can be extended to modular-qudit codes by decorating appropriate generators with powers. For example, \\([[4,2,2]]\\) qubit code generators can be adjusted to \\(ZZZZ\\) and \\(XX^{-1} XX^{-1}\\). A systematic procedure extending a qubit code to prime-qudit codes involves putting its generator matrix into local-dimension-invariant (LDI) form [L. G. Gunderman, \u201cLocal-dimension-invariant qudit stabilizer codes\u201d, Physical Review A 101, (2020). DOI; 1910.08122]. Various bounds exist on the distance of the resulting codes [Arun J. Moorthy and Lane G. Gunderman, \u201cLocal-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise\u201d. 2110.11510][L. G. Gunderman, \u201cDegenerate local-dimension-invariant stabilizer codes and an alternative bound for the distance preservation condition\u201d, Physical Review A 105, (2022). DOI; 2110.15274].", "cousin_of_code_id": "galois_stabilizer\nmetrological\nmovassagh_ouyang\nsubsystem_stabilizer\ntranslationally_invariant_stabilizer", "cousin_of_detail": "Galois-qudit stabilizer codes reduce to qubit stabilizer codes for \\(q=2\\).\nA joint \\(+1\\) and \\(-1\\) eigenstate of a set of stabilizer can form a metrological stabilizer code [Philippe Faist et al., \u201cTime-energy uncertainty relation for noisy quantum metrology\u201d. 2207.13707].\nMany, but not all, Movassagh-Ouyang codes are stabilizer codes.\nSubsystem stabilizer codes reduce to stabilizer codes when there are no gauge qubits.\nQubit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site.", "_type": "ecc", "_page_id": "c_qubit_stabilizer", "_href": "c/qubit_stabilizer"}, "c_quantum_reed_muller": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Magic state distillation in all prime dimensions [E. T. Campbell, H. Anwar, and D. E. Browne, \u201cMagic-State Distillation in All Prime Dimensions Using Quantum Reed-Muller Codes\u201d, Physical Review X 2, (2012). DOI]", "features_threshold": "Between \\(10^{-3}\\) and \\(10^{-6}\\) for depolarizing noise (assuming ideal decoders), see [L. Luo et al., \u201cFault-tolerance thresholds for code conversion schemes with quantum Reed\u2013Muller codes\u201d, Quantum Science and Technology 5, 045022 (2020). DOI]", "features_rate": "\\(\\frac{k}{n}\\), where \\(k = 2^r - {r \\choose t} + 2 \\sum_{i=0}^{t-1} {r \\choose i}\\). Additionally, CSS codes formed from binary Reed-Muller codes achieve channel capacity on erasure channels [Shrinivas Kudekar et al., \u201cReed-Muller Codes Achieve Capacity on Erasure Channels\u201d. 1601.04689].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "Gate switching protocol for universal computation [J. T. Anderson, G. Duclos-Cianci, and D. Poulin, \u201cFault-Tolerant Conversion between the Steane and Reed-Muller Quantum Codes\u201d, Physical Review Letters 113, (2014). DOI; 1403.2734].", "name": "Quantum Reed-Muller code", "code_id": "quantum_reed_muller", "realizations": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Andrew Steane, \u201cQuantum Reed-Muller Codes\u201d. quant-ph/9608026]", "description": "A CSS code formed from a classical Reed-Muller code (or its punctured versions) in which polynomials over finite fields encode data. This is done by transforming these polynomials into the stabilizer generator matrices.", "parents_code_id": "css", "parents_detail": "", "parent_of_code_id": "diagonal_clifford\nquantum_hamming_css", "parent_of_detail": "\n\\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS codes are quantum Reed-Muller codes because they are formed from classical Hamming codes, which are equivalent to RM\\((r-2,r)\\).", "cousins_code_id": "reed_muller\nquantum_convolutional", "cousins_detail": "\nQuantum convolutional codes can be derived from Quantum Reed-Muller codes [Salah A. Aly, Andreas Klappenecker, and Pradeep Kiran Sarvepalli, \u201cQuantum Convolutional Codes Derived From Reed-Solomon and Reed-Muller Codes\u201d. quant-ph/0701037].", "cousin_of_code_id": "covariant\nquantum_divisible\nquantum_triorthogonal", "cousin_of_detail": "Quantum RM codes are approximately covariant and nearly saturate certain covariance-performance bounds [Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360].\nQuantum RM codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions.\nClassification of triorthongonal codes yields a connection to Reed-Muller polynomials [S. Nezami and J. Haah, \u201cClassification of small triorthogonal codes\u201d, Physical Review A 106, (2022). DOI; 2107.09684].", "_type": "ecc", "_page_id": "c_quantum_reed_muller", "_href": "c/quantum_reed_muller"}, "c_movassagh_ouyang": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The rate depends on the classical code, but distance can scale linearly with \\(n\\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Movassagh-Ouyang Hamiltonian code", "code_id": "movassagh_ouyang", "realizations": "", "protection": "Let \\(C \\subset \\{0,1,\\dots,q-1\\}^n\\) be a classical code with distance \\(d_x\\). Let \\(d_z\\) satisfy \\(q^n > 2 V_q(d_z-1) -1\\), where \\(V_q(r)\\) is the volume of the \\(q\\)-ary Hamming ball of radius \\(r\\). Then the algorithm produces a quantum code with distance \\(d = \\text{min}(d_x,d_z)\\). Asymptotically, the distance scales linearly with \\(n\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Ramis Movassagh and Yingkai Ouyang, \u201cConstructing quantum codes from any classical code and their embedding in ground space of local Hamiltonians\u201d. 2012.01453]", "description": "This is a family of codes derived via an algorithm that takes as input any binary classical code and outputs a quantum code (note that this framework can be extended to \\(q\\)-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.\n\nThis family strictly generalizes CSS codes (because CSS codes come only from linear or self orthogonal classical codes). These codes can be shown to be realized as a subspace of the ground space of a (geometrically) local Hamiltonian. ", "parents_code_id": "qubits_into_qubits\nhamiltonian", "parents_detail": "\nMovassagh-Ouyang codes reside in the ground space of a Hamiltonian.", "parent_of_code_id": "css", "parent_of_detail": "Movassagh-Ouyang codes stem from a prescription that converts an arbitrary classical code into a quantum code.", "cousins_code_id": "qubit_stabilizer\nbits_into_bits", "cousins_detail": "Many, but not all, Movassagh-Ouyang codes are stabilizer codes.\nMovassagh-Ouyang codes are constructed from classical binary codes.", "cousin_of_code_id": "cws", "cousin_of_detail": "The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other.", "_type": "ecc", "_page_id": "c_movassagh_ouyang", "_href": "c/movassagh_ouyang"}, "c_quantum_bch": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Qubit BCH code", "code_id": "quantum_bch", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[M. Grassl, T. Beth, and T. Pellizzari, \u201cCodes for the quantum erasure channel\u201d, Physical Review A 56, 33 (1997). DOI; quant-ph/9610042][A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006][Andrew M. Steane, \u201cEnlargement of Calderbank Shor Steane quantum codes\u201d. quant-ph/9802061][Markus Grassl and Thomas Beth, \u201cQuantum BCH Codes\u201d. quant-ph/9910060]", "description": "Qubit stabilizer code constructed from a self-orthogonal binary BCH code via the CSS construction, from a Hermitian self-orthogonal quaternary BCH code via the stabilizer-over-\\(GF(4)\\) construction, or by taking a Euclidean self-orthogonal BCH code over \\(GF(2^m)\\), converting it to a binary code, and applying the CSS construction. ", "parents_code_id": "qubit_stabilizer", "parents_detail": "qubit BCH codes constructed via the CSS construction are CSS codes, and the rest are stabilizer codes over \\(GF(4)\\).", "cousins_code_id": "bch\nq-ary_bch\ncss\nstabilizer_over_gf4", "cousins_detail": "Binary BCH codes are used to construct a subset of qubit BCH codes via the CSS construction.\nBCH codes are used to construct qubit BCH codes via the CSS and stabilizer-over-\\(GF(4)\\) constructions.\nSome qubit BCH codes are CSS.\nHermitian self-orthogonal quaternary BCH codes are used to construct a subset of qubit BCH codes via the stabilizer-over-\\(GF(4)\\) construction.", "cousin_of_code_id": "galois_bch", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_quantum_bch", "_href": "c/quantum_bch"}, "c_gnu_permutation_invariant": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "GNU permutation-invariant code", "code_id": "gnu_permutation_invariant", "realizations": "", "protection": "Depends on the family. One family which is completely symmetrized versions of Bacon-Shor codes (parameterized by \\(t\\)) protects against arbitrary weight-\\(t\\) qubit errors. Additionally, codes with large enough length \\((t+1)(3t+1)+t\\) can approximately correct \\(t\\) spontaneous decay errors.", "notes": "", "physical": "qubits", "short_name": "GNU", "introduced": "[Y. Ouyang, \u201cPermutation-invariant quantum codes\u201d, Physical Review A 90, (2014). DOI; 1302.3247]", "description": "Can be expressed in terms of Dicke states where the logical states are \\begin{align}\n|\\overline{\\pm}\\rangle = \\sum_{\\ell=0}^{n} \\frac{(\\pm 1)^\\ell}{\\sqrt{2^n}} \\sqrt{n \\choose \\ell} |D^m_{g \\ell}\\rangle~.\n\\end{align} Here, \\(m\\) is the number of particles used for encoding \\(1\\) qubit, and \\(g, n \\leq m\\) are arbitrary positive integers. The state \\(|D^m_w\\rangle\\) is a Dicke state -- a normalized permutation-invariant state on \\(m\\) qubits with \\(w\\) excitations, i.e., a normalized sum over all basis elements with \\(w\\) ones and \\(m - w\\) zeroes.\n\nA qudit extension of such codes, based on a correspondence with binomial codes, exists [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]. ", "parents_code_id": "permutation_invariant", "parents_detail": "", "cousins_code_id": "bacon_shor\nhamiltonian\napproximate_qecc\nbinomial\nquantum_repetition", "cousins_detail": "Symmetrized versions of the Bacon-Shor codes are GNU codes\nGNU codes lie within the ground state of ferromagnetic Heisenberg models without an external magnetic field [Y. Ouyang, \u201cQuantum storage in quantum ferromagnets\u201d, Physical Review B 103, (2021). DOI; 1904.01458].\nGNU codes protect approximately against amplitude damping errors.\nBinomial codes and GNU codes are both related to spin-coherent states, and a qudit generalization can be obtained from qudit binomial codes ([V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010], Appx. C).\nGNU codewords for \\(g=1\\) reduce to the phase-flip code.", "_type": "ecc", "_page_id": "c_gnu_permutation_invariant", "_href": "c/gnu_permutation_invariant"}, "c_cws": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "If \\( \\mathcal{C} \\) has an efficient classical encoder, then so does the CWS code \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\).", "features_decoders": "There is no known efficient algorithm to decode non-additive (non-stabilizer) CWS codes.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Codeword stabilized (CWS) code", "code_id": "cws", "realizations": "", "protection": "Code distance \\(\\mathcal{Q} = ( \\mathcal{G},\\mathcal{C}) \\) is upper bounded by the distance of the classical code \\(\\mathcal{C} \\). The diagonal distance is upper bounded by \\(\\delta + 1\\), where \\(\\delta\\) is the minimum degree of \\(\\mathcal{G}\\). Computing the distance is generally NP-complete, and is NP-hard for non-degenerate codes [Upendra Kapshikar and Srijita Kundu, \u201cDiagonal distance of quantum codes and hardness of the minimum distance problem\u201d. 2203.04262].", "notes": "", "physical": "qubits", "short_name": "CWS", "introduced": "[A. Cross et al., \u201cCodeword Stabilized Quantum Codes\u201d, IEEE Transactions on Information Theory 55, 433 (2009). DOI; 0708.1021]", "description": "This family of codes strictly generalizes stabilizer codes. They are usually denoted by \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\) where \\(\\mathcal{G}\\) is a graph and \\(\\mathcal{C}\\) is a \\( (n,K,d) \\) binary classical code. From the graph we form the unique graph state (stabilizer state) \\( |G \\rangle \\). From the classical code we form Pauli \\(Z\\)-type operators \\( W_i = Z^{c_{i,1}} \\otimes \\cdots \\otimes Z^{c_{i,n}} \\), where \\(c_{i,j} \\) is the \\(j\\)-th bit of the \\(i\\)-th classical codeword. The CWS codewords are then \\( | i \\rangle =  W_i | G \\rangle \\).\n\nThere is an alternative description to the one above that is locally Clifford-equivalent. In particular, we can describe CWS codes as \\( \\mathcal{Q} = (S,\\mathcal{W})\\) where \\(S\\) is a stabilizer group and \\( \\mathcal{W} = \\{ w_\\ell \\}_{\\ell = 1}^K \\) is a family of \\(K\\) \\(n\\)-qubit Pauli strings. We then form CWS codeswords as \\( | i \\rangle = w_i | S \\rangle \\), where \\( | S \\rangle \\) is the (unique) stabilizer state of \\(S\\). ", "parents_code_id": "qubits_into_qubits", "parents_detail": "", "parent_of_code_id": "qubit_stabilizer", "parent_of_detail": "If the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code.", "cousins_code_id": "movassagh_ouyang\nspacetime", "cousins_detail": "The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other.\nCWS codes have been considered in the context of spacetime replication of quantum data [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913][P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544], while STCs are designed to replicate classical data.", "cousin_of_code_id": "xp_stabilizer", "cousin_of_detail": "The orbit representatives of XP codes play a similar role to the word operators of CWS codes.", "_type": "ecc", "_page_id": "c_cws", "_href": "c/cws"}, "c_css": {"logical": "qubits", "features_code_capacity_threshold": "Bounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights [A. A. Kovalev and L. P. Pryadko, \u201cFault tolerance of quantum low-density parity check codes with sublinear distance scaling\u201d, Physical Review A 87, (2013). DOI; 1208.2317][I. Dumer, A. A. Kovalev, and L. P. Pryadko, \u201cThresholds for Correcting Errors, Erasures, and Faulty Syndrome Measurements in Degenerate Quantum Codes\u201d, Physical Review Letters 115, (2015). DOI; 1412.6172].", "features_general_gates": "LDPC CSS code symmetries called \\(XZ\\)-dualities allow for fold-transversal gates, i.e., transversal gates followed by qubit permutations [Nikolas P. Breuckmann and Simon Burton, \u201cFold-Transversal Clifford Gates for Quantum Codes\u201d. 2202.06647].", "features_threshold": "", "features_rate": "For a depolarizing channel with probability \\(p\\), CSS codes allowing for arbitrarily accurate recovery exist with asymptotic rate \\(1-2h(p)\\), where \\(h\\) is the binary entropy function [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143].", "features_magic_scaling_exponent": "", "features_encoders": "Stabilizer measurement [J. \u0141odyga et al., \u201cSimple scheme for encoding and decoding a qubit in unknown state for various topological codes\u201d, Scientific Reports 5, (2015). DOI; 1404.2495].", "features_decoders": "Coherent decoders allow for measurement-free error correction [Toshiaki Inada et al., \u201cMeasurement-Free Ultrafast Quantum Error Correction by Using Multi-Controlled Gates in Higher-Dimensional State Space\u201d. 2109.00086]. One method is table/multi-control decoding [G. A. Paz-Silva, G. K. Brennen, and J. Twamley, \u201cFault Tolerance with Noisy and Slow Measurements and Preparation\u201d, Physical Review Letters 105, (2010). DOI; 1002.1536], which scales exponentially with the number of ancillas used in syndrome measurement. Another method, the Ising-based decoder, utilizes the mapping of the effect of the noise to a statistical mechanical model [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][Albert T. Schmitz, \u201cThermal Stability of Dynamical Phase Transitions in Higher Dimensional Stabilizer Codes\u201d. 2002.11733] such that the decoding problem maps to preparation of the ground state of an Ising model.", "features_transversal_gates": "CNOT gates. Self-dual CSS codes admit transversal Clifford gates.", "features_fault_tolerance": "Steane error correction [A. M. Steane, \u201cActive Stabilization, Quantum Computation, and Quantum State Synthesis\u201d, Physical Review Letters 78, 2252 (1997). DOI; quant-ph/9611027].\nHomomorphic gadgets fault-tolerant measurement unify Steane and Shor error correction [Shilin Huang, Tomas Jochym-O'Connor, and Theodore J. Yoder, \u201cHomomorphic Logical Measurements\u201d. 2211.03625].\nParallel syndrome extraction for distance-three codes can be done fault-tolerantly using one flag qubit [Pei-Hao Liou and Ching-Yi Lai, \u201cParallel syndrome extraction with shared flag qubits for CSS codes of distance three\u201d. 2208.00581].", "name": "Calderbank-Shor-Steane (CSS) stabilizer code", "code_id": "css", "realizations": "Fully homomorphic encryption [G. Alagic et al., \u201cQuantum Fully Homomorphic Encryption with Verification\u201d, Advances in Cryptology \u2013 ASIACRYPT 2017 438 (2017). DOI; 1708.09156].\nEntanglement purification protocols related to quantum key distribution (QKD) [P. W. Shor and J. Preskill, \u201cSimple Proof of Security of the BB84 Quantum Key Distribution Protocol\u201d, Physical Review Letters 85, 441 (2000). DOI; quant-ph/0003004].", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.\n\nUsing the relation to chain complexes, the number of encoded logical qubits is equal to the dimension of the first \\(\\mathbb{Z}_2\\)-homology of the chain complex, \\(H_1(\\partial, \\mathbb{Z}_2) = \\frac{\\text{Ker}(\\partial_1)}{\\text{Im}(\\partial_2)}\\). The distance of the CSS code is equal to the minimum of the combinatorial (\\(d-1\\))-systole of the cellulated \\(d\\)-dimensional manifold and its dual. ", "notes": "Introduction to CSS-to-homology correspondence by M. Hastings.\nUsing linear programming to solve a set of equations and inequalities on weight distribution of a classical self-orthogonal code \\(C=(n, 2^n-k)\\) and its dual, one can find a \\(C\\) such that the \\([[n,k,d]]\\) CSS code constructed using \\(C\\) and its dual would have rate and distance close to the Singleton bound [A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006].", "physical": "qubits", "short_name": "CSS", "introduced": "[A. R. Calderbank and P. W. Shor, \u201cGood quantum error-correcting codes exist\u201d, Physical Review A 54, 1098 (1996). DOI; quant-ph/9512032][A. M. Steane, \u201cError Correcting Codes in Quantum Theory\u201d, Physical Review Letters 77, 793 (1996). DOI][\u201cMultiple-particle interference and quantum error correction\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 452, 2551 (1996). DOI; quant-ph/9601029]", "description": "An \\([[n,k,d]]\\) stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The stabilizer generator matrix is of the form \\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parity}\n\\end{align} such that the rows of the two blocks must be orthogonal \\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:comm}\n\\end{align} The above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related binary linear codes, an \\([n,k_X,d^\\prime_X]\\) code \\(C_X\\) and \\([n,k_Z,d^\\prime_Z]\\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d^\\prime_X,d^\\prime_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\(\\eqref{eq:parity}\\) is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\(\\eqref{eq:comm}\\). Basis states for the code are, for \\(\\gamma \\in C_X\\), \\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n\nA CSS code has stabilizer weight \\(w\\) if the highest weight of any stabilizer generator is \\(w\\), i.e., any row of \\(H_X\\) and \\(H_Z\\) has weight at most \\(w\\). In the context of comparing weight as well as of determining distances for noise models biased toward \\(X\\)- or \\(Z\\)-type errors, an extended notation for asymmetric CSS codes is \\([[n,k,(d_X,d_Z),w]]\\) or \\([[n,k,d_X/d_Z,w]]\\). The quantity \\(\\min\\{d_X,d_Z\\}\\) is often called the worst-case minimum distance.\n\nCSS-to-homology correspondence\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCSS-to-homology correspondence: CSS codes and their properties can be formulated in terms of homology theory, yielding a powerful correspondence between codes and chain complexes, the primary homological structures. There exists a many-to-one mapping from size three chain complexes to CSS codes [A. Y. Kitaev, \u201cQuantum computations: algorithms and error correction\u201d, Russian Mathematical Surveys 52, 1191 (1997). DOI][H. Bombin and M. A. Martin-Delgado, \u201cHomological error correction: Classical and quantum codes\u201d, Journal of Mathematical Physics 48, 052105 (2007). DOI; quant-ph/0605094][Sergey Bravyi and Matthew B. Hastings, \u201cHomological Product Codes\u201d. 1311.0885][Nikolas P. Breuckmann, \u201cPhD thesis: Homological Quantum Codes Beyond the Toric Code\u201d. 1802.01520] that allows one to extract code properties from topological features of the complexes. Codes constructed in this manner are sometimes called homological CSS codes, but they are equivalent to CSS codes. This mapping of codes to manifolds allows the application of structures from topology to error correction, yielding various QLDPC codes with favorable properties.\n\nA chain complex of size three is given by binary vector spaces \\(A_2\\), \\(A_1\\), \\(A_0\\) and binary matrices \\(\\partial_{i=1,2}\\) (called boundary operators) \\(A_i\\) to \\(A_{i-1}\\) that satisfy \\(\\partial_1 \\partial_2 = 0\\). Such a complex is typically denoted as \\begin{align}\nA_2 \\xrightarrow{\\partial_2} A_1 \\xrightarrow{\\partial_1} A_0~.\n\\label{eq:chain}\n\\end{align} One constructs a CSS code by associating a physical qubit to every basis element of \\(A_1\\), and defining parity-check matrices \\(H_X=\\partial_1^T\\) and \\(H_Z=\\partial_2\\)). That way, the spaces \\(A_0\\) and \\(A_2\\) can be associated with \\(X\\)-type and \\(Z\\)-type Pauli operators, respectively, and boundary operators determine the Paulis making up the stabilizer generators. The requirement \\(\\partial_1 \\partial_2 = 0\\) guarantees that the \\(X\\)-stabilizer generators associated with \\(H_X\\) commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nUsually, the chain complex \\(\\eqref{eq:chain}\\) used in the construction comes from the chain complex associated with a cellulation of a manifold. When the manifold is a two-dimensional surface, its entire chain is used. Higher-dimensional manifolds allow for longer chain complexes, and one can use the three largest non-trivial vector spaces in its chain.", "parents_code_id": "qubit_stabilizer\nmovassagh_ouyang", "parents_detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) self-orthogonal CSS code, with the mapping preserving geometric locality of a code up to a constant factor [S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791].\nMovassagh-Ouyang codes stem from a prescription that converts an arbitrary classical code into a quantum code.", "parent_of_code_id": "balanced_product\nclassical_product\ncolor\ndhlv\ndistance_balanced\nquantum_h\nsurface\nquantum_reed_muller\nquantum_tanner\nquantum_divisible\nquantum_parity\nquantum_triorthogonal", "parent_of_detail": "\n\n\n\n\n\n\n\n\n\n\n", "cousins_code_id": "binary_linear\ndual\nalternant", "cousins_detail": "Construction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\).\nCSS codes for which \\(C_X=C_Z \\equiv C\\) are called self-orthogonal since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\).\nAlternant codes used in the CSS construction yield quantum codes that asymptotically achieve the quantum Gilbert-Varshamov bound [J. Fan et al., \u201cPartially Concatenated Calderbank-Shor-Steane Codes Achieving the Quantum Gilbert-Varshamov Bound Asymptotically\u201d, IEEE Transactions on Information Theory 1 (2022). DOI].", "cousin_of_code_id": "eastab\ngalois_css\ngeneralized_homological_product\nhomological_classical\ngroup_gkp\nhomological_cv\nmajorana_stab\nqudit_css\nquantum_bch\nxp_stabilizer", "cousin_of_detail": "As opposed to CSS codes, EA stabilizer codes can be constructed from any linear binary code.\nExtension of qubit CSS codes to Galois qudits.\nThe notion of homological products arose from interpreting CSS codes in terms of chain complexes over manifolds, but some generalized products no longer yield CSS codes.\nCSS codes can also be constructed using homology techniques but for manifolds of dimension two or greater.\nAn \\(n\\)-qubit CSS code corresponds to the \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{n}\\) group construction.\nCSS and homological CV codes utilize chain complexes in code construction, with the latter complexes having trivial homology.\nWhen constructing a Majorana stabilizer code from a self-orthogonal classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space [S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791][Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different self-orthogonal classical codes with an odd number of bits, as is often done in the CSS construction.\nExtension of CSS codes to modular-integer qudits.\nSome qubit BCH codes are CSS.\nEach XP-regular code can be mapped to a CSS code with a similar logical operator structure [Mark A. Webster, Benjamin J. Brown, and Stephen D. Bartlett, \u201cThe XP Stabiliser Formalism: a Generalisation of the Pauli Stabiliser Formalism with Arbitrary Phases\u201d. 2203.00103].", "_type": "ecc", "_page_id": "c_css", "_href": "c/css"}, "c_xp_stabilizer": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "XP stabilizer code", "code_id": "xp_stabilizer", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Mark A. Webster, Benjamin J. Brown, and Stephen D. Bartlett, \u201cThe XP Stabiliser Formalism: a Generalisation of the Pauli Stabiliser Formalism with Arbitrary Phases\u201d. 2203.00103]", "description": "The XP Stabilizer formalism is a generalization of the XS and Pauli stabilizer formalisms, with stabilizer generators taken from the group \\( \\{\\omega I, X, P\\}^{\\otimes n} \\). Here, \\( \\omega \\) is a \\( 2N \\) root of unity, and \\( P = \\text{diag} ( 1, \\omega^2) \\). The codespace is a \\(+1\\) eigenspace of a set of XP stabilizer generators, which need not commute to define a valid codespace.\n\nXP stabilizer codes are classified into XP-regular and XP-non-regular, where the former can be mapped to a CSS code with similar logical operator structure. ", "parents_code_id": "qubits_into_qubits", "parents_detail": "", "parent_of_code_id": "qubit_stabilizer\nxs_stabilizer", "parent_of_detail": "The XP stabilizer formalism reduces to the Pauli formalism at \\(N=2\\).\nThe XP stabilizer formalism reduces to the XS formalism at \\(N=4\\).", "cousins_code_id": "css\ncws", "cousins_detail": "Each XP-regular code can be mapped to a CSS code with a similar logical operator structure [Mark A. Webster, Benjamin J. Brown, and Stephen D. Bartlett, \u201cThe XP Stabiliser Formalism: a Generalisation of the Pauli Stabiliser Formalism with Arbitrary Phases\u201d. 2203.00103].\nThe orbit representatives of XP codes play a similar role to the word operators of CWS codes.", "_type": "ecc", "_page_id": "c_xp_stabilizer", "_href": "c/xp_stabilizer"}, "c_quantum_parity": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum parity code (QPC)", "code_id": "quantum_parity", "realizations": "The \\([[m^2,1,m]]\\) codes for \\(m\\leq 7\\) have been realized in trapped-ion quantum devices [N. H. Nguyen et al., \u201cDemonstration of Shor Encoding on a Trapped-Ion Quantum Computer\u201d, Physical Review Applied 16, (2021). DOI; 2104.01205].", "protection": "Has distance \\(d=\\min(m_1,m_2)\\).", "notes": "Non-determinisitic linear-optical encoding [T. C. Ralph, A. J. F. Hayes, and A. Gilchrist, \u201cLoss-Tolerant Optical Qubits\u201d, Physical Review Letters 95, (2005). DOI; quant-ph/0501184] whose success probability \\(P_{E}\\) is determined by the efficiency \\(\\eta\\) of the photonic encoding circuit. A threshold \\(\\eta > 0.82 \\) exists for the efficiency, above which \\(P_{E}\\to 1\\) as \\(m_1\\to\\infty\\) given particular \\(m_2\\).\nStudied in the context of error-corrected quantum repeaters [S. Muralidharan et al., \u201cUltrafast and Fault-Tolerant Quantum Communication across Long Distances\u201d, Physical Review Letters 112, (2014). DOI; 1310.5291].", "physical": "qubits", "short_name": "QPC", "introduced": "[T. C. Ralph, A. J. F. Hayes, and A. Gilchrist, \u201cLoss-Tolerant Optical Qubits\u201d, Physical Review Letters 95, (2005). DOI; quant-ph/0501184][E. Knill, R. Laflamme, and G. J. Milburn, \u201cA scheme for efficient quantum computation with linear optics\u201d, Nature 409, 46 (2001). DOI][E. Knill, R. Laflamme, and G. Milburn, \u201cEfficient Linear Optics Quantum Computation\u201d. quant-ph/0006088]", "description": "Also called a generalized Shor code [Dave Bacon and Andrea Casaccino, \u201cQuantum Error Correcting Subsystem Codes From Two Classical Linear Codes\u201d. quant-ph/0610088]. A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) CSS code family obtained from concatenating an \\(m_1\\)-qubit phase-flip repetition code with an \\(m_2\\)-qubit bit-flip repetition code. Logical codewords are \\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}+|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}-|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}~.\n\\end{split}\n\\end{align} ", "parents_code_id": "css\ntranslationally_invariant_stabilizer", "parents_detail": "\n", "parent_of_code_id": "quantum_repetition\nshor_nine", "parent_of_detail": "A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) QPC is a concatenation of a \\(m_1\\) bit-flip and a \\(m_2\\) phase-flip repetition codes, reducing to a repetition code when \\(m_1\\) or \\(m_2\\) is one.\nShor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "cousins_code_id": "quantum_concatenated\nbacon_shor", "cousins_detail": "A QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code.\nBacon-Shor codes reduce to QPCs for a particular gauge configuration.", "cousin_of_code_id": "stab_4_2_2", "cousin_of_detail": "\\([[4,1,2]]\\) subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "_type": "ecc", "_page_id": "c_quantum_parity", "_href": "c/quantum_parity"}, "c_quantum_polar": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The rate approaches the symmetric coherent information of the quantum noise channel [M. M. Wilde and J. M. Renes, \u201cQuantum polar codes for arbitrary channels\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1201.2906].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Constructed using classical polar decoders for the amplitude and phase channels.", "features_transversal_gates": "", "features_fault_tolerance": "State preparation of a single logical qubit [Ashutosh Goswami, Mehdi Mhalla, and Valentin Savin, \u201cFault-Tolerant Preparation of Quantum Polar Codes Encoding One Logical Qubit\u201d. 2209.06673].", "name": "Quantum polar code", "code_id": "quantum_polar", "realizations": "", "protection": "Protects against Pauli noise and erasures.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[J. M. Renes, F. Dupuis, and R. Renner, \u201cEfficient Polar Coding of Quantum Information\u201d, Physical Review Letters 109, (2012). DOI; 1109.3195]", "description": "Entanglement-assisted CSS code utilized in a quantum polar coding scheme producing entangled pairs of qubits between sender and receiver. In such a scheme, the amplitude and phase information of a quantum state is handled in complementary fashion [J. M. Renes and J.-C. Boileau, \u201cPhysical underpinnings of privacy\u201d, Physical Review A 78, (2008). DOI; 0803.3096] using an encoding based on classical polar codes. Variants of the initial scheme have been developed for degradable channels [M. M. Wilde and J. M. Renes, \u201cQuantum polar codes for arbitrary channels\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1201.2906] and extended to arbitrary channels [M. M. Wilde and S. Guha, \u201cPolar Codes for Degradable Quantum Channels\u201d, IEEE Transactions on Information Theory 59, 4718 (2013). DOI; 1109.5346].\n\nThe scheme requires some a-priori quantum side information in the general case, making the associated code entanglement assisted [J. M. Renes, F. Dupuis, and R. Renner, \u201cEfficient Polar Coding of Quantum Information\u201d, Physical Review Letters 109, (2012). DOI; 1109.3195]. The requirement of having quantum side information vanishes when the sum of the amplitude channel fidelity and the phase channel fidelity is not greater than 1. It is shown to vanish for the case of degradable noise channels [M. M. Wilde and S. Guha, \u201cPolar Codes for Degradable Quantum Channels\u201d, IEEE Transactions on Information Theory 59, 4718 (2013). DOI; 1109.5346]. A more complicated quantum polar-coding scheme that does not require pre-shared entanglement has also been derived [J. M. Renes et al., \u201cEfficient Quantum Polar Codes Requiring No Preshared Entanglement\u201d, IEEE Transactions on Information Theory 61, 6395 (2015). DOI; 1307.1136]. ", "parents_code_id": "eastab", "parents_detail": "Quantum polar codes are CSS codes used in an entanglement generation scheme that generally requires entanglement assistance. However, a variant exists that does not require entanglement assisstance [J. M. Renes et al., \u201cEfficient Quantum Polar Codes Requiring No Preshared Entanglement\u201d, IEEE Transactions on Information Theory 61, 6395 (2015). DOI; 1307.1136].", "cousins_code_id": "polar", "cousins_detail": "", "cousin_of_code_id": "coherent_constellation\nstab_4_2_2", "cousin_of_detail": "Coherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the quantum capacity of the thermal noise channel [F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent-state constellations and polar codes for thermal Gaussian channels\u201d, Physical Review A 95, (2017). DOI; 1603.05970][F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent state constellations for Bosonic Gaussian channels\u201d, 2016 IEEE International Symposium on Information Theory (ISIT) (2016). DOI].\n\\([[4,2,2]]\\) code is a small quantum polar code [Kyungjoo Noh, Leung code as quantum polar code, 2017.].", "_type": "ecc", "_page_id": "c_quantum_polar", "_href": "c/quantum_polar"}, "c_stabilizer_over_gf4": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "Characterizing fault-tolerant multi-qubit gates may involve characterizing all global automorphisms of some number of copies of a code that preserve the symplectic inner product [Eric M. Rains, \u201cNonbinary quantum codes\u201d. quant-ph/9703048; pg. 9].", "name": "Stabilizer code over \\(GF(4)\\)", "code_id": "stabilizer_over_gf4", "realizations": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "notes": "Tables of \\([[n,0,d]]\\) codes, corresponding to a self-dual \\(GF(4)\\) representation, at this website.", "physical": "qubits", "short_name": "", "introduced": "[A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006]", "description": "An \\([[n,k,d]]\\) stabilizer code constructed from a quaternary classical code using the one-to-one correspondence between the four Pauli matrices \\(\\{I,X,Y,Z\\}\\) and the four elements \\(\\{0,1,\\alpha^2,\\alpha\\}\\) of the quaternary field \\(GF(4)\\).\n\nAn \\(n\\)-qubit Pauli stabilizer can be represented as a length-\\(n\\) quaternary vector. The stabilizer commutation condition corresponds to a zero trace-Hermitian inner product between the corresponding vectors. Stabilizer codes over \\(GF(4)\\) can thus be constructed from classical trace-Hermitian self-orthogonal additive quaternary codes and Hermitian self-orthogonal linear quaternary codes (since the latter are automatically trace-Hermitian self-orthogonal). The classical code corresponds to the stabilizer group \\(\\mathsf{S}\\) while its trace-Hermitian dual corresponds to the normalizer \\(\\mathsf{N(S)}\\).\n\nStabilizer codes over \\(GF(4)\\) can be constructed as follows. Let \\(\\phi\\) be a bijection from a linear binary subspace to \\(GF(4)^n\\). Let \\(C\\) be a trace-Hermitian self-orthogonal additive subcode over \\(GF(4)\\), containing \\(2^{n-k}\\) vectors, such that there are no vectors of weight less than \\(d\\) in \\(C^{\\perp}\\setminus C\\). Then, any eigenspace of the inverse map \\(\\phi^{-1}(C)\\) is an \\([[n, k, d]]\\) stabilizer code over \\(GF(4)\\).", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "parent_of_code_id": "stab_5_1_3", "parent_of_detail": "The five-qubit code is derived from the \\([5,3,3]_4\\) Hamming code.", "cousins_code_id": "dual_additive\ndual", "cousins_detail": "The stabilizer commutation condition for stabilizer codes over \\(GF(4)\\) can equivalently be stated in the representation of stabilizers as quaternary vectors. A pair of \\(n\\)-qubit stabilizers commute iff the trace-Hermitian inner product of their corresponding vectors is zero. Stabilizer codes over \\(GF(4)\\) can thus be constructed from trace-Hermitian self-orthogonal additive quaternary codes.\nIf the classical additive code of quaternary vectors corresponding a stabilizer code over \\(GF(4)\\) is linear, then the code is self-orthogonal with respect to both the trace-Hermitian and Hermitian inner products ([W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.4.1). In other words, the extra trace operation can be removed from the definition of inner product.", "cousin_of_code_id": "quantum_bch\nstabilizer_over_gfqsq", "cousin_of_detail": "Hermitian self-orthogonal quaternary BCH codes are used to construct a subset of qubit BCH codes via the stabilizer-over-\\(GF(4)\\) construction.\nStabilizer codes over \\(GF(q^2)\\) are Galois-qudit extensions of those over \\(GF(4)\\).", "_type": "ecc", "_page_id": "c_stabilizer_over_gf4", "_href": "c/stabilizer_over_gf4"}, "c_happy": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "\\(26\\%\\) for boundary erasure errors on the the pentagon/hexagon HaPPY code, which has alternating layers of pentagons and hexagons in the tiling.\n\\(\\sim 50\\%\\) for boundary erasure errors on the single-qubit HaPPY code, which has a central pentagon encoding one bulk operator and hexagons tiling all other layers\n\\(16.3\\%\\) for boundary Pauli errors on the single-qubit HaPPY code with 3 layers [R. J. Harris et al., \u201cDecoding holographic codes with an integer optimization decoder\u201d, Physical Review A 102, (2020). DOI; 2008.10206].\nThere is no threshold for the pentagon HaPPY code as a constant number of errors (two) can make bulk recovery impossible.", "features_rate": "The pentagon HaPPY code has an asymptotic rate \\(\\frac{1}{\\sqrt{5}} \\approx 0.447\\). The pentagon/hexagon HaPPY code, with alternating layers of pentagons and hexagons in the tiling, has a rate of \\(0.299\\) if the last layer is a pentagon layer and a rate of \\(0.088\\) if the last layer is a hexagon layer.", "features_magic_scaling_exponent": "", "features_encoders": "Heisenberg-picture encoding is done through tensor pushing. Each bulk operator (logical) is pushed to an operator supported on a portion of the boundary region (physical). Pushing all the bulk operators through results in reconstruction of the boundary.", "features_decoders": "Greedy algorithm for decoding specified in Ref. [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].", "features_transversal_gates": "For locality-preserving physical gates on the boundary, the set of transversally implementable logical operations in the bulk is strictly contained in the Clifford group [S. Cree et al., \u201cFault-Tolerant Logical Gates in Holographic Stabilizer Codes Are Severely Restricted\u201d, PRX Quantum 2, (2021). DOI; 2103.13404].", "features_fault_tolerance": "", "name": "Pastawski-Yoshida-Harlow-Preskill (HaPPY) code", "code_id": "happy", "realizations": "", "protection": "Protects against erasure errors and Pauli errors on the boundary qubits.", "notes": "Ref. [Jordan Cotler and Andrew Strominger, \u201cThe Universe as a Quantum Encoder\u201d. 2201.11658] discusses the HaPPY code for an AdS_3 space and its relation to a dS_2 braneworld with a conformal boundary.", "physical": "qubits", "short_name": "HaPPY", "introduced": "[F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237]", "description": "Also known as a hyperbolic pentagon code (HyPeC). Holographic code constructed out of a network of perfect tensors that tesselates hyperbolic space. Physical qubits are associated with uncontracted tensor legs at the boundary of the tesselation, while logical qubits are associated with uncontracted legs in the bulk. The code serves as a minimal model for several aspects of the AdS/CFT holographic duality. The construction below is described for qubits, but straightforward generalizations exist to modular qudits, oscillators, and rotors [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].\n\nEncoding is accomplished using a tensor network of five-qubit encoding isometries, which are six-legged perfect tensors (with five legs corresponding to the physical qubits and one for the encoded logical qubit). A \\(2n\\)-legged perfect tensor is proportional to an isometry for any bipartition of its indices into a set \\(A\\) and a complementary set \\(A^{\\perp}\\) such that \\(|A|\\leq|A^{\\perp}|\\).\n\nTo construct the encoding, one first uniformly tiles the hyperbolic AdS/CFT disc using pentagons and hexagons. Then, one places a 6-legged five-qubit encoding tensor at each hexagon and pentagon, contracting legs between neighboring shapes and leaving one leg uncontracted at each pentagon. This construction forms an encoding isometry from the uncontracted legs in the bulk to the uncontracted legs at the boundary.", "parents_code_id": "holographic\nqubit_stabilizer", "parents_detail": "\nThe HaPPY code is a stabilizer code because it is defined by a contracted network of stabilizer tensors; see Thm. 6 in Ref. [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].", "cousins_code_id": "stab_5_1_3\nmajorana_stab", "cousins_detail": "The five-qubit encoding isometry tiles various holographic codes because its corresponding tensor is perfect [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nHaPPY code Hamiltonian can be expressed in terms of mutually commuting two-body Majorana operators [A. Jahn et al., \u201cMajorana dimers and holographic quantum error-correcting codes\u201d, Physical Review Research 1, (2019). DOI; 1905.03268].", "_type": "ecc", "_page_id": "c_happy", "_href": "c/happy"}, "c_quantum_triorthogonal": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Triorthogonal codes can be used for high-quality magic-state distillation [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426].", "features_threshold": "Approximately \\(\\frac{1}{3k + 1}\\) [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426].", "features_rate": "", "features_magic_scaling_exponent": "Depends on the matrix. Reference [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426] gave a family of \\(\\frac{k}{3k+8}\\) codes with magic-state distillation scaling exponent \\(\\gamma = \\log_2 \\frac{3k+8}{k}\\).", "features_encoders": "Encoder for magic states for the code constructed in [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426].", "features_decoders": "", "features_transversal_gates": "Admits transversal \\(T\\) gates [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426] and the controlled-controlled-\\(Z\\) gate [A. Paetznick and B. W. Reichardt, \u201cUniversal Fault-Tolerant Quantum Computation with Only Transversal Gates and Error Correction\u201d, Physical Review Letters 111, (2013). DOI; 1304.3709].", "features_fault_tolerance": "Universal fault-tolerant gates can be performed without magic-state distillation [A. Paetznick and B. W. Reichardt, \u201cUniversal Fault-Tolerant Quantum Computation with Only Transversal Gates and Error Correction\u201d, Physical Review Letters 111, (2013). DOI; 1304.3709][Darren Banfield and Alastair Kay, \u201cImplementing Logical Operators using Code Rewiring\u201d. 2210.14074].", "name": "Triorthogonal code", "code_id": "quantum_triorthogonal", "realizations": "", "protection": "Weight \\(t\\) Pauli errors, where \\(t\\) depends on the family. For example, Ref. [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426] provides a family of distance \\(2\\) codes. It also presents a \\([[49, 1, 5]]\\) code.", "notes": "Reference [S. Nezami and J. Haah, \u201cClassification of small triorthogonal codes\u201d, Physical Review A 106, (2022). DOI; 2107.09684] presents a classification of triorthogonal codes up to \\(n + k \\leq 38\\) by associating each triorthogonal code with a Reed-Muller polynomial.", "physical": "qubits", "short_name": "", "introduced": "[S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426]", "description": "A triorthogonal \\(m \\times n\\) binary matrix is triorthogonal if its rows \\(r_1, \\ldots, r_m\\) satisfy \\(|r_i \\cdot r_j| = 0\\) and \\(|r_i \\cdot r_j \\cdot r_k| = 0\\), where addition and multiplication are done on \\(\\mathbb{Z}_2\\). The triorthogonal code associated with the matrix is constructed by mapping non-zero entries in even-weight rows to \\(X\\) operators, and \\(Z\\) operators for each row in the orthogonal complement.", "parents_code_id": "css", "parents_detail": "", "parent_of_code_id": "stab_15_1_3", "parent_of_detail": "The \\([[15, 1, 3]]\\) code is a triorthogonal code [S. Nezami and J. Haah, \u201cClassification of small triorthogonal codes\u201d, Physical Review A 106, (2022). DOI; 2107.09684].", "cousins_code_id": "quantum_reed_muller", "cousins_detail": "Classification of triorthongonal codes yields a connection to Reed-Muller polynomials [S. Nezami and J. Haah, \u201cClassification of small triorthogonal codes\u201d, Physical Review A 106, (2022). DOI; 2107.09684].", "cousin_of_code_id": "color\nquantum_divisible", "cousin_of_detail": "The 3D color code is triorthogonal.\nTriorthogonal codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions.", "_type": "ecc", "_page_id": "c_quantum_triorthogonal", "_href": "c/quantum_triorthogonal"}, "c_color": {"logical": "qubits", "features_code_capacity_threshold": "\\(\\geq 6\\%\\) threshold with rescaling-based decoder [Pedro Parrado-Rodr\u00edguez, Manuel Rispler, and Markus M\u00fcller, \u201cRescaling decoder for 2D topological quantum color codes on 4.8.8 lattices\u201d. 2112.09584].", "features_general_gates": "Magic-state distillation protocols [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI].\nNon-clifford gates can be implemented via code switching [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI].\nLattice surgery scheme for 2D layout yields lower resource overhead when compared to analogous surface code scheme [Felix Thomsen et al., \u201cLow-overhead quantum computing with the color code\u201d. 2201.07806].", "features_threshold": "\\(\\geq 6.25\\%\\) threshold for 2D color codes with error-free syndrome extraction, and \\(0.1\\%\\) with faulty syndrome extraction [D. S. Wang et al., \u201cGraphical algorithms and threshold error rates for the 2d colour code\u201d. 0907.1708].\n\\(0.46\\%\\) for 3D codes with clustering decoder [A. Kubica et al., \u201cThree-Dimensional Color Code Thresholds via Statistical-Mechanical Mapping\u201d, Physical Review Letters 120, (2018). DOI; 1708.07131].\n\\(1.9\\%\\) for 1D string-like logical operators and \\(27.6\\%\\) for 2D sheet-like operators for 3D codes with noise models using optimal decoding and perfect measurements [A. Kubica et al., \u201cThree-Dimensional Color Code Thresholds via Statistical-Mechanical Mapping\u201d, Physical Review Letters 120, (2018). DOI; 1708.07131].\n\\(0.31\\%\\) noise threshold error rate for gauge code using clustering decoder [B. J. Brown, N. H. Nickerson, and D. E. Browne, \u201cFault-tolerant error correction with the gauge color code\u201d, Nature Communications 7, (2016). DOI; 1503.08217].\n\\(0.143\\%\\) with depolarising circuit-level noise using perfect-matching decoder [Andrew J. Landahl and Ciaran Ryan-Anderson, \u201cQuantum computing by color-code lattice surgery\u201d. 1407.5103].\n\\(>0\\%\\) threshold with sweep decoder [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI].", "features_rate": "For general 2D manifolds, \\(kd^2 \\leq c(\\log k)^2 n\\) for some constant \\(c\\) [N. Delfosse, \u201cTradeoffs for reliable quantum information storage in surface codes and color codes\u201d, 2013 IEEE International Symposium on Information Theory (2013). DOI; 1301.6588], meaning that color codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Projection decoder [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI].\nMatching decoder gives low logical failure rate [K. Sahay and B. J. Brown, \u201cDecoder for the Triangular Color Code by Matching on a M\u00f6bius Strip\u201d, PRX Quantum 3, (2022). DOI; 2108.11395].\nInteger-program-based decoder [Ashley M. Stephens, \u201cEfficient fault-tolerant decoding of topological color codes\u201d. 1402.3037].\nRestriction decoder [C. Chamberland et al., \u201cTriangular color codes on trivalent graphs with flag qubits\u201d, New Journal of Physics 22, 023019 (2020). DOI].\nCellular-automaton decoder for the \\(XYZ\\) color code [Jonathan F. San Miguel, Dominic J. Williamson, and Benjamin J. Brown, \u201cA cellular automaton decoder for a noise-bias tailored color code\u201d. 2203.16534].", "features_transversal_gates": "Transversal CNOT can be implemented via braiding [A. G. Fowler, \u201cTwo-dimensional color-code quantum computation\u201d, Physical Review A 83, (2011). DOI; 0806.4827]. Universal transversal gates can be achieved in 3D color code using gauge fixing [H. Bombin, \u201cGauge Color Codes: Optimal Transversal Gates and Gauge Fixing in Topological Stabilizer Codes\u201d. 1311.0879], lattice surgery [Andrew J. Landahl and Ciaran Ryan-Anderson, \u201cQuantum computing by color-code lattice surgery\u201d. 1407.5103], or code deformation [H. Bombin, \u201cClifford gates by code deformation\u201d, New Journal of Physics 13, 043005 (2011). DOI][A. G. Fowler, \u201cTwo-dimensional color-code quantum computation\u201d, Physical Review A 83, (2011). DOI; 0806.4827].", "features_fault_tolerance": "Clifford gates can be performed fault-tolerantly on a suitable 2D lattice [H. Bombin and M. A. Martin-Delgado, \u201cTopological Quantum Distillation\u201d, Physical Review Letters 97, (2006). DOI; quant-ph/0605138].\nSyndrome measurement [Andrew J. Landahl and Ciaran Ryan-Anderson, \u201cQuantum computing by color-code lattice surgery\u201d. 1407.5103].\nSteane's ancilla-coupled measurement method [Andrew J. Landahl and Ciaran Ryan-Anderson, \u201cQuantum computing by color-code lattice surgery\u201d. 1407.5103]", "name": "Color code", "code_id": "color", "realizations": "", "protection": "As with the surface code, the code distance depends on the specific kind of lattice used to define the code. More precisely, the distance depends on the homology of logical string operators [H. Bombin, \u201cAn Introduction to Topological Quantum Codes\u201d. 1311.0277].", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[H. Bombin and M. A. Martin-Delgado, \u201cTopological Quantum Distillation\u201d, Physical Review Letters 97, (2006). DOI; quant-ph/0605138]", "description": "A family of abelian topological CSS stabilizer codes defined on a \\(D\\)-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial \\(D\\)-complex obtained as a triangulation of the interior of a \\(D\\)-simplex and (2) is \\(D+1\\)-colorable. Qubits are placed on the \\(D\\)-simplices and generators are supported on suitable simplices [A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. DOI]. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face [H. Bombin, \u201cAn Introduction to Topological Quantum Codes\u201d. 1311.0277].", "parents_code_id": "css\ntopological_abelian", "parents_detail": "\nWhen treated as ground states of the code Hamiltonian, 2D color code states on realize \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) topological order [M. Kargarian, H. Bombin, and M. A. Martin-Delgado, \u201cTopological color codes and two-body quantum lattice Hamiltonians\u201d, New Journal of Physics 12, 025018 (2010). DOI; 0906.4127], equivalent to the phase realized by two copies of the surface code [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065].", "parent_of_code_id": "stab_15_1_3\nsteane", "parent_of_detail": "The \\([[15,1,3]]\\) code is a 3D color code.\nSteane code is the smallest 2D color code.", "cousins_code_id": "surface\nquantum_triorthogonal", "cousins_detail": "Color code is equivalent to surface code in several ways [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065][Arun B. Aloshious, Arjun Nitin Bhagoji, and Pradeep Kiran Sarvepalli, \u201cOn the Local Equivalence of 2D Color Codes and Surface Codes with Applications\u201d. 1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.\nThe 3D color code is triorthogonal.", "cousin_of_code_id": "floquet_color\ngalois_topological\nhaah_cubic\nself_correct\n3d_surface\nsubsystem_color", "cousin_of_detail": "\nColor code has been extended to Galois qudits.\nThe color and cubic code families both include 3D codes that do not admit string-like operators.\nThe 6D color code is a self-correcting quantum memory [H. Bombin et al., \u201cSelf-Correcting Quantum Computers\u201d. 0907.5228].\nColor code is equivalent to surface code in several ways [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065][Arun B. Aloshious, Arjun Nitin Bhagoji, and Pradeep Kiran Sarvepalli, \u201cOn the Local Equivalence of 2D Color Codes and Surface Codes with Applications\u201d. 1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.\n", "_type": "ecc", "_page_id": "c_color", "_href": "c/color"}, "c_haah_cubic": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "The encoding rate depends on the code implemented, but code 0 has been shown to have \\(k \\ge L\\) (on a periodic finite cubic lattice of side length \\(L\\). In general we expect the number of logical bits to scale as \\(k \\sim L\\).", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Haah cubic code", "code_id": "haah_cubic", "realizations": "", "protection": "Cubic codes protect against simultaneous independent Pauli errors on different sites (not qubits, since there can be 2 qubits per site). Codes 0-4 are known to have distance \\(d \\ge L\\), meaning they can achieve macroscopic code distance as \\(L\\to\\infty\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962]", "description": "Class of stabilizer codes on a length-\\(L\\) cubic lattice with one or two qubits per site. We also require that the stabilizer group \\(\\mathsf{S}\\) is translation invariant and generated by two types of operators with support on a cube. In the non-CSS case, these two are related by spatial inversion. For CSS codes, we require that the product of all corner operators is the identity. We lastly require that there are no non-trival ''string operators'', meaning that single-site operators are a phase, and any period one logical operator \\(l \\in \\mathsf{S}^{\\perp}\\) is just a phase. Haah showed in his original construction that there is exactly one non-CSS code of this form, and 17 CSS codes [J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962]. The non-CSS code is labeled code 0, and the rest are numbered from 1 - 17. Codes 1-4, 7, 8, and 10 do not have string logical operators [J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962][A. Dua et al., \u201cSorting topological stabilizer models in three dimensions\u201d, Physical Review B 100, (2019). DOI; 1908.08049].\n\nStraightforward generalizations of the above codes exist to modular qudits, oscillators, and rotors [J. Haah, Two generalizations of the cubic code model, KITP Conference: Frontiers of Quantum Information Physics, UCSB, Santa Barbara, CA.][V. V. Albert, S. Pascazio, and M. H. Devoret, \u201cGeneral phase spaces: from discrete variables to rotor and continuum limits\u201d, Journal of Physics A: Mathematical and Theoretical 50, 504002 (2017). DOI; 1709.04460]. ", "parents_code_id": "qubit_stabilizer\nfracton", "parents_detail": "\nHaah cubic codes are the first examples of Type-II fracton phases [M. Pretko, X. Chen, and Y. You, \u201cFracton phases of matter\u201d, International Journal of Modern Physics A 35, 2030003 (2020). DOI; 2001.01722].", "cousins_code_id": "color\nsurface", "cousins_detail": "The color and cubic code families both include 3D codes that do not admit string-like operators.\nThe energy of any partial implementation of code 1 is proportional to the boundary length similar to the 4D toric code, which can potentially surpress the effects of thermal errors, but it is currently an open problem.", "cousin_of_code_id": "fibonacci_model\nlifted_product\nself_correct", "cousin_of_detail": "The Fibonacci code is designed to mimic the fractal properties of (quantum) Haah cubic code so that studying the former can help us toward the development of an efficient algorithm for the latter.\nA lifted product code for the ring \\(R=\\mathbb{F}_2[x,y,z]/(x^L-1,y^L-1,z^L-1)\\) is the cubic code.\nCubic code 1 is partially self-correcting with a logarithmic energy barrier [S. Bravyi and J. Haah, \u201cQuantum Self-Correction in the 3D Cubic Code Model\u201d, Physical Review Letters 111, (2013). DOI; 1112.3252].", "_type": "ecc", "_page_id": "c_haah_cubic", "_href": "c/haah_cubic"}, "c_matching": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Matching code", "code_id": "matching", "realizations": "Braiding of defects has been demonstrated for a five-qubit version of code [J. R. Wootton, \u201cDemonstrating non-Abelian braiding of surface code defects in a five qubit experiment\u201d, Quantum Science and Technology 2, 015006 (2017). DOI; 1609.07774].", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[J. R. Wootton, \u201cA family of stabilizer codes for $D({{\\mathbb{Z}}_{2}})$ anyons and Majorana modes\u201d, Journal of Physics A: Mathematical and Theoretical 48, 215302 (2015). DOI; 1501.07779]", "description": "Stub.", "parents_code_id": "qubit_stabilizer\ntopological_abelian", "parents_detail": "\nMatching codes were inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438], which realizes \\(\\mathbb{Z}_2\\) topological order.", "parent_of_code_id": "xyz_hexagonal", "parent_of_detail": "", "cousin_of_code_id": "honeycomb", "cousin_of_detail": "Matching and honeycomb codes are both inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438].", "_type": "ecc", "_page_id": "c_matching", "_href": "c/matching"}, "c_double_semion": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Double-semion code", "code_id": "double_semion", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617]", "description": "Stub.", "parents_code_id": "qudit_stabilizer\ntopological_abelian", "parents_detail": "Double-semion code can be realized as a modular-qudit stabilizer code with \\(q=4\\) [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394].\nWhen treated as ground states of the code Hamiltonian, the code states realize double-semion topological order, a topological phase of matter that also exists in twisted \\(\\mathbb{Z}_2\\) gauge theory [R. Dijkgraaf and E. Witten, \u201cTopological gauge theories and group cohomology\u201d, Communications in Mathematical Physics 129, 393 (1990). DOI].", "cousins_code_id": "surface", "cousins_detail": "There is a logical basis for the toric and double-semion codes where each codeword is a superposition of states corresponding to all noncontractible loops of a particular homotopy type. The superposition is equal for the toric code, whereas some loops appear with a \\(-1\\) coefficient for the double semion.", "_type": "ecc", "_page_id": "c_double_semion", "_href": "c/double_semion"}, "c_rbh": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Raussendorf-Bravyi-Harrington (RBH) code", "code_id": "rbh", "realizations": "", "protection": "Code exhibiting symmetry-protected self-correction. The energy barrier for symmetry-preserving exhitations outside of the code space grows linearly with the lattice width. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the lattice width. ", "notes": "", "physical": "", "short_name": "", "introduced": "[S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]", "description": "Stub. (see Sec. III E of [S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]) ", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "cousins_code_id": "symmetry_protected_self_correct\nsubsystem_color\nsurface", "cousins_detail": "\nThe RBH code on a certain lattice is dual to the gauge color code.\nWithout symmetry protection, one of 2D boundaries of the cubic RBH code is effectively a 2D toric code.", "_type": "ecc", "_page_id": "c_rbh", "_href": "c/rbh"}, "c_xyz_hexagonal": {"logical": "qubits", "features_code_capacity_threshold": "\\(50\\%\\) for pure \\(Z\\), \\(Y\\), or \\(Z\\) noise under maximum-likelihood decoding.\nThreshold matches that of the \\(XZZX\\) code for various bias levels of \\(X\\), \\(Y\\), or \\(Z\\) biased noise under maximum-likelihood decoding.\n\\(\\sim 18\\%\\) for depolarizing noise under maximum-likelihood decoding.", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Maximum-likelihood decoding using the EWD decoder [K. Hammar et al., \u201cError-rate-agnostic decoding of topological stabilizer codes\u201d, Physical Review A 105, (2022). DOI; 2112.01977].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "XYZ\\(^2\\) hexagonal stabilizer code", "code_id": "xyz_hexagonal", "realizations": "", "protection": "As a stabilizer code with boundaries, protects a single qubit with parameters \\([[2 d^2, 1, d]]\\).", "notes": "Isolated \\(X\\), \\(Y\\), and \\(Z\\) errors lead to unidirectional pairs of plaquette defects along the three directions of the triangular lattice.", "physical": "qubits", "short_name": "", "introduced": "[J. R. Wootton, \u201cHexagonal matching codes with two-body measurements\u201d, Journal of Physics A: Mathematical and Theoretical 55, 295302 (2022). DOI; 2109.13308][B. Srivastava, A. Frisk Kockum, and M. Granath, \u201cThe XYZ<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\"><mml:msup><mml:mi /><mml:mn>2</mml:mn></mml:msup></mml:math> hexagonal stabilizer code\u201d, Quantum 6, 698 (2022). DOI; 2112.06036]", "description": "An instance of the matching code based on the Kitaev honeycomb model. It is described on a hexagonal lattice with \\(XYZXYZ\\) stabilizers on each hexagonal plaquette. Each vertical pair of qubits has an \\(XX\\), \\(YY\\), or \\(ZZ\\) link stabilizer depending on the orientation of the plaquette stabilizers.", "parents_code_id": "matching", "parents_detail": "", "_type": "ecc", "_page_id": "c_xyz_hexagonal", "_href": "c/xyz_hexagonal"}, "c_fractal_surface": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Fractal surface code", "code_id": "fractal_surface", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Guanyu Zhu, Tomas Jochym-O'Connor, and Arpit Dua, \u201cTopological Order, Quantum Codes and Quantum Computation on Fractal Geometries\u201d. 2108.00018][Arpit Dua, Tomas Jochym-O'Connor, and Guanyu Zhu, \u201cQuantum error correction with fractal topological codes\u201d. 2201.03568]", "description": "Kitaev surface code on a fractal geometry, which is obtained by removing qubits from the surface code on a cubic lattice. Stub.", "parents_code_id": "surface", "parents_detail": "", "cousins_code_id": "higher_dimensional_surface", "cousins_detail": "Fractal surface codes are obtained by removing qubits from the surface code on a cubic lattice.", "_type": "ecc", "_page_id": "c_fractal_surface", "_href": "c/fractal_surface"}, "c_surface-17": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Lookup table [Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747].", "features_transversal_gates": "Pauli gates, CNOT gate, and \\(H\\) gate (with relabeling).", "features_fault_tolerance": "", "name": "Surface-17 code", "code_id": "surface-17", "realizations": "Implemented at ETH Zurich by the Wallraff group [S. Krinner et al., \u201cRealizing repeated quantum error correction in a distance-three surface code\u201d, Nature 605, 669 (2022). DOI; 2112.03708] and on the Zuchongzhi 2.1 superconducting quantum processor [Y. Zhao et al., \u201cRealization of an Error-Correcting Surface Code with Superconducting Qubits\u201d, Physical Review Letters 129, (2022). DOI; 2112.13505]. Both experimental error rates are above the pseudothreshold for this code relative to a single qubit. See Physics viewpoint for a summary [L. Frunzio and S. Singh, \u201cError-Correcting Surface Codes Get Experimental Vetting\u201d, Physics 15, (2022). DOI]. ", "protection": "Independent correction of single-qubit \\(X\\) and \\(Z\\) errors. Correction for some two-qubit \\(X\\) and \\(Z\\) errors.", "notes": "Subject of various numerical studies examining the system for noises and architectures specific to trapped ions [Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747][C. J. Trout et al., \u201cSimulating the performance of a distance-3 surface code in a linear ion trap\u201d, New Journal of Physics 20, 043038 (2018). DOI; 1710.01378][Dripto M. Debroy et al., \u201cLogical Performance of 9 Qubit Compass Codes in Ion Traps with Crosstalk Errors\u201d. 1910.08495] and superconducting circuits [R. Versluis et al., \u201cScalable Quantum Circuit and Control for a Superconducting Surface Code\u201d, Physical Review Applied 8, (2017). DOI; 1612.08208][T. E. O\u2019Brien, B. Tarasinski, and L. DiCarlo, \u201cDensity-matrix simulation of small surface codes under current and projected experimental noise\u201d, npj Quantum Information 3, (2017). DOI; 1703.04136][B. M. Varbanov et al., \u201cLeakage detection for a transmon-based surface code\u201d, npj Quantum Information 6, (2020). DOI; 2002.07119]", "physical": "qubits", "short_name": "", "introduced": "[Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747]", "description": "A \\([[9,1,3]]\\) rotated surface code named for the sum of its 9 data qubits and 8 syndrome qubits. It uses the smallest number of qubits to perform error correction on a surface code with parallel syndrome extraction.", "parents_code_id": "rotated_surface", "parents_detail": "", "_type": "ecc", "_page_id": "c_surface-17", "_href": "c/surface-17"}, "c_rotated_surface": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Local neural-network using 3D convolutions, combined with a separate global decoder [Christopher Chamberland et al., \u201cTechniques for combining fast local decoders with global decoders under circuit-level noise\u201d. 2208.01178].", "features_transversal_gates": "", "features_fault_tolerance": "A particular choice of CNOT gates during syndrome extraction is required to be fault-tolerant to syndrome qubit errors [Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747].", "name": "Rotated surface code", "code_id": "rotated_surface", "realizations": "", "protection": "The \\([[L^2,1,L]]\\) variant of this family includes the \\([[9,1,3]]\\) surface-17 code, named as such because 8 ancilla qubits are used for check operator measurements alongside the 9 physical qubits.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[H. Bombin and M. A. Martin-Delgado, \u201cOptimal resources for topological two-dimensional stabilizer codes: Comparative study\u201d, Physical Review A 76, (2007). DOI; quant-ph/0703272][Jonas T. Anderson, \u201cHomological Stabilizer Codes\u201d. 1107.3502][A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928][Y. Tomita and K. M. Svore, \u201cLow-distance surface codes under realistic quantum noise\u201d, Physical Review A 90, (2014). DOI; 1404.3747]", "description": "Also called a checkerboard code. CSS variant of the surface code defined on a square lattice that has been rotated 45 degrees such that qubits are on vertices, and both \\(X\\)- and \\(Z\\)-type check operators occupy plaquettes in an alternating checkerboard pattern.", "parents_code_id": "clifford-deformed_surface\nquantum_tanner", "parents_detail": "Rotated surface codes can be obtained from surface codes via a constant-depth Clifford circuit.\nSpecializing the quantum Tanner construction to the surface code yields the rotated surface code [Nikolas P. Breuckmann, private communication, 2022][Anthony Leverrier, Mapping the toric code to the rotated toric code, 2022.].", "parent_of_code_id": "surface-17", "parent_of_detail": "", "cousins_code_id": "hypergraph_product\nheavy_hex", "cousins_detail": "Rotated code can be obtained from hypergraph product of two cyclic binary cyclic codes with palindromic generator polynomial ([A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928], Ex. 7).\nA rotated surface code can be mapped onto a heavy square lattice, resulting in a code similar to the heavy-hexagon code [C. Chamberland et al., \u201cTopological and Subsystem Codes on Low-Degree Graphs with Flag Qubits\u201d, Physical Review X 10, (2020). DOI; 1907.09528].", "cousin_of_code_id": "xzzx\nstab_4_2_2", "cousin_of_detail": "XZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).\nVarious \\([[4,1,2]]\\) subcodes are small rotated planar codes [A. Erhard et al., \u201cEntangling logical qubits with lattice surgery\u201d, Nature 589, 220 (2021). DOI; 2006.03071][C. K. Andersen et al., \u201cRepeated quantum error detection in a surface code\u201d, Nature Physics 16, 875 (2020). DOI; 1912.09410][Google Quantum AI et al., \u201cExponential suppression of bit or phase errors with cyclic error correction\u201d, Nature 595, 383 (2021). DOI; 2102.06132][J. F. Marques et al., \u201cLogical-qubit operations in an error-detecting surface code\u201d, Nature Physics 18, 80 (2021). DOI; 2102.13071].", "_type": "ecc", "_page_id": "c_rotated_surface", "_href": "c/rotated_surface"}, "c_xzzx": {"logical": "qubits", "features_code_capacity_threshold": "\\(50\\%\\) threshold for noise infinitely biased towards \\(X\\) or \\(Y\\) or \\(Z\\) errors using a maximum-likelihood decoder.\nFor large but finite \\(X\\)- or \\(Z\\)-biased noise, the code's thresholds exceed the zero-rate hashing bound. The difference of the threshold from the hashing bound exceeds \\(2.9\\%\\) at a \\(Z\\) or \\(X\\) bias of 300.\n\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder.\n\\(0.817\\%\\) and \\(0.940\\%\\) with minimum-weight perfect matching and belief-matching decoder, respectively, for biased circuit-level noise [Oscar Higgott et al., \u201cFragile boundaries of tailored surface codes and improved decoding of circuit-level noise\u201d. 2203.04948].\n\\(4.15\\%\\) when \\(98\\%\\) of depolarizing errors are coverted into erasure errors with union-find decoder on a planar code, vs. \\(0.937\\%\\) for pure depolarizing noise. In Rydberg atomic devices, erasure conversion during gates is promising because the dominant source of noise is spontaneous decay into detectable energy levels outside of the computational subspace [Y. Wu et al., \u201cErasure conversion for fault-tolerant quantum computing in alkaline earth Rydberg atom arrays\u201d, Nature Communications 13, (2022). DOI; 2201.03540].", "features_general_gates": "", "features_threshold": "\\(\\sim 4.5\\%\\) using minimum-weight perfect matching decoder for depolarizing noise (bias \\(\\eta=0.5\\)); \\(\\sim 10\\%\\) for infinite \\(Z\\) bias.", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Minimum-weight perfect matching decoder, which can be used for \\(X\\) and \\(Z\\) noise. For \\(Y\\) noise, a variant of the matching decoder could be used like it is used for the XY code in Ref. [D. K. Tuckett et al., \u201cFault-Tolerant Thresholds for the Surface Code in Excess of \n<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mn>5</mml:mn><mml:mo>%</mml:mo></mml:math>\n Under Biased Noise\u201d, Physical Review Letters 124, (2020). DOI; 1907.02554].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "XZZX surface code", "code_id": "xzzx", "realizations": "Distance-five 25-qubit code implemented on a superconducting quantum processor by Google Quantum AI [Rajeev Acharya et al., \u201cSuppressing quantum errors by scaling a surface code logical qubit\u201d. 2207.06431]. This code outperformed the average of several instances of the smaller distance-three 9-qubit \\(XZZX\\) variant of the surface-17 code realized on the same device, both in terms of logical error probability over 25 cycles and in terms of logical error per cycle. This increase in error-correcting capabilities while using more physical qubits supports the notion of an error threshold. Braiding of defects has been demonstrated for the distance-five code [Trond I. Andersen et al., \u201cObservation of non-Abelian exchange statistics on a superconducting processor\u201d. 2210.10255]. Leakage errors have been handled in a separate work in a distance-three code [Kevin C. Miao et al., \u201cOvercoming leakage in scalable quantum error correction\u201d. 2211.04728].", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "notes": "A single \\(X\\) or \\(Z\\) error gives rise to two nearby defects, which can be viewed as endpoints of a string. That way, multiple \\(Z\\) errors can be decomposed into a combination of diagonal strings.\nOriginally formulated as an example of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [X.-G. Wen, \u201cQuantum Orders in an Exact Soluble Model\u201d, Physical Review Letters 90, (2003). DOI; quant-ph/0205004].", "physical": "qubits", "short_name": "", "introduced": "[X.-G. Wen, \u201cQuantum Orders in an Exact Soluble Model\u201d, Physical Review Letters 90, (2003). DOI; quant-ph/0205004][J. P. Bonilla Ataides et al., \u201cThe XZZX surface code\u201d, Nature Communications 12, (2021). DOI; 2009.07851]", "description": "Non-CSS variant of the rotated surface code whose generators are \\(XZXZ\\) Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).", "parents_code_id": "clifford-deformed_surface", "parents_detail": "XZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).", "cousins_code_id": "rotated_surface\nfracton\ntopological_abelian", "cousins_detail": "XZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).\nSubsystem symmetries play a role in finite-bias decoders for both codes [B. J. Brown and D. J. Williamson, \u201cParallelized quantum error correction with fracton topological codes\u201d, Physical Review Research 2, (2020). DOI; 1901.08061].\nExample of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [X.-G. Wen, \u201cQuantum Orders in an Exact Soluble Model\u201d, Physical Review Letters 90, (2003). DOI; quant-ph/0205004].", "_type": "ecc", "_page_id": "c_xzzx", "_href": "c/xzzx"}, "c_freedman_meyer_luo": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Codes held a 20-year record the best lower bound on asymptotic scaling of the minimum code distance, \\(d=\\Omega(\\sqrt{n \\sqrt{\\log n}})\\), broken by Ramanujan tensor-product codes.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Freedman-Meyer-Luo code", "code_id": "freedman_meyer_luo", "realizations": "", "protection": "Four-dimensional manifolds with weak systolic freedom yield \\([[n,2,\\Omega(\\sqrt{n \\sqrt{\\log n}})]]\\) surface codes.", "notes": "See thesis by Fetaya for pedagogical exposition [Ethan Fetaya, \u201cHomological Error Correcting Codes and Systolic Geometry\u201d. 1108.2886].", "physical": "qubits", "short_name": "", "introduced": "[\u201cZ2-systolic freedom and quantum codes\u201d, Mathematics of Quantum Computation 303 (2002). DOI]", "description": "Hyperbolic surface code constructed using cellulation of a Riemannian Manifold \\(M\\) exhibiting systolic freedom [M. H. Freedman, \u201c<b>Z</b><sub>2</sub>\u2013Systolic-Freedom\u201d, Proceedings of the Kirbyfest (1999). DOI]. Codes derived from such manifolds can achieve distances scaling better than \\(\\sqrt{n}\\), something that is impossible using closed 2D surfaces or 2D surfaces with boundaries [E. Fetaya, \u201cBounding the distance of quantum surface codes\u201d, Journal of Mathematical Physics 53, 062202 (2012). DOI]. Improved codes are obtained by studying a weak family of Riemann metrics on closed 4-dimensional manifolds \\(S^2\\otimes S^2\\) with the \\(Z_2\\)-homology. ", "parents_code_id": "hyperbolic_surface\nhigher_dimensional_surface", "parents_detail": "\n", "cousin_of_code_id": "ramanujan_tensor_product", "cousin_of_detail": "Ramanujan codes broke 20-year record on minimum code distance set by Freedman-Meyer-Luo codes.", "_type": "ecc", "_page_id": "c_freedman_meyer_luo", "_href": "c/freedman_meyer_luo"}, "c_xysurface": {"logical": "qubits", "features_code_capacity_threshold": "\\(50\\%\\) at infinite \\(Z\\) bias with maximum-likelihood decoder [D. K. Tuckett et al., \u201cTailoring Surface Codes for Highly Biased Noise\u201d, Physical Review X 9, (2019). DOI; 1812.08186].\n\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder [D. K. Tuckett et al., \u201cTailoring Surface Codes for Highly Biased Noise\u201d, Physical Review X 9, (2019). DOI; 1812.08186].", "features_general_gates": "", "features_threshold": "\\(6.32(3)\\%\\) for infinite \\(Z\\) bias, and thresholds of \\(\\sim 5\\%\\) for \\(Z\\) bias around \\(\\eta = 100\\) using a variant of the minimum-weight perfect matching decoder [D. K. Tuckett et al., \u201cFault-Tolerant Thresholds for the Surface Code in Excess of \n<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mn>5</mml:mn><mml:mo>%</mml:mo></mml:math>\n Under Biased Noise\u201d, Physical Review Letters 124, (2020). DOI; 1907.02554].", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "XY surface code", "code_id": "xysurface", "realizations": "", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[D. K. Tuckett, S. D. Bartlett, and S. T. Flammia, \u201cUltrahigh Error Threshold for Surface Codes with Biased Noise\u201d, Physical Review Letters 120, (2018). DOI; 1708.08474]", "description": "Also called the tailored surface code (TSC). Non-CSS derivative of the surface code whose generators are \\(XXXX\\) and \\(YYYY\\), obtained by mapping \\(Z \\to Y\\) in the surface code.", "parents_code_id": "clifford-deformed_surface", "parents_detail": "XY code is obtained from the surface code by applying \\(H\\sqrt{Z}H\\) to all qubits, thereby exchaning \\(Z\\leftrightarrow Y\\).", "_type": "ecc", "_page_id": "c_xysurface", "_href": "c/xysurface"}, "c_real_projective_plane": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The rate is \\(1/n\\), where \\(n\\) is the number of edges of the particular cellulation.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Projective-plane surface code", "code_id": "real_projective_plane", "realizations": "", "protection": "If \\(\\mathcal{C}\\) is a cellulation of \\(\\mathbb{R}P^2\\), then the bit-flip distance \\(d_X\\) is the shortest cycle in \\(\\mathcal{C}\\), and the phase-flip distance \\(d_Z\\) is the shortest cycle in the dual cellulation \\(\\mathcal{C}^*\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Michael H. Freedman and David A. Meyer, \u201cProjective plane and planar quantum codes\u201d. quant-ph/9810055]", "description": "A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold \\(\\mathbb{R}P^2\\) (in contrast to a genus-\\(g\\) surface). Whereas genus-\\(g\\) surface codes require \\(2g\\) logical qubits, qubit codes on \\(\\mathbb{R}P^2\\) are made from a single logical qubit.", "parents_code_id": "surface", "parents_detail": "", "cousin_of_code_id": "shor_nine", "cousin_of_detail": "Shor's code is the smallest surface code defined on the projective plane [Michael H. Freedman and David A. Meyer, \u201cProjective plane and planar quantum codes\u201d. quant-ph/9810055].", "_type": "ecc", "_page_id": "c_real_projective_plane", "_href": "c/real_projective_plane"}, "c_golden_code": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Golden code", "code_id": "golden_code", "realizations": "", "protection": "Nonvanishing rate and asymptotic distance lower bounded by \\(n^0.1\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[\u201c[]\u201d, Quantum Information and Computation 19, (2019). DOI; 1712.08578]", "description": "Variant of the Guth-Lubotzky hyperbolic surface code that uses regular tessellations for 4-dimensional hyperbolic space. ", "parents_code_id": "four_dimensional_hyperbolic", "parents_detail": "", "_type": "ecc", "_page_id": "c_golden_code", "_href": "c/golden_code"}, "c_four_dimensional_hyperbolic": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Guth-Lubotzky code", "code_id": "four_dimensional_hyperbolic", "realizations": "", "protection": "Protection stems from the relationship between properties of manifolds and CSS codes derived from their cellulation. The number of physical \\(k\\) qubits and distance \\(d\\) of the code will scale as \\(\\Omega(n)\\) and \\(\\Omega(n^\\epsilon)\\), respectively.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[L. Guth and A. Lubotzky, \u201cQuantum error correcting codes and 4-dimensional arithmetic hyperbolic manifolds\u201d, Journal of Mathematical Physics 55, 082202 (2014). DOI; 1310.5555]", "description": "Hyperbolic surface code based on cellulations of certain four-dimensional manifolds. The manifolds are shown to have good homology and systolic properties for the purposes of code construction, with corresponding codes exhibiting linear rate.\n\nGuth and Lubotzky [L. Guth and A. Lubotzky, \u201cQuantum error correcting codes and 4-dimensional arithmetic hyperbolic manifolds\u201d, Journal of Mathematical Physics 55, 082202 (2014). DOI; 1310.5555] show that there exists \\(\\epsilon\\), a four-dimensional hyperbolic manifold \\(M\\), and a sequence of manifolds \\(M_i\\) such that each \\(M_i\\) is a finite sheeted covering of \\(M\\), and the four-dimensional volumes of the manifolds \\(\\text{Vol}_4(M_i)\\) of the sequence tend to infinity. Also, the dimension of the second homology and size of systoles are bounded by \\(H_2(M_i, Z_2) \\geq \\frac{\\text{Vol}_4(M_i)}{100}\\) and \\(\\text{Sys}_2(M_i) \\geq \\text{Vol}_4(M_i)^\\epsilon\\), respectively.\n\nThen given any cellulation of \\(M\\), it can naturally be extended to cellulations for each of the manifolds \\(M_i\\) and used to define CSS codes via the homological construction by choosing the size three chain complex consisting of the \\(3,2\\) and \\(1\\)-cells of the cellulations.\n\nFor dense cellulations (i.e. large \\(n\\)) the number of physical qubits for these codes will scale with the volume of the manifolds. Therefore, bounds on the dimension of the second homology and size of systoles are achieved in terms of \\(n\\) for large \\(n\\).", "parents_code_id": "hyperbolic_surface\nhigher_dimensional_surface", "parents_detail": "\n", "parent_of_code_id": "golden_code", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_four_dimensional_hyperbolic", "_href": "c/four_dimensional_hyperbolic"}, "c_3d_surface": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Solid code", "code_id": "3d_surface", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[K. P. Michnicki, \u201c3D Topological Quantum Memory with a Power-Law Energy Barrier\u201d, Physical Review Letters 113, (2014). DOI; 1406.4227]", "description": "A variant of Kitaev's surface code on a 3D lattice.", "parents_code_id": "higher_dimensional_surface", "parents_detail": "", "cousins_code_id": "color", "cousins_detail": "Color code is equivalent to surface code in several ways [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065][Arun B. Aloshious, Arjun Nitin Bhagoji, and Pradeep Kiran Sarvepalli, \u201cOn the Local Equivalence of 2D Color Codes and Surface Codes with Applications\u201d. 1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.", "cousin_of_code_id": "self_correct", "cousin_of_detail": "The 3D welded solid code is partially self-correcting with a power-law energy barrier [K. P. Michnicki, \u201c3D Topological Quantum Memory with a Power-Law Energy Barrier\u201d, Physical Review Letters 113, (2014). DOI; 1406.4227]. The 3D toric code is a classical self-correcting memory, whose protected bit admits a membrane-like logical operator [O. Landon-Cardinal et al., \u201cPerturbative instability of quantum memory based on effective long-range interactions\u201d, Physical Review A 91, (2015). DOI; 1501.04112].", "_type": "ecc", "_page_id": "c_3d_surface", "_href": "c/3d_surface"}, "c_hyperbolic_surface": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hyperbolic surface code", "code_id": "hyperbolic_surface", "realizations": "", "protection": "Constructions (see code children below) have yielded distances scaling favorably with the number of qubits. The use of hyperbolic surfaces allows one to circumvent bounds on surface code parameters that are valid for surfaces with bounded geometry.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "", "description": "An extension of the Kitaev surface code construction to hyperbolic manifolds in dimension two or greater. Given a cellulation of a manifold, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers are associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\(i+1\\)-faces. ", "parents_code_id": "surface", "parents_detail": "", "parent_of_code_id": "freedman_meyer_luo\nfour_dimensional_hyperbolic\ntwo_dimensional_hyperbolic_surface", "parent_of_detail": "\n\n", "cousins_code_id": "holographic", "cousins_detail": "Both holographic and hyperbolic surface codes utilize tesselations of hyperbolic surfaces. Encodings for the former are hyperbolically tiled tensor networks, while the latter is defined on hyperbolically tiled physical-qubit lattices.", "_type": "ecc", "_page_id": "c_hyperbolic_surface", "_href": "c/hyperbolic_surface"}, "c_two_dimensional_hyperbolic_surface": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "1\\(\\%\\) - 5\\(\\%\\) for a \\({5,4}\\) tiling under minimum-weight decoding [A. A. Kovalev and L. P. Pryadko, \u201cFault tolerance of quantum low-density parity check codes with sublinear distance scaling\u201d, Physical Review A 87, (2013). DOI; 1208.2317]. For larger tilings, the lower bound on the distance decreases, suggesting the threshold will also decrease.", "features_rate": "Two-dimensional hyperbolic surface codes have an asymptotically constant encoding rate \\( k/n \\) with a distance scaling logarithmically with \\( n\\) when the surface is closed. The encoding rate depends on the tiling \\( {r,s} \\) and is given by \\( k/n = (1-2/r - 2/s) + 2/n \\), which approaches a constant value as the number of physical qubits grows. The weight of the stabilizers is \\( r \\) for \\( Z \\)-checks and \\( s \\) for \\( X \\)-checks. For open boundary conditions, the code reduces to constant distnace.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Due to the symmetries of hyperbolic surface codes, optimal measurement schedules of the stabilizers can be found [O. Higgott and N. P. Breuckmann, \u201cSubsystem Codes with High Thresholds by Gauge Fixing and Reduced Qubit Overhead\u201d, Physical Review X 11, (2021). DOI; 2010.09626].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Two-dimensional hyperbolic surface code", "code_id": "two_dimensional_hyperbolic_surface", "realizations": "", "protection": "Protects against Pauli errors with distance \\( d \\propto \\log(n) \\). Code parameters are \\( [[n, (1-2/r - 2/s)  n + 2, O(\\log n) ]] \\)", "notes": "See Sec III A of Ref. [N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309] for a description of this code.\nConnection to percolation theory as shown in [Nicolas Delfosse and Gilles Z\u00e9mor, \u201cUpper Bounds on the Rate of Low Density Stabilizer Codes for the Quantum Erasure Channel\u201d. 1205.7036].", "physical": "qubits", "short_name": "", "introduced": "[N. P. Breuckmann and B. M. Terhal, \u201cConstructions and Noise Threshold of Hyperbolic Surface Codes\u201d, IEEE Transactions on Information Theory 62, 3731 (2016). DOI; 1506.04029]", "description": "Hyperbolic surface codes based on a tessellation of a closed 2D manifold with a hyperbolic geometry (i.e., non-Euclidean geometry, e.g., saddle surfaces when defined on a 2D plane).\n\nFor a tessellation involving regular polygons with \\( r \\) sides and \\( s \\) polygons meeting at each edge, the number of logical qubits is given by \\( k = (1-2/r - 2/s) n + 2 \\). Some possible tilings are \\( {r,s}: {7,3}, {5,4} \\). The weight of the stabilizer generators are dependent on the tiling, with \\({5,4}\\) having lower weight than \\({7,3}\\). ", "parents_code_id": "hyperbolic_surface", "parents_detail": "", "_type": "ecc", "_page_id": "c_two_dimensional_hyperbolic_surface", "_href": "c/two_dimensional_hyperbolic_surface"}, "c_higher_dimensional_surface": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Higher-dimensional surface code", "code_id": "higher_dimensional_surface", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143]", "description": "A family of Kitaev surface codes on planar or toric surfaces of dimension greater than two. Stub.", "parents_code_id": "surface", "parents_detail": "", "parent_of_code_id": "freedman_meyer_luo\nfour_dimensional_hyperbolic\nhemicubic\nhypersphere_product\n3d_surface", "parent_of_detail": "\n\n\n\n", "cousin_of_code_id": "fractal_surface\nself_correct", "cousin_of_detail": "Fractal surface codes are obtained by removing qubits from the surface code on a cubic lattice.\nThe 4D toric code is a self-correcting quantum memory [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][R. Alicki et al., \u201cOn thermal stability of topological qubit in Kitaev's 4D model\u201d. 0811.0033].", "_type": "ecc", "_page_id": "c_higher_dimensional_surface", "_href": "c/higher_dimensional_surface"}, "c_clifford-deformed_surface": {"logical": "qubits", "features_code_capacity_threshold": "A class of random CDSCs, parametrized by the probabilities \\(\\Pi_{XZ},~ \\Pi_{YZ}\\) of \\(X\\leftrightarrow Z\\) and \\(Y\\leftrightarrow Z\\) Pauli permutations, respectively, has \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.\nCertain translation-invariant CDSCs such as the XY code and the XZZX code also have \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.\nXZZX code and the \\((0.5,\\Pi_{YZ})\\) random CDSCs have a \\(50\\%\\) code capacity threshold for noise infinitely biased towards either Pauli-\\(X\\), \\(Y\\), or \\(Z\\) errors.", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "In order to leverage the benefits of CDSCs into practical universal computation, we have to implement syndrome measurement circuits and fault-tolerant logical gates in a bias-preserving way.", "name": "Clifford-deformed surface code (CDSC)", "code_id": "clifford-deformed_surface", "realizations": "", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "notes": "", "physical": "qubits", "short_name": "CDSC", "introduced": "[Arpit Dua et al., \u201cClifford-deformed Surface Codes\u201d. 2201.07802]", "description": "A generally non-CSS derivative of the surface code defined by applying a constant-depth Clifford circuit to the original (CSS) surface code. Unlike the surface code, CDSCs include codes whose thresholds and subthreshold performance are enhanced under noise biased towards dephasing. Examples of CDSCs include the XY code, XZZX code, and random CDSCs.", "parents_code_id": "qubit_stabilizer\ntopological_abelian", "parents_detail": "\nLocal deformations of the surface code preserve its \\(\\mathbb{Z}_2\\) topological order.", "parent_of_code_id": "surface\nrotated_surface\nxysurface\nxzzx", "parent_of_detail": "CDSC codes are deformations of the surface code via constant-depth Clifford circuits that may not be CSS.\nRotated surface codes can be obtained from surface codes via a constant-depth Clifford circuit.\nXY code is obtained from the surface code by applying \\(H\\sqrt{Z}H\\) to all qubits, thereby exchaning \\(Z\\leftrightarrow Y\\).\nXZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).", "cousins_code_id": "dynamic_gen\nquantum_random", "cousins_detail": "To create CDSCs, a dynamical process is applied on top of the surface code.\nMany useful CDSCs are constructed using random Clifford circuits.", "_type": "ecc", "_page_id": "c_clifford-deformed_surface", "_href": "c/clifford-deformed_surface"}, "c_surface": {"logical": "qubits", "features_code_capacity_threshold": "Independent \\(X,Z\\) noise: \\(10.31\\%\\) under MWPM decoding [C. Wang, J. Harrington, and J. Preskill, \u201cConfinement-Higgs transition in a disordered gauge theory and the accuracy threshold for quantum memory\u201d, Annals of Physics 303, 31 (2003). DOI; quant-ph/0207088] (see also Ref. [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883]). The threshold under ML decoding corresponds to the value of critical point of the two-dimensional random-bond Ising model on the Nishimori line [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143], calculated to be \\(10.94 \\pm 0.02\\%\\) in Ref. [O. Derzhko, J. Richter, and O. Zaburannyi, \u201cSpin-Peierls instability in the spin-1/2 transverse XX chain with Dzyaloshinskii-Moriya interaction\u201d. cond-mat/0001014], \\(10.93(2)\\%\\) in Ref. [F. Merz and J. T. Chalker, \u201cTwo-dimensional random-bond Ising model, free fermions, and the network model\u201d, Physical Review B 65, (2002). DOI; cond-mat/0106023], and estimated to be between \\(10.9\\%\\) and \\(11\\%\\) in Ref. [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883].\nDepolarizing noise: between \\(17\\%\\) and \\(18.5\\%\\) under tensor-network decoding [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883], and between \\(15\\%\\) and \\(16\\%\\) under RG [G. Duclos-Cianci and D. Poulin, \u201cFast Decoders for Topological Quantum Codes\u201d, Physical Review Letters 104, (2010). DOI; 0911.0581], Markov-chain [A. Hutter, J. R. Wootton, and D. Loss, \u201cEfficient Markov chain Monte Carlo algorithm for the surface code\u201d, Physical Review A 89, (2014). DOI; 1302.2669], or MWPM [D. S. Wang et al., \u201cThreshold error rates for the toric and surface codes\u201d. 0905.0531] decoding. The threshold under ML decoding corresponds to the value of critical point in the disordered eight-vertex Ising model, calculated to be \\(18.9(3)\\%\\) [H. Bombin et al., \u201cStrong Resilience of Topological Codes to Depolarization\u201d, Physical Review X 2, (2012). DOI; 1202.1852] (see also APS Physics viewpoint [D. Gottesman, \u201cKeeping One Step Ahead of Errors\u201d, Physics 5, (2012). DOI]).\nErasure noise: \\(50\\%\\) for square tiling [T. M. Stace, S. D. Barrett, and A. C. Doherty, \u201cThresholds for Topological Codes in the Presence of Loss\u201d, Physical Review Letters 102, (2009). DOI; 0904.3556]. There is an inverse relationship between coordination number of the syndrome graph, with the threshold corresponding to a percolation transition [Naomi Nickerson and H\u00e9ctor Bomb\u00edn, \u201cMeasurement based fault tolerance beyond foliation\u201d. 1810.09621].\nPhenomenological noise: \\(3.3\\%\\) for square tiling [T. Ohno et al., \u201cPhase structure of the random-plaquette gauge model: accuracy threshold for a toric quantum memory\u201d, Nuclear Physics B 697, 462 (2004). DOI; quant-ph/0401101].", "features_general_gates": "Clifford gates can be implemented via lattice surgery [C. Horsman et al., \u201cSurface code quantum computing by lattice surgery\u201d, New Journal of Physics 14, 123011 (2012). DOI; 1111.4022][D. Litinski and F. von . Oppen, \u201cLattice Surgery with a Twist: Simplifying Clifford Gates of Surface Codes\u201d, Quantum 2, 62 (2018). DOI; 1709.02318][D. Litinski, \u201cA Game of Surface Codes: Large-Scale Quantum Computing with Lattice Surgery\u201d, Quantum 3, 128 (2019). DOI; 1808.02892][C. Chamberland and E. T. Campbell, \u201cUniversal Quantum Computing with Twist-Free and Temporally Encoded Lattice Surgery\u201d, PRX Quantum 3, (2022). DOI; 2109.02746], twist-based lattice surgery [C. Chamberland and E. T. Campbell, \u201cCircuit-level protocol and analysis for twist-based lattice surgery\u201d, Physical Review Research 4, (2022). DOI; 2201.05678], or braiding defects [R. Raussendorf and J. Harrington, \u201cFault-Tolerant Quantum Computation with High Threshold in Two Dimensions\u201d, Physical Review Letters 98, (2007). DOI; quant-ph/0610082][R. Raussendorf, J. Harrington, and K. Goyal, \u201cTopological fault-tolerance in cluster state quantum computation\u201d, New Journal of Physics 9, 199 (2007). DOI; quant-ph/0703143][A. G. Fowler et al., \u201cSurface codes: Towards practical large-scale quantum computation\u201d, Physical Review A 86, (2012). DOI; 1208.0928][B. J. Brown et al., \u201cPoking Holes and Cutting Corners to Achieve Clifford Gates with the Surface Code\u201d, Physical Review X 7, (2017). DOI; 1609.04673]. \nNon-Clifford gates require magic state distillation [D. Litinski, \u201cMagic State Distillation: Not as Costly as You Think\u201d, Quantum 3, 205 (2019). DOI; 1905.06903], Dehn twists [G. Zhu, A. Lavasani, and M. Barkeshli, \u201cInstantaneous braids and Dehn twists in topologically ordered states\u201d, Physical Review B 102, (2020). DOI; 1806.06078], or just-in-time decoding [B. J. Brown, \u201cA fault-tolerant non-Clifford gate for the surface code in two dimensions\u201d, Science Advances 6, (2020). DOI; 1903.11634]. ", "features_threshold": "\\(1.8\\%\\) for circuit-level depolarizing noise under optimal decoder [Bettina Heim, Krysta M. Svore, and Matthew B. Hastings, \u201cOptimal Circuit-Level Decoding for Surface Codes\u201d. 1609.06373]. \\(0.57\\%\\) for depolarizing noise on data and syndrome qubits as well initialization, gate, and measurement errors under MPWM decoding [A. G. Fowler et al., \u201cSurface codes: Towards practical large-scale quantum computation\u201d, Physical Review A 86, (2012). DOI; 1208.0928]. For this model, a logical qubit with a \\(10^{-14}\\) logical error rate requires between \\(10^3\\) to \\(10^4\\) physical qubits and a target gate fidelity above \\(99.9\\%\\). Later work showed that arbitrarily large computations are possible for a physical error rate of approximately \\(10^{-4}\\) [A. G. Fowler, \u201cProof of Finite Surface Code Threshold for Matching\u201d, Physical Review Letters 109, (2012). DOI; 1206.0800].\n\\(0.35\\%\\) for circuit-level independent \\(X,Z\\) noise under optimal decoder [Bettina Heim, Krysta M. Svore, and Matthew B. Hastings, \u201cOptimal Circuit-Level Decoding for Surface Codes\u201d. 1609.06373].\n\\(0.5-2.9\\%\\) for various noise models [M. Ohzeki, \u201cLocations of multicritical points for spin glasses on regular lattices\u201d, Physical Review E 79, (2009). DOI; 0811.0464] (see also Refs. [C. Wang, J. Harrington, and J. Preskill, \u201cConfinement-Higgs transition in a disordered gauge theory and the accuracy threshold for quantum memory\u201d, Annals of Physics 303, 31 (2003). DOI; quant-ph/0207088][A. M. Stephens, \u201cFault-tolerant thresholds for quantum error correction with the surface code\u201d, Physical Review A 89, (2014). DOI; 1311.5003]).", "features_rate": "Rate depends on the underlying cellulation and manifold. For general 2D manifolds, \\(kd^2\\leq c(\\log k)^2 n\\) for some constant \\(c\\) [N. Delfosse, \u201cTradeoffs for reliable quantum information storage in surface codes and color codes\u201d, 2013 IEEE International Symposium on Information Theory (2013). DOI; 1301.6588], meaning that (1) 2D surface codes with bounded geometry have distance scaling at most as \\(O(\\sqrt{n})\\) [S. Bravyi, D. Poulin, and B. Terhal, \u201cTradeoffs for Reliable Quantum Information Storage in 2D Systems\u201d, Physical Review Letters 104, (2010). DOI; 0909.5200][E. Fetaya, \u201cBounding the distance of quantum surface codes\u201d, Journal of Mathematical Physics 53, 062202 (2012). DOI], and (2) surface codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\). Higher-dimensional hyperbolic manifolds (see code children below) yield distances scaling more favorably. Loewner's theorem provides an upper bound for any bounded-geometry surface code [\u201cZ2-systolic freedom and quantum codes\u201d, Mathematics of Quantum Computation 303 (2002). DOI]. ", "features_magic_scaling_exponent": "", "features_encoders": "For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit [O. Higgott et al., \u201cOptimal local unitary encoding circuits for the surface code\u201d, Quantum 5, 517 (2021). DOI; 2002.00362][Yu-Jie Liu et al., \u201cMethods for simulating string-net states and anyons on a digital quantum computer\u201d. 2110.02020] or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates [M. Aguado and G. Vidal, \u201cEntanglement Renormalization and Topological Order\u201d, Physical Review Letters 100, (2008). DOI; 0712.0348][J. Joo et al., \u201cGenerating and verifying graph states for fault-tolerant topological measurement-based quantum computing in two-dimensional optical lattices\u201d, Physical Review A 88, (2013). DOI; 1207.0253] (matching a lower bound in Ref. [Dorit Aharonov and Yonathan Touati, \u201cQuantum Circuit Depth Lower Bounds For Homological Codes\u201d. 1810.03912]).\nLindbladian-based dissipative encoding for the toric code [J. Dengis, R. K\u00f6nig, and F. Pastawski, \u201cAn optimal dissipative encoder for the toric code\u201d, New Journal of Physics 16, 013023 (2014). DOI; 1310.1036] that does not give a speedup relative to circuit-based encoders [R. K\u00f6nig and F. Pastawski, \u201cGenerating topological order: No speedup by dissipation\u201d, Physical Review B 90, (2014). DOI; 1310.1037].\nStabilizer measurement-based circuit of linear depth [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][J. \u0141odyga et al., \u201cSimple scheme for encoding and decoding a qubit in unknown state for various topological codes\u201d, Scientific Reports 5, (2015). DOI; 1404.2495].", "features_decoders": "Maximum-likelihood (ML) [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143], which takes time of order \\(O(n^2)\\) for independent \\(X,Z\\) noise [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883].\nMinimum weight perfect-matching (MWPM) [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][Austin G. Fowler, \u201cMinimum weight perfect matching of fault-tolerant topological quantum error correction in average $O(1)$ parallel time\u201d. 1307.1740] (based on work by Edmonds on finding a matching in a graph [J. Edmonds, \u201cPaths, Trees, and Flowers\u201d, Canadian Journal of Mathematics 17, 449 (1965). DOI][J. Edmonds, \u201cMaximum matching and a polyhedron with 0,1-vertices\u201d, Journal of Research of the National Bureau of Standards Section B Mathematics and Mathematical Physics 69B, 125 (1965). DOI]). Pipeline MWPM [Austin G. Fowler, \u201cOptimal complexity correction of correlated errors in the surface code\u201d. 1310.0863][Alexandru Paler and Austin G. Fowler, \u201cPipelined correlated minimum weight perfect matching of the surface code\u201d. 2205.09828] - a modification accounting for correlations between events. A modification utilizing the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) [Christopher A. Pattison et al., \u201cImproved quantum error correction using soft information\u201d. 2107.13589]. Correlated matching modifies MWPM to include correlations between \\(X\\) and \\(Z\\)-type errors [Austin G. Fowler, \u201cOptimal complexity correction of correlated errors in the surface code\u201d. 1310.0863]. Belief perfect matching is a combination of belief-propagation and MWPM [Oscar Higgott et al., \u201cFragile boundaries of tailored surface codes and improved decoding of circuit-level noise\u201d. 2203.04948].\nRenormalization group (RG) [G. Duclos-Cianci and D. Poulin, \u201cFast Decoders for Topological Quantum Codes\u201d, Physical Review Letters 104, (2010). DOI; 0911.0581][Guillaume Duclos-Cianci and David Poulin, \u201cFault-Tolerant Renormalization Group Decoder for Abelian Topological Codes\u201d. 1304.6100][F. H. E. Watson, H. Anwar, and D. E. Browne, \u201cFast fault-tolerant decoder for qubit and qudit surface codes\u201d, Physical Review A 92, (2015). DOI; 1411.3028].\nMarkov-chain Monte Carlo [A. Hutter, J. R. Wootton, and D. Loss, \u201cEfficient Markov chain Monte Carlo algorithm for the surface code\u201d, Physical Review A 89, (2014). DOI; 1302.2669].\nTensor network [S. Bravyi, M. Suchara, and A. Vargo, \u201cEfficient algorithms for maximum likelihood decoding in the surface code\u201d, Physical Review A 90, (2014). DOI; 1405.4883].\nCellular automaton [J. W. Harrington, Analysis of Quantum Error-correcting Codes: Symplectic Lattice Codes and Toric Codes, California Institute of Technology, 2004. DOI][M. Herold et al., \u201cCellular automaton decoders of topological quantum memories in the fault tolerant setting\u201d, New Journal of Physics 19, 063012 (2017). DOI; 1511.05579].\nNeural network [G. Torlai and R. G. Melko, \u201cNeural Decoder for Topological Codes\u201d, Physical Review Letters 119, (2017). DOI; 1610.04238][C. Chamberland and P. Ronagh, \u201cDeep neural decoders for near term fault-tolerant experiments\u201d, Quantum Science and Technology 3, 044002 (2018). DOI; 1802.06441][R. Sweke et al., \u201cReinforcement learning decoders for fault-tolerant quantum computation\u201d, Machine Learning: Science and Technology 2, 025005 (2020). DOI; 1810.07207][Yosuke Ueno et al., \u201cNEO-QEC: Neural Network Enhanced Online Superconducting Decoder for Surface Codes\u201d. 2208.05758].\nUnion-find [N. Delfosse and N. H. Nickerson, \u201cAlmost-linear time decoding algorithm for topological codes\u201d, Quantum 5, 595 (2021). DOI; 1709.06218]. A subsequent modification utilizes the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) [Christopher A. Pattison et al., \u201cImproved quantum error correction using soft information\u201d. 2107.13589]. Belief union find is a combination of belief-propagation and union-find [Oscar Higgott et al., \u201cFragile boundaries of tailored surface codes and improved decoding of circuit-level noise\u201d. 2203.04948].\nDecoders can be augmented with a pre-decoder [Nicolas Delfosse, \u201cHierarchical decoding to reduce hardware requirements for quantum computing\u201d. 2001.11427][Samuel C. Smith, Benjamin J. Brown, and Stephen D. Bartlett, \u201cA local pre-decoder to reduce the bandwidth and latency of quantum error correction\u201d. 2208.04660], which can allow for some processing to be done inside the cryogenic environment of the quantum system [Gokul Subramanian Ravi et al., \u201cHave your QEC and Bandwidth too!: A lightweight cryogenic decoder for common / trivial errors, and efficient bandwidth + execution management otherwise\u201d. 2208.08547].\nSliding-window [Xinyu Tan et al., \u201cScalable surface code decoders with parallelization in time\u201d. 2209.09219][Luka Skoric et al., \u201cParallel window decoding enables scalable fault tolerant quantum computation\u201d. 2209.08552] and parallel-window [Xinyu Tan et al., \u201cScalable surface code decoders with parallelization in time\u201d. 2209.09219] parallelizable decoders can be combined with many inner decoders, such as MWPM or union-find.", "features_transversal_gates": "Transversal Pauli gates exist and are based on non-trivial loops on surface. Transversal Clifford gates can be done on folded surface codes [J. E. Moussa, \u201cTransversal Clifford gates on folded surface codes\u201d, Physical Review A 94, (2016). DOI; 1603.02286]. ", "features_fault_tolerance": "Transversal (non-Clifford) CCZ gate by bringing 2D surface codes together and using just-in-time decoding [B. J. Brown, \u201cA fault-tolerant non-Clifford gate for the surface code in two dimensions\u201d, Science Advances 6, (2020). DOI; 1903.11634]. Gate can be simulated by taking 2D slices out of 3D surface codes [T. R. Scruby et al., \u201cNumerical Implementation of Just-In-Time Decoding in Novel Lattice Slices Through the Three-Dimensional Surface Code\u201d, Quantum 6, 721 (2022). DOI; 2012.08536].\nHomomorphic measurement protocols for arbitrary surface codes [Shilin Huang, Tomas Jochym-O'Connor, and Theodore J. Yoder, \u201cHomomorphic Logical Measurements\u201d. 2211.03625].", "name": "Kitaev surface code", "code_id": "surface", "realizations": "One cycle of syndrome readout on 19-qubit planar and 24-qubit toric codes realized in two-dimensional Rydberg atomic arrays [D. Bluvstein et al., \u201cA quantum processor based on coherent transport of entangled atom arrays\u201d, Nature 604, 451 (2022). DOI; 2112.03923]. \nSignatures of corresponding topological phase of matter detected in superconducting circuits [K. J. Satzinger et al., \u201cRealizing topologically ordered states on a quantum processor\u201d, Science 374, 1237 (2021). DOI; 2104.01180] and two-dimensional Rydberg atomic arrays [G. Semeghini et al., \u201cProbing topological spin liquids on a programmable quantum simulator\u201d, Science 374, 1242 (2021). DOI; 2104.04119]. ", "protection": "Toric code on an \\(L\\times L\\) torus is a \\([[2L^2,2,L]]\\) CSS code, and there exists a planar code with \\([[L^2,1,L]]\\) [C. Horsman et al., \u201cSurface code quantum computing by lattice surgery\u201d, New Journal of Physics 14, 123011 (2012). DOI; 1111.4022]. More generally, the code distance is related to the homology of the cellulation [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143].\n\nCoherent physical errors are expected to become incoherent logical errors after MWPM decoding; see corroborating numerical studies performed via the Majorana mapping [S. Bravyi et al., \u201cCorrecting coherent errors with surface codes\u201d, npj Quantum Information 4, (2018). DOI; 1710.02270] as well as analytical bounds [J. K. Iverson and J. Preskill, \u201cCoherence in logical quantum channels\u201d, New Journal of Physics 22, 073066 (2020). DOI; 1912.04319]. ", "notes": "Surfmap framework provides a way to stitch the surface code to various superconducting-circuit geometries by assigning each superconducting qubit to be either a physical or ancilla qubit, designing stabilizer measurement circuits, and scheduling stabilizer measurements [Anbang Wu et al., \u201cMapping Surface Code to Superconducting Quantum Processors\u201d. 2111.13729].\n2D and 3D surface code visualization tool. \nTutorials from error-correction perspective by J. Haah and condensed-matter perspective by M. Levin and C. Nayak. ", "physical": "qubits", "short_name": "", "introduced": "[A. Y. Kitaev, \u201cQuantum computations: algorithms and error correction\u201d, Russian Mathematical Surveys 52, 1191 (1997). DOI][A. Y. Kitaev, \u201cQuantum Error Correction with Imperfect Gates\u201d, Quantum Communication, Computing, and Measurement 181 (1997). DOI][A. Y. Kitaev, \u201cFault-tolerant quantum computation by anyons\u201d, Annals of Physics 303, 2 (2003). DOI; quant-ph/9707021] ", "description": "A family of abelian topological CSS stabilizer codes whose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a cellulation of a two-dimensional surface (with a qubit located at each edge of the cellulation). Toric code often either refers to the construction on the two-dimensional torus or is an alternative name for the general construction. The construction on surfaces with boundaries is often called the planar code [S. B. Bravyi and A. Yu. Kitaev, \u201cQuantum codes on a lattice with boundary\u201d. quant-ph/9811052].\n\nThe original construction can be naturally extended to arbitrary \\(D\\)-dimensional manifolds [\u201cZ2-systolic freedom and quantum codes\u201d, Mathematics of Quantum Computation 303 (2002). DOI][G. Z\u00e9mor, \u201cOn Cayley Graphs, Surface Codes, and the Limits of Homological Coding for Quantum Error Correction\u201d, Lecture Notes in Computer Science 259 (2009). DOI]. Given a cellulation, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers are associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\(i+1\\)-faces. Such extensions are often called the \\(D\\)-dimensional surface or \\(D\\)-dimensional toric codes.\n\nThe stabilizers of the surface code on the 2-dimensional torus are generated by star operators \\(A_v\\) and plaquette operators \\(B_p\\). Each star operator is a product of four Pauli-\\(X\\) operators on the edges adjacent to a vertex \\(v\\) of the lattice; each plaquette operator is a product of four Pauli-\\(Z\\) operators applied to the edges adjacent to a face, or plaquette, \\(p\\) of the lattice (Figure\u00a0I).\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n                  [/fig/d580bfd1b11ef8689fbb2b97ed51f625.svg]                   \n\nFigure\u00a0I: Stabilizer generators and logical operators of the 2D surface code on a torus. The star operators \\(A_v\\) and the plaquette operators \\(B_p\\) generate the stabilizer group of the toric code. The logical operators are strings that wrap around the torus.\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n\nThe two-dimensional toric code encodes two logical qubits. We denote by \\(\\overline{X}_i,\\overline{Z}_i\\) the logical Pauli-\\(X\\) and Pauli-\\(Z\\) operator of the \\(i\\)-th logical qubit. They can are represented by strings of Pauli-\\(X\\) operators or Pauli-\\(Z\\) operators that wrap around the torus as shown in Figure\u00a0I.", "parents_code_id": "css\nclifford-deformed_surface\ntopological_abelian", "parents_detail": "\nCDSC codes are deformations of the surface code via constant-depth Clifford circuits that may not be CSS.\nWhen treated as ground states of the code Hamiltonian, the code states realize \\(\\mathbb{Z}_2\\) topological order, a topological phase of matter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory [F. J. Wegner, \u201cDuality in Generalized Ising Models and Phase Transitions without Local Order Parameters\u201d, Journal of Mathematical Physics 12, 2259 (1971). DOI]. Codewords correspond to ground state of the code Hamiltonian, and error operators correspond to spontaneous creation and annihilation of pairs of charges or vortices. ", "parent_of_code_id": "fractal_surface\nhigher_dimensional_surface\nhyperbolic_surface\nreal_projective_plane\nstab_4_2_2", "parent_of_detail": "\n\n\n\n\\([[4,2,2]]\\) code is the smallest toric code.", "cousins_code_id": "hypergraph_product\nquantum_double\nstring_net\nmajorana_stab", "cousins_detail": "Planar (toric) code can be obtained from hypergraph product of two repetition (cyclic) codes ([A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928], Ex. 6).\nA quantum-double model with \\(G=\\mathbb{Z}_2\\) is the surface code.\nString-net model reduces to the surface code when the category is the group \\(\\mathbb{Z}_2\\).\nThe Majorana mapping can be used to construct efficient algorithms for simulating rounds of error correction for the surface code [S. Bravyi et al., \u201cCorrecting coherent errors with surface codes\u201d, npj Quantum Information 4, (2018). DOI; 1710.02270].", "cousin_of_code_id": "analog_surface\ncolor\ndouble_semion\ngalois_topological\nhaah_cubic\nheavy_hex\nhoneycomb\nlifted_product\nqudit_surface\nrbh\nsubsystem_surface\ntranslationally_invariant_stabilizer", "cousin_of_detail": "The analog surface code is an oscillator-into-oscillator version of the surface code.\nColor code is equivalent to surface code in several ways [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065][Arun B. Aloshious, Arjun Nitin Bhagoji, and Pradeep Kiran Sarvepalli, \u201cOn the Local Equivalence of 2D Color Codes and Surface Codes with Applications\u201d. 1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.\nThere is a logical basis for the toric and double-semion codes where each codeword is a superposition of states corresponding to all noncontractible loops of a particular homotopy type. The superposition is equal for the toric code, whereas some loops appear with a \\(-1\\) coefficient for the double semion.\nSurface code has been extended to Galois qudits.\nThe energy of any partial implementation of code 1 is proportional to the boundary length similar to the 4D toric code, which can potentially surpress the effects of thermal errors, but it is currently an open problem.\nSurface code stabilizers are used to measure the Z-type stabilizers of the code.\nMeasurement of each check operator of the honeycomb Floquet code involves two qubits and projects the state of the two qubits to a two-dimensional subspace, which we regard as an effective qubit. These effective qubits form a surface code on a hexagonal superlattice. Electric and magnetic operators on the embedded surface code correspond to outer logical operators of the Floquet code. In fact, outer logical operators transition back and forth from magnetic to electric surface code operators under the measurement dynamics. Inspired by this code, stabilizer measurement circuits consisting of two-body measurements have been designed for the surface code [R. Chao et al., \u201cOptimization of the surface code design for Majorana-based qubits\u201d, Quantum 4, 352 (2020). DOI; 2007.00307][Craig Gidney, \u201cA Pair Measurement Surface Code on Pentagons\u201d. 2206.12780].\nA lifted product code for the ring \\(R=\\mathbb{F}_2[x,y]/(x^L-1,y^L-1)\\) is the toric code.\nThe qudit surface code with \\(q=2\\) is the surface code.\nWithout symmetry protection, one of 2D boundaries of the cubic RBH code is effectively a 2D toric code.\n\nTranslation-invariant 2D qubit topological stabilizer codes are equivalent to several copies of the Kitaev surface code via a local constant-depth Clifford circuit [H. Bombin, G. Duclos-Cianci, and D. Poulin, \u201cUniversal topological phase of two-dimensional stabilizer codes\u201d, New Journal of Physics 14, 073048 (2012). DOI; 1103.4606][H. Bomb\u00edn, \u201cStructure of 2D Topological Stabilizer Codes\u201d, Communications in Mathematical Physics 327, 387 (2014). DOI; 1107.2707][J. Haah, \u201cAlgebraic Methods for Quantum Codes on Lattices\u201d, Revista Colombiana de Matem\u00e1ticas 50, 299 (2017). DOI; 1607.01387].", "_type": "ecc", "_page_id": "c_surface", "_href": "c/surface"}, "c_haar_random": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "The rate of the code is equal to the coherent information of the channel (i.e. the quantum channel capacity).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Haar-random code", "code_id": "haar_random", "realizations": "", "protection": "Random code achieve the capacity of any noisy quantum channel.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Peter W. Shor, The quantum channel capacity and coherent information, 2002 (obtained from the MSRI Workshop on Quantum Computation website).][P. Hayden et al., \u201cA Decoupling Approach to the Quantum Capacity\u201d, Open Systems &amp; Information Dynamics 15, 7 (2008). DOI; quant-ph/0702005][I. Devetak, \u201cThe private classical capacity and quantum capacity of a quantum channel\u201d. quant-ph/0304127][Rochus Klesse, \u201cA random-coding based proof for the quantum coding theorem\u201d. 0712.2558]", "description": "Haar-random codewords are generated in a process involving averaging over unitary operations distributed accoding to the Haar measure. Haar-random codes are used to prove statements about the capacity of a quantum channel to transmit quantum information [\u201cPreface to the Second Edition\u201d, Quantum Information Theory xi (2016). DOI; 1106.1445], but encoding and decoding in such \\(n\\)-qubit codes quickly becomes impractical as \\(n\\to\\infty\\).\n\nThere are different approaches to create Haar-random codewords. In the construction of Ref. [P. Hayden et al., \u201cA Decoupling Approach to the Quantum Capacity\u201d, Open Systems &amp; Information Dynamics 15, 7 (2008). DOI; quant-ph/0702005], codewords are produced by performing a unitarily covariant projective measurement on a typical subspace of a tensor-power state. Reference [P. Hayden et al., \u201cA Decoupling Approach to the Quantum Capacity\u201d, Open Systems &amp; Information Dynamics 15, 7 (2008). DOI; quant-ph/0702005] showed that the capacity of a noisy quantum channel can be achieved by encoding in such Haar-random codes. In particular, Haar-random codes achieve perfect transmission in the \\(n\\to\\infty\\)) limit by proving that the encoded information becomes decoupled from the environment. This is a necessary and sufficient condition for successful decoding since measurements of the environment should never reveal the encoded information [B. Schumacher and M. A. Nielsen, \u201cQuantum data processing and error correction\u201d, Physical Review A 54, 2629 (1996). DOI; quant-ph/9604022].\n\nIntuitively, coupling with the environment can be decreased by projecting the system onto a random codespace. The more qubits that are randomly discarded, the more the codespace is decoupled from the environment. One may ask what is the least amount of qubits that can be discarded, i.e. the largest remaining codespace, that still achieves decoupling. It can be shown through the decoupling inequality [M. Horodecki, J. Oppenheim, and A. Winter, \u201cQuantum State Merging and Negative Information\u201d, Communications in Mathematical Physics 269, 107 (2006). DOI; quant-ph/0512247] that the largest possible dimension of the random codespace that achieves arbitrarily large decoupling is exponential in the coherent information of the channel. Therefore, there exist codes that can transmit information with rate equal to the coherent information. Furthermore, these codes can be constructed with high probability by performing a Haar-random isometry embedding a \\(k\\)-dimensional logical subspace into an \\(n\\)-dimensional physical space, where \\(k/n\\) is equal to the coherent information. Such an isometry can be produced by QR decomposition of a Gaussian random matrix [G. W. Stewart, \u201cThe Efficient Generation of Random Orthogonal Matrices with an Application to Condition Estimators\u201d, SIAM Journal on Numerical Analysis 17, 403 (1980). DOI].", "parents_code_id": "random_circuit", "parents_detail": "", "cousins_code_id": "t-designs", "cousins_detail": "Approximating the random projections through \\(t\\)-designs is necessary in order to make the protocol practical. Replacing with random Clifford gates is especially convenient since the Clifford group forms a unitary 2-design and produces stabilizer codes.", "_type": "ecc", "_page_id": "c_haar_random", "_href": "c/haar_random"}, "c_crystalline_dynamic_gen": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Clifford quantum cellular automaton (CQCA) that preserves crystalline symmetry.", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Crystalline-circuit code", "code_id": "crystalline_dynamic_gen", "realizations": "", "protection": "The code protects against Pauli errors. The circuit composed of iSWAP and \\(R_X[\\pi/2]\\) gates on the square lattice is a \u201cgood scrambler\u201d with non-fractal operator spreading and thus behaves like a random circuit in that regard, motivating the use of contiguous code distance as a proxy for code distance.\n\nFor the \\(D_4\\) example above, the unit cell \\(a=2\\), and the initial product group is chosen to have code rate \\(1/2\\). The parameters of the code are \\([[n, n/2, d(t)]]\\), and the contiguous code distance [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983] grows linearly before saturating at \\(O(n)\\).\n\nSelecting the code defined by the stabilizer group at the time when the contiguous distance is maximized and subjecting it to random erasures, an optimal threshold of \\(1/4\\) is achieved for a subset of system sizes [N. Delfosse and G. Z\u00e9mor, \u201cLinear-time maximum likelihood decoding of surface codes over the quantum erasure channel\u201d, Physical Review Research 2, (2020). DOI; 1703.01517][M. J. Gullans et al., \u201cQuantum Coding with Low-Depth Random Circuits\u201d, Physical Review X 11, (2021). DOI; 2010.09775]. The subthreshold scaling is competitive with random codes, which obey the random matrix theory ansatz [M. J. Gullans et al., \u201cQuantum Coding with Low-Depth Random Circuits\u201d, Physical Review X 11, (2021). DOI; 2010.09775].", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Grace M. Sommers, David A. Huse, and Michael J. Gullans, \u201cCrystalline Quantum Circuits\u201d. 2210.10808]", "description": "Code dynamically generated by unitary Clifford circuits defined on a lattice with some crystalline symmetry. A notable example is the circuit defined on a rotated square lattice with vertices corresponding to iSWAP gates and edges decorated by \\(R_X[\\pi/2]\\), a single-qubit rotation by \\(\\pi/2\\) around the \\(X\\)-axis. This circuit is invariant under space-time translations by a unit cell \\((T, a)\\) and all transformations of the square lattice point group \\(D_4\\).\n\nThe input state to the circuit is taken to be a product stabilizer state with finite entropy density. If the input is translation-invariant, then this periodicity is preserved by the circuit at all later times, so the code is a quantum quasi-cyclic code with unit cell \\(a\\). The initial product state recurs after a time \\(\\tau(n)\\) that is linear in \\(n\\) for \\(n=a 2^k\\), but is thought to be exponential for generic \\(n\\). ", "parents_code_id": "dynamic_gen\nqubit_stabilizer\ntranslationally_invariant_stabilizer", "parents_detail": "\n\n", "parent_of_code_id": "floquet", "parent_of_detail": "Floquet codes are crystalline-circuit codes with non-commuting measurements in 2D.", "cousins_code_id": "random_circuit\nmonitored_random_circuits", "cousins_detail": "Crystalline-circuit codes can be thought of as random-circuit codes with symmetries.\nProjective measurements can be included in crystalline-circuit codes in a spacetime translation-invariant fashion, turning such codes into monitored crystalline-circuit codes. However, the unit cell of measurements must be large enough to avoid purification.", "_type": "ecc", "_page_id": "c_crystalline_dynamic_gen", "_href": "c/crystalline_dynamic_gen"}, "c_floquet_color": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Floquet color code", "code_id": "floquet_color", "realizations": "Plaquette stabilizer measurement realized on the IBM Falcon superconducting-qubit device [James R. Wootton, \u201cMeasurements of Floquet code plaquette stabilizers\u201d. 2210.13154]", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[B. Brown, \u201cAnyon condensation and the color code\u201d, (2022). DOI]", "description": "Stub. ", "parents_code_id": "floquet", "parents_detail": "", "cousins_code_id": "color", "cousins_detail": "", "_type": "ecc", "_page_id": "c_floquet_color", "_href": "c/floquet_color"}, "c_t-designs": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Random local circuit of depth proportional to \\(n^{\\alpha}\\), with \\(\\alpha\\) depending on system geometry.", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Local Haar-random circuit code", "code_id": "t-designs", "realizations": "", "protection": "In a 1D geometry, the code approximately detects any error with support on a segment of length \\(\\leq n/4\\), with deviations exponentially suppressed in \\(n\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[F. G. S. L. Brand\u00e3o, A. W. Harrow, and M. Horodecki, \u201cLocal Random Quantum Circuits are Approximate Polynomial-Designs\u201d, Communications in Mathematical Physics 346, 397 (2016). DOI]", "description": "An \\(n\\)-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal \\(n\\)-qubit states and acting with a random unitary circuit of depth polynomial in \\(n\\). Two states are locally indistinguishable if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about \\(n/2\\) two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries. The above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (\\(D=1\\), while codes for higher-dimensional geometries require \\(O(n^{1/D})\\)-depth circuits [F. G. S. L. Brand\u00e3o, A. W. Harrow, and M. Horodecki, \u201cLocal Random Quantum Circuits are Approximate Polynomial-Designs\u201d, Communications in Mathematical Physics 346, 397 (2016). DOI]. Follow-up work [M. J. Gullans et al., \u201cQuantum Coding with Low-Depth Random Circuits\u201d, Physical Review X 11, (2021). DOI; 2010.09775] revealed that optimal code properties require only \\(O(\\sqrt{n})\\)-depth circuits for that case, and \\(O(\\sqrt{n})\\)-depth circuits for a two-dimensional square-lattice geometry.", "parents_code_id": "random_circuit", "parents_detail": "", "cousins_code_id": "topological\napproximate_qecc", "cousins_detail": "Local Haar-random codewords, like topological codewords, are locally indistinguishable [F. G. S. L. Brand\u00e3o, A. W. Harrow, and M. Horodecki, \u201cLocal Random Quantum Circuits are Approximate Polynomial-Designs\u201d, Communications in Mathematical Physics 346, 397 (2016). DOI].\n", "cousin_of_code_id": "haar_random", "cousin_of_detail": "Approximating the random projections through \\(t\\)-designs is necessary in order to make the protocol practical. Replacing with random Clifford gates is especially convenient since the Clifford group forms a unitary 2-design and produces stabilizer codes.", "_type": "ecc", "_page_id": "c_t-designs", "_href": "c/t-designs"}, "c_floquet": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Floquet code", "code_id": "floquet", "realizations": "", "protection": "Protects against single-qubit Pauli noise and check operator measurement errors.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194]", "description": "Dynamically-generated stabilizer-based code whose logical qubits are generated through a particular sequence of check-operator measurements such that the number of logical qubits is larger than when the code is viewed as a static subsystem stabilizer code. After each measurement in the sequence, the codespace is a joint \\(+1\\) eigenspace of an instantaneous stabilizer group (ISG), i.e., a particular stabilizer group corresponding to the measurement. The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured in the next step in the sequence. As opposed to subsystem codes, only specific measurement sequences maintain the codespace. ", "parents_code_id": "crystalline_dynamic_gen", "parents_detail": "Floquet codes are crystalline-circuit codes with non-commuting measurements in 2D.", "parent_of_code_id": "floquet_color\nhoneycomb", "parent_of_detail": "\nThe honeycomb Floquet code is the first 2D Floquet code.", "cousins_code_id": "subsystem_stabilizer\nmonitored_random_circuits\nmajorana_stab", "cousins_detail": "This code can be viewed as a subsystem stabilizer code, albeit one with less logical qubits.\nBoth Floquet and monitored random circuit codes can have an instantaneous stabilizer group which evolves through unitary evolution and measurements. However, Floquet codewords are generated via a specific sequence of measurements, while random-circuit codes maintain a stabilizer group after any measurement. Floquet codes have the additional capability of detecting errors induced during the measurement process; see Appx. A of Ref. [M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].\nFloquet codes are viable candidates for storage in Majorana-qubit devices [Adam Paetznick et al., \u201cPerformance of planar Floquet codes with Majorana-based qubits\u201d. 2202.11829].", "_type": "ecc", "_page_id": "c_floquet", "_href": "c/floquet"}, "c_nonlocal_lowdepth": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Low-depth random Clifford-circuit code", "code_id": "nonlocal_lowdepth", "realizations": "", "protection": "Creates a random \\([[n,k,d]]\\) stabilizer code that detects errors on \\(d-1\\) qubits, and corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[W. Brown and O. Fawzi, \u201cShort random circuits define good quantum error correcting codes\u201d, 2013 IEEE International Symposium on Information Theory (2013). DOI; 1312.7646]", "description": "An encoder for an \\([[n,k]]\\) quantum error correcting code, is an \\(n\\)-qubit unitary transformation that takes a \\(k\\)-qubit state as input (with \\(k\\leq n\\), and the remaining \\(n-k\\) qubits initialized to \\(|0\\rangle^{\\otimes n-k}\\) ) to give a corresponding state in the codespace as the output. An n-qubit quantum circuit with random 2-qubit Clifford gates can act as an encoder into a code with distance \\(d\\) with high probability, with a size (i.e. number of gates in the circuit) at most \\(O(n^2 log n)\\)). Noting that two gates acting on disjoint qubits could in fact be executed simultaneously, this is equivalent to the depth (number of time steps in the circuit) being at most \\(O(log^3 n)\\).", "parents_code_id": "random_circuit", "parents_detail": "", "_type": "ecc", "_page_id": "c_nonlocal_lowdepth", "_href": "c/nonlocal_lowdepth"}, "c_honeycomb": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "There are two types of logical operators, inner and outer. An inner logical operator is the product of check operators on a homologically nontrivial cycle. They belong to the stabilizer group as a subsystem code. Outer logical operators have an interpretation in terms of magnetic and electric operators of an embedded surface code, and they do not belong to the stabilizer group of the associated subsystem code.", "features_threshold": "\\(0.2\\%-0.3\\%\\) in a controlled-not circuit model with a correlated minimum-weight perfect-matching decoder [C. Gidney et al., \u201cA Fault-Tolerant Honeycomb Memory\u201d, Quantum 5, 605 (2021). DOI; 2108.10457].\n\\(1.5\\%<p<2.0\\%\\) in a circuit model with native two-body measurements and a correlated minimum-weight perfect-matching decoder [C. Gidney et al., \u201cA Fault-Tolerant Honeycomb Memory\u201d, Quantum 5, 605 (2021). DOI; 2108.10457]. Here, \\(p\\) is the collective error rate of the two-body measurement gate, including both measurement and correlated data depolarization error processes.\nAgainst circuit-level noise: within \\(0.2\\% \u2212 0.3\\%\\) for SD6 (standard depolarizing 6-step cycle), \\(0.1\\% \u2212 0.15\\%\\) for SI1000 (superconducting-inspired 1000 ns cycle), and \\(1.5\\% \u2212 2.0\\%\\) for EM3 (entangling-measurement 3-step cycle) [Craig Gidney, Michael Newman, and Matt McEwen, \u201cBenchmarking the Planar Honeycomb Code\u201d. 2202.11845][Adam Paetznick et al., \u201cPerformance of planar Floquet codes with Majorana-based qubits\u201d. 2202.11829].", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Initialization can be performed by preparing each pair of qubits on an edge in some particular state independently specified by the effective-one-qubit operators (two-qubit Pauli strings centered on an edge) and then beginning the check measurement sequence. This is analogous to projecting a state into the code space by measuring stabilizers.", "features_decoders": "The ISG has a static subgroup for all time steps \\(r\\geq 3\\) \u2013 that is, a subgroup which remains a subgroup of the ISG for all future times \u2013 given by so-called plaquette stabilizers. These are stabilizers consisting of products of check operators around homologically trivial paths. The syndrome bits correspond to the eigenvalues of the plaquette stabilizers. Because of the structure of the check operators, only one-third of all plaquettes are measured each round. The syndrome bits must therefore be represented by a lattice in spacetime, to reflect when and where the outcome was obtained.", "features_transversal_gates": "", "features_fault_tolerance": "One can run a fault-tolerant decoding algorithm by (1) bipartitioning the syndrome lattice into two graphs which are congruent to the Cayley graph of the free abelian group with three generators (up to boundary conditions) and (2) performing a matching algorithm to deduce errors.", "name": "Honeycomb Floquet code", "code_id": "honeycomb", "realizations": "Plaquette stabilizer measurement realized on the IBM Falcon superconducting-qubit device [James R. Wootton, \u201cMeasurements of Floquet code plaquette stabilizers\u201d. 2210.13154]", "protection": "Protective features similar to the surface code: on a torus geometry, the code protects two logical qubits with a code distance proportional to the linear size of the torus. Properties of the code with open boundaries are discussed in Refs. [J. Haah and M. B. Hastings, \u201cBoundaries for the Honeycomb Code\u201d, Quantum 6, 693 (2022). DOI; 2110.09545][Christophe Vuillot, \u201cPlanar Floquet Codes\u201d. 2110.05348], and various other generalizations have been proposed [D. Aasen, Z. Wang, and M. B. Hastings, \u201cAdiabatic paths of Hamiltonians, symmetries of topological order, and automorphism codes\u201d, Physical Review B 106, (2022). DOI; 2203.11137].", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194]", "description": "Floquet code inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438] whose logical qubits are generated through a particular sequence of measurements.\n\nThe code is defined on a hexagonal (honeycomb) lattice with a physical qubit located at each vertex. Edges are labeled \\(x\\), \\(y\\), and \\(z\\), such that one edge of each label meet at every vertex. Check operators are defined as \\(XX\\) acting on any two qubits joined by an \\(x\\) edge, and similarly for \\(y\\) and \\(z\\). The hexagonal lattice is 3-colorable, so the hexagons may be labeled 0, 1, 2 such that no two neighboring hexagons have the same label.\n\nThe code-generating measurement pattern consists of measuring the check operators located on all of the \\(r\\)-labeled edges in round \\(r\\) mod 3. The code space is the \\(+1\\) eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured.\n\nA CSS version of the code has been proposed which loosens the restriction of which sequences to use [Margarita Davydova, Nathanan Tantivasadakarn, and Shankar Balasubramanian, \u201cFloquet codes without parent subsystem codes\u201d. 2210.02468].", "parents_code_id": "floquet", "parents_detail": "The honeycomb Floquet code is the first 2D Floquet code.", "cousins_code_id": "surface\nsubsystem_color\nmajorana_stab\nmatching\nqldpc", "cousins_detail": "Measurement of each check operator of the honeycomb Floquet code involves two qubits and projects the state of the two qubits to a two-dimensional subspace, which we regard as an effective qubit. These effective qubits form a surface code on a hexagonal superlattice. Electric and magnetic operators on the embedded surface code correspond to outer logical operators of the Floquet code. In fact, outer logical operators transition back and forth from magnetic to electric surface code operators under the measurement dynamics. Inspired by this code, stabilizer measurement circuits consisting of two-body measurements have been designed for the surface code [R. Chao et al., \u201cOptimization of the surface code design for Majorana-based qubits\u201d, Quantum 4, 352 (2020). DOI; 2007.00307][Craig Gidney, \u201cA Pair Measurement Surface Code on Pentagons\u201d. 2206.12780].\nBoth honeycomb and subsystem color codes are generated via periodic sequences of measurements. However, any measurement sequence can be performed on the color code without destroying the logical qubits, while honeycomb codes can be maintained only with specific sequences. Honeycomb codes require a shorter measurement cycle and use fewer qubits at the given code distance [M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].\nThe Honeycomb code admits a representation in terms of Majorana fermions. This leads to a possible physical realization of the code in terms of tetrons [T. Karzig et al., \u201cScalable designs for quasiparticle-poisoning-protected topological quantum computation with Majorana zero modes\u201d, Physical Review B 95, (2017). DOI; 1610.05289], where each physical qubit is composed of four Majorana modes.\nMatching and honeycomb codes are both inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438].\nThe Floquet check operators are weight-two, and each qubit participates in one check each round.", "_type": "ecc", "_page_id": "c_honeycomb", "_href": "c/honeycomb"}, "c_monitored_random_circuits": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "Above the critical measurement rate \\( p_c\\), the natural error correction properties of the circuit can no longer protect the information. This can be interpreted as the code threshold.\nThese dynamically generated codes saturate the trade off between density of encoded information and the error rate threshold [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]", "features_rate": "Rate can be finite [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195], depending on the family of random codes generated by the circuit.", "features_magic_scaling_exponent": "", "features_encoders": "The dynamics of the monitored random circuit can be recast in the language of stabilizer codes [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]. The stabilizer group of the error-correcting code resulting from a monitored Clifford circuit either grows or shrinks with each time step, depending on which projective measurements were performed during the time step.\nOne can construct optimal single-copy encoding operations for strong purification transitions [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]", "features_decoders": "The recovery operation is the reverse unitary transformation with access to the measurement record (for dynamically generated codes with a strong purification transition) [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Monitored random-circuit code", "code_id": "monitored_random_circuits", "realizations": "Measurement induced quantum phases have been realized in a trapped-ion processor [C. Noel et al., \u201cMeasurement-induced quantum phases realized in a trapped-ion quantum computer\u201d, Nature Physics 18, 760 (2022). DOI; 2106.05881].", "protection": "When in the volume-law phase, protects against random projective measurements at a rate \\( p < p_c \\). While the true code distance is not known, it is conjectured to be proportional to the contiguous distance. As first described in Ref. [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195], the contiguous distance for these circuits is defined with respect to all partitions of the system.", "notes": "Connections to information scrambling in black hole physics, as introduced in Section 11 of [S. Choi et al., \u201cQuantum Error Correction in Scrambling Dynamics and Measurement-Induced Phase Transition\u201d, Physical Review Letters 125, (2020). DOI; 1903.05124]. In particular, monitored random circuits can be viewed as the Hayden-Preskill recovery problem [B. Yoshida, \u201cSoft mode and interior operator in the Hayden-Preskill thought experiment\u201d, Physical Review D 100, (2019). DOI] running backwards in time. In this setting, the volume-law entanglement phase of the monitored circuit describes the phase when information can be recovered from an old black hole (ie, a black hole that is maximally entangled with the early universe).\nMapping monitored random circuits to statistical mechanics models can help estimate thresholds and code distances for these systems [Y. Li and M. P. A. Fisher, \u201cStatistical mechanics of quantum error correcting codes\u201d, Physical Review B 103, (2021). DOI; 2007.03822].", "physical": "groups", "short_name": "", "introduced": "[B. Skinner, J. Ruhman, and A. Nahum, \u201cMeasurement-Induced Phase Transitions in the Dynamics of Entanglement\u201d, Physical Review X 9, (2019). DOI][Y. Li, X. Chen, and M. P. A. Fisher, \u201cQuantum Zeno effect and the many-body entanglement transition\u201d, Physical Review B 98, (2018). DOI][A. Chan et al., \u201cUnitary-projective entanglement dynamics\u201d, Physical Review B 99, (2019). DOI; 1808.05949]", "description": "Error-correcting code arising from a monitored random circuit. Such a circuit is described by a series of intermittant random local projective Pauli measurements with random unitary time-evolution operators. An important sub-family consists of Clifford monitored random circuits, where unitaries are sampled from the Clifford group [Y. Li, X. Chen, and M. P. A. Fisher, \u201cMeasurement-driven entanglement transition in hybrid quantum circuits\u201d, Physical Review B 100, (2019). DOI; 1901.08092]. When the rate of projective measurements is independently controlled by a probability parameter \\(p\\), there can exist two stable phases, one described by volume-law entanglement entropy and the other by area-law entanglement entropy. The phases and their transition can be understood from the perspective of quantum error correction, information scrambling, and channel capacities [S. Choi et al., \u201cQuantum Error Correction in Scrambling Dynamics and Measurement-Induced Phase Transition\u201d, Physical Review Letters 125, (2020). DOI; 1903.05124][M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195].\n\nMonitored random circuits have a finite information capacity that decays exponentially with respect to system size [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]. When \\( p = 0 \\), the random circuit achieves channel capacity, meaning that it stores the most amount of information possible. This notion quantifies the recoverability of information and the reversability of the system under the monitored random dynamics. In the volume-law phase (\\( p < p_c \\) for some critical probability \\(p_c\\)), the channel capacity remains non-zero, and the monitored channel projects an initial state into a random error-correcting code [M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195]. With appropriately chosen evolution operators and measurements, the code is a stabilizer code whose parameters depend on time, \\( [[n,k(t),d(t)]] \\). A similar notion applies to Haar random circuits with measurements [A. Zabalo et al., \u201cCritical properties of the measurement-induced transition in random quantum circuits\u201d, Physical Review B 101, (2020). DOI; 1911.00008]. ", "parents_code_id": "random_circuit", "parents_detail": "Monitored random circuits are random circuits where projective measurements are interspersed throughout the circuit and measurement results are recorded.", "cousins_code_id": "topological", "cousins_detail": "Topological order can be generated in 2D monitored random circuits [A. Lavasani, Y. Alavirad, and M. Barkeshli, \u201cTopological Order and Criticality in <mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mo stretchy=\"false\">(</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy=\"false\">)</mml:mo><mml:mi mathvariant=\"normal\">D</mml:mi></mml:mrow></mml:math> Monitored Random Quantum Circuits\u201d, Physical Review Letters 127, (2021). DOI; 2011.06595].", "cousin_of_code_id": "crystalline_dynamic_gen\nfloquet", "cousin_of_detail": "Projective measurements can be included in crystalline-circuit codes in a spacetime translation-invariant fashion, turning such codes into monitored crystalline-circuit codes. However, the unit cell of measurements must be large enough to avoid purification.\nBoth Floquet and monitored random circuit codes can have an instantaneous stabilizer group which evolves through unitary evolution and measurements. However, Floquet codewords are generated via a specific sequence of measurements, while random-circuit codes maintain a stabilizer group after any measurement. Floquet codes have the additional capability of detecting errors induced during the measurement process; see Appx. A of Ref. [M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].", "_type": "ecc", "_page_id": "c_monitored_random_circuits", "_href": "c/monitored_random_circuits"}, "c_quantum_divisible": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "The \\([[2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), 3]]\\) quantum divisible code family can serve as outer codes of either the five-qubit \\([[5,1,3]]\\) or Steane \\([[7,1,3]]\\) code to realize a \\(T\\) gate on the inner code. For example, when \\(m=5\\) (\\(m=6\\)), the resulting \\([[31,5,3]]\\) (\\([[63,7,3]]\\)) code yields the \\(T\\) gate on the inner five-qubit (Steane) code.", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "The \\(T\\) gate realized by concatenating members of the \\([[2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), 3]]\\) quantum divisible code family with either the five-qubit \\([[5,1,3]]\\) or Steane \\([[7,1,3]]\\) code is fault-tolerant and does not require magic-state distillation. The gate is performed on the inner five-qubit/Steane code and does require encoding and decoding algorithms to pass between the inner and outer codes.", "name": "Quantum divisible code", "code_id": "quantum_divisible", "realizations": "", "protection": "Distance \\(d\\) is upper bounded by the two classical codes that determine the CSS code.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Jingzhen Hu, Qingzhong Liang, and Robert Calderbank, \u201cDivisible Codes for Quantum Computation\u201d. 2204.13176]", "description": "Consider a CSS code whose \\(Z\\)-stabilizers are determined by the dual of a classical \\([n, k_1]\\) linear binary code \\(C_1\\), and whose \\(X\\)-stabilizers are determined by a classical \\([n, k_2]\\) binary code \\(C_2 \\subset C_1\\). This code is quantum divisible if all weights in \\(C_2\\) share a common divisor \\(\\Delta > 1\\), and all weights in each coset of \\(C_2\\) in \\(C_1\\) are congruent to \\(\\Delta\\).\n\nFor example, if \\(C_2\\) is the first-order Reed-Muller code, and \\(C_1/ C_2\\) consists of quadratic forms with a bounded rank, then \\([[n = 2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), d = 3]]\\) is a family of quantum divisible codes. ", "parents_code_id": "css", "parents_detail": "", "cousins_code_id": "divisible\nreed_muller\nquantum_reed_muller\nquantum_triorthogonal\nquantum_concatenated\nstab_5_1_3\nsteane", "cousins_detail": "Quantum divisible codes are constructed via the CSS construction using a divisible linear binary code.\nQuantum divisible codes can be constructed out of first-order RM codes.\nQuantum RM codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions.\nTriorthogonal codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions.\nA fault-tolerant \\(T\\) gate on the five-qubit or Steane code can be obtained by concatenating with particular quantum divisible codes.\nA fault-tolerant \\(T\\) gate on the five-qubit code can be obtained by concatenating with particular quantum divisible codes.\nA fault-tolerant \\(T\\) gate on the Steane code can be obtained by concatenating with particular quantum divisible codes.", "_type": "ecc", "_page_id": "c_quantum_divisible", "_href": "c/quantum_divisible"}, "c_quantum_hamming": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "Concatenations of Hamming codes yield fault-tolerant quantum computation with constant space and quasi-polylogarithmic time overheads [Hayata Yamasaki and Masato Koashi, \u201cTime-Efficient Constant-Space-Overhead Fault-Tolerant Quantum Computation\u201d. 2207.08826].", "name": "\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming code", "code_id": "quantum_hamming", "realizations": "", "protection": "Protects against any single qubit error.", "notes": "", "physical": "qubits", "short_name": "\\([[2^r, 2^r-r-2, 3]]\\)", "introduced": "[D. Gottesman, \u201cClass of quantum error-correcting codes saturating the quantum Hamming bound\u201d, Physical Review A 54, 1862 (1996). DOI; quant-ph/9604038]", "description": "A family of stabilizer codes of distance \\(3\\) that asymptotically saturate quantum Hamming bound.", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "cousins_code_id": "quantum_perfect", "cousins_detail": "Quantum Hamming codes saturate the asymptotic Hamming bound.", "cousin_of_code_id": "hamming", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_quantum_hamming", "_href": "c/quantum_hamming"}, "c_diagonal_clifford": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "\\(Z\\)-rotation by angle \\(-\\pi/2^{r-1}\\) [B. Zeng et al., \u201cLocal unitary versus local Clifford equivalence of stabilizer and graph states\u201d, Physical Review A 75, (2007). DOI; quant-ph/0611214].", "features_fault_tolerance": "", "name": "\\([[2^r-1, 1, 3]]\\) quantum Reed-Muller code", "code_id": "diagonal_clifford", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "\\([[2^r-1, 1, 3]]\\)", "introduced": "[D. Gottesman and I. L. Chuang, \u201cDemonstrating the viability of universal quantum computation using teleportation and single-qubit operations\u201d, Nature 402, 390 (1999). DOI; quant-ph/9908010][B. Zeng et al., \u201cLocal unitary versus local Clifford equivalence of stabilizer and graph states\u201d, Physical Review A 75, (2007). DOI; quant-ph/0611214]", "description": "Member of CSS code family constructed with a first-order punctured RM\\((1,r)\\) \\([2^r-1,r+1,2^{r-1}-1]\\) code and its even subcode for \\(r \\geq 3\\). Each code transversally implements a member of an infinite family of diagonal gates from the Clifford hierarchy [S. X. Cui, D. Gottesman, and A. Krishna, \u201cDiagonal gates in the Clifford hierarchy\u201d, Physical Review A 95, (2017). DOI; 1608.06596].", "parents_code_id": "quantum_reed_muller", "parents_detail": "", "parent_of_code_id": "stab_15_1_3\nsteane", "parent_of_detail": "\nSteane code is the smallest member of a family of Reed-Muller-based CSS codes.", "_type": "ecc", "_page_id": "c_diagonal_clifford", "_href": "c/diagonal_clifford"}, "c_quantum_hamming_css": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "Syndrome measurement can be done with two ancillary flag qubits [R. Chao and B. W. Reichardt, \u201cQuantum Error Correction with Only Two Extra Qubits\u201d, Physical Review Letters 121, (2018). DOI; 1705.02329].", "name": "\\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS code", "code_id": "quantum_hamming_css", "realizations": "", "protection": "Protects against any single qubit error.", "notes": "", "physical": "qubits", "short_name": "\\([[2^r-1, 2^r-2r-1, 3]]\\)", "introduced": "", "description": "A Hamming-based CSS code is a CCS code constructed with a classical Hamming code \\([2^r-1,2^r-1-r,3]=C_X=C_Z\\) a.k.a. a first-order punctured Reed-Muller code RM\\((r-2,r)\\).", "parents_code_id": "quantum_reed_muller", "parents_detail": "\\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS codes are quantum Reed-Muller codes because they are formed from classical Hamming codes, which are equivalent to RM\\((r-2,r)\\).", "parent_of_code_id": "steane", "parent_of_detail": "Steane code is the smallest member of a family of Hamming-based CSS codes.", "cousins_code_id": "hamming", "cousins_detail": "Quantum Hamming codes result from applying the CSS construction to Hamming codes.", "cousin_of_code_id": "qudit_hamming_css", "cousin_of_detail": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) codes are prime-qudit extensions of \\([[2^r-1, 2^r-2r-1, 3]]\\) codes.", "_type": "ecc", "_page_id": "c_quantum_hamming_css", "_href": "c/quantum_hamming_css"}, "c_tfim": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "1D geometrically local constant-depth brickwork circuit of nearest-neighbor gates on alternating even and odd bonds. Gates are generated by interaction terms of the transverse-field Ising Hamiltonian.", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Transverse-field Ising model (TFIM) code", "code_id": "tfim", "realizations": "", "protection": "Code distance is 1 for open boundary conditions similar to a repetition code, and 3 for periodic boundary conditions with an encoding circuit depth of 4.", "notes": "", "physical": "qubits", "short_name": "TFIM", "introduced": "[Y. Hong et al., \u201cQuantum error correction in a time-dependent transverse-field Ising model\u201d, Physical Review A 106, (2022). DOI; 2205.12998]", "description": "A 1D translationally invariant stabilizer code whose encoding is a constant-depth circuit of nearest-neighbor gates on alternating even and odd bonds that consist of transverse-field Ising Hamiltonian interactions. The code allows for perfect state transfer of arbitrary distance using local operations and classical communications (LOCC).", "parents_code_id": "qubit_stabilizer\ntranslationally_invariant_stabilizer", "parents_detail": "\n", "cousins_code_id": "majorana_stab\nquantum_repetition", "cousins_detail": "The TFIM code stabilizers can be expressed in terms of Majorana operators.\nWhen written in the computational basis, the phase-flip and TFIM codewords are superpositions of qubit states of fixed total parity. The superposition is equal for the phase-flip code, whereas some states appear with a \\(-1\\) coefficient for TFIM code. However, the TFIM code can be encoded in constant depth.", "_type": "ecc", "_page_id": "c_tfim", "_href": "c/tfim"}, "c_quantum_h": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "The H codes can be used for high-quality and high-efficiency magic-state distillation [C. Jones, \u201cMultilevel distillation of magic states for quantum computing\u201d, Physical Review A 87, (2013). DOI; 1210.3388]. Their associated multi-level magic states protocols have an efficency advantage over the 10-to-2 and 15-to-1 protocals for output error below \\(10^{-7}\\).", "features_threshold": "", "features_rate": "The H codes are dense, i.e., the rate \\(\\frac{k}{k+4}\\rightarrow 1\\) as \\(k \\rightarrow \\infty\\). The distance is 2. However an \\(r\\)-level concatenation of H codes gives a distance of \\(2^r\\).", "features_magic_scaling_exponent": "A total of \\(r\\) rounds of magic-state distillation yields a magic-state scaling exponent \\(\\gamma\\to 1\\) as \\(k,r\\rightarrow \\infty\\). This matches a conjectured bound for \\(\\gamma\\) [S. Bravyi and J. Haah, \u201cMagic-state distillation with low overhead\u201d, Physical Review A 86, (2012). DOI; 1209.2426].", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "Hadamard and \\(TXT^{\\dagger}\\) gates, with the latter Clifford-equivalent to Hadamard, and where \\(T=\\exp(i\\pi(I-Z)/8)\\) is the \\(\\pi/8\\)-rotation gate.", "features_fault_tolerance": "", "name": "H code", "code_id": "quantum_h", "realizations": "", "protection": "Detects weight-1 Pauli errors. The \\(r\\)-level contatenated H code detects weight Pauli errors up to weight \\(2^r-1\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[C. Jones, \u201cMultilevel distillation of magic states for quantum computing\u201d, Physical Review A 87, (2013). DOI; 1210.3388]", "description": "Family of \\([[k+4,k,2]]\\) CSS codes with transversal Hadamard gates; relevant to magic state distillation. Four stablizer generators are \\(X_1X_2X_3X_4\\), \\(Z_1Z_2Z_3Z_4\\), \\(X_1X_2X_5X_6...X_{k+4}\\), and \\(Z_1Z_2Z_5Z_6...Z_{k+4}\\).", "parents_code_id": "css", "parents_detail": "", "_type": "ecc", "_page_id": "c_quantum_h", "_href": "c/quantum_h"}, "c_quantum_repetition": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Toffoli magic-state preparation protocol [C. Chamberland et al., \u201cBuilding a Fault-Tolerant Quantum Computer Using Concatenated Cat Codes\u201d, PRX Quantum 3, (2022). DOI; 2012.04108].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Lindbladian-based dissipative encoding passively protecting against bit flips [C. Ahn, A. C. Doherty, and A. J. Landahl, \u201cContinuous quantum error correction via quantum feedback control\u201d, Physical Review A 65, (2002). DOI; quant-ph/0110111][F. Reiter et al., \u201cDissipative quantum error correction and application to quantum sensing with trapped ions\u201d, Nature Communications 8, (2017). DOI; 1702.08673].", "features_decoders": "Automaton-like decoders for the repetition code on a 2D lattice, otherwise known as the classical 2D Ising model, were developed by Toom [A. L. Toom, \u201cNonergodic Multidimensional System of Automata\u201d, Probl. Peredachi Inf., 10:3 (1974), 70\u201379; Problems Inform. Transmission, 10:3 (1974), 239\u2013246][L. F. Gray, \u201cToom\u2019s Stability Theorem in Continuous Time\u201d, Perplexing Problems in Probability 331 (1999). DOI]. An automaton by Gacs yields a decoder for a 1D lattice [P. G\u00e1cs, \u201c[]\u201d, Journal of Statistical Physics 103, 45 (2001). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "Toffoli magic-state preparation protocol [C. Chamberland et al., \u201cBuilding a Fault-Tolerant Quantum Computer Using Concatenated Cat Codes\u201d, PRX Quantum 3, (2022). DOI; 2012.04108].", "name": "Quantum repetition code", "code_id": "quantum_repetition", "realizations": "NMR: 3-qubit phase-flip code [D. G. Cory et al., \u201cExperimental Quantum Error Correction\u201d, Physical Review Letters 81, 2152 (1998). DOI; quant-ph/9802018][O. Moussa et al., \u201cDemonstration of Sufficient Control for Two Rounds of Quantum Error Correction in a Solid State Ensemble Quantum Information Processor\u201d, Physical Review Letters 107, (2011). DOI; 1108.4842], with up to two rounds of error correction in liquid-state NMR [J. Zhang et al., \u201cExperimental quantum error correction with high fidelity\u201d, Physical Review A 84, (2011). DOI; 1109.4821].\nSuperconducting circuits: 3-qubit phase-flip and bit-flip code by Schoelkopf group [M. D. Reed et al., \u201cRealization of three-qubit quantum error correction with superconducting circuits\u201d, Nature 482, 382 (2012). DOI; 1109.4948]; 3-qubit bit-flip code [D. Rist\u00e8 et al., \u201cDetecting bit-flip errors in a logical qubit using stabilizer measurements\u201d, Nature Communications 6, (2015). DOI; 1411.5542]; 3-qubit phase-flip code up to 3 cycles of error correction [J. Cramer et al., \u201cRepeated quantum error correction on a continuously encoded qubit by real-time feedback\u201d, Nature Communications 7, (2016). DOI; 1508.01388]; IBM 15-qubit device [J. R. Wootton and D. Loss, \u201cRepetition code of 15 qubits\u201d, Physical Review A 97, (2018). DOI; 1709.00990]; IBM Rochester device using 43-qubit code [J. R. Wootton, \u201cBenchmarking near-term devices with quantum error correction\u201d, Quantum Science and Technology 5, 044004 (2020). DOI; 2004.11037]; Google system performing up to 8 error-correction cycles on 5 and 9 qubits [J. Kelly et al., \u201cState preservation by repetitive error detection in a superconducting quantum circuit\u201d, Nature 519, 66 (2015). DOI; 1411.7403]; Google Quantum AI Sycamore utilizing up to 11 physical qubits and running 50 correction rounds [Google Quantum AI et al., \u201cExponential suppression of bit or phase errors with cyclic error correction\u201d, Nature 595, 383 (2021). DOI; 2102.06132]; Google Quantum AI Sycamore utilizing up to 25 qubits for comparison of logical error scaling with a quantum code [Rajeev Acharya et al., \u201cSuppressing quantum errors by scaling a surface code logical qubit\u201d. 2207.06431] (see also [Kevin C. Miao et al., \u201cOvercoming leakage in scalable quantum error correction\u201d. 2211.04728]).\nContinuous error correction protocols have been implemented on a 3-qubit superconducting qubit device [W. P. Livingston et al., \u201cExperimental demonstration of continuous quantum error correction\u201d, Nature Communications 13, (2022). DOI; 2107.11398].\nSemiconductor spin-qubit devices: 3-qubit devices at RIKEN [K. Takeda et al., \u201cQuantum error correction with silicon spin qubits\u201d, Nature 608, 682 (2022). DOI; 2201.08581] and Delft [F. van Riggelen et al., \u201cPhase flip code with semiconductor spin qubits\u201d. 2202.11530].\nNitrogen-vacancy centers in diamond: 3-qubit phase-flip code [G. Waldherr et al., \u201cQuantum error correction in a solid-state hybrid spin register\u201d, Nature 506, 204 (2014). DOI; 1309.6424][T. Nakazato et al., \u201cQuantum error correction of spin quantum memories in diamond under a zero magnetic field\u201d, Communications Physics 5, (2022). DOI] (see also Ref. [T. H. Taminiau et al., \u201cUniversal control and error correction in multi-qubit spin registers in diamond\u201d, Nature Nanotechnology 9, 171 (2014). DOI; 1309.5452]).\nTrapped-ion device: 3-qubit phase-flip algorithm implemented in 3 cycles on high fidelity gate operations [P. Schindler et al., \u201cExperimental Repetitive Quantum Error Correction\u201d, Science 332, 1059 (2011). DOI].", "protection": "Bit-flip code detects bit-flip errors \\(X\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any phase-flip errors \\(Z\\). Phase-flip code detects phase-flip errors \\(Z\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any bit-flip errors \\(X\\). Because they protect against only one type of noise, both codes can be thought of as a classical \\([n,1,d]\\) repetition code with classical distance \\(d=\\left\\lfloor (n-1)/2\\right\\rfloor\\) embedded in a quantum system.", "notes": "Repetition codes can be used to benchmark device performance [Teague Tomesh et al., \u201cSupermarQ: A Scalable Quantum Benchmark Suite\u201d. 2202.11045].", "physical": "qubits", "short_name": "", "introduced": "[A. Peres, \u201cReversible logic and quantum computers\u201d, Physical Review A 32, 3266 (1985). DOI]", "description": "Encodes \\(1\\) qubit into \\(n\\) qubits according to \\(|0\\rangle\\to|\\phi_0\\rangle^{\\otimes n}\\) and \\(|1\\rangle\\to|\\phi_1\\rangle^{\\otimes n}\\). Also known as a bit-flip code when \\(|\\phi_i\\rangle = |i\\rangle\\), and a phase-flip code when \\(|\\phi_0\\rangle = |+\\rangle\\) and \\(|\\phi_1\\rangle = |-\\rangle\\).\n\nThe \\(\\pm\\)-basis codewords for the bit-flip code are GHz (a.k.a. cat) states \\(|0\\rangle^{\\otimes n}\\pm|1\\rangle^{\\otimes n}\\). These are ground states of the one-dimensional classical Ising model Hamiltonian \\(H=\\sum_{i} Z_{i}Z_{i+1}\\).\n\nThe \\(\\pm\\)-basis codewords for the phase-flip code are expanded in the computational basis as \\begin{align}\n  \\begin{split}\n    |\\overline{+}\\rangle =\\frac{1}{\\sqrt{2^{n-1}}}\\sum_{\\sum_{i}v_{i}=0}|v_{1},\\cdots,v_{n}\\rangle~{\\phantom{,}}\\\\\n    |\\overline{-}\\rangle =\\frac{1}{\\sqrt{2^{n-1}}}\\sum_{\\sum_{i}v_{i}=1}|v_{1},\\cdots,v_{n}\\rangle~,\n  \\end{split}\n\\end{align} showing that the phase-flip code stores information in the total parity of the qubits.", "parents_code_id": "quantum_parity", "parents_detail": "A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) QPC is a concatenation of a \\(m_1\\) bit-flip and a \\(m_2\\) phase-flip repetition codes, reducing to a repetition code when \\(m_1\\) or \\(m_2\\) is one.", "cousins_code_id": "hamiltonian", "cousins_detail": "Bit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions.", "cousin_of_code_id": "gnu_permutation_invariant\nrepetition\nself_correct\ntfim\nvery-small-logical-qubit\nshor_nine", "cousin_of_detail": "GNU codewords for \\(g=1\\) reduce to the phase-flip code.\n\nThe bit-flip repetition code associated with the 2D classical Ising model is a self-correcting classical memory [B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643; Sec. V.A].\nWhen written in the computational basis, the phase-flip and TFIM codewords are superpositions of qubit states of fixed total parity. The superposition is equal for the phase-flip code, whereas some states appear with a \\(-1\\) coefficient for TFIM code. However, the TFIM code can be encoded in constant depth.\nParts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss.\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.", "_type": "ecc", "_page_id": "c_quantum_repetition", "_href": "c/quantum_repetition"}, "c_stab_4_2_2": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "Transversal Pauli, Hadamard, and two-qubit \\(R\\) gates [Daniel Gottesman, \u201cQuantum fault tolerance in small experiments\u201d. 1610.03507].", "features_fault_tolerance": "Preparation of certain states along with transversal gates can be performed fault-tolerantly, but requires post-selection because the code cannot correct errors [Daniel Gottesman, \u201cQuantum fault tolerance in small experiments\u201d. 1610.03507].", "name": "\\([[4,2,2]]\\) CSS code", "code_id": "stab_4_2_2", "realizations": "\\([[4,1,2]]\\) subcode implemented using four-qubit graph state of photons [B. A. Bell et al., \u201cExperimental demonstration of a graph state quantum error-correction code\u201d, Nature Communications 5, (2014). DOI; 1404.5498]. \nTrapped-ion device by IonQ [N. M. Linke et al., \u201cFault-tolerant quantum error detection\u201d, Science Advances 3, (2017). DOI; 1611.06946].\nLogical state preparation and flag-qubit error correction realized in superconducting-circuit devices by IBM [M. Takita et al., \u201cExperimental Demonstration of Fault-Tolerant State Preparation with Superconducting Qubits\u201d, Physical Review Letters 119, (2017). DOI; 1705.09259][E. H. Chen et al., \u201cCalibrated Decoders for Experimental Quantum Error Correction\u201d, Physical Review Letters 128, (2022). DOI; 2110.04285].\nThe subcode \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [C. K. Andersen et al., \u201cRepeated quantum error detection in a surface code\u201d, Nature Physics 16, 875 (2020). DOI; 1912.09410] and \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) [Google Quantum AI et al., \u201cExponential suppression of bit or phase errors with cyclic error correction\u201d, Nature 595, 383 (2021). DOI; 2102.06132], treated as a planar surface code, has been realized in superconducting-circuit devices.\nLogical gates between two copies of the subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\), interpreted as lattice surgery between planar surface codes, realized in superconducting circuits [A. Erhard et al., \u201cEntangling logical qubits with lattice surgery\u201d, Nature 589, 220 (2021). DOI; 2006.03071].\nLogical gates for the \\(\\{|\\overline{00}\\rangle,|\\overline{11}\\rangle\\}\\) subcode, treated as a planar code, realized in superconducting circuits [J. F. Marques et al., \u201cLogical-qubit operations in an error-detecting surface code\u201d, Nature Physics 18, 80 (2021). DOI; 2102.13071].", "protection": "Detects a single-qubit error [L. Vaidman, L. Goldenberg, and S. Wiesner, \u201cError prevention scheme with four particles\u201d, Physical Review A 54, R1745 (1996). DOI; quant-ph/9603031] or single erasure [M. Grassl, T. Beth, and T. Pellizzari, \u201cCodes for the quantum erasure channel\u201d, Physical Review A 56, 33 (1997). DOI; quant-ph/9610042]. Not able to correct arbitrary single-qubit errors because \\( \\lfloor \\frac{d-1}{2} \\rfloor =0 \\). Approximately corrects a single amplitude damping error [D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002].", "notes": "Concatenating \\([[4,2,2]]\\) code with surface code can generate 2D topological code with a reasonable circuit-based threshold [B. Criger and B. Terhal, \u201cNoise thresholds for the [4,2,2]-concatenated toric code\u201d, Quantum Information and Computation 16, 1261 (2016). DOI].", "physical": "qubits", "short_name": "\\([[4,2,2]]\\)", "introduced": "[L. Vaidman, L. Goldenberg, and S. Wiesner, \u201cError prevention scheme with four particles\u201d, Physical Review A 54, R1745 (1996). DOI; quant-ph/9603031]", "description": "Also known as the \\(C_4\\) code. Four-qubit CSS stabilizer code with generators \\(\\{XXXX, ZZZZ\\} \\) and codewords \\begin{align}\n  \\begin{split}\n    |\\overline{00}\\rangle = (|0000\\rangle + |1111\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{01}\\rangle = (|0011\\rangle + |1100\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{10}\\rangle = (|0101\\rangle + |1010\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{11}\\rangle = (|0110\\rangle + |1001\\rangle)/\\sqrt{2}~.\n  \\end{split}\n\\end{align} This code is the smallest single-qubit error-detecting code. It is also the smallest instance of the toric code, and its various single-qubit subcodes are small planar surface codes.\n\nThe subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is a \\([[4,1,2]]\\) code [D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002], whose \\(\\pm\\)-basis codewords can be written as \\begin{align}\n  |\\overline{\\pm}\\rangle = \\frac{1}{2}(|00\\rangle \\pm |11\\rangle)^{\\otimes 2}~.\\\\\n\\end{align} This code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code. The subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\) [G. Alber et al., \u201cStabilizing Distinguishable Qubits against Spontaneous Decay by Detected-Jump Correcting Quantum Codes\u201d, Physical Review Letters 86, 4402 (2001). DOI; quant-ph/0103042] has also been studied against amplitude-damping noise. This subcode [A. Erhard et al., \u201cEntangling logical qubits with lattice surgery\u201d, Nature 589, 220 (2021). DOI; 2006.03071] and the subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [C. K. Andersen et al., \u201cRepeated quantum error detection in a surface code\u201d, Nature Physics 16, 875 (2020). DOI; 1912.09410], \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) [Google Quantum AI et al., \u201cExponential suppression of bit or phase errors with cyclic error correction\u201d, Nature 595, 383 (2021). DOI; 2102.06132], and \\(\\{|\\overline{00}\\rangle,|\\overline{11}\\rangle\\}\\) [J. F. Marques et al., \u201cLogical-qubit operations in an error-detecting surface code\u201d, Nature Physics 18, 80 (2021). DOI; 2102.13071] are small planar surface codes. ", "parents_code_id": "surface", "parents_detail": "\\([[4,2,2]]\\) code is the smallest toric code.", "cousins_code_id": "rotated_surface\nquantum_parity\nstab_5_1_3\nquantum_polar\napproximate_qecc\nbinomial", "cousins_detail": "Various \\([[4,1,2]]\\) subcodes are small rotated planar codes [A. Erhard et al., \u201cEntangling logical qubits with lattice surgery\u201d, Nature 589, 220 (2021). DOI; 2006.03071][C. K. Andersen et al., \u201cRepeated quantum error detection in a surface code\u201d, Nature Physics 16, 875 (2020). DOI; 1912.09410][Google Quantum AI et al., \u201cExponential suppression of bit or phase errors with cyclic error correction\u201d, Nature 595, 383 (2021). DOI; 2102.06132][J. F. Marques et al., \u201cLogical-qubit operations in an error-detecting surface code\u201d, Nature Physics 18, 80 (2021). DOI; 2102.13071].\n\\([[4,1,2]]\\) subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes.\n\\([[4,2,2]]\\) can be derived from the five-qubit code using a protocol that converts an \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman [Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052].\n\\([[4,2,2]]\\) code is a small quantum polar code [Kyungjoo Noh, Leung code as quantum polar code, 2017.].\n\\([[4,1,2]]\\) subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002] and \\(\\{|\\overline{01}\\rangle,|\\overline{11}\\rangle\\}\\) [G. Alber et al., \u201cStabilizing Distinguishable Qubits against Spontaneous Decay by Detected-Jump Correcting Quantum Codes\u201d, Physical Review Letters 86, 4402 (2001). DOI; quant-ph/0103042] approximately correct a single amplitude damping error.\n\\([[4,1,2]]\\) subcode consisting of \\(\\{|\\overline{00}\\rangle\\) and any other codeword reduces to the \\(0,2,4\\) binomial code when the basis labels in each codeword are written as in base-ten. Such a mapping can be generalized [Linshu Li, private communication, 2018].", "cousin_of_code_id": "heavy_hex", "cousin_of_detail": "The \\(d=2\\) heavy-hexagonal code is closely related to the \\([[4,1,2]]\\) code.", "_type": "ecc", "_page_id": "c_stab_4_2_2", "_href": "c/stab_4_2_2"}, "c_steane": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Pieceable fault-tolerant CCZ gate [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Nine CNOT and four Hadamard gates ([M. Nakahara, \u201cQuantum Computing\u201d, [] (2008). DOI], Fig. 10.14).", "features_decoders": "", "features_transversal_gates": "All single-qubit Clifford gates [Peter W. Shor, \u201cFault-tolerant quantum computation\u201d. quant-ph/9605011][Bei Zeng, Andrew Cross, and Isaac L. Chuang, \u201cTransversality versus Universality for Additive Quantum Codes\u201d. 0706.1382].", "features_fault_tolerance": "Pieceable fault-tolerant CCZ gate [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].\nSyndrome measurement can be done with ancillary flag qubits [T. J. Yoder and I. H. Kim, \u201cThe surface code with a twist\u201d, Quantum 1, 2 (2017). DOI; 1612.04795][R. Chao and B. W. Reichardt, \u201cQuantum Error Correction with Only Two Extra Qubits\u201d, Physical Review Letters 121, (2018). DOI; 1705.02329] or with no extra qubits [B. W. Reichardt, \u201cFault-tolerant quantum error correction for Steane\u2019s seven-qubit color code with few or no extra qubits\u201d, Quantum Science and Technology 6, 015007 (2020). DOI].", "name": "\\([[7,1,3]]\\) Steane code", "code_id": "steane", "realizations": "Trapped-ion qubits: seven-qubit device in Blatt group [D. Nigg et al., \u201cQuantum computations on a topologically encoded qubit\u201d, Science 345, 302 (2014). DOI; 1403.5426], ten-qubit QCCD device by Quantinuum [C. Ryan-Anderson et al., \u201cRealization of real-time fault-tolerant quantum error correction\u201d. 2107.07505] (see APS Physics Synopsys [P. Ball, \u201cReal-Time Error Correction for Quantum Computing\u201d, Physics 14, (2021). DOI]). Fault-tolerant universal two-qubit gate set by Monz group [L. Postler et al., \u201cDemonstration of fault-tolerant universal quantum gate operations\u201d, Nature 605, 675 (2022). DOI; 2111.12654]. Logical CNOT gate between two logical qubits, including rounds of correction and fault-tolerant primitives such as flag qubits and pieceable fault tolerance, on a 20-qubit device by Quantinuum [C. Ryan-Anderson et al., \u201cImplementing Fault-tolerant Entangling Gates on the Five-qubit Code and the Color Code\u201d. 2208.01863]; logical fidelity interval of the combined preparation-CNOT-measurement procedure was higher than that of the unencoded physical qubits.\nRydberg atom arrays: Lukin group [D. Bluvstein et al., \u201cA quantum processor based on coherent transport of entangled atom arrays\u201d, Nature 604, 451 (2022). DOI; 2112.03923].", "protection": "The Steane code is a distance 3 code. It detects errors on 2 qubits, corrects errors on 1 qubit.", "notes": "", "physical": "qubits", "short_name": "Steane", "introduced": "[\u201cMultiple-particle interference and quantum error correction\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 452, 2551 (1996). DOI; quant-ph/9601029]", "description": "A \\([[7,1,3]]\\) CSS code that uses the classical binary \\([7,4,3]\\) Hamming code for protecting against \\(X\\) errors and its dual \\([7,3,4]\\) for \\(Z\\) errors. The parity-check matrix for the \\([7,4,3]\\) Hamming code is \\begin{align}\n  H = \\left(\\begin{matrix}\n    1&0&0&1&0&1&1\\\\\n    0&1&0&1&1&0&1\\\\\n    0&0&1&0&1&1&1\n  \\end{matrix}\\right),\n\\end{align} and the check matrix for the Steane code is therefore \\begin{align}\n  \\left(\\begin{matrix}\n    0&H\\\\\n    H&0\n  \\end{matrix}\\right).\n\\end{align} The stabilizer group for the Steane code has six generators. Logical codewords are \\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{8}}\\Big(|0000000\\rangle+|1010101\\rangle+|0110011\\rangle+|1100110\\rangle\\\\&\\,\\,\\,\\,\\,\\,\\,\\,+|0001111\\rangle+|1011010\\rangle+|0111100\\rangle+|1101001\\rangle\\Big)\\\\|\\overline{1}\\rangle&=\\frac{1}{\\sqrt{8}}\\Big(|1111111\\rangle+|0101010\\rangle+|1001100\\rangle+|0011001\\rangle\\\\&\\,\\,\\,\\,\\,\\,\\,\\,+|1110000\\rangle+|0100101\\rangle+|1000011\\rangle+|0010110\\rangle\\Big)~.\n\\end{split}\n\\end{align} ", "parents_code_id": "diagonal_clifford\nquantum_hamming_css\ncolor", "parents_detail": "Steane code is the smallest member of a family of Reed-Muller-based CSS codes.\nSteane code is the smallest member of a family of Hamming-based CSS codes.\nSteane code is the smallest 2D color code.", "cousins_code_id": "hamming", "cousins_detail": "The Steane code is constructed from a classical Hamming code.", "cousin_of_code_id": "quantum_divisible", "cousin_of_detail": "A fault-tolerant \\(T\\) gate on the Steane code can be obtained by concatenating with particular quantum divisible codes.", "_type": "ecc", "_page_id": "c_steane", "_href": "c/steane"}, "c_stab_5_1_3": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Pieceable fault-tolerant CZ, CNOT, and CCZ gates [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Four CCZ, four Hadamard, and one \\(Z\\) gate ([M. Nakahara, \u201cQuantum Computing\u201d, [] (2008). DOI], Fig. 10.16).\nFour CNOT and five CPHASE gates [A. De and L. P. Pryadko, \u201cUniversal set of dynamically protected gates for bipartite qubit networks: Soft pulse implementation of the [[5,1,3]] quantum error-correcting code\u201d, Physical Review A 93, (2016). DOI; 1509.01239].", "features_decoders": "Combined dynamical decoupling and error correction protocol on individually-controlled qubits with always-on Ising couplings [A. De and L. P. Pryadko, \u201cUniversal set of dynamically protected gates for bipartite qubit networks: Soft pulse implementation of the [[5,1,3]] quantum error-correcting code\u201d, Physical Review A 93, (2016). DOI; 1509.01239].\nSymmetric decoder correcting all weight-one Pauli errors. The resulting logical error channel after coherent noise has been explicitly derived [Chaobin Liu, \u201cExact performance of the five-qubit code with coherent errors\u201d. 2203.01706].", "features_transversal_gates": "Pauli gates are transversal, along with a non-Pauli Hadamard-phase gate \\(SH\\) and three-qubit Clifford operation \\(M_3\\) [Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052].", "features_fault_tolerance": "Pieceable fault-tolerant CZ, CNOT, and CCZ gates [T. J. Yoder, R. Takagi, and I. L. Chuang, \u201cUniversal Fault-Tolerant Gates on Concatenated Stabilizer Codes\u201d, Physical Review X 6, (2016). DOI; 1603.03948].\nSyndrome measurement can be done with two ancillary flag qubits [R. Chao and B. W. Reichardt, \u201cQuantum Error Correction with Only Two Extra Qubits\u201d, Physical Review Letters 121, (2018). DOI; 1705.02329].", "name": "Five-qubit perfect code", "code_id": "stab_5_1_3", "realizations": "NMR: Implementation of perfect error correcting code on 5 spin subsystem of labeled crotonic acid for quantum network benchmarking [E. Knill et al., \u201cBenchmarking Quantum Computers: The Five-Qubit Error Correcting Code\u201d, Physical Review Letters 86, 5811 (2001). DOI; quant-ph/0101034]. Single-qubit logical gates [J. Zhang, R. Laflamme, and D. Suter, \u201cExperimental Implementation of Encoded Logical Qubit Operations in a Perfect Quantum Error Correcting Code\u201d, Physical Review Letters 109, (2012). DOI; 1208.4797].\nSuperconducting qubits [M. Gong et al., \u201cExperimental exploration of five-qubit quantum error-correcting code with superconducting qubits\u201d, National Science Review 9, (2021). DOI; 1907.04507].\nTrapped-ion qubits: non-transversal CNOT gate between two logical qubits, including rounds of correction and fault-tolerant primitives such as flag qubits and pieceable fault tolerance, on a 12-qubit device by Quantinuum [C. Ryan-Anderson et al., \u201cImplementing Fault-tolerant Entangling Gates on the Five-qubit Code and the Color Code\u201d. 2208.01863].\nNitrogen-vacancy centers in diamond: fault-tolerant single-qubit Clifford operations [M. H. Abobeih et al., \u201cFault-tolerant operation of a logical qubit in a diamond quantum processor\u201d, Nature 606, 884 (2022). DOI; 2108.01646].", "protection": "Smallest stabilizer code that protects against a single error on any one qubit. Detects two-qubit errors.", "notes": "", "physical": "qubits", "short_name": "\\([[5,1,3]]\\)", "introduced": "[Raymond Laflamme et al., \u201cPerfect Quantum Error Correction Code\u201d. quant-ph/9602019]", "description": "Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, \\begin{align} \\begin{split} S_1 &= IXZZX \\\\ S_2 &= XZZXI \\\\ S_3 &= ZZXIX \\\\ S_4 &= ZXIXZ~. \\end{split} \\end{align}", "parents_code_id": "stabilizer_over_gf4\nquantum_mds", "parents_detail": "The five-qubit code is derived from the \\([5,3,3]_4\\) Hamming code.\nThe five-qubit codes is the smallest qubit quantum MDS code.", "cousins_code_id": "quantum_perfect\nquantum_cyclic\nhamiltonian\nmajorana_stab", "cousins_detail": "The five-qubit codes is the smallest perfect code.\nThe five-qubit code is the smallest known example of quantum cyclic code.\nThe five-qubit code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].\nThe five-qubit code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].", "cousin_of_code_id": "braunstein\nhexacode\nhappy\nquantum_divisible\nstab_4_2_2\nrotor_5_1_3", "cousin_of_detail": "The Braunstein five-mode code is a bosonic analogue of the five-qubit code.\nApplying the stabilizer-over-\\(GF(4)\\) construction to the hexacode yields a \\([[6,0,4]]\\) quantum code [A. J. Scott, \u201cMultipartite entanglement, quantum-error-correcting codes, and entangling power of quantum evolutions\u201d, Physical Review A 69, (2004). DOI; quant-ph/0310137] corresponding to the six-qubit perfect state. The five-qubit code can be obtained from this code by tracing out a qubit [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nThe five-qubit encoding isometry tiles various holographic codes because its corresponding tensor is perfect [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nA fault-tolerant \\(T\\) gate on the five-qubit code can be obtained by concatenating with particular quantum divisible codes.\n\\([[4,2,2]]\\) can be derived from the five-qubit code using a protocol that converts an \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman [Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052].\n", "_type": "ecc", "_page_id": "c_stab_5_1_3", "_href": "c/stab_5_1_3"}, "c_shor_nine": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Bit- and phase-flip circuits utilize CNOT and Hadamard gates ([M. Nakahara, \u201cQuantum Computing\u201d, [] (2008). DOI], Fig. 10.6).", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\([[9,1,3]]\\) Shor code", "code_id": "shor_nine", "realizations": "Trapped-ion qubits: state preparation with 98.8(1)% and 98.5(1)% fidelity for state \\(|\\overline{0}\\rangle\\) and \\(|\\overline{1}\\rangle\\), respectively, by N. Linke group [N. H. Nguyen et al., \u201cDemonstration of Shor Encoding on a Trapped-Ion Quantum Computer\u201d, Physical Review Applied 16, (2021). DOI; 2104.01205]. Variants of the code to handle coherent noise studied and realized by K. Brown and C. Monroe groups [D. M. Debroy et al., \u201cOptimizing Stabilizer Parities for Improved Logical Qubit Memories\u201d, Physical Review Letters 127, (2021). DOI; 2105.05068].\nOptical systems: quantum teleportation of information implemented by J.-W. Pan group on maximally entangled pair of one physical and one logical qubit with fidelity rate of up to 78.6% [Y.-H. Luo et al., \u201cQuantum teleportation of physical qubits into logical code spaces\u201d, Proceedings of the National Academy of Sciences 118, (2021). DOI; 2009.06242]. All-photonic quantum repeater architecture tested on the same code [R. Zhang et al., \u201cLoss-tolerant all-photonic quantum repeater with generalized Shor code\u201d, Optica 9, 152 (2022). DOI; 2203.07979].", "protection": "The code detects two-qubit errors or corrects an arbitrary single-qubit error.", "notes": "Shor's code is the first known quantum error correction code. ", "physical": "qubits", "short_name": "Shor", "introduced": "[P. W. Shor, \u201cScheme for reducing decoherence in quantum computer memory\u201d, Physical Review A 52, R2493 (1995). DOI]", "description": "Nine-qubit CSS code that is the smallest such code to correct a single-qubit error. Logical codewords are \\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right)^{\\otimes3}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle-|111\\rangle\\right)^{\\otimes3}~.\n\\end{split}\n\\end{align} The code works by concatenating each qubit of a phase-flip with a bit-flip repetition code. Therefore, the code can correct both type of errors simultaneously.\n\nSpecifically, a state is phase-flip error-corrected by a three-qubit phase-flip repetition code, with stabilizer generators \\(X_0 X_1I_2\\) and \\(X_0I_1X_2\\) in \\(X\\) basis, where the subscript represents the qubit index. Each logical qubit is encoded using \\begin{align}\n\\label{eq:phase-flip}\n\\begin{split}\n  |\\overline{0}\\rangle &= |+_0+_1+_2\\rangle \\\\\n  |\\overline{1}\\rangle &= |-_0-_1-_2\\rangle .\n\\end{split}\n\\end{align} Then, each physical qubit used in \\(\\eqref{eq:phase-flip}\\) is further encoded in the three-qubit bit-flip repetition code, \\begin{align}\n  |\\pm _j \\rangle  = \\frac{1}{\\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\\rangle \\pm |1_{j0}1_{j1}1_{j2}\\rangle),\n\\end{align} each with bit-flip error stabilizer generators \\(Z_{j0}Z_{j1}I_{j2}\\) and \\(Z_{j0}I_{j1}Z_{j2} \\) with \\(j=0,1,2\\). Notice now the phase-flip error stabilizer generator is extended as \\(X_j = X_{j0}X_{j1}X_{j2}\\). As a result, the stabilizer generators with the qubit index flattened are \\begin{align}\n\\begin{split}\n  Z_{j0}Z_{j1}I_{j2} &\\rightarrow \\{Z_0Z_1, Z_3Z_4, Z_6Z_7\\} \\\\\n  Z_{j0}I_{j1}Z_{j2} &\\rightarrow \\{Z_0Z_2, Z_3Z_5, Z_6Z_8\\} \\\\\n  X_0 X_1I_2  &\\rightarrow  \\{X_0X_1X_2X_3X_4X_5\\}\\\\\n  X_0 I_1X_2  &\\rightarrow  \\{X_0X_1X_2X_6X_7X_8\\}.\n\\end{split}\n\\end{align} ", "parents_code_id": "quantum_parity", "parents_detail": "Shor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "cousins_code_id": "quantum_repetition\nquantum_concatenated\nreal_projective_plane", "cousins_detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\nShor's code is the smallest surface code defined on the projective plane [Michael H. Freedman and David A. Meyer, \u201cProjective plane and planar quantum codes\u201d. quant-ph/9810055].", "cousin_of_code_id": "lloyd_slotine", "cousin_of_detail": "The Lloyd-Slotine nine-mode code is a bosonic analogue of Shor's code.", "_type": "ecc", "_page_id": "c_shor_nine", "_href": "c/shor_nine"}, "c_stab_15_1_3": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Code is often used in magic-state distillation protocols because of its transversal \\(T\\) gate [S. Bravyi and A. Kitaev, \u201cUniversal quantum computation with ideal Clifford gates and noisy ancillas\u201d, Physical Review A 71, (2005). DOI; quant-ph/0403025].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "Magic-state distillation scaling exponent \\( \\gamma= \\log_d (n/k)\\approx 2.46\\) [J. Haah et al., \u201cMagic state distillation with low space overhead and optimal asymptotic input count\u201d, Quantum 1, 31 (2017). DOI; 1703.07847].", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "This code is the smallest qubit stabilizer code with a transversal gate outside of the Clifford group [Stergios Koutsioumpas, Darren Banfield, and Alastair Kay, \u201cThe Smallest Code with Transversal T\u201d. 2210.14066]. A transversal logical \\(T^\\dagger\\) is implemented by applying a \\(T\\) gate on every qubit [E. Knill, R. Laflamme, and W. Zurek, \u201cThreshold Accuracy for Quantum Computation\u201d. quant-ph/9610011][J. T. Anderson, G. Duclos-Cianci, and D. Poulin, \u201cFault-Tolerant Conversion between the Steane and Reed-Muller Quantum Codes\u201d, Physical Review Letters 113, (2014). DOI; 1403.2734][E. T. Campbell, B. M. Terhal, and C. Vuillot, \u201cRoads towards fault-tolerant universal quantum computation\u201d, Nature 549, 172 (2017). DOI; 1612.07330]. A subsystem version yields a transversal \\(CCZ\\) gate [A. Paetznick and B. W. Reichardt, \u201cUniversal Fault-Tolerant Quantum Computation with Only Transversal Gates and Error Correction\u201d, Physical Review Letters 111, (2013). DOI; 1304.3709]. The code fails to have a transversal Hadamard gate; otherwise, it would vioalate the Eastin-Knill theorem.", "features_fault_tolerance": "Combining the Steane code and the 15-qubit Reed-Muller code through a fault-tolerant conversion can result in a universal transversal gate set that does not need magic state distillation [A. Paetznick and B. W. Reichardt, \u201cUniversal Fault-Tolerant Quantum Computation with Only Transversal Gates and Error Correction\u201d, Physical Review Letters 111, (2013). DOI; 1304.3709][J. T. Anderson, G. Duclos-Cianci, and D. Poulin, \u201cFault-Tolerant Conversion between the Steane and Reed-Muller Quantum Codes\u201d, Physical Review Letters 113, (2014). DOI; 1403.2734][D.-X. Quan et al., \u201cFault-tolerant conversion between adjacent Reed\u2013Muller quantum codes based on gauge fixing\u201d, Journal of Physics A: Mathematical and Theoretical 51, 115305 (2018). DOI; 1703.03860][Darren Banfield and Alastair Kay, \u201cImplementing Logical Operators using Code Rewiring\u201d. 2210.14074].", "name": "\\([[15,1,3]]\\) quantum Reed-Muller code", "code_id": "stab_15_1_3", "realizations": "", "protection": "", "notes": "The \\([[15,1,3]]\\) code can be converted into the smallest known stabilizer code with a fault-tolerant logical \\(T\\) gate (i.e., the \\([[10,1,2]]\\) code) through a \"morphing procedure\" [M. Vasmer and A. Kubica, \u201cMorphing Quantum Codes\u201d, PRX Quantum 3, (2022). DOI; 2112.01446].", "physical": "qubits", "short_name": "\\([[15,1,3]]\\)", "introduced": "", "description": "\\([[15,1,3]]\\) CSS code that is most easily thought of as a tetrahedral 3D color code. This code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center. The tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers. Each colored cell corresponds to a weight-8 \\(X\\)-check, and each face corresponds to a weight-4 \\(Z\\)-check. A logical \\(Z\\) is any weight-3 \\(Z\\)-string along an edge of the entire tetrahedron. The logical \\(X\\) is any weight-7 \\(X\\)-face of the entire tetrahedron. ", "parents_code_id": "diagonal_clifford\nquantum_triorthogonal\ncolor", "parents_detail": "\nThe \\([[15, 1, 3]]\\) code is a triorthogonal code [S. Nezami and J. Haah, \u201cClassification of small triorthogonal codes\u201d, Physical Review A 106, (2022). DOI; 2107.09684].\nThe \\([[15,1,3]]\\) code is a 3D color code.", "_type": "ecc", "_page_id": "c_stab_15_1_3", "_href": "c/stab_15_1_3"}, "c_check_product": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum check-product code", "code_id": "check_product", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Andrew Cross et al., \u201cQuantum Locally Testable Code with Exotic Parameters\u201d. 2209.11405]", "description": "Stub. ", "parents_code_id": "generalized_homological_product\nqltc", "parents_detail": "\nQuantum check-product constructions yield a sLTC code with constant soundness \\(2\\rho\\) from a classical LTC code with soundness \\(\\rho\\). While these are the first bona-fide QLTC code family because they admit asymptotically constant soundess, they are not practical because their distance is two.", "cousins_code_id": "tensor\ndistance_balanced", "cousins_detail": "Quantum check-product codes extend the concept of a check product, which yields the dual of a tensor code, to a product between a classical and a quantum code.\nQuantum check-product code constructions use distance balancing to increase distance.", "_type": "ecc", "_page_id": "c_check_product", "_href": "c/check_product"}, "c_ramanujan_tensor_product": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "For 2D Ramanujan complexes, the rate is \\(\\Omega(\\sqrt{ \\frac{1}{n \\log n} })\\), with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}) \\). For 3D, the rate is \\( \\Omega(\\frac{1}{\\sqrt{n}\\log n}) \\) with minimum distance \\(d \\geq \\sqrt{n} \\log n \\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "For 2D simplicial complexes, cycle code decoder admitting a polynomial-time decoding algorithm can be used [Shai Evra, Tali Kaufman, and Gilles Z\u00e9mor, \u201cDecodable quantum LDPC codes beyond the $\\sqrt{n}$ distance barrier using high dimensional expanders\u201d. 2004.07935].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Ramanujan-complex product code", "code_id": "ramanujan_tensor_product", "realizations": "", "protection": "Without distance balancing, a Ramanujan code can have \\(d_X =\\Omega(\\log n)\\) and \\(d_Z = \\Omega (n)\\). For 2D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d = \\Omega(\\sqrt{n \\log n})\\). For 3D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d= \\Omega(\\sqrt{n} \\log n )\\).", "notes": "Codes were first to break a 20-year record set by the Freedman-Meyer-Luo code for the lower bound on scaling of the minimum distance [N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309].", "physical": "qubits", "short_name": "", "introduced": "[Shai Evra, Tali Kaufman, and Gilles Z\u00e9mor, \u201cDecodable quantum LDPC codes beyond the $\\sqrt{n}$ distance barrier using high dimensional expanders\u201d. 2004.07935]", "description": "CSS code constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.", "parents_code_id": "generalized_homological_product", "parents_detail": "Ramanujan codes result from a tensor product of a classical-code and a quantum-code chain complex.", "parent_of_code_id": "iterated_ramanujan", "parent_of_detail": "", "cousins_code_id": "distance_balanced\nfreedman_meyer_luo", "cousins_detail": "Ramanujan tensor-product constructions use distance balancing to increase distance.\nRamanujan codes broke 20-year record on minimum code distance set by Freedman-Meyer-Luo codes.", "_type": "ecc", "_page_id": "c_ramanujan_tensor_product", "_href": "c/ramanujan_tensor_product"}, "c_fiber_bundle": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Rate \\(k/n = \\Omega(n^{-2/5}/\\text{polylog}(n))\\), distance \\(d=\\Omega(n^{3/5}/\\text{polylog}(n))\\). This is the first QLDPC code to achieve a distance scaling better than \\(\\sqrt{n}~\\text{polylog}(n)\\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Greedy algorithm can be used to efficiently decode \\(X\\) errors, but no known efficient decoding of \\(Z\\) errors yet [Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Fiber-bundle code", "code_id": "fiber_bundle", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921]", "description": "Also called a twisted product code. CSS code constructed by combining a random LDPC code as the base and a cyclic repetition code as the fiber of a fiber bundle. After applying distance balancing, a QLDPC code with distance \\(\\Omega(n^{3/5}\\text{polylog}(n))\\) and rate \\(\\Omega(n^{-2/5}\\text{polylog}(n))\\) is obtained.", "parents_code_id": "balanced_product", "parents_detail": "Fiber-bundle codes can be formulated in terms of a balanced product [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].", "parent_of_code_id": "homological_product", "parent_of_detail": "Fiber-bundle code can be viewed as a homological product code with a twisted product.", "cousins_code_id": "distance_balanced\nquantum_random", "cousins_detail": "Fiber-bundle code constructions use distance balancing to increase distance.\n", "_type": "ecc", "_page_id": "c_fiber_bundle", "_href": "c/fiber_bundle"}, "c_iterated_ramanujan": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Tensored-Ramanujan-complex product code", "code_id": "iterated_ramanujan", "realizations": "", "protection": "Construction yields explicit QLDPC codes with distance \\(\\sqrt{n}\\log^c n\\) using the \\(c\\)-tensor-product of Ramanujan complexes.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Tali Kaufman and Ran J. Tessler, \u201cNew Cosystolic Expanders from Tensors Imply Explicit Quantum LDPC Codes with $\u03a9(\\sqrt{n}\\log^kn)$ Distance\u201d. 2008.09495]", "description": "Code constructed in a similar way as the Ramanujan-complex product code, but utilizing tensor products of Ramanujan complexes in order to improve code distance from \\(\\sqrt{n}\\log n\\) to \\(\\sqrt{n}~\\text{polylog}(n)\\). The utility of such tensor products comes from the fact that one of the Ramanujan complexes is a collective cosystolic expander as opposed to just a cosystolic expander.", "parents_code_id": "ramanujan_tensor_product", "parents_detail": "", "_type": "ecc", "_page_id": "c_iterated_ramanujan", "_href": "c/iterated_ramanujan"}, "c_quantum_tanner": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Asymptotically good QLDPC codes.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Linear-time decoder similar to the small-set-flip decoder for quantum expander codes [Shouzhen Gu, Christopher A. Pattison, and Eugene Tang, \u201cAn efficient decoder for a linear distance quantum LDPC code\u201d. 2206.06557].\nLinear-time decoder [Anthony Leverrier and Gilles Z\u00e9mor, \u201cEfficient decoding up to a constant fraction of the code length for asymptotically good quantum codes\u201d. 2206.07571].\nLogarithmic-time decoder [Anthony Leverrier and Gilles Z\u00e9mor, \u201cA parallel decoder for good quantum LDPC codes\u201d. 2208.05537].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum Tanner code", "code_id": "quantum_tanner", "realizations": "Used to obtain explicit lower bounds in the sum-of-squares game [Max Hopkins and Ting-Chun Lin, \u201cExplicit Lower Bounds Against $\u03a9(n)$-Rounds of Sum-of-Squares\u201d. 2204.11469].\nStates that, on average, achieve small violations of check operators for quantum Tanner codes require a circuit of non-constant depth to make. They are used in the proof [Anurag Anshu, Nikolas P. Breuckmann, and Chinmay Nirkhe, \u201cNLTS Hamiltonians from good quantum codes\u201d. 2206.13228] of the No low-energy trivial states (NLTS) conjecture [M. H. Freedman and M. B. Hastings, \u201cQuantum Systems on Non-$k$-Hyperfinite Complexes: A Generalization of Classical Statistical Mechanics on Expander Graphs\u201d. 1301.1363].", "protection": "Minimum distance bound obtained using robustness of dual tensor-product codes [Anthony Leverrier and Gilles Z\u00e9mor, \u201cA parallel decoder for good quantum LDPC codes\u201d. 2208.05537].", "notes": "For details, see talk by A. Leverrier.", "physical": "qubits", "short_name": "", "introduced": "[Anthony Leverrier and Gilles Z\u00e9mor, \u201cQuantum Tanner codes\u201d. 2202.13641]", "description": "Stub.", "parents_code_id": "generalized_homological_product\ncss", "parents_detail": "\n", "parent_of_code_id": "rotated_surface", "parent_of_detail": "Specializing the quantum Tanner construction to the surface code yields the rotated surface code [Nikolas P. Breuckmann, private communication, 2022][Anthony Leverrier, Mapping the toric code to the rotated toric code, 2022.].", "cousins_code_id": "good_qldpc\ntanner\ntensor\nexpander_lifted_product", "cousins_detail": "Quantum Tanner code construction yields asymptotically good QLDPC codes.\nTanner codes are used in constructing quantum Tanner codes.\nTensor codes are used in constructing quantum Tanner codes.\nQuantum Tanner codes are an attempt to construct asymptotically good QLDPC codes that are similar to but simpler than expander lifted-product codes; see Ref. [Anthony Leverrier and Gilles Z\u00e9mor, \u201cEfficient decoding up to a constant fraction of the code length for asymptotically good quantum codes\u201d. 2206.07571] for connection between the codes.", "cousin_of_code_id": "classical_product\nlr-cayley-complex", "cousin_of_detail": "A \\([[512,174,8]]\\) classical-product code performed well [Dimiter Ostrev et al., \u201cClassical product code constructions for quantum Calderbank-Shor-Steane codes\u201d. 2209.13474] against erasure and depolarizing noise when compared to a member of an asymptotically good quantum Tanner code family.\nApplying the CSS construction to two left-right Cayley complex codes yields quantum Tanner codes, and one can simultaneously prove a linear distance for the quantum code and local testability for one of its constituent classical codes [Anthony Leverrier and Gilles Z\u00e9mor, \u201cQuantum Tanner codes\u201d. 2202.13641].", "_type": "ecc", "_page_id": "c_quantum_tanner", "_href": "c/quantum_tanner"}, "c_quantum_expander": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "Current estimate of \\(2.7 \\cdot 10^{-16}\\) in locally stochastic noise model [O. Fawzi, A. Grospellier, and A. Leverrier, \u201cEfficient decoding of random errors for quantum expander codes\u201d, Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of Computing (2018). DOI; 1711.08351].", "features_rate": "\\([[n,k=\\Theta(n),d=O(\\sqrt{n})]]\\) code with asymptotically constant rate.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Small set-flip linear-time decoder, which corrects \\(\\Omega(n^{1/2})\\) adversarial errors [A. Leverrier, J.-P. Tillich, and G. Zemor, \u201cQuantum Expander Codes\u201d, 2015 IEEE 56th Annual Symposium on Foundations of Computer Science (2015). DOI; 1504.00822].\nLog-time decoder [O. Fawzi, A. Grospellier, and A. Leverrier, \u201cConstant Overhead Quantum Fault-Tolerance with Quantum Expander Codes\u201d, 2018 IEEE 59th Annual Symposium on Foundations of Computer Science (FOCS) (2018). DOI; 1808.03821].\nConstant-time decoder [A. Grospellier. Constant time decoding of quantum expander codes and application to fault-tolerant quantum computation. PhD thesis, Inria Paris (2019).].", "features_transversal_gates": "", "features_fault_tolerance": "Fault-tolerance with constant overhead can be achieved [O. Fawzi, A. Grospellier, and A. Leverrier, \u201cConstant Overhead Quantum Fault-Tolerance with Quantum Expander Codes\u201d, 2018 IEEE 59th Annual Symposium on Foundations of Computer Science (FOCS) (2018). DOI; 1808.03821].", "name": "Quantum expander code", "code_id": "quantum_expander", "realizations": "", "protection": "Pauli errors of weight \\(\\leq t\\), distance scales as \\(\\Omega(n^{1/2})\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[A. Leverrier, J.-P. Tillich, and G. Zemor, \u201cQuantum Expander Codes\u201d, 2015 IEEE 56th Annual Symposium on Foundations of Computer Science (2015). DOI; 1504.00822]", "description": "CSS codes constructed from a hypergraph product of bipartite expander graphs with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as \\(X\\) checks, and the parity check matrix of the other as \\(Z\\) checks.", "parents_code_id": "hypergraph_product", "parents_detail": "", "cousins_code_id": "expander", "cousins_detail": "", "_type": "ecc", "_page_id": "c_quantum_expander", "_href": "c/quantum_expander"}, "c_homological_product": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state [T. Jochym-O'Connor, \u201cFault-tolerant gates via homological product codes\u201d, Quantum 3, 120 (2019). DOI; 1807.09783].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Union-find [N. Delfosse and M. B. Hastings, \u201cUnion-Find Decoders For Homological Product Codes\u201d, Quantum 5, 406 (2021). DOI; 2009.14226].", "features_transversal_gates": "", "features_fault_tolerance": "Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state [T. Jochym-O'Connor, \u201cFault-tolerant gates via homological product codes\u201d, Quantum 3, 120 (2019). DOI; 1807.09783].", "name": "Homological product code", "code_id": "homological_product", "realizations": "", "protection": "Given two codes \\([[n_a, k_a, d_a, w_a]]\\) for \\(a\\in\\{1,2\\}\\), where \\(w_a\\) denotes the maximum hamming weight of all rows and columns of \\(\\partial_a\\), the homological product code has parameter \\([[n=n_1 n_2, k=k_1 k_2, d\\leq d_1 d_2, w\\leq w_1+w_2]]\\). From this formula, and the fact that a randomly selected boundary operator \\(\\partial\\) yields a CSS code that is good with high probability, we see that the product code has \\(k=\\Theta(n)\\) and \\(w=O(\\sqrt{n})\\) with high probability. The main result in [Sergey Bravyi and Matthew B. Hastings, \u201cHomological Product Codes\u201d. 1311.0885] is to show that the product code actually has linear distance with high probability as well. To sum up, it is shown that we have a family of \\([[n,k=c_1 n, d=c_2 n, w=c_3 \\sqrt{n}]]\\) codes given small enough \\(c_1,c_2,c_3\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[M. H. Freedman and M. B. Hastings, \u201cQuantum Systems on Non-$k$-Hyperfinite Complexes: A Generalization of Classical Statistical Mechanics on Expander Graphs\u201d. 1301.1363][Sergey Bravyi and Matthew B. Hastings, \u201cHomological Product Codes\u201d. 1311.0885]", "description": "CSS code formulated using the homological product of two chain complexes (see CSS-to-homology correspondence). Stub. ", "parents_code_id": "fiber_bundle", "parents_detail": "Fiber-bundle code can be viewed as a homological product code with a twisted product.", "parent_of_code_id": "distance_balanced\nhypergraph_product", "parent_of_detail": "Distance balancing relies on taking homological product of chain complexes corresponding to a classical and a quantum code.\nA homological product of chain complexes corresponding to two classical codes is a hypergraph product code [Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921].", "cousins_code_id": "quantum_random", "cousins_detail": "", "_type": "ecc", "_page_id": "c_homological_product", "_href": "c/homological_product"}, "c_classical_product": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "CSS classical product code", "code_id": "classical_product", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[M. Hivadi, \u201cOn quantum SPC product codes\u201d, Quantum Information Processing 17, (2018). DOI][Dimiter Ostrev et al., \u201cClassical product code constructions for quantum Calderbank-Shor-Steane codes\u201d. 2209.13474]", "description": "A CSS code constructed by separately constructing the \\(X\\) and \\(Z\\) check matrices using product constructions from classical codes. A particular \\([[512,174,8]]\\) code performed well [Dimiter Ostrev et al., \u201cClassical product code constructions for quantum Calderbank-Shor-Steane codes\u201d. 2209.13474] against erasure and depolarizing noise when compared to other notable CSS codes, such as the asymptotically good quantum Tanner codes.\n\nFor example, for \\(H_i^x\\), \\(H_i^z\\) being the \\(X\\) and \\(Z\\) check matrices of CSS codes \\(C_i\\) with \\(i\\in\\{1,2,3,4\\}\\), the 2-fold symmetric classical product code is given by \\begin{align}\nH_{\\otimes}^x &:=\\left(\\begin{array}{c}\nH_1^x \\otimes H_2^x \\otimes I \\otimes I \\\\\nI \\otimes I \\otimes H_3^x \\otimes H_4^x\n\\end{array}\\right) \\\\\nH_{\\otimes}^z &:=\\left(\\begin{array}{c}\nH_1^z \\otimes I \\otimes H_3^z \\otimes I \\\\\nI \\otimes H_2^z \\otimes I \\otimes H_4^z\n\\end{array}\\right)~.\n\\end{align}", "parents_code_id": "css", "parents_detail": "", "cousins_code_id": "quantum_tanner\nparity_check\ntensor", "cousins_detail": "A \\([[512,174,8]]\\) classical-product code performed well [Dimiter Ostrev et al., \u201cClassical product code constructions for quantum Calderbank-Shor-Steane codes\u201d. 2209.13474] against erasure and depolarizing noise when compared to a member of an asymptotically good quantum Tanner code family.\nSPC codes are used as component codes in classical-product code constructions.\nTensor-product codes are utilized in classical-product code constructions.", "_type": "ecc", "_page_id": "c_classical_product", "_href": "c/classical_product"}, "c_dhlv": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Asymptotically good QLDPC codes.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Linear-time decoder utilizing the small set-flip decoder [Shouzhen Gu, Christopher A. Pattison, and Eugene Tang, \u201cAn efficient decoder for a linear distance quantum LDPC code\u201d. 2206.06557] for \\(Z\\) errors and a reconstruction procedure for \\(X\\) errors [Irit Dinur et al., \u201cGood Quantum LDPC Codes with Linear Time Decoders\u201d. 2206.07750].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Dinur-Hsieh-Lin-Vidick (DHLV) code", "code_id": "dhlv", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "DHLV", "introduced": "[Irit Dinur et al., \u201cGood Quantum LDPC Codes with Linear Time Decoders\u201d. 2206.07750]", "description": "Stub.", "parents_code_id": "balanced_product\ncss", "parents_detail": "\n", "cousins_code_id": "good_qldpc\ntanner\ntensor", "cousins_detail": "DHLV code construction yields asymptotically good QLDPC codes.\nTanner codes are used in constructing quantum DHLV codes.\nTensor codes are used in constructing quantum DHLV codes.", "_type": "ecc", "_page_id": "c_dhlv", "_href": "c/dhlv"}, "c_hemicubic": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hemicubic code", "code_id": "hemicubic", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[A. Leverrier, V. Londe, and G. Z\u00e9mor, \u201cTowards local testability for quantum coding\u201d, Quantum 6, 661 (2022). DOI; 1911.03069]", "description": "Stub. ", "parents_code_id": "higher_dimensional_surface", "parents_detail": "", "cousins_code_id": "qltc", "cousins_detail": "A hemicubic code family has asymptotically diminishing soundness that scales as order \\(\\Omega(1/\\log n)\\).", "_type": "ecc", "_page_id": "c_hemicubic", "_href": "c/hemicubic"}, "c_xyz_product": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Not much has been proven about the relationship between XYZ-product codes and other codes. The logical dimension depends on properties of the input classical codes, specifically similarity invariants from abstract algebra. It is conjectured that specific instances of XYZ-product codes have a constant encoding rate and a minimum distance of \\(d \\in \\Theta(n^{2/3})\\) [A. Leverrier, S. Apers, and C. Vuillot, \u201cQuantum XYZ Product Codes\u201d, Quantum 6, 766 (2022). DOI; 2011.09746]. ", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "XYZ product code", "code_id": "xyz_product", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[A. Leverrier, S. Apers, and C. Vuillot, \u201cQuantum XYZ Product Codes\u201d, Quantum 6, 766 (2022). DOI; 2011.09746]", "description": "A non-CSS QLDPC code constructed from three classical codes. The construction of an XYZ product code is similar to that of a hypergraph product code and related codes. The idea is that rather than taking a product of only two classical codes to produce a CSS code, a third classical code is considered, acting with Pauli-\\(Y\\) operators. ", "parents_code_id": "qubit_stabilizer\ngeneralized_homological_product", "parents_detail": "\nXYZ product codes result from a tensor product of three classical-code chain complexes.", "cousins_code_id": "hypergraph_product", "cousins_detail": "The XYZ product code is based on a hypergraph product of three classical codes.", "_type": "ecc", "_page_id": "c_xyz_product", "_href": "c/xyz_product"}, "c_hypergraph_product": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Code deformation techniques yield Clifford gates [A. Krishna and D. Poulin, \u201cFault-Tolerant Gates on Hypergraph Product Codes\u201d, Physical Review X 11, (2021). DOI; 1909.07424].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "ReShape decoder that uses minimum weight decoders for the classical codes used in the hypergraph construction [Armanda O. Quintavalle and Earl T. Campbell, \u201cReShape: a decoder for hypergraph product codes\u201d. 2105.02370].\nErasure-correction can be implemented approximately with \\(O(n^2)\\) operations, with a probabilistic version running in \\(O(n^{1.5})\\) operations [Nicholas Connolly et al., \u201cFast erasure decoder for a class of quantum LDPC codes\u201d. 2208.01002].", "features_transversal_gates": "Hadamard (up to logical SWAP gates) and control-\\(Z\\) on all logical qubits [Armanda O. Quintavalle, Paul Webster, and Michael Vasmer, \u201cPartitioning qubits in hypergraph product codes to implement logical gates\u201d. 2204.10812].", "features_fault_tolerance": "", "name": "Hypergraph product code", "code_id": "hypergraph_product", "realizations": "", "protection": "The hypergraph product has distance \\(d=O(\\sqrt{n})\\). The number of encoded logical qubits is \\(k=O(k_1k_2)\\) where \\(k_1\\) and \\(k_2\\) are the dimensions of the classical seed codes \\(C_1\\) and \\(C_2\\).", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[J.-P. Tillich and G. Zemor, \u201cQuantum LDPC Codes With Positive Rate and Minimum Distance Proportional to the Square Root of the Blocklength\u201d, IEEE Transactions on Information Theory 60, 1193 (2014). DOI; 0903.0566][A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928]", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two binary linear seed codes \\(C_1\\) and \\(C_2\\).", "parents_code_id": "lifted_product\nhomological_product", "parents_detail": "Lifted-product codes for trivial group \\(G\\) are hypergraph-product codes.\nA homological product of chain complexes corresponding to two classical codes is a hypergraph product code [Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921].", "parent_of_code_id": "quantum_expander", "parent_of_detail": "", "cousin_of_code_id": "surface\nrotated_surface\nxyz_product", "cousin_of_detail": "Planar (toric) code can be obtained from hypergraph product of two repetition (cyclic) codes ([A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928], Ex. 6).\nRotated code can be obtained from hypergraph product of two cyclic binary cyclic codes with palindromic generator polynomial ([A. A. Kovalev and L. P. Pryadko, \u201cImproved quantum hypergraph-product LDPC codes\u201d, 2012 IEEE International Symposium on Information Theory Proceedings (2012). DOI; 1202.0928], Ex. 7).\nThe XYZ product code is based on a hypergraph product of three classical codes.", "_type": "ecc", "_page_id": "c_hypergraph_product", "_href": "c/hypergraph_product"}, "c_hypersphere_product": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hypersphere product code", "code_id": "hypersphere_product", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[M. B. Hastings, \u201cQuantum Codes from High-Dimensional Manifolds\u201d. 1608.05089]", "description": "Stub. ", "parents_code_id": "higher_dimensional_surface", "parents_detail": "", "cousins_code_id": "qltc", "cousins_detail": "The hypersphere product code family has asymptotically diminishing soundness that scales as order \\(O(1/(\\log n)^2)\\), locality of stabilizer generators scaling as order \\(O(\\log n)\\), and distance \\(\\Theta(\\sqrt{n})\\).", "_type": "ecc", "_page_id": "c_hypersphere_product", "_href": "c/hypersphere_product"}, "c_heavy_hex": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Universal gate set achieved with magic state injection and lattice surgery.", "features_threshold": "\\(0.45\\%\\) for \\(X\\) errors under a full circuit-level depolarizing noise model (obtained from Monte Carlo simulations).\n\\(Z\\)-errors have no threshold given the \\(X\\)-type Bacon-Shor stabilizers.", "features_rate": "\\(1/n\\) for a distance-\\(d\\) heavy-hexagon code on \\(n = (5d^2-2d-1)/2\\) qubits.", "features_magic_scaling_exponent": "", "features_encoders": "For a logical-zero state, prepare all data qubits in the physical-zero state and then measure the \\(X\\)-type Bacon-Shor stabilizers. For logical-plus state, prepare all data qubits in the physical-plus state and then measure \\(Z\\)-type surface code stabilizers.\nStabilizer measurement encoding circuits have a constant depth of 10 time steps (excluding ancilla state preparation and measurement).", "features_decoders": "Any graph-based decoder can be used, such as MWPM and Union Find. However, edge weights must be dynamically renormalized using flag-qubit measurement outcomes after each syndrome measurement round.\nMachine-learning decoder [Debasmita Bhoumik et al., \u201cEfficient Machine-Learning-based decoder for Heavy Hexagonal QECC\u201d. 2210.09730].", "features_transversal_gates": "CNOT gates are transveral for this code. However, for most architectures, all logical gates would be implemented using lattice surgery methods.", "features_fault_tolerance": "All logical gates can be fault-tolerantly implemented using lattice surgery and magic state injection.\nStabilizer measurements are measured fault-tolerantly using one-flag circuits since some single-fault events can result in weight-two data qubit errors which are parallel to the code's logical operators. Hence, using information from the flag-qubit measurements is crucial to fault-tolerantly measure the code stabilizers.", "name": "Heavy-hexagon code", "code_id": "heavy_hex", "realizations": "Logical state preparation and flag-qubit error correction realized in superconducting-circuit devices (specifically, fixed-frequency transmon qubit architectures) by IBM for \\(d=2\\) [M. Takita et al., \u201cExperimental Demonstration of Fault-Tolerant State Preparation with Superconducting Qubits\u201d, Physical Review Letters 119, (2017). DOI; 1705.09259][E. H. Chen et al., \u201cCalibrated Decoders for Experimental Quantum Error Correction\u201d, Physical Review Letters 128, (2022). DOI; 2110.04285] and \\(d=3\\) [Neereja Sundaresan et al., \u201cMatching and maximum likelihood decoding of a multi-round subsystem quantum error correction experiment\u201d. 2203.07205].", "protection": "Protects against Pauli noise. The code has no threshold for \\(Z\\)-type Pauli errors since they are detected by Bacon-Shor-type stabilizers.", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[C. Chamberland et al., \u201cTopological and Subsystem Codes on Low-Degree Graphs with Flag Qubits\u201d, Physical Review X 10, (2020). DOI; 1907.09528]", "description": "Subsystem stabilizer code on the heavy-hexagonal lattice that combines Bacon-Shor and surface-code stabilizers. Encodes one logical qubit into \\(n=(5d^2-2d-1)/2\\) physical qubits with distance \\(d\\). The heavy-hexagonal lattice allows for low degree (at most 3) connectivity between all the data and ancilla qubits, which is suitable for fixed-frequency transom qubits subject to frequency collision errors.\n\nData qubits and ancillas of the code are placed on a heavy-hexagonal lattice (vertices and edges of a tilling of hexagons). A subset of the ancilla qubits are flag qubits used for detecting high-weight errors arising from fewer faults. The code stabilizers for detecting \\(X\\)-type errors are measured by measuring weight-two \\(Z\\)-type gauge operators whose product produces stabilizers of the surface code. \\(X\\)-type stabilizers are column operators corresponding to stabilizers of the Bacon-Shor code, which are measured by taking products of weight-four and weight-two \\(X\\)-type gauge operators. ", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "cousins_code_id": "surface\nbacon_shor\nstab_4_2_2", "cousins_detail": "Surface code stabilizers are used to measure the Z-type stabilizers of the code.\nBacon-Shor stabilizers are used to measure the X-type stabilizers of the code.\nThe \\(d=2\\) heavy-hexagonal code is closely related to the \\([[4,1,2]]\\) code.", "cousin_of_code_id": "rotated_surface", "cousin_of_detail": "A rotated surface code can be mapped onto a heavy square lattice, resulting in a code similar to the heavy-hexagon code [C. Chamberland et al., \u201cTopological and Subsystem Codes on Low-Degree Graphs with Flag Qubits\u201d, Physical Review X 10, (2020). DOI; 1907.09528].", "_type": "ecc", "_page_id": "c_heavy_hex", "_href": "c/heavy_hex"}, "c_subsystem_surface": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "\\(0.81\\%\\) threshold for circuit-level depolarizing noise under a variant of MWPM and using gauge-fixing and specific measurement schedules [O. Higgott and N. P. Breuckmann, \u201cSubsystem Codes with High Thresholds by Gauge Fixing and Reduced Qubit Overhead\u201d, Physical Review X 11, (2021). DOI; 2010.09626], improving the \\(0.67\\%\\) threshold for standard measurement schedules [Sergey Bravyi et al., \u201cSubsystem surface codes with three-qubit check operators\u201d. 1207.1443].\n\\(2.22\\%\\) threshold for circuit-level infinitely biased noise under a variant of MWPM and using gauge-fixing and specific measurement schedules [O. Higgott and N. P. Breuckmann, \u201cSubsystem Codes with High Thresholds by Gauge Fixing and Reduced Qubit Overhead\u201d, Physical Review X 11, (2021). DOI; 2010.09626], improving the \\(0.52\\%\\) threshold with standarn measurement schedules.", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "Gauge fixing and changing the order in which check operators are measured yields a fault-tolerant decoder [O. Higgott and N. P. Breuckmann, \u201cSubsystem Codes with High Thresholds by Gauge Fixing and Reduced Qubit Overhead\u201d, Physical Review X 11, (2021). DOI; 2010.09626].", "name": "Subsystem surface code", "code_id": "subsystem_surface", "realizations": "", "protection": "", "notes": "See [B. M. Terhal, \u201cQuantum error correction for quantum memories\u201d, Reviews of Modern Physics 87, 307 (2015). DOI; 1302.3428; Sec. III.C3] for an exposition.", "physical": "qubits", "short_name": "", "introduced": "[Sergey Bravyi et al., \u201cSubsystem surface codes with three-qubit check operators\u201d. 1207.1443]", "description": "Stub. ", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "cousins_code_id": "surface", "cousins_detail": "", "_type": "ecc", "_page_id": "c_subsystem_surface", "_href": "c/subsystem_surface"}, "c_subsystem_stabilizer": {"logical": "qubits", "features_code_capacity_threshold": "For correlated Pauli noise, bounds can be obtained by mapping the effect of noise on the code to a statistical mechanical model [C. T. Chubb and S. T. Flammia, \u201cStatistical mechanical models for quantum codes with correlated noise\u201d, Annales de l\u2019Institut Henri Poincar\u00e9 D 8, 269 (2021). DOI; 1809.10704].", "features_general_gates": "Logical Clifford gates can be implemented fault-tolerantly for subsystem codes of distance at least three [Darren Banfield and Alastair Kay, \u201cImplementing Logical Operators using Code Rewiring\u201d. 2210.14074].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Syndrome measurements are obtained by first measuring gauge operators of the code and taking their products, which give the stabilizer measurement outcomes.", "features_transversal_gates": "", "features_fault_tolerance": "Logical Clifford gates can be implemented fault-tolerantly for subsystem codes of distance at least three [Darren Banfield and Alastair Kay, \u201cImplementing Logical Operators using Code Rewiring\u201d. 2210.14074].", "name": "Subsystem qubit stabilizer code", "code_id": "subsystem_stabilizer", "realizations": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. More generally, a set of errors \\( \\{ E_a \\} \\) is correctable iff \\( E_aE_b \\not\\in N(\\mathsf{S}) \\setminus \\mathsf{G} \\) for all pairs \\(a,b\\). The distance of the code is the minimal weight of operators in \\( N(\\mathsf{S}) \\setminus \\mathsf{G}\\).", "notes": "When the gauge group \\( \\mathsf{G} \\) is abelian, the above is reduced to the standard stabilizer formalism.", "physical": "qubits", "short_name": "", "introduced": "[D. Poulin, \u201cStabilizer Formalism for Operator Quantum Error Correction\u201d, Physical Review Letters 95, (2005). DOI; quant-ph/0508131]", "description": "Also called a gauge stabilizer code. A stabilizer code with some of its logical qubits denoted as gauge qubits and not used for storage of logical information. Note that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by \\([[n,k,r,d]]\\), similar to stabilizer codes, but with an extra parameter \\(r\\) denoting the number of gauge qubits.\n\nTo create these codes proceed as follows. Choose \\(2n\\) operators \\(\\{ \\tilde{X}_j,\\tilde{Z}_j\\}_{j=1}^n\\) from \\(\\mathsf{P}_n\\), the Pauli group on \\(n\\) qubits, such that they obey the same commutation relations as the regular \\(n\\)-qubit Pauli generators \\( \\{X_j,Z_j\\}_{j=1}^n \\) (the subscript on these latter operators indicates the single qubit the Pauli matrix acts on). The tilde operators might act on more than one physical (or bare) qubit but they behave as if they acted only on a single qubit. WLOG we can choose a stabilizer group as \\( \\mathsf{S} = \\langle Z_1,\\dots,Z_s \\rangle \\). It follows that the normalizer of \\(\\mathsf{S} \\) is \\( N(\\mathsf{S}) = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_n, \\tilde{X}_{s+1},\\dots, \\tilde{X}_n \\rangle \\). We now choose a gauge group as \\( \\mathsf{G} = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_s, \\tilde{X}_{s+1}, \\tilde{Z}_{s+1}, \\dots, \\tilde{X}_{s+r}, \\tilde{Z}_{s+r} \\rangle \\) with \\( s + r \\leq n \\). The logical group is choosen as \\( \\mathsf{L} = N(\\mathsf{S})/\\mathsf{G} \\simeq \\langle \\tilde{X}_{s+r+1},\\tilde{Z}_{s+r+1}, \\dots, \\tilde{X}_n,\\tilde{Z}_n \\rangle \\). Now the codespace \\( C \\) is as usual the \\(+1\\) eigenspace of the stabilizer \\( \\mathsf{S} \\). But the gauge and logical groups have further decomposed this space into \\( C = A \\otimes B \\simeq (\\mathbb{C}^2)^{\\otimes k} \\otimes (\\mathbb{C}^2)^{\\otimes r} \\). Thus the Hilbert space is partitioned into 3 sets; \\(k\\) logical qubits, \\(r\\) gauge qubits, and \\(s\\) stabilizer qubits, with \\(s+r+k=n\\). ", "parents_code_id": "oecc", "parents_detail": "", "parent_of_code_id": "topological_abelian\nbravyi_bacon_shor\nheavy_hex\nsubsystem_color\nsubsystem_surface", "parent_of_detail": "All premodular abelian topological orders can be realized as modular-qudit subsystem stabilizer codes [Tyler D. Ellison et al., \u201cPauli topological subsystem codes from Abelian anyon theories\u201d. 2211.03798].\n\n\n\n", "cousins_code_id": "qubit_stabilizer", "cousins_detail": "Subsystem stabilizer codes reduce to stabilizer codes when there are no gauge qubits.", "cousin_of_code_id": "balanced_product\ndistance_balanced\nfloquet\nqudit_subsystem_stabilizer", "cousin_of_detail": "Distance balancing is used to form balanced-product subsystem codes [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].\n\nThis code can be viewed as a subsystem stabilizer code, albeit one with less logical qubits.\nSubsystem modular-qudit stabilizer codes reduce to subsystem qubit stabilizer codes for qudit dimension \\(q=2\\).", "_type": "ecc", "_page_id": "c_subsystem_stabilizer", "_href": "c/subsystem_stabilizer"}, "c_bacon_shor": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively [Yoder, Theodore., DSpace@MIT Practical Fault-Tolerant Quantum Computation (2018)].", "features_threshold": "A lower bound of \\(1.94 \\times 10^{-4}\\) for the accuracy threshold was proved for Bacon-Shor code with 5 levels of concatenation, using Steane method of FTEC [P. Aliferis and A. W. Cross, \u201cSubsystem Fault Tolerance with the Bacon-Shor Code\u201d, Physical Review Letters 98, (2007). DOI; quant-ph/0610063].\nThe three dimensional version offers the possibility of being a self-correcting quantum memory [D. Bacon, \u201cOperator quantum error-correcting subsystems for self-correcting quantum memories\u201d, Physical Review A 73, (2006). DOI; quant-ph/0506023].", "features_rate": "A non-LDPC family of Bacon-Shor codes achieves a distance of \\(\\Omega(n^{1-\\epsilon})\\) with sparse gauge operators.", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "While check operators are few-body, stabilizer weights scale with the number of qubits, and stabilizer expectation values are obtained by taking products of gauge-operator expectation values. It is thus not clear how to extract stabilizer values in a fault-tolerant manner [Matthew B. Hastings, Jeongwan Haah, and Ryan O'Donnell, \u201cFiber Bundle Codes: Breaking the $N^{1/2} \\operatorname{polylog}(N)$ Barrier for Quantum LDPC Codes\u201d. 2009.03921][M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].", "features_transversal_gates": "Logical Hadamard is transversal in symmetric Bacon-Shor codes up to a qubit permutation [P. Aliferis and A. W. Cross, \u201cSubsystem Fault Tolerance with the Bacon-Shor Code\u201d, Physical Review Letters 98, (2007). DOI; quant-ph/0610063] and can be implemented with teleportation [X. Zhou, D. W. Leung, and I. L. Chuang, \u201cMethodology for quantum logic gate construction\u201d, Physical Review A 62, (2000). DOI; quant-ph/0002039]. Bacon-Shor codes on an \\(m \\times mk\\) lattice admit transversal \\(k\\)-qubit-controlled \\(Z\\) gates [Theodore J. Yoder, \u201cUniversal fault-tolerant quantum computation with Bacon-Shor codes\u201d. 1705.01686].", "features_fault_tolerance": "Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively [Yoder, Theodore., DSpace@MIT Practical Fault-Tolerant Quantum Computation (2018)].", "name": "Bacon-Shor code", "code_id": "bacon_shor", "realizations": "Trapped-ion qubits: state preparation, logical measurement, and stabilizer measurement for nine-qubit Bacon-Shor code demonstrated on a 13-qubit device by M. Cetina and C. Monroe groups [Laird Egan et al., \u201cFault-Tolerant Operation of a Quantum Error-Correction Code\u201d. 2009.11482].", "protection": "The \\([[m_1 m_2,1,min(m_1,m_2)]]\\) variant has distance \\(d=min(m_1,m_2)\\). In a symmetric 3-dimensional case (defined on a cubic lattice) with \\(L^3\\) qubits, the code has the parameters \\([[L^3,1,L]]\\).", "notes": "See [B. M. Terhal, \u201cQuantum error correction for quantum memories\u201d, Reviews of Modern Physics 87, 307 (2015). DOI; 1302.3428; Sec. III.C1] for an exposition.", "physical": "qubits", "short_name": "", "introduced": "[P. W. Shor, \u201cScheme for reducing decoherence in quantum computer memory\u201d, Physical Review A 52, R2493 (1995). DOI][D. Bacon, \u201cOperator quantum error-correcting subsystems for self-correcting quantum memories\u201d, Physical Review A 73, (2006). DOI; quant-ph/0506023]", "description": "CSS subsystem stabilizer code defined on an \\(m_1 \\times m_2\\) lattice of qubits. It is said to be symmetric when \\(m_1=m_2\\). The \\(X\\)-type and \\(Z\\)-type stabilizers defined as \\(X\\) and \\(Z\\) operators acting on all qubits on adjacent columns and rows, respectively. Let \\(O_{i,j}\\) denote an operator acting on the qubit at a position \\((i,j)\\) on the lattice, with \\(i\\in\\{0,1,\\ldots ,m_1-1\\}\\) and \\(j\\in\\{0,1,\\ldots,m_2-1\\}\\). The code's stabilizer group is \\begin{align}\n\\mathsf{S}=\\langle X_{i,*}X_{i+1,*},Z_{*,j}Z_{*,j+1}\\rangle~,\n\\end{align} with generators expressed as products of nearest-neightbour 2-qubit gauge operators, \\begin{align}\n\\begin{split}\nX_{i,*}X_{i+1,*}= \\bigotimes_{k=0}^{m_2-1} X_{i,k}X_{i+1,k} \\\\\nZ_{*,j}Z_{*,j+1}=\\bigotimes_{k=0}^{m_1-1} Z_{k,j}Z_{k,j+1}~.\n\\end{split}\n\\end{align} Syndrome extraction can be done by measuring these gauge operators, which are on fewer qubits and local.\n\nThe error-detecting \\([[4,1,2]]\\) Bacon-Shor code, which reduces to a subcode of the \\([[4,2,2]]\\) code for a particular gauge configuration, has gauge operators \\(\\{XIXI,IIXX,ZIZI,IZIZ\\}\\). The shortest error-correcting Bacon-Shor code is \\([[9,1,3]]\\) with four stabilizer generators \\begin{align}\n  \\begin{array}{ccccccccc}\n    X & X & X & X & X & X & I & I & I\\\\\n    I & I & I & X & X & X & X & X & X\\\\\n    Z & Z & I & Z & Z & I & Z & Z & I\\\\\n    I & Z & Z & I & Z & Z & I & Z & Z\n  \\end{array}\n\\end{align} and eight gauge generators \\begin{align}\n  \\begin{array}{ccccccccc}\n  X & I & I & X & I & I & I & I & I\\\\\n  I & X & I & I & X & I & I & I & I\\\\\n  I & I & I & X & I & I & X & I & I\\\\\n  I & I & I & I & X & I & I & X & I\\\\\n  Z & Z & I & I & I & I & I & I & I\\\\\n  I & I & I & Z & Z & I & I & I & I\\\\\n  I & Z & Z & I & I & I & I & I & I\\\\\n  I & I & I & I & Z & Z & I & I & I\n  \\end{array}~.\n\\end{align} If the physical qubits are arranged in a three-by-three square, the \\(Z\\)-type (\\(X\\)-type) gauge operators are supported on qubits in the same row (column). The code reduces to the Shor code for a particular gauge configuration. ", "parents_code_id": "bravyi_bacon_shor", "parents_detail": "", "cousins_code_id": "hamiltonian", "cousins_detail": "The 2D Bacon-Shor code Hamiltonian is the compass model [K. I. Kugel' and D. I. Khomski\u012d, \u201cThe Jahn-Teller effect and magnetism: transition metal compounds\u201d, Soviet Physics Uspekhi 25, 231 (1982). DOI][J. Dorier, F. Becca, and F. Mila, \u201cQuantum compass model on the square lattice\u201d, Physical Review B 72, (2005). DOI; cond-mat/0501708].", "cousin_of_code_id": "gnu_permutation_invariant\nheavy_hex\nquantum_parity\nself_correct", "cousin_of_detail": "Symmetrized versions of the Bacon-Shor codes are GNU codes\nBacon-Shor stabilizers are used to measure the X-type stabilizers of the code.\nBacon-Shor codes reduce to QPCs for a particular gauge configuration.\n3D Bacon-Shor codes were conjectured to be self-correcting [D. Bacon, \u201cOperator quantum error-correcting subsystems for self-correcting quantum memories\u201d, Physical Review A 73, (2006). DOI; quant-ph/0506023], but there remain issues to be resolved in order to validate this conjecture (see [B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643; Sec. IX.B]).", "_type": "ecc", "_page_id": "c_bacon_shor", "_href": "c/bacon_shor"}, "c_bravyi_bacon_shor": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Bravyi-Bacon-Shor (BBS) code", "code_id": "bravyi_bacon_shor", "realizations": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits, where \\(d\\) is the minimum weight of a row or column in \\(A\\) [Muyuan Li and Theodore J. Yoder, \u201cA Numerical Study of Bravyi-Bacon-Shor and Subsystem Hypergraph Product Codes\u201d. 2002.06257].", "notes": "", "physical": "qubits", "short_name": "BBS", "introduced": "[S. Bravyi, \u201cSubsystem codes with spatially local generators\u201d, Physical Review A 83, (2011). DOI; 1008.1029]", "description": "An \\([[n,k,d]]\\) CSS subsystem stabilizer code generalizing Bacon-Shor codes to a larger set of qubit geometries. Defined through a binary matrix \\(A\\) such that physical qubits live on sites \\((i,j)\\) whenever \\(A_{i,j}=1\\). The gauge group is generated by 2-qubit operators, including \\(XX\\) interations between any two qubits sharing a column in \\(A\\), and \\(ZZ\\) interations between two qubits sharing a row. The code parameters are: \\(n=\\sum_{i,j}A_{i,j}\\), \\(k=\\text{rank}(A)\\), and the distance is the minimum weight of any row or column.", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "parent_of_code_id": "bacon_shor", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_bravyi_bacon_shor", "_href": "c/bravyi_bacon_shor"}, "c_subsystem_color": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Subsystem color code", "code_id": "subsystem_color", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[H. Bombin, \u201cTopological subsystem codes\u201d, Physical Review A 81, (2010). DOI; 0908.4246][H. Bombin, \u201cGauge Color Codes: Optimal Transversal Gates and Gauge Fixing in Topological Stabilizer Codes\u201d. 1311.0879]", "description": "Stub. ", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "cousins_code_id": "color\nsymmetry_protected_self_correct", "cousins_detail": "\nA particular gauge-fixed version of this code on a 3D lattice yields a self-correcting memory protected by one-form symmetries (see Sec. IV D of Ref. [S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]). The symmetric energy barrier grows linearly with the length of a side of the lattice. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the side length.", "cousin_of_code_id": "honeycomb\nrbh", "cousin_of_detail": "Both honeycomb and subsystem color codes are generated via periodic sequences of measurements. However, any measurement sequence can be performed on the color code without destroying the logical qubits, while honeycomb codes can be maintained only with specific sequences. Honeycomb codes require a shorter measurement cycle and use fewer qubits at the given code distance [M. B. Hastings and J. Haah, \u201cDynamically Generated Logical Qubits\u201d, Quantum 5, 564 (2021). DOI; 2107.02194].\nThe RBH code on a certain lattice is dual to the gauge color code.", "_type": "ecc", "_page_id": "c_subsystem_color", "_href": "c/subsystem_color"}, "c_hybrid_qudit_oscillator": {"logical": "groups", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hybrid qudit-oscillator code", "code_id": "hybrid_qudit_oscillator", "realizations": "", "protection": "", "notes": "", "physical": "qudits", "short_name": "", "introduced": "", "description": "Encodes a \\(K\\)-dimensional logical Hilbert space into \\(n_1\\) qudits of dimension \\(q\\) and \\(n_2 \\neq 0\\) oscillators, i.e., the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{Z}_q^{n_1} \\times \\mathbb{R}^{n_2}\\).", "parents_code_id": "oscillators", "parents_detail": "The physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator.", "parent_of_code_id": "very-small-logical-qubit", "parent_of_detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators.", "cousins_code_id": "qudits_into_oscillators", "cousins_detail": "Hybrid code with \\(n_1=0\\).", "_type": "ecc", "_page_id": "c_hybrid_qudit_oscillator", "_href": "c/hybrid_qudit_oscillator"}, "c_single-mode": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Single-mode bosonic code", "code_id": "single-mode", "realizations": "", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into a single bosonic mode.", "parents_code_id": "qudits_into_oscillators", "parents_detail": "", "parent_of_code_id": "bosonic_rotation\nchebyshev\ngkp\nnumopt", "parent_of_detail": "\n\n\n", "_type": "ecc", "_page_id": "c_single-mode", "_href": "c/single-mode"}, "c_oscillators_into_oscillators": {"logical": "oscillators", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Oscillator-into-oscillator code", "code_id": "oscillators_into_oscillators", "realizations": "", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[S. Lloyd and J.-J. E. Slotine, \u201cAnalog Quantum Error Correction\u201d, Physical Review Letters 80, 4088 (1998). DOI; quant-ph/9711021][S. L. Braunstein, \u201cError Correction for Continuous Quantum Variables\u201d, Physical Review Letters 80, 4084 (1998). DOI; quant-ph/9711049]", "description": "Also called an analog quantum code. Encodes \\(k\\) bosonic modes into \\(n\\) bosonic modes.", "parents_code_id": "oscillators", "parents_detail": "Oscillator-into-oscillator codes are bosonic codes with an infinite-dimensional logical subspace.", "parent_of_code_id": "analog_stabilizer\ngkp-stabilizer", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_oscillators_into_oscillators", "_href": "c/oscillators_into_oscillators"}, "c_oscillators": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Bosonic code", "code_id": "oscillators", "realizations": "", "protection": "An error set relevant to bosonic stabilizer codes is the set of displacement operators, a bosonic analogue of the Pauli string basis for qubit codes. For a single mode, its elements are products of exponentials of the mode's position and momentum operators, acting on the mode's position states \\(|y\\rangle\\) for \\(y\\in\\mathbb{R}\\) as \\begin{align}\n  e^{-iq\\hat{p}}\\left|y\\right\\rangle =\\left|y+q\\right\\rangle \\,\\,\\text{ and }\\,\\,e^{iq\\hat{x}}\\left|y\\right\\rangle =e^{iq y}\\left|y\\right\\rangle ~,\n\\end{align} where \\(q\\in\\mathbb{R}\\). For multiple modes, error set elements are tensor products of elements of the single-qudit error set, characterized by the vector of coefficients \\(\\xi\\in\\mathbb{R}^{2n}\\).\n\nThe displacement error set is a unitary basis for trace-class linear operators on the \\(n\\)-mode Hilbert space that is Dirac-orthonormal under the Hilbert-Schmidt inner product [K. E. Cahill and R. J. Glauber, \u201cOrdered Expansions in Boson Amplitude Operators\u201d, Physical Review 177, 1857 (1969). DOI]. There are two definitions of code distance associated with displacements. The definition inherited from qubit codes is the minimum weight of a displacement operator (i.e., number of nonzero entries in \\(\\xi\\)) that implements a nontrivial logical operation in the code. The second definition is the minimum Euclidean distance (i.e., \\(\\ell^2\\)-norm of \\(\\xi\\)) such that the corresponding displacement implements a nontrivial logical operation in the code.\n\nAn error set relevant to Fock-state bosonic codes is the set of loss operators associated with the amplitude damping (a.k.a. photon loss or attenuation) noise channel, a common form of physical noise in bosonic systems. For a single mode, loss operators are proportional to powers of the mode's annihilation operator \\(a=(\\hat{x}+i\\hat{p})/\\sqrt{2}\\), where \\(\\hat x\\) (\\(\\hat p\\)) is the mode's position (momentum) operator, and with the power signifying the number of particles lost during the error. For multiple modes, error set elements are tensor products of elements of the single-mode error set. A definition of distance associated with this error set is the minimum weight of a loss error that implements a nontrivial logical operation in the code.\n\nAn related error set is the set of powers of the Susskind\u2013Glogower phase operator \\(\\frac{1}{\\sqrt{a a^\\dagger}} a\\) [L. Susskind and J. Glogower, \u201cQuantum mechanical phase and time operator\u201d, Physics Physique \u0444\u0438\u0437\u0438\u043a\u0430 1, 49 (1964). DOI] and its adjoint (a.k.a. phasors [J. Bergou and B.-G. Englert, \u201cOperators of the phase. Fundamentals\u201d, Annals of Physics 209, 479 (1991). DOI]) along with Fock-space rotations generated by the occupation number operator \\(a^\\dagger a\\). These also allow one to expand trace-class operators, but do not form an orthonormal set [Victor V. Albert, \u201cBosonic coding: introduction and use cases\u201d. 2211.05714]. These operators are correspong to a polar-like decomposition of a single mode, complementing the cartesian-like decomposition in terms of position and momentum displacements.", "notes": "Reviews on bosonic codes can be found in Refs. [A. Joshi, K. Noh, and Y. Y. Gao, \u201cQuantum information processing with bosonic qubits in circuit QED\u201d, Quantum Science and Technology 6, 033001 (2021). DOI; 2008.13471][W. Cai et al., \u201cBosonic quantum error correction codes in superconducting quantum circuits\u201d, Fundamental Research 1, 50 (2021). DOI; 2010.08699][Steven M. Girvin, \u201cIntroduction to Quantum Error Correction and Fault Tolerance\u201d. 2111.08894][Victor V. Albert, \u201cBosonic coding: introduction and use cases\u201d. 2211.05714].\nFor an introduction to continuous-variable quantum systems, see the books [N. J. Cerf, G. Leuchs, and E. S. Polzik, Quantum Information with Continuous Variables of Atoms and Light (PUBLISHED BY IMPERIAL COLLEGE PRESS AND DISTRIBUTED BY WORLD SCIENTIFIC PUBLISHING CO., 2007). DOI][A. Serafini, \u201cQuantum Continuous Variables\u201d, [] (2017). DOI].", "physical": "oscillators", "short_name": "", "introduced": "", "description": "Also called an oscillator or a continuous-variable (CV) code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one oscillator (a.k.a. bosonic mode or qumode). States of a single oscillator are elements of the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}\\)). Ideal codewords may not be normalizable because the space is infinite-dimensional, so approximate versions have to be constructed in practice.", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "oscillator_stabilizer\ncoherent_constellation\nhybrid_qudit_oscillator\noscillators_into_oscillators\nqudits_into_oscillators", "parent_of_detail": "\n\nThe physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator.\nOscillator-into-oscillator codes are bosonic codes with an infinite-dimensional logical subspace.\nQudit-into-oscillator codes are bosonic codes with a finite-dimensional logical subspace.", "cousin_of_code_id": "fermions\ngroup_quantum", "cousin_of_detail": "Bosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom.\nGroup quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes.", "_type": "ecc", "_page_id": "c_oscillators", "_href": "c/oscillators"}, "c_qudits_into_oscillators": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Given an encoding of a finite-dimensional code, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [K. Audenaert and B. De Moor, \u201cOptimizing completely positive maps using semidefinite programming\u201d, Physical Review A 65, (2002). DOI; quant-ph/0109155][M. Reimpell and R. F. Werner, \u201cIterative Optimization of Quantum Error Correcting Codes\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0307138] (see also Ref. [Andrew S. Fletcher, \u201cChannel-Adapted Quantum Error Correction\u201d. 0706.3400]). This approximate QEC technique can be adapted to bosonic codes as long as they are restricted to a finite-dimensional subspace of the oscillator Hilbert space [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Qudit-into-oscillator code", "code_id": "qudits_into_oscillators", "realizations": "", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into \\(n\\) bosonic modes.", "parents_code_id": "oscillators", "parents_detail": "Qudit-into-oscillator codes are bosonic codes with a finite-dimensional logical subspace.", "parent_of_code_id": "fock_state\ngkp-cluster-state\nsingle-mode", "parent_of_detail": "\n\n", "cousins_code_id": "approximate_qecc", "cousins_detail": "Approximate QEC techniques of finding the entanglement fidelity can be adapted to bosonic codes with a finite-dimensional codespace [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].", "cousin_of_code_id": "hybrid_qudit_oscillator", "cousin_of_detail": "Hybrid code with \\(n_1=0\\).", "_type": "ecc", "_page_id": "c_qudits_into_oscillators", "_href": "c/qudits_into_oscillators"}, "c_very-small-logical-qubit": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Single logical qubit operations implemented by resonant physical qubit driving and phase shifting the SQUID drives.\nA CZ gate between two logical qubits implemented by coupling devices through another driven SQUID and applying a pulse to the coupling squid simultaneously with a single qubit operation on one of the logical qubits.", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Engineering a circuit made of two transmons and two oscillators coupled through three driven superconducting quantum interference devices (SQUIDs) results in passive stabilization of the logical states.", "features_decoders": "Logical qubit can be measured with physical qubit measurements along \\(X\\). Can be implemented by engineering a coupling of one of the qubits to a readout cavity via the interaction \\(\\sigma_x (a+a^\\dagger)\\) [N. Didier, J. Bourassa, and A. Blais, \u201cFast Quantum Nondemolition Readout by Parametric Modulation of Longitudinal Qubit-Oscillator Interaction\u201d, Physical Review Letters 115, (2015). DOI]. This results in an \\(X\\)-dependent shift of the readout cavity resonance which can be measured.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Very small logical qubit (VSLQ) code", "code_id": "very-small-logical-qubit", "realizations": "", "protection": "Passively protects against single photon loss.", "notes": "", "physical": "groups", "short_name": "VSLQ", "introduced": "[E. Kapit, \u201cHardware-Efficient and Fully Autonomous Quantum Error Correction in Superconducting Circuits\u201d, Physical Review Letters 116, (2016). DOI]", "description": "The two logical codewords are \\(|\\pm\\rangle \\propto (|0\\rangle\\pm|2\\rangle)(|0\\rangle\\pm|2\\rangle)|0\\rangle|0\\rangle\\), where the total Hilbert space is the tensor product of two qudits (whose ground states \\(|0\\rangle\\) and second excited states \\(|2\\rangle\\) are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.", "parents_code_id": "hybrid_qudit_oscillator", "parents_detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators.", "cousins_code_id": "quantum_repetition", "cousins_detail": "Parts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss.", "_type": "ecc", "_page_id": "c_very-small-logical-qubit", "_href": "c/very-small-logical-qubit"}, "c_two-legged-cat": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Universal gates in the quantum optical setting can be performed using teleportation, Bell measurements, displacements, and rotations [T. C. Ralph et al., \u201cQuantum computation with optical coherent states\u201d, Physical Review A 68, (2003). DOI; quant-ph/0306004]. An earlier protocol requires a non-linear interaction and uses state teleportation [H. Jeong and M. S. Kim, \u201cEfficient quantum computation using coherent states\u201d, Physical Review A 65, (2002). DOI; quant-ph/0109077].\nUniversal gates in the microwave setting can be performed using displacement operators and a rotation based on the Kerr nonlinearity [M. Mirrahimi et al., \u201cDynamically protected cat-qubits: a new paradigm for universal quantum computation\u201d, New Journal of Physics 16, 045014 (2014). DOI; 1312.2017]. Kerr nonlinearity converts coherent states into Yurke-Stoler states [B. Yurke and D. Stoler, \u201cGenerating quantum mechanical superpositions of macroscopically distinguishable states via amplitude dispersion\u201d, Physical Review Letters 57, 13 (1986). DOI].\nBias-preserving Hamiltonian-based CNOT gate utilizing an \\(X\\) gate with a topological Berry phase [J. Guillaud and M. Mirrahimi, \u201cRepetition Cat Qubits for Fault-Tolerant Quantum Computation\u201d, Physical Review X 9, (2019). DOI; 1904.09474][S. Puri et al., \u201cBias-preserving gates with stabilized cat qubits\u201d, Science Advances 6, (2020). DOI; 1905.00450]. Bias-preserving SWAP gate [J. Guillaud and M. Mirrahimi, \u201cError rates and resource overheads of repetition cat qubits\u201d, Physical Review A 103, (2021). DOI; 2009.10756].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Lindbladian-based dissipative encoding [M. Mirrahimi et al., \u201cDynamically protected cat-qubits: a new paradigm for universal quantum computation\u201d, New Journal of Physics 16, 045014 (2014). DOI; 1312.2017] utilizing two-photon absorption [M. Wolinsky and H. J. Carmichael, \u201cQuantum noise in the parametric oscillator: From squeezed states to coherent-state superpositions\u201d, Physical Review Letters 60, 1836 (1988). DOI][L. Krippner, W. J. Munro, and M. D. Reid, \u201cTransient macroscopic quantum superposition states in degenerate parametric oscillation: Calculations in the large-quantum-noise limit using the positive<i>P</i>representation\u201d, Physical Review A 50, 4330 (1994). DOI][E. E. Hach III and C. C. Gerry, \u201cGeneration of mixtures of Schr\u00f6dinger-cat states from a competitive two-photon process\u201d, Physical Review A 49, 490 (1994). DOI][L. Gilles, B. M. Garraway, and P. L. Knight, \u201cGeneration of nonclassical light by dissipative two-photon processes\u201d, Physical Review A 49, 2785 (1994). DOI]. Encoding passively protects against cavity dephasing, suppressing dephasing noise exponentially with \\(|\\alpha|^2\\) [M. Mirrahimi et al., \u201cDynamically protected cat-qubits: a new paradigm for universal quantum computation\u201d, New Journal of Physics 16, 045014 (2014). DOI; 1312.2017].\nHamiltonian-based 'Kerr-cat' encoding utilizing the Kerr-effect Hamiltonian [S. Puri, S. Boutin, and A. Blais, \u201cEngineering the quantum states of light in a Kerr-nonlinear resonator by two-photon driving\u201d, npj Quantum Information 3, (2017). DOI; 1605.09408] (see also Ref. [H. Goto, \u201cBifurcation-based adiabatic quantum computation with a nonlinear oscillator network\u201d, Scientific Reports 6, (2016). DOI; 1510.02566]).\nColored dissipation [H. Putterman et al., \u201cStabilizing a Bosonic Qubit Using Colored Dissipation\u201d, Physical Review Letters 128, (2022). DOI; 2107.09198].\nCombined dissipative and Hamiltonian-based encoding utilizing two-photon exchange with an ancillary qubit [Ronan Gautier, Alain Sarlette, and Mazyar Mirrahimi, \u201cCombined Dissipative and Hamiltonian Confinement of Cat Qubits\u201d. 2112.05545].\nCritical encoding at non-zero detuning [Luca Gravina, Fabrizio Minganti, and Vincenzo Savona, \u201cA critical dissipative Schr\u00f6dinger cat qubit\u201d. 2208.04928].", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "Fault-tolerant error-correction procedure using small amplitude coherent states [A. P. Lund, T. C. Ralph, and H. L. Haselgrove, \u201cFault-Tolerant Linear Optical Quantum Computing with Small-Amplitude Coherent States\u201d, Physical Review Letters 100, (2008). DOI; 0707.0327].\nBias-preserving Hamiltonian-based CNOT gate [S. Puri et al., \u201cBias-preserving gates with stabilized cat qubits\u201d, Science Advances 6, (2020). DOI; 1905.00450] is part of a universal bias-preserving gate set that can be made fault tolerant using concatenation [J. Guillaud and M. Mirrahimi, \u201cRepetition Cat Qubits for Fault-Tolerant Quantum Computation\u201d, Physical Review X 9, (2019). DOI; 1904.09474][S. Puri et al., \u201cBias-preserving gates with stabilized cat qubits\u201d, Science Advances 6, (2020). DOI; 1905.00450].\nAncilla qubits encoded in two-component cat codes yield fault-tolerant syndrome extraction circuits [S. Puri et al., \u201cStabilized Cat in a Driven Nonlinear Cavity: A Fault-Tolerant Error Syndrome Detector\u201d, Physical Review X 9, (2019). DOI; 1807.09334].", "name": "Two-component cat code", "code_id": "two-legged-cat", "realizations": "Lindbladian-based [Z. Leghtas et al., \u201cConfining the state of light to a quantum manifold by engineered two-photon loss\u201d, Science 347, 853 (2015). DOI; 1412.4633][S. Touzard et al., \u201cCoherent Oscillations inside a Quantum Manifold Stabilized by Dissipation\u201d, Physical Review X 8, (2018). DOI; 1705.02401] and Hamiltonian-based 'Kerr-cat' [A. Grimm et al., \u201cStabilization and operation of a Kerr-cat qubit\u201d, Nature 584, 205 (2020). DOI; 1907.12131] encodings have been achieved in superconducting circuit devices by the Devoret group; Ref. [S. Touzard et al., \u201cCoherent Oscillations inside a Quantum Manifold Stabilized by Dissipation\u201d, Physical Review X 8, (2018). DOI; 1705.02401] also demonstrated a displacement-based gate. The Lindbladian-based scheme has further achieved a suppression of bit-flip errors that is exponential in the average photon number [R. Lescanne et al., \u201cExponential suppression of bit-flips in a qubit encoded in an oscillator\u201d, Nature Physics 16, 509 (2020). DOI; 1907.11729] up to a bit-flip time of 1ms. A bit-flip time of 1s has been achieved in a similar system in the classical bit regime [C. Berdou et al., \u201cOne hundred second bit-flip time in a two-photon dissipative oscillator\u201d. 2204.09128].\nApproximate version realized in a superconducting circuit device by the Wang group [J. M. Gertler et al., \u201cProtecting a bosonic qubit with autonomous quantum error correction\u201d, Nature 590, 243 (2021). DOI; 2004.09322].", "protection": "Two-legged cat codes for large \\(\\alpha\\) provide protection against modal dephasing, i.e., diffusion of the angular degree of freedom of the mode. They do not protect against photon loss events, but there exist modifications based on sign alternation [L. Li et al., \u201cPhase-engineered bosonic quantum codes\u201d, Physical Review A 103, (2021). DOI; 1901.05358], squeezing [David S. Schlegel, Fabrizio Minganti, and Vincenzo Savona, \u201cQuantum error correction using squeezed Schr\u00f6dinger cat states\u201d. 2201.02570][Qian Xu et al., \u201cAutonomous quantum error correction and fault-tolerant quantum computation with squeezed cat qubits\u201d. 2210.13406][Qian Xu et al., \u201cAutonomous quantum error correction and fault-tolerant quantum computation with squeezed cat qubits\u201d. 2210.13406], and detuning [Diego Ruiz et al., \u201cTwo-photon driven Kerr quantum oscillator with multiple spectral degeneracies\u201d. 2211.03689] that can add such protection.", "notes": "Pedagogical introduction to cat codes in the context of microwave cavities can be found in Refs. [J\u00e9r\u00e9mie Guillaud, Joachim Cohen, and Mazyar Mirrahimi, \u201cQuantum computation with cat qubits\u201d. 2203.03222][Shruti Puri, QEC when the noise is biased, 2019.], and in the context of optical systems in books [S. Haroche and J.-M. Raimond, Exploring the Quantum (Oxford University Press, 2006). DOI][H. Jeong and T. C. Ralph, \u201cSchr\u00f6dinger Cat States for Quantum Information Processing\u201d, Quantum Information with Continuous Variables of Atoms and Light 159 (2007). DOI][H. Bachor and T. C. Ralph, A Guide to Experiments in Quantum Optics (Wiley, 2019). DOI].", "physical": "oscillators", "short_name": "", "introduced": "[P. T. Cochrane, G. J. Milburn, and W. J. Munro, \u201cMacroscopically distinct quantum-superposition states as a bosonic code for amplitude damping\u201d, Physical Review A 59, 2631 (1999). DOI; quant-ph/9809037]", "description": "Code whose codespace is spanned by two coherent states \\(\\left|\\pm\\alpha\\right\\rangle\\) for nonzero complex \\(\\alpha\\). An orthonormal basis for the codespace consists of the bosonic cat states \\begin{align}\n  |\\overline{\\pm}\\rangle=\\frac{\\left|\\alpha\\right\\rangle \\pm\\left|-\\alpha\\right\\rangle }{\\sqrt{2\\left(1\\pm e^{-2|\\alpha|^{2}}\\right)}}\n\\end{align} for any complex \\(\\alpha\\). ", "parents_code_id": "cat", "parents_detail": "The cat code reduces to its two-component version for \\(S=0\\)", "cousins_code_id": "hamiltonian", "cousins_detail": "Two-legged cat codewords form ground-state subspace of a Kerr Hamiltonian [S. Puri, S. Boutin, and A. Blais, \u201cEngineering the quantum states of light in a Kerr-nonlinear resonator by two-photon driving\u201d, npj Quantum Information 3, (2017). DOI; 1605.09408].", "cousin_of_code_id": "bpsk", "cousin_of_detail": "The two-component cat code is a quantum analogue of BPSK.", "_type": "ecc", "_page_id": "c_two-legged-cat", "_href": "c/two-legged-cat"}, "c_cat": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Holonomic gates utilizing the Berry phase of coherent states are universal [V. V. Albert et al., \u201cHolonomic Quantum Control with Continuous Variable Systems\u201d, Physical Review Letters 116, (2016). DOI; 1503.00194].\nUniversal gates in the microwave setting for the \\(S=1\\) code can be performed using squeezing operators and a rotation based on the Kerr nonlinearity [M. Mirrahimi et al., \u201cDynamically protected cat-qubits: a new paradigm for universal quantum computation\u201d, New Journal of Physics 16, 045014 (2014). DOI; 1312.2017].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Lindbladian-based dissipative encoding utilizing multi-photon generalization of two-photon absorption [M. Wolinsky and H. J. Carmichael, \u201cQuantum noise in the parametric oscillator: From squeezed states to coherent-state superpositions\u201d, Physical Review Letters 60, 1836 (1988). DOI][L. Krippner, W. J. Munro, and M. D. Reid, \u201cTransient macroscopic quantum superposition states in degenerate parametric oscillation: Calculations in the large-quantum-noise limit using the positive<i>P</i>representation\u201d, Physical Review A 50, 4330 (1994). DOI][E. E. Hach III and C. C. Gerry, \u201cGeneration of mixtures of Schr\u00f6dinger-cat states from a competitive two-photon process\u201d, Physical Review A 49, 490 (1994). DOI][L. Gilles, B. M. Garraway, and P. L. Knight, \u201cGeneration of nonclassical light by dissipative two-photon processes\u201d, Physical Review A 49, 2785 (1994). DOI]. Encoding passively protects against modal dephasing, suppressing dephasing noise exponentially with \\(|\\alpha|^2\\) [M. Mirrahimi et al., \u201cDynamically protected cat-qubits: a new paradigm for universal quantum computation\u201d, New Journal of Physics 16, 045014 (2014). DOI; 1312.2017].", "features_decoders": "Measuring the Fock-state number modulo \\(2S\\) can be used to determine if photon loss or excitation errors occurred.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Cat code", "code_id": "cat", "realizations": "Four-legged (\\(S=1\\)) cat code has been realized in a superconducting circuit device [Nissim Ofek et al., \u201cDemonstrating Quantum Error Correction that Extends the Lifetime of Quantum Information\u201d. 1602.04768]. This paper is the first to reach break-even error-correction, where the lifetime of a logical qubit is on par with the lifetime of the noisiest constituent of the system.", "protection": "Due to the spacing between sets of Fock states, the distance between two distinct logical states is \\(d=S+1\\). Hence, this code is able to detect \\(S\\)-photon loss error.", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[Z. Leghtas et al., \u201cHardware-Efficient Autonomous Quantum Memory Protection\u201d, Physical Review Letters 111, (2013). DOI; 1207.0679]", "description": "Rotation-symmetric bosonic Fock-state code encoding a \\(q\\)-dimensional qudit into one oscillator. Codewords for a qubit code (\\(q=2\\)) consist of a coherent state \\(|\\alpha\\rangle\\) projected onto a subspace of Fock state number modulo \\(2(S+1)\\). The logical state \\(|\\overline{0}\\rangle\\) is in the \\(\\{|0\\rangle , |2(S+1)\\rangle , |4(S+1)\\rangle \\cdots \\}\\) Fock-state subspace, while \\(|\\overline{1}\\rangle\\) is in the \\(\\{|(S+1)\\rangle, |3(S+1)\\rangle , |5(S+1)\\rangle , |7(S+1)\\rangle \\cdots \\}\\) subspace. An alternative basis, valid for general \\(q\\) and \\(\\alpha\\neq 0\\), consists of \\(q\\) coherent states distributed equidistantly around a circle in phase space of radius \\(\\alpha\\). ", "parents_code_id": "bosonic_rotation\ncoherent_constellation", "parents_detail": "The cat code is a bosonic rotation code whose primitive state is the coherent state \\(|\\alpha\\rangle\\) [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nCat-code codewords are constructed using a coherent-state constellation that forms the cyclic group \\(\\mathbb{Z}_{2S+2}\\).", "parent_of_code_id": "two-legged-cat", "parent_of_detail": "The cat code reduces to its two-component version for \\(S=0\\)", "cousins_code_id": "number_phase", "cousins_detail": "In the limit as \\(N,S \\to \\infty\\), phase measurement in the cat code has vanishing variance, just like in a number-phase code [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "cousin_of_code_id": "binomial\npaircat\npsk", "cousin_of_detail": "For a fixed \\(S\\), binomial codes with \\(N \\to \\infty\\) coincide with cat codes as \\(\\alpha \\to \\infty\\) [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008].\nCat (pair-cat) codewords are superpositions of coherent (pair-coherent) states. Many cat-code protocols have analogues for the two-mode pair-cat codes.\nThe cat code is a quantum analogue of PSK for \\(q=2S\\).", "_type": "ecc", "_page_id": "c_cat", "_href": "c/cat"}, "c_coherent_constellation": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Coherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the quantum capacity of the thermal noise channel [F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent-state constellations and polar codes for thermal Gaussian channels\u201d, Physical Review A 95, (2017). DOI; 1603.05970][F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent state constellations for Bosonic Gaussian channels\u201d, 2016 IEEE International Symposium on Information Theory (ISIT) (2016). DOI].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Coherent-state constellation quantum code", "code_id": "coherent_constellation", "realizations": "", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "", "description": "Qudit-into-oscillator code whose codewords can succinctly be expressed as superpositions of a countable set of coherent states that is called a constellation. Some useful constellations form a group (see gkpcat or \\(2T\\)-qutrit codes) while others make up a Gaussian quadrature rule [F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent-state constellations and polar codes for thermal Gaussian channels\u201d, Physical Review A 95, (2017). DOI; 1603.05970][F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent state constellations for Bosonic Gaussian channels\u201d, 2016 IEEE International Symposium on Information Theory (ISIT) (2016). DOI]. ", "parents_code_id": "oscillators", "parents_detail": "", "parent_of_code_id": "2t_qutrit\ncat\nmultimodegkp", "parent_of_detail": "\\(2T\\)-qutrit codewords are constructed using a coherent-state constellation that forms the binary tetrahedral group \\(2T\\).\nCat-code codewords are constructed using a coherent-state constellation that forms the cyclic group \\(\\mathbb{Z}_{2S+2}\\).\nGKP codewords can be written as superpositions of coherent states lying on a lattice in phase space [D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].", "cousins_code_id": "quantum_polar\nquantum_concatenated\nanalog", "cousins_detail": "Coherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the quantum capacity of the thermal noise channel [F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent-state constellations and polar codes for thermal Gaussian channels\u201d, Physical Review A 95, (2017). DOI; 1603.05970][F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent state constellations for Bosonic Gaussian channels\u201d, 2016 IEEE International Symposium on Information Theory (ISIT) (2016). DOI].\nCoherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the quantum capacity of the thermal noise channel [F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent-state constellations and polar codes for thermal Gaussian channels\u201d, Physical Review A 95, (2017). DOI; 1603.05970][F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent state constellations for Bosonic Gaussian channels\u201d, 2016 IEEE International Symposium on Information Theory (ISIT) (2016). DOI].\nCoherent-state constellation codes are quantum versions of analog codes in that their codewords are superpositions of points in a constellation. Additionally, analog codes that achieve AGWN capacity [Y. Wu and S. Verdu, \u201cThe impact of constellation cardinality on Gaussian channel capacity\u201d, 2010 48th Annual Allerton Conference on Communication, Control, and Computing (Allerton) (2010). DOI] can be used to develop capacity-achieving concatenations of coherent-state constellation codes with quantum polar codes [F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent-state constellations and polar codes for thermal Gaussian channels\u201d, Physical Review A 95, (2017). DOI; 1603.05970][F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent state constellations for Bosonic Gaussian channels\u201d, 2016 IEEE International Symposium on Information Theory (ISIT) (2016). DOI].", "_type": "ecc", "_page_id": "c_coherent_constellation", "_href": "c/coherent_constellation"}, "c_2t_qutrit": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Logical phase-flip can be implemented using an excitation-preserving Gaussian transformation. Degree-four polynomial in the lowering operators of the two modes serves as a non-unitary logical bit-flip. Rotations of either mode by \\(\\pi/4\\) are logical gates that swap two logical codewords.", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "2T-qutrit code", "code_id": "2t_qutrit", "realizations": "", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "", "description": "Two-mode qutrit code constructed out of superpositions of coherent states whose amplitudes make up the binary tetrahedral group \\(2T\\). The codespace is a particular three-dimensional subspace of the 24-dimensional two-mode coherent-state subspace, \\begin{align}\n  \\mathrm{Span}( \\{|\\sqrt{2} e^{i (2k+1) \\pi/4} \\alpha\\rangle |0\\rangle,  |0\\rangle |\\sqrt{2} e^{i (2k+1) \\pi/4} \\alpha\\rangle, |e^{i k\\pi/2} \\alpha\\rangle |e^{i \\ell \\pi/2} \\alpha\\rangle \\: : \\: 0\\leq  k, \\ell \\leq 3\\})\n\\end{align} for any \\(\\alpha \\geq 0\\). A basis can be constructed whose elements are equal superpositions of coherent states whose amplitudes make up cosets of the quaternion subgroup \\(Q\\) in \\(2T\\). ", "parents_code_id": "coherent_constellation", "parents_detail": "\\(2T\\)-qutrit codewords are constructed using a coherent-state constellation that forms the binary tetrahedral group \\(2T\\).", "cousins_code_id": "chuang-leung-yamamoto", "cousins_detail": "The \\(2T\\)-qutrit code reduces to the two-mode \"0-2-4\" CLY code as \\(\\alpha\\to 0\\).", "_type": "ecc", "_page_id": "c_2t_qutrit", "_href": "c/2t_qutrit"}, "c_homological_cv": {"logical": "oscillators", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Encoding depends on the specific dimension, but can generally be done using generalized conditional-rotation and Fourier-transform gates.", "features_decoders": "Decoding requires a different circuit for each possible erasure error, with no general circuit decoding any possible erasure error. Every circuit relies on a generalized conditional rotation, which Ref. [P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544] calls the QND Gate and which is defined as \\(QND_c | x , y \\rangle = |x + c y, y \\rangle\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Homological bosonic code", "code_id": "homological_cv", "realizations": "", "protection": "Protects against certain types of erasure errors (depending on the specific dimension). Certain constructions also protect arbitrary sized errors on multiple photon states.", "notes": "Proposed experimental optical procedure for realizing the simplest non-trival code with 5 modes [P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544].", "physical": "oscillators", "short_name": "", "introduced": "[P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544]", "description": "An \\([[n,1]]_{\\mathbb{R}}\\) Gaussian CSS code defined using homological structres associated with an \\(n-1\\) simplex. Relevant to the study of spacetime replication of quantum information [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913].\n\nStabilizer generators are defined by two orthogonal subspaces of the \\(C_1\\) in the chain complex. \\(C_X = \\partial_2 C_2\\) and \\(C_P = \\partial_1^T Q\\) for some \\(Q \\subset C_0\\). The standard approach would use \\(Q = C_0\\), which would mean the logical dimension would be the dimension of the 1st homology group \\(H^1\\). However, \\(H^1\\) is trivial for the \\(n-1\\) simplex, so one chooses \\(Q \\neq C_0\\) such that exactly one stabilizer is removed, yielding a stabilizer code instead of a single stabilized state. ", "parents_code_id": "analog_stabilizer", "parents_detail": "", "cousins_code_id": "css\nniset_andersen_cerf\nspacetime", "cousins_detail": "CSS and homological CV codes utilize chain complexes in code construction, with the latter complexes having trivial homology.\nThe Niset-Andersen-Cerf code can be viewed as a scheme to replicate quantum information in multiple regions [P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544].\nHomological CV codes have been considered in the context of spacetime replication of quantum data [P. Hayden and A. May, \u201cSummoning information in spacetime, or where and when can a qubit be?\u201d, Journal of Physics A: Mathematical and Theoretical 49, 175304 (2016). DOI; 1210.0913][P. Hayden et al., \u201cSpacetime replication of continuous variable quantum information\u201d, New Journal of Physics 18, 083043 (2016). DOI; 1601.02544], while STCs are designed to replicate classical data.", "_type": "ecc", "_page_id": "c_homological_cv", "_href": "c/homological_cv"}, "c_analog_surface": {"logical": "oscillators", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Shift-based decoder [C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Analog surface code", "code_id": "analog_surface", "realizations": "", "protection": "", "notes": "See [B. M. Terhal, \u201cQuantum error correction for quantum memories\u201d, Reviews of Modern Physics 87, 307 (2015). DOI; 1302.3428; Sec. III.C2] for an exposition.", "physical": "oscillators", "short_name": "", "introduced": "[J. Zhang et al., \u201cAnyon statistics with continuous variables\u201d, Physical Review A 78, (2008). DOI; 0711.0820]", "description": "Also called a continuous-variable (CV) surface code. An analog CSS version of the Kitaev surface code. ", "parents_code_id": "analog_stabilizer", "parents_detail": "", "cousins_code_id": "surface", "cousins_detail": "The analog surface code is an oscillator-into-oscillator version of the surface code.", "_type": "ecc", "_page_id": "c_analog_surface", "_href": "c/analog_surface"}, "c_lloyd_slotine": {"logical": "oscillators", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Lloyd-Slotine nine-mode code", "code_id": "lloyd_slotine", "realizations": "Optical network by the Furusawa group [Takao Aoki et al., \u201cQuantum error correction beyond qubits\u201d. 0811.3734].", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[S. Lloyd and J.-J. E. Slotine, \u201cAnalog Quantum Error Correction\u201d, Physical Review Letters 80, 4088 (1998). DOI; quant-ph/9711021]", "description": "A \\([[9,1,3]]_{\\mathbb{R}}\\) analogue CSS version of Shor's nine-qubit code. ", "parents_code_id": "analog_stabilizer", "parents_detail": "", "cousins_code_id": "shor_nine", "cousins_detail": "The Lloyd-Slotine nine-mode code is a bosonic analogue of Shor's code.", "_type": "ecc", "_page_id": "c_lloyd_slotine", "_href": "c/lloyd_slotine"}, "c_gkp": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements [B. Q. Baragiola et al., \u201cAll-Gaussian Universality and Fault Tolerance with the Gottesman-Kitaev-Preskill Code\u201d, Physical Review Letters 123, (2019). DOI; 1903.00012].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Preparation of approximate GKP states is studied both theoretically and experimentally by putting the GKP lattice inside a Gaussian envelope [B. M. Terhal and D. Weigand, \u201cEncoding a qubit into a cavity mode in circuit QED using phase estimation\u201d, Physical Review A 93, (2016). DOI; 1506.05033][D. J. Weigand and B. M. Terhal, \u201cGenerating grid states from Schr\u00f6dinger-cat states without postselection\u201d, Physical Review A 97, (2018). DOI][P. Campagne-Ibarcq et al., \u201cQuantum error correction of a qubit encoded in grid states of an oscillator\u201d, Nature 584, 368 (2020). DOI][I. Tzitrin et al., \u201cProgress towards practical qubit computation using approximate Gottesman-Kitaev-Preskill codes\u201d, Physical Review A 101, (2020). DOI; 1910.03673].\nDissipative stabilization of finite-energy GKP states using stabilizers conjugated by a cooling ([N. C. Menicucci, \u201cFault-Tolerant Measurement-Based Quantum Computing with Continuous-Variable Cluster States\u201d, Physical Review Letters 112, (2014). DOI; 1310.7596], Appx. B) or damping operator, i.e., a damped exponential of the total occupation number [B. Royer, S. Singh, and S. M. Girvin, \u201cStabilization of Finite-Energy Gottesman-Kitaev-Preskill States\u201d, Physical Review Letters 125, (2020). DOI; 2009.07941][Brennan de Neeve et al., \u201cError correction of a logical grid state qubit by dissipative pumping\u201d. 2010.09681].\nTwo Josephson junctions coupled by a gyrator [M. Rymarz et al., \u201cHardware-Encoding Grid States in a Nonreciprocal Superconducting Circuit\u201d, Physical Review X 11, (2021). DOI; 2002.07718].", "features_decoders": "Syndrome measurement can be done by applying a controlled-displacement controlled by an ancilla qubit. The syndrome information can be obtained by measuring the ancilla qubit after controlled-displacement opearation. See Section. 2D in [A. L. Grimsmo and S. Puri, \u201cQuantum Error Correction with the Gottesman-Kitaev-Preskill Code\u201d, PRX Quantum 2, (2021). DOI; 2106.12989].\nPauli \\(X\\),\\(Y\\) and \\(Z\\) measurements can be performed by measuring \\(-\\hat{p},\\hat{x}-\\hat{p}\\) and \\(\\hat{x}\\) repectively. If the measurement outcome is closed to an even multiple of \\(\\sqrt{\\pi}\\), then the outcome is +1. If the measurement outcome is closed to an odd multiple of \\(\\sqrt{\\pi}\\), then the outcome is -1. See Section. 2D in [A. L. Grimsmo and S. Puri, \u201cQuantum Error Correction with the Gottesman-Kitaev-Preskill Code\u201d, PRX Quantum 2, (2021). DOI; 2106.12989].", "features_transversal_gates": "", "features_fault_tolerance": "Clifford gates can be realized by performing linear-optical operations, sympletic transformations and displacements, all of which are Gaussian operations. Pauli gates can be performed using displacement operators. Clifford gates are fault tolerant in the sense that they map bounded-size errors to bounded-size errors [D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040].\nError correction scheme is fault-tolerant to displacement noise as long as all input states have displacement errors less than \\(\\sqrt{\\pi}/6\\) [S. Glancy and E. Knill, \u201cError analysis for encoding a qubit in an oscillator\u201d, Physical Review A 73, (2006). DOI; quant-ph/0510107].", "name": "Gottesman-Kitaev-Preskill (GKP) code", "code_id": "gkp", "realizations": "Motional degree of freedom of a trapped ion: GKP encoding realized with the help of post-selection [C. Fl\u00fchmann et al., \u201cEncoding a qubit in a trapped-ion mechanical oscillator\u201d, Nature 566, 513 (2019). DOI; 1807.01033][C. Fl\u00fchmann and J. P. Home, \u201cDirect Characteristic-Function Tomography of Quantum States of the Trapped-Ion Motional Oscillator\u201d, Physical Review Letters 125, (2020). DOI; 1907.06478], followed by realization of reduced form of GKP error correction, where displacement error syndromes are measured to one bit of precision using an ion electronic state [Brennan de Neeve et al., \u201cError correction of a logical grid state qubit by dissipative pumping\u201d. 2010.09681].\nMicrowave cavity coupled to superconducting circuits: reduced form of GKP error correction, where displacement error syndromes are measured to one bit of precision using an ancillary transmon [P. Campagne-Ibarcq et al., \u201cQuantum error correction of a qubit encoded in grid states of an oscillator\u201d. 1907.12487].\nSingle-qubit \\(Z\\)-gate has been demonstrated in the single-photon subspace of an infinite-mode space [N. Fabre et al., \u201cGeneration of a time-frequency grid state with integrated biphoton frequency combs\u201d, Physical Review A 102, (2020). DOI; 1904.01351], in which time and frequency become bosonic conjugate variables of a single effective bosonic mode.\nIn signal processing, GKP state position-state wavefunctions are related to Dirac combs [H. G. Feichtinger and T. Strohmer, editors , Gabor Analysis and Algorithms (Birkh\u00e4user Boston, 1998). DOI].", "protection": "For stabilizer \\(\\hat{S}_q(2\\alpha),\\hat{S}_p(2\\beta)\\), code can correct displacement errors up to \\(\\frac{\\alpha}{2}\\) in the \\(q\\)-direction and \\(\\frac{\\beta}{2}\\) at \\(p\\)-direction. Approximately protects against photon loss errors [B. M. Terhal and D. Weigand, \u201cEncoding a qubit into a cavity mode in circuit QED using phase estimation\u201d, Physical Review A 93, (2016). DOI; 1506.05033][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010], outperforming most other codes designed to explicitly protect against loss [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]. Very sensitive to dephasing errors [A. L. Grimsmo and S. Puri, \u201cQuantum Error Correction with the Gottesman-Kitaev-Preskill Code\u201d, PRX Quantum 2, (2021). DOI; 2106.12989]. A biased-noise GKP error correcting code can be prepared by choosing \\(\\alpha\\neq \\beta\\).", "notes": "GKP codes were obtained after iterative numerical optimization of encoding and recovery against photon loss, starting with Haar-random states [K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].\nReviews on GKP codes presented in Refs. [B. M. Terhal, J. Conrad, and C. Vuillot, \u201cTowards scalable bosonic quantum error correction\u201d, Quantum Science and Technology 5, 043001 (2020). DOI; 2002.11008][A. L. Grimsmo and S. Puri, \u201cQuantum Error Correction with the Gottesman-Kitaev-Preskill Code\u201d, PRX Quantum 2, (2021). DOI; 2106.12989].", "physical": "oscillators", "short_name": "GKP", "introduced": "[D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040]", "description": "Bosonic qudit-into-oscillator code whose stabilizers are oscillator displacement operators \\(\\hat{S}_q(2\\alpha)=e^{-2i\\alpha \\hat{p}}\\) and \\(\\hat{S}_p(2\\beta)=e^{2i\\beta \\hat{x}}\\). To ensure \\(\\hat{S}_q(2\\alpha)\\) and \\(\\hat{S}_p(2\\beta)\\) generate a stabilizer group that is Abelian, there is another constraint that \\(\\alpha\\beta=2k\\pi\\) where \\(k\\) is an integer. Codewords can be expressed as equal weight superpositions of coherent states on an infinite lattice, such as a square lattice in phase space with spatial period \\(2\\sqrt{\\pi}\\). The exact GKP state is non-normalizable, so approximate constructs have to be considered.", "parents_code_id": "single-mode\nmultimodegkp", "parents_detail": "\n", "cousins_code_id": "approximate_qecc", "cousins_detail": "GKP codes approximately protect against photon loss [B. M. Terhal and D. Weigand, \u201cEncoding a qubit into a cavity mode in circuit QED using phase estimation\u201d, Physical Review A 93, (2016). DOI; 1506.05033][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].", "cousin_of_code_id": "number_phase\nqam\nrotor_gkp\nspin_gkp", "cousin_of_detail": "GKP codes utilize translational symmetry in phase space, while number-phase codes utilize rotational symmetry. The two are related via a mapping [Allan D. C. Tosta, Thiago O. Maciel, and Leandro Aolita, \u201cGrand Unification of continuous-variable codes\u201d. 2206.01751].\nGKP codes are quantum analogues of lattice-based QAM codes.\nGKP (rotor GKP) codes protect against shifts in linear (angular) degrees of freedom.\nSpin-GKP code construcions utilize the Holstein-Primakoff mapping [T. Holstein and H. Primakoff, \u201cField Dependence of the Intrinsic Domain Magnetization of a Ferromagnet\u201d, Physical Review 58, 1098 (1940). DOI] (see also [C. D. Cushen and R. L. Hudson, \u201cA quantum-mechanical central limit theorem\u201d, Journal of Applied Probability 8, 454 (1971). DOI]) to convert various expressions for GKP states into codes for spin systems.", "_type": "ecc", "_page_id": "c_gkp", "_href": "c/gkp"}, "c_analog_stabilizer": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "A Gaussian operation acting on position states.", "features_decoders": "Homodyne measurement of nullifiers yields real-valued syndromes, and recovery can be performed by displacements conditional on the syndromes.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Analog stabilizer code", "code_id": "analog_stabilizer", "realizations": "", "protection": "Protect against erasures of at most \\(d-1\\) modes, or arbitrarily large dispalcements on those modes. If an error operator does not commute with a nullifier, then that error is detectable. Protection of logical modes against small displacements cannot be done using only Gaussian resources [J. Niset, J. Fiur\u00e1\u0161ek, and N. J. Cerf, \u201cNo-Go Theorem for Gaussian Quantum Error Correction\u201d, Physical Review Letters 102, (2009). DOI; 0811.3128][C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047] (see also [J. Eisert, S. Scheel, and M. B. Plenio, \u201cDistilling Gaussian States with Gaussian Operations is Impossible\u201d, Physical Review Letters 89, (2002). DOI; quant-ph/0204052][G. Giedke and J. Ignacio Cirac, \u201cCharacterization of Gaussian operations and distillation of Gaussian states\u201d, Physical Review A 66, (2002). DOI; quant-ph/0204085]). There are no such restrictions for non-Gaussian noise [Peter van Loock, \u201cA note on quantum error correction with continuous variables\u201d. 0811.3616].", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "", "description": "Also known as a linear or Gaussian stabilizer code. Oscillator-into-oscillator stabilizer code encoding \\(k\\) logical modes into \\(n\\) physical modes. An \\(((n,k,d))_{\\mathbb{R}}\\) analog stabilizer code is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.\n\nAnalog stabilizer codes admit continuous stabilizer group of displacements. This group can equivalently be defined in terms of its Lie algebra. The codespace is equivalently the common \\(0\\)-eigenvalue eigenspace of the Lie algebra generators, which are mutually commuting linear combinations of oscillator position and momentum operators called nullifiers [M. Gu et al., \u201cQuantum computing with continuous-variable clusters\u201d, Physical Review A 79, (2009). DOI; 0903.3233] or annihilators. A analog stabilizer code admitting a set a set of nullifiers such that each nullifier consists of either position or momentum operators is called an analog CSS code. ", "parents_code_id": "oscillator_stabilizer\noscillators_into_oscillators", "parents_detail": "\n", "parent_of_code_id": "analog_surface\nbraunstein\nhomological_cv\nlloyd_slotine", "parent_of_detail": "\n\n\n", "cousins_code_id": "gkp-stabilizer", "cousins_detail": "Analog stabilizer codes protect logical modes against artbirarily large displacements on a few modes, while GKP-stabilizer codes protect a finite-dimensional logical space against sufficiently small displacements in any number of modes. Encoding in analog-stabilizer (GKP-stabilizer) codes can be done by a Gaussian operation acting on a tensor product of an arbitrary state in the first mode and position states (GKP states) on the remaining modes. Protection of logical modes against small displacements cannot be done using only Gaussian resources [C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047][J. Eisert, S. Scheel, and M. B. Plenio, \u201cDistilling Gaussian States with Gaussian Operations is Impossible\u201d, Physical Review Letters 89, (2002). DOI; quant-ph/0204052][J. Niset, J. Fiur\u00e1\u0161ek, and N. J. Cerf, \u201cNo-Go Theorem for Gaussian Quantum Error Correction\u201d, Physical Review Letters 102, (2009). DOI; 0811.3128], so GKP-stabilizer codes can be thought of as analog stabilizer encodings utilizing non-Gaussian GKP resource states.", "_type": "ecc", "_page_id": "c_analog_stabilizer", "_href": "c/analog_stabilizer"}, "c_oscillator_stabilizer": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Bosonic stabilizer code", "code_id": "oscillator_stabilizer", "realizations": "", "protection": "Protective properties can be delineated in terms of the nullifiers or displacements, and the most natural noise model for such codes is displacement noise. If an error operator does not commute with a stabilizer group element, then that error is detectable. Oscillator-into-oscillator stabilizer codes protect against erasures of a subset of modes, while GKP codes protect against sufficiently small displacements in any number of modes.", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[Richard L. Barnes, \u201cStabilizer Codes for Continuous-variable Quantum Error Correction\u201d. quant-ph/0405064]", "description": "Also known as a continuous-variable (CV) stabilizer code. Bosonic code whose codespace is defined as the common \\(+1\\) eigenspace of a group of mutually commuting displacement operators. Displacements form the stabilizers of the code, and have continuous eigenvalues, in contrast with the discrete set of eigenvalues of qubit stabilizers. As a result, exact codewords are non-normalizable, so approximate constructions have to be considered.\n\nStabilizer codewords encoding a finite-dimensional codespace admit a discrete infinite stabilizer group. Such qudit-into-oscillator stabilizer codes are GKP and multimode GKP codes.\n\nStabilizer codewords encoding a logical oscillator (i.e., CV quantum information) admit either a discrete or a continuous stabilizer group. The former, called GKP-stabilizer codes, are obtained from multimode GKP codes by removing stabilizer generators for some of the modes. The latter can be defined in terms of the continuous group's Lie algebra, i.e., as the common \\(0\\)-eigenvalue eigenspace of mutually commuting linear combinations of oscillator position and momentum operators called nullifiers [M. Gu et al., \u201cQuantum computing with continuous-variable clusters\u201d, Physical Review A 79, (2009). DOI; 0903.3233] or annihilators. An oscillator-into-oscillator stabilizer code encoding \\(k\\) logical modes into \\(n\\) physical modes is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.", "parents_code_id": "stabilizer\noscillators", "parents_detail": "\n", "parent_of_code_id": "analog_stabilizer\nmultimodegkp", "parent_of_detail": "\n", "cousin_of_code_id": "group_gkp\nnumber_phase", "cousin_of_detail": "The group-GKP construction encompasses all bosonic CSS codes. A singlemode qubit GKP code corresponds to the \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\) group construction, and multimode GKP codes can be similarly described. An \\([[n,k,d]]_{\\mathbb{R}}\\) analog stabilizer code corresponds to the \\(\\mathbb{R}^{ k_1} \\subseteq \\mathbb{R}^{ k_2} \\subset \\mathbb{R}^{n}\\) group construction, where \\(k=k_2/k_1\\). GKP stabilizer codes for \\(n\\) modes correspond to subgroups \\(\\mathbb{Z}^m\\) for \\(m<n\\).\nNumber-phase codewords span the joint right eigenspace of the \\(N\\)th power of the Pegg-Barnett phase operator and the bosonic rotation operator [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071]. These operators no longer form a group since the phase operator is not unitary.", "_type": "ecc", "_page_id": "c_oscillator_stabilizer", "_href": "c/oscillator_stabilizer"}, "c_gkp-stabilizer": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "Thresholds against displacement noise cannot be obtained without ideal (i.e., non-normalizable) codewords [L. Hanggli and R. Konig, \u201cOscillator-to-Oscillator Codes Do Not Have a Threshold\u201d, IEEE Transactions on Information Theory 68, 1068 (2022). DOI; 2102.05545].", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "GKP-stabilizer code", "code_id": "gkp-stabilizer", "realizations": "", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[K. Noh, S. M. Girvin, and L. Jiang, \u201cEncoding an Oscillator into Many Oscillators\u201d, Physical Review Letters 125, (2020). DOI; 1903.12615]", "description": "Stub.", "parents_code_id": "oscillators_into_oscillators\nmultimodegkp\nquantum_concatenated", "parents_detail": "\nGKP-stabilizer codes are \\(n\\)-mode GKP codes with less than \\(2n\\) stabilizers. Equivalently, they correspond to multimode GKP codes constructed using a degenerate lattice (see Appx. A of Ref. [J. Conrad, J. Eisert, and F. Arzani, \u201cGottesman-Kitaev-Preskill codes: A lattice perspective\u201d, Quantum 6, 648 (2022). DOI; 2109.14645]).\nGKP-stabilizer oscillator-into-oscillator codes concantenated with GKP qubit-into-mode codes can outperform the more conventional concatenations of GKP codes with qubit stabilizer codes [Yijia Xu et al., \u201cQubit-oscillator concatenated codes: decoding formalism & code comparison\u201d. 2209.04573].", "cousin_of_code_id": "analog_stabilizer", "cousin_of_detail": "Analog stabilizer codes protect logical modes against artbirarily large displacements on a few modes, while GKP-stabilizer codes protect a finite-dimensional logical space against sufficiently small displacements in any number of modes. Encoding in analog-stabilizer (GKP-stabilizer) codes can be done by a Gaussian operation acting on a tensor product of an arbitrary state in the first mode and position states (GKP states) on the remaining modes. Protection of logical modes against small displacements cannot be done using only Gaussian resources [C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047][J. Eisert, S. Scheel, and M. B. Plenio, \u201cDistilling Gaussian States with Gaussian Operations is Impossible\u201d, Physical Review Letters 89, (2002). DOI; quant-ph/0204052][J. Niset, J. Fiur\u00e1\u0161ek, and N. J. Cerf, \u201cNo-Go Theorem for Gaussian Quantum Error Correction\u201d, Physical Review Letters 102, (2009). DOI; 0811.3128], so GKP-stabilizer codes can be thought of as analog stabilizer encodings utilizing non-Gaussian GKP resource states.", "_type": "ecc", "_page_id": "c_gkp-stabilizer", "_href": "c/gkp-stabilizer"}, "c_braunstein": {"logical": "oscillators", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Error correction can be done using linear-optical elements and feedback [S. L. Braunstein, \u201cQuantum error correction for communication with linear optics\u201d, Nature 394, 47 (1998). DOI].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Braunstein five-mode code", "code_id": "braunstein", "realizations": "", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[S. L. Braunstein, \u201cError Correction for Continuous Quantum Variables\u201d, Physical Review Letters 80, 4084 (1998). DOI; quant-ph/9711049]", "description": "A \\([[5,1,3]]_{\\mathbb{R}}\\) analog stabilizer version of the five-qubit perfect code. ", "parents_code_id": "analog_stabilizer", "parents_detail": "", "cousins_code_id": "stab_5_1_3", "cousins_detail": "The Braunstein five-mode code is a bosonic analogue of the five-qubit code.", "_type": "ecc", "_page_id": "c_braunstein", "_href": "c/braunstein"}, "c_gkp-cluster-state": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "Single-mode logical Clifford gates can be performed using Gaussian operations and measurements on a 1D GKP cluster state, while two-mode logical Clifford gates require a 2D cluster state. Magic-state distillation using photon-counting can be used for a non-Clifford logical \\(\\pi/8\\) gate.", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "First encoding demonstrating the possibility of fault-tolerant measurement-based computation with CV cluster states. A fault-tolerance threshold can be achieved by concatenating existing fault-tolerant schemes for qubit-based cluster-state encodings with the GKP code [N. C. Menicucci, \u201cFault-Tolerant Measurement-Based Quantum Computing with Continuous-Variable Cluster States\u201d, Physical Review Letters 112, (2014). DOI; 1310.7596].\nHybrid cluster state consisting of GKP qubits at some modes and squeezed states at others has been proposed to work in a fault-tolerant scheme [J. E. Bourassa et al., \u201cBlueprint for a Scalable Photonic Fault-Tolerant Quantum Computer\u201d, Quantum 5, 392 (2021). DOI; 2010.02905].", "name": "GKP cluster-state concatenated code", "code_id": "gkp-cluster-state", "realizations": "", "protection": "", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[N. C. Menicucci, \u201cFault-Tolerant Measurement-Based Quantum Computing with Continuous-Variable Cluster States\u201d, Physical Review Letters 112, (2014). DOI; 1310.7596]", "description": "Multi-mode code encoding logical qubits into a cluster-state stabilizer code concatenated with a single-mode GKP code. Provides a way to perform a continuous-variable (CV) analogue of fault-tolerant measurement-based qubit computation.\n\nA cluster state of GKP qubits on a graph is made by applying two-mode \\(C_Z\\)-type gates \\(e^{\\pm i \\hat{x}\\otimes\\hat{x}}\\) to a tensor product of \\(|\\overline{+}\\rangle\\) logical GKP states on each vertex. Logical Clifford gates are performed on the cluster state using CV measurement-based computation [N. C. Menicucci et al., \u201cUniversal Quantum Computation with Continuous-Variable Cluster States\u201d, Physical Review Letters 97, (2006). DOI; quant-ph/0605198][M. Gu et al., \u201cQuantum computing with continuous-variable clusters\u201d, Physical Review A 79, (2009). DOI; 0903.3233], i.e., via a combination of linear-optical gates and homodyne measurements on subsets of vertices. Magic-state distillation is required for universal computation. GKP error correction can be naturally combined with CV measurement-based protocols since the performance of both is quantified by a squeezing parameter. ", "parents_code_id": "qudits_into_oscillators\nmultimodegkp", "parents_detail": "\nA GKP-based cluster state is a multimode GKP codeword, although other codewords are not utilized in CV measurement-based computation.", "cousins_code_id": "quantum_concatenated", "cousins_detail": "", "_type": "ecc", "_page_id": "c_gkp-cluster-state", "_href": "c/gkp-cluster-state"}, "c_multimodegkp": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements [B. Q. Baragiola et al., \u201cAll-Gaussian Universality and Fault Tolerance with the Gottesman-Kitaev-Preskill Code\u201d, Physical Review Letters 123, (2019). DOI; 1903.00012].", "features_threshold": "", "features_rate": "Transmission schemes with multimode GKP codes achieve, up to a constant-factor offset, the capacity of displacement-noise and thermal-noise Gaussian loss channels [J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058][K. Sharma et al., \u201cBounding the energy-constrained quantum and private capacities of phase-insensitive bosonic Gaussian channels\u201d, New Journal of Physics 20, 063025 (2018). DOI; 1708.07257][M. Rosati, A. Mari, and V. Giovannetti, \u201cNarrow bounds for the quantum capacity of thermal attenuators\u201d, Nature Communications 9, (2018). DOI; 1801.04731][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271]. Particular lattice families of multimode GKP codes achieve the hashing bound of the displacement noise channel [J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058].", "features_magic_scaling_exponent": "", "features_encoders": "Multi-mode GKP codes with fixed \\(n\\) and prime-dimensional logical Hilbert space are symplectically related to a disjoint product of single-mode GKP codes on \\(n\\) modes, such that encoding via Gaussian unitaries is possible.\nDissipative stabilization of finite-energy GKP states using stabilizers conjugated by cooling ([N. C. Menicucci, \u201cFault-Tolerant Measurement-Based Quantum Computing with Continuous-Variable Cluster States\u201d, Physical Review Letters 112, (2014). DOI; 1310.7596], Appx. B) or damping operator, i.e., a damped exponential of the total occupation number [B. Royer, S. Singh, and S. M. Girvin, \u201cStabilization of Finite-Energy Gottesman-Kitaev-Preskill States\u201d, Physical Review Letters 125, (2020). DOI; 2009.07941][B. Royer, S. Singh, and S. M. Girvin, \u201cEncoding Qubits in Multimode Grid States\u201d, PRX Quantum 3, (2022). DOI; 2201.12337].", "features_decoders": "The MLD decoder for Gaussian displacement errors is realized by evaluating a lattice theta function, and in general the decision can be approximated by either solving (approximating) the closest vector problem (CVP) or by using other effective iterative schemes when e.g. the lattice represents a concatenated GKP code [C. Vuillot et al., \u201cQuantum error correction with the toric Gottesman-Kitaev-Preskill code\u201d, Physical Review A 99, (2019). DOI; 1810.00047][K. Noh and C. Chamberland, \u201cFault-tolerant bosonic quantum error correction with the surface\u2013Gottesman-Kitaev-Preskill code\u201d, Physical Review A 101, (2020). DOI; 1908.03579][J. Conrad, J. Eisert, and F. Arzani, \u201cGottesman-Kitaev-Preskill codes: A lattice perspective\u201d, Quantum 6, 648 (2022). DOI; 2109.14645][N. Raveendran et al., \u201cFinite Rate QLDPC-GKP Coding Scheme that Surpasses the CSS Hamming Bound\u201d, Quantum 6, 767 (2022). DOI; 2111.07029].", "features_transversal_gates": "", "features_fault_tolerance": "Logical Clifford operations are given by Gaussian unitaries, which map bounded-size errors to bounded-size errors [D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040].", "name": "Multi-mode GKP code", "code_id": "multimodegkp", "realizations": "", "protection": "The level of protection against displacement errors is quantified by the Euclidean code distance \\(\\Delta=\\min_{x\\in {\\mathcal{L}}^{\\perp}\\setminus {\\mathcal{L}}} \\|x\\|_2\\) [J. Conrad, J. Eisert, and F. Arzani, \u201cGottesman-Kitaev-Preskill codes: A lattice perspective\u201d, Quantum 6, 648 (2022). DOI; 2109.14645].", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040][J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058]", "description": "Generalization of the GKP code to \\(n\\) bosonic modes whose stabilizer group is an infinite countable group of oscillator displacement operators.\n\nDisplacement operators on \\(n\\) modes can be written as \\begin{align}\nD(\\xi) = \\exp \\left\\{-i \\sqrt{2\\pi} {\\xi}^\\mathrm{T} J \\hat{q} \\right\\} , \\quad \\xi \\in \\mathbb{R}^{2n}~,\n\\end{align} where \\(\\hat{q}\\) is a \\(2n\\)-dimensional vector position and momentum operators of the modes, the symplectic form \\begin{align}\nJ = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} \\otimes I_n = \\begin{pmatrix}\n0 &  I_n \\\\\n-I_n  & 0 \\end{pmatrix}~,\n\\end{align} and \\(I_n\\) is the identity matrix. A group generated by a set of independent displacement operators is given by a lattice \\({\\mathcal{L}}\\) \\begin{align}\n\\langle D(\\xi_1) ,\\dots,  D(\\xi_{m})  \\rangle = \\{ e^{ i \\phi_M (\\xi) } D(\\xi) ~\\vert~ \\xi \\in {\\mathcal{L}} \\}\n\\end{align} and becomes a valid stabilizer group when every symplectic inner product between lattice vectors yields an integer. In other words, the corresponding lattice is symplectically integral, corresponding to an integer-valued symplectic Gram matrix \\(A\\), \\begin{align}\nA_{ij}={\\xi}^T_i J \\xi_j \\in \\mathbb{Z}~.\n\\end{align} The \\(m=2n\\) case yields multimode GKP codes encoding a finite-dimensional logical subspace, while removing some displacements yields GKP-stabilizer codes encoding an infinite-dimensional logical subspace. Codes defined on a hyper-rectangular lattice are CSS GKP codes, and more general lattices, obtained by Gaussian transformations, yield non-CSS codes.\n\nThe centralizer for the stabilizer group within the displacement operators for the \\(m=2n\\) case can be identified with the symplectic dual lattice \\({\\mathcal{L}}^{\\perp}\\) (i.e. all points in \\(\\mathbb{R}^{2n}\\) that have integer symplectic inner product with all points in \\({\\mathcal{L}}\\) ), such that logical operations are identified with the dual quotients \\({\\mathcal{L}}^{\\perp}/{\\mathcal{L}}\\). The size of this dual quotient is the determinant of the Gram matrix, yielding the logical dimension \\(d=\\sqrt{\\| \\det{A}\\|}\\) [D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040].", "parents_code_id": "oscillator_stabilizer\ncoherent_constellation", "parents_detail": "\nGKP codewords can be written as superpositions of coherent states lying on a lattice in phase space [D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].", "parent_of_code_id": "gkp-cluster-state\ngkp-stabilizer\ngkp", "parent_of_detail": "A GKP-based cluster state is a multimode GKP codeword, although other codewords are not utilized in CV measurement-based computation.\nGKP-stabilizer codes are \\(n\\)-mode GKP codes with less than \\(2n\\) stabilizers. Equivalently, they correspond to multimode GKP codes constructed using a degenerate lattice (see Appx. A of Ref. [J. Conrad, J. Eisert, and F. Arzani, \u201cGottesman-Kitaev-Preskill codes: A lattice perspective\u201d, Quantum 6, 648 (2022). DOI; 2109.14645]).\n", "cousins_code_id": "approximate_qecc\npoints_into_lattices", "cousins_detail": "Approximate error-correction offered by GKP codes yields achievable rates that are a constant away from the capacity of Guassian loss channels [J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058][K. Sharma et al., \u201cBounding the energy-constrained quantum and private capacities of phase-insensitive bosonic Gaussian channels\u201d, New Journal of Physics 20, 063025 (2018). DOI; 1708.07257][M. Rosati, A. Mari, and V. Giovannetti, \u201cNarrow bounds for the quantum capacity of thermal attenuators\u201d, Nature Communications 9, (2018). DOI; 1801.04731][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].\nMultimode GKP codes are quantum analogues of lattice-based codes.", "_type": "ecc", "_page_id": "c_multimodegkp", "_href": "c/multimodegkp"}, "c_chuang-leung-yamamoto": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Code rate is \\(\\frac{k}{n \\log_2(N+1)}\\). To correct the loss of up to \\(t\\) excitations with \\(K+1\\) codewords, a code exists with scaling \\(N \\sim t^3 K/2\\).", "features_magic_scaling_exponent": "", "features_encoders": "Photon Fock state input into a network of beamsplitters, phase shifters, and Kerr media. These operations all preserve total photon number. Beamsplitters and phase shifters take annihilation operators to linear combinations of annihilation operators, and the transformation matrix is unitary. The operations corresponding to Kerr nonlinear media are diagonal in the Fock basis, but they implement phases that in general depend nonlinearly on the number of photons in each mode. State preparation may require ancillary modes and be conditioned on photon-number measurement results.", "features_decoders": "Destructive decoding with a photon number measurement on each mode.\nState can be decoded with a network of beamsplitters, phase shifters, and Kerr media.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Chuang-Leung-Yamamoto (CLY) code", "code_id": "chuang-leung-yamamoto", "realizations": "", "protection": "Protects against amplitude damping for up to \\(t = d-1\\) excitation losses. Defining the spacing between two Fock states \\(|u_1\\cdots u_n\\rangle\\) and \\(|v_1\\cdots v_n\\rangle\\), \\begin{align}\n\\text{Spacing}(u,v) = \\frac{1}{2}\\sum_{i=1}^n |u_i - v_i|,\n\\end{align} the code distance \\(d\\) can be defined as the minimial spacing between Fock states making up the codewords. ", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[I. L. Chuang, D. W. Leung, and Y. Yamamoto, \u201cBosonic quantum codes for amplitude damping\u201d, Physical Review A 56, 1114 (1997). DOI]", "description": "Bosonic Fock-state code that encodes \\(k\\) qubits into \\(n\\) oscillators, with each oscillator restricted to having at most \\(N\\) excitations. Codewords are superpositions of oscillator Fock states which have exactly \\(N\\) total excitations, and are either uniform (i.e., balanced) superpositions or unbalanced superpositions. Codes can be denoted as \\([[N,n,2^k,d]]\\), which conflicts with stabilizer code notation.\n\nA simple example of a CLY code is a two-mode \"0-2-4\" qubit code with codewords \\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{2}}\\left(|40\\rangle+|04\\rangle\\right)\\\\\n  |\\overline{1}\\rangle&=|22\\rangle~.\n\\end{split}\n\\end{align} ", "parents_code_id": "fock_state\nconstant_excitation", "parents_detail": "Chuang-Leung-Yamamoto code are multi-mode Fock-state codes.\nChuang-Leung-Yamamoto codewords are constructed out of Fock states with the same total excitation number.", "parent_of_code_id": "constant_excitation_permutation_invariant", "parent_of_detail": "", "cousin_of_code_id": "2t_qutrit\nbinomial", "cousin_of_detail": "The \\(2T\\)-qutrit code reduces to the two-mode \"0-2-4\" CLY code as \\(\\alpha\\to 0\\).\nTwo-mode version of binomial codes correspond to two-mode \"0-2-4\" CLY codes (see Sec. IV.A of Ref. [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008]).", "_type": "ecc", "_page_id": "c_chuang-leung-yamamoto", "_href": "c/chuang-leung-yamamoto"}, "c_wasilewski-banaszek": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Single-qubit gates implemented using linear optical networks, sometimes with the addition of auxiliary modes with vacuum input and (conditional) output.", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "A qubit in the dual-rail code can be transferred to this code via a linear optical network using four ancillary modes, each with one photon input. Successful encoding is conditioned on measuring the state \\(|110\\rangle\\) on the last three modes.", "features_decoders": "Destructive measurement with photon number measurements on each mode.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Wasilewski-Banaszek code", "code_id": "wasilewski-banaszek", "realizations": "", "protection": "Protects against single photon loss in any one mode.", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[W. Wasilewski and K. Banaszek, \u201cProtecting an optical qubit against photon loss\u201d, Physical Review A 75, (2007). DOI; quant-ph/0702075]", "description": "Three-oscillator Fock-state code encoding a single logical qubit using codewords \\begin{align} \\begin{split} |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{3}}(|003\\rangle+|030\\rangle+|300\\rangle)\\\\ |\\overline{1}\\rangle &= |111\\rangle \\end{split}. \\end{align}", "parents_code_id": "constant_excitation_permutation_invariant", "parents_detail": "", "_type": "ecc", "_page_id": "c_wasilewski-banaszek", "_href": "c/wasilewski-banaszek"}, "c_dual_rail": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "General gates are performed using beamsplitters and Kerr non-linearities. Universal quantum computing can be achieved with photons in dual-rail encodings using the KLM protocol [E. Knill, R. Laflamme, and G. J. Milburn, \u201cA scheme for efficient quantum computation with linear optics\u201d, Nature 409, 46 (2001). DOI] with only linear optical elements and photon detectors.", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "Dual-rail qubits can be used to convert leakage and amplitude damping noise into erasure noise [Aleksander Kubica et al., \u201cErasure qubits: Overcoming the $T_1$ limit in superconducting circuits\u201d. 2208.05461].", "name": "Dual-rail quantum code", "code_id": "dual_rail", "realizations": "", "protection": "This is an error-detecting code against one photon loss event; it is often used in photonic quantum devices because of its ease of realization. A single loss event can be detected because, after the loss occurs, the output state \\(|00\\rangle\\) is orthogonal to the codespace. Recovery is not possible, so a successful run of a quantum circuit is conditioned on not losing a photon during the circuit.\n\nFor Deutsch''s problem specifically, this code protects against errors resulting in states that have the correct photon number, but in the wrong modes [I. L. Chuang and Y. Yamamoto, \u201cSimple quantum computer\u201d, Physical Review A 52, 3489 (1995). DOI]. ", "notes": "For Deutsch's problem [\u201cRapid solution of problems by quantum computation\u201d, Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences 439, 553 (1992). DOI] with optical qubits, error correction using photon number detection reduces the error probability from \\(\\frac{1}{4} (1+e^{-\\gamma}-2e^{-3\\gamma/2}) \\) to \\(\\frac{1}{2} (1- \\text{sech} \\gamma/2)\\).\nSee review [P. Kok et al., \u201cLinear optical quantum computing with photonic qubits\u201d, Reviews of Modern Physics 79, 135 (2007). DOI; quant-ph/0512071] for more details.", "physical": "qubits", "short_name": "", "introduced": "[I. L. Chuang and Y. Yamamoto, \u201cSimple quantum computer\u201d, Physical Review A 52, 3489 (1995). DOI]", "description": "Two-mode code encoding a logical qubit in Fock states with one excitation. The logical-zero state is represented by \\(|01\\rangle\\), while the logical-one state is represented by \\(|10\\rangle\\). The two modes of the encoding can represent temporal or spatial modes, corresponding to a time-bin or frequency-bin encoding.", "parents_code_id": "constant_excitation_permutation_invariant", "parents_detail": "", "_type": "ecc", "_page_id": "c_dual_rail", "_href": "c/dual_rail"}, "c_paircat": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Hamiltonian \\(X\\), \\(XX\\), \\(Z\\) gates, holonomic \\(Z\\) gate, control-phase gate.\nBias-preserving gates [Ming Yuan, Qian Xu, and Liang Jiang, \u201cConstruction of Bias-preserving Operations for Pair-cat Code\u201d. 2208.06913].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Lindbladian-based dissipative encoding utilizing two-mode two-photon absorption [G. S. Agarwal, \u201cGeneration of Pair Coherent States and Squeezing via the Competition of Four-Wave Mixing and Amplified Spontaneous Emission\u201d, Physical Review Letters 57, 827 (1986). DOI]. Encoding passively protects against cavity dephasing, suppressing dephasing noise exponentially with \\(\\gamma^2\\).", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Pair-cat code", "code_id": "paircat", "realizations": "Microwave cavities coupled to superconducting circuits by the Wang group [Jeffrey M. Gertler et al., \u201cExperimental Realization and Characterization of Stabilized Pair Coherent States\u201d. 2209.11643].", "protection": "The occupation-number differences form the syndromes, as opposed to the photon number parity for the single-mode cat code. Any loss even combination that changes the relative differences of photons between modes is a detectable error. The two-mode two-component paircat code can detect arbitrary single-mode losses, but cannot detect simultaneous photon loss in both modes. An \\(n\\)-mode code can detect any loss errors of at most \\(n-1\\) weight. Higher numbers of legs correspond to more pair-coherent state present in the codewords, and allow for protection against simulataneous losses.", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[V. V. Albert et al., \u201cPair-cat codes: autonomous error-correction with low-order nonlinearity\u201d, Quantum Science and Technology 4, 035007 (2019). DOI; 1801.05897]", "description": "Two- or higher-mode extension of cat codes whose codewords are right eigenstates of powers of products of the modes' lowering operators. Many gadgets for cat codes have two-mode pair-cat analogues, with the advantage being that such gates can be done in parallel with a dissipative error-correction process.\n\nTwo-mode codewords are supported by Fock states with occupation number \\(\\hat{n}_2-\\hat{n}_1\\) fixed to some integer \\(\\Delta\\). In the two-component case, \\(|\\overline{0}_{\\gamma,\\Delta}\\rangle \\sim |\\gamma_\\Delta \\rangle + (-1)^\\Delta |i\\gamma_\\Delta\\rangle\\) and \\(|\\overline{1}_{\\gamma,\\Delta}\\rangle \\sim |\\gamma_\\Delta\\rangle - (-1)^\\Delta |i \\gamma\\rangle\\), where \\begin{align}\n|\\alpha_\\Delta \\rangle \\propto \\sum_{n=0}^\\infty \\frac{\\alpha^{2n+\\Delta}}{\\sqrt{n! (n+\\Delta)!}} |n,n+\\Delta\\rangle\n\\end{align} is the corresponding pair-coherent state [A. O. Barut and L. Girardello, \u201cNew \u201cCoherent\u201d States associated with non-compact groups\u201d, Communications in Mathematical Physics 21, 41 (1971). DOI][G. S. Agarwal, \u201cGeneration of Pair Coherent States and Squeezing via the Competition of Four-Wave Mixing and Amplified Spontaneous Emission\u201d, Physical Review Letters 57, 827 (1986). DOI][G. S. Agarwal, \u201cNonclassical statistics of fields in pair coherent states\u201d, Journal of the Optical Society of America B 5, 1940 (1988). DOI] with complex amplitude \\(\\alpha\\), up to normalization. ", "parents_code_id": "fock_state", "parents_detail": "", "cousins_code_id": "cat\nhamiltonian", "cousins_detail": "Cat (pair-cat) codewords are superpositions of coherent (pair-coherent) states. Many cat-code protocols have analogues for the two-mode pair-cat codes.\nTwo-legged pair-cat codewords form ground-state subspace of a multimode Kerr Hamiltonian.", "_type": "ecc", "_page_id": "c_paircat", "_href": "c/paircat"}, "c_chebyshev": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Chebyshev code", "code_id": "chebyshev", "realizations": "", "protection": "The \\(s\\)th-order code corrects errors from the set \\(\\{I,a,a^{\\dagger},{\\hat n},{\\hat n}^2,\\cdots,{\\hat n}^{s-1}\\}\\).", "notes": "", "physical": "", "short_name": "", "introduced": "[D. Layden et al., \u201cAncilla-Free Quantum Error Correction Codes for Quantum Metrology\u201d, Physical Review Letters 122, (2019). DOI; 1811.01450]", "description": "Single-mode bosonic Fock-state code that can be used for error-corrected sensing of a signal Hamiltonian \\({\\hat n}^s\\), where \\({\\hat n}\\) is the occupation number operator. Codewords for the \\(s\\)th-order Chebyshev code are \\begin{align}\n\\begin{split}\n\\ket{\\overline 0} &=\\sum_{k \\text{~even}}^{[0,s]} \\tilde{c}_k \\Ket{\\left\\lfloor M\\sin^2\\left( k\\pi/{2s}\\right) \\right\\rfloor},\\\\\n\\ket{\\overline 1} &= \\sum_{k \\text{~odd}}^{[0,s]} \\tilde{c}_k \\Ket{\\left\\lfloor M\\sin^2 \\left(k\\pi/{2s}\\right) \\right\\rfloor},\n\\end{split}\n\\end{align} where \\(\\tilde{c}_k>0\\) can be obtained by solving a system of order \\(O(s^2)\\) linear equations, and where \\(\\lfloor x \\rfloor\\) is the floor function. The code approaches optimality for sensing the signal Hamiltonian as \\(M\\) increases. ", "parents_code_id": "single-mode\nbosonic_rotation\nmetopt", "parents_detail": "\n\n", "cousins_code_id": "binomial", "cousins_detail": "Chebyshev codes resemble binomial codes, and a class of binomial codes have similar error-correcting properties [D. Layden et al., \u201cAncilla-Free Quantum Error Correction Codes for Quantum Metrology\u201d, Physical Review Letters 122, (2019). DOI; 1811.01450].", "_type": "ecc", "_page_id": "c_chebyshev", "_href": "c/chebyshev"}, "c_numopt": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Numerically optimized code", "code_id": "numopt", "realizations": "", "protection": "Number phase codes protect from a finite number of loss events. However, unlike Fock-state codes, their protection does not stem from a Fock-state spacing.", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]", "description": "Bosonic Fock-state code obtained from a numerical minimization procedure, e.g., from enforcing error-correction criteria against some number of losses while minimizing average occupation number.\n\nThe smallest numerically optimized code is the \\(\\sqrt(17)\\) code, \\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{\\sqrt{6}}\\left(\\sqrt{7-\\sqrt{17}}|0\\rangle+\\sqrt{\\sqrt{17}-1}|3\\rangle\\right)\\\\\n|\\overline{1}\\rangle&=\\frac{1}{\\sqrt{6}}\\left(\\sqrt{9-\\sqrt{17}}|1\\rangle-\\sqrt{\\sqrt{17}-3}|4\\rangle\\right)~,\n\\end{split}\n\\end{align} correcting a single loss error. The average occupation number of the codewords is \\(\\approx 1.6\\), which is \\(0.4\\) photons lower than that of the smallest binomial code with the same level of protection. ", "parents_code_id": "single-mode", "parents_detail": "", "_type": "ecc", "_page_id": "c_numopt", "_href": "c/numopt"}, "c_constant_excitation_permutation_invariant": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Constant-excitation permutation-invariant code", "code_id": "constant_excitation_permutation_invariant", "realizations": "", "protection": "", "notes": "", "physical": "qubits", "short_name": "", "introduced": "[Y. Ouyang and R. Chao, \u201cPermutation-Invariant Constant-Excitation Quantum Codes for Amplitude Damping\u201d, IEEE Transactions on Information Theory 66, 2921 (2020). DOI; 1809.09801]", "description": "Stub. ", "parents_code_id": "permutation_invariant\nchuang-leung-yamamoto", "parents_detail": "\n", "parent_of_code_id": "dual_rail\nwasilewski-banaszek", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_constant_excitation_permutation_invariant", "_href": "c/constant_excitation_permutation_invariant"}, "c_fock_state": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Fock-state bosonic code", "code_id": "fock_state", "realizations": "", "protection": "Code distance \\(d\\) is the minimum distance (assuming some metric) between any two labels of Fock states corresponding to different code basis states. For a single mode, \\(d\\) is the minimum absolute value of the difference between any two Fock-state labels; such codes can detect up to \\(d-1\\) loss events. Multimode distances can be defined analogously; see, e.g., Chuang-Leung-Yamamoto codes.", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "", "description": "Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. The simplest example is the dual-rail code, which has codewords consisting of single Fock states \\(|10\\rangle\\) and \\(|01\\rangle\\). This code can detect a single loss error since a loss operator in either mode maps one of the codewords to a different Fock state \\(|00\\rangle\\). More involved codewords consist of several well-separated Fock states such that multiple loss events can be detected and corrected.", "parents_code_id": "qudits_into_oscillators", "parents_detail": "", "parent_of_code_id": "bosonic_rotation\nchuang-leung-yamamoto\npaircat", "parent_of_detail": "Single-mode Fock-state codes are typically rotationally invariant.\nChuang-Leung-Yamamoto code are multi-mode Fock-state codes.\n", "cousins_code_id": "bits_into_bits\nqubits_into_qubits", "cousins_detail": "Fock-state code distance is a natural extension of Hamming distance between binary strings.\nFock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators [Victor V. Albert, private communication, 2016]. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations [Steven M. Girvin, \u201cIntroduction to Quantum Error Correction and Fault Tolerance\u201d. 2111.08894].", "cousin_of_code_id": "fusion", "cousin_of_detail": "While FBQC is a general framework, an intended application to linear-optical quantum computing will likely utilize small Fock-state bosonic codes such as the dual-rail code.", "_type": "ecc", "_page_id": "c_fock_state", "_href": "c/fock_state"}, "c_binomial": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Photon loss and dephasing errors can be detected by measuring the phase-space rotation \\(\\exp\\left(2\\pi\\mathrm{i} \\hat{n} / (S+1)\\right)\\) and the check operator \\(J_x/J\\) in the spin-coherent state language, where \\(J\\) is the total angular momentum and \\(J_x\\) is the angular momentum in the \\(x\\) direction [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010]. This type of error correction fails for errors that are products of photon loss/gain and dephasing errors. However, for certain \\((N,S)\\) instances of the binomial code, detection of these types of errors can be done.\nRecovery can be done via projective measurements and unitary operations [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binomial code", "code_id": "binomial", "realizations": "Microwave cavities coupled to superconducting circuits: state transfer between a binomial codeword to another system [C. J. Axline et al., \u201cOn-demand quantum state transfer and entanglement between remote microwave cavity memories\u201d, Nature Physics 14, 705 (2018). DOI; 1712.05832], error-correction protocol nearly reaching break-even [L. Hu et al., \u201cQuantum error correction and universal gate set operation on a binomial bosonic logical qubit\u201d, Nature Physics 15, 503 (2019). DOI; 1805.09072], and a teleported CNOT gate [Y. Xu et al., \u201cDemonstration of Controlled-Phase Gates between Two Error-Correctable Photonic Qubits\u201d, Physical Review Letters 124, (2020). DOI; 1810.04690].", "protection": "An \\((N, S)\\) binomial code protects against \\(L\\) boson losses, \\(G\\) boson gains, and dephasing up to \\(\\hat{n}^{D}\\), where \\(S=L+G\\) and \\(N = \\mathrm{max}(L,G,2D)\\). Binomial codes approximately protect against continuous-time amplitude damping, boson loss and gain, and dephasing.", "notes": "The mean occupation number, or average Fock-state number in maximally-mixed state of the code, is \\((N+1)(S+1)(q-1)/2 \\), where \\(q\\) is the qudit dimension.", "physical": "oscillators", "short_name": "", "introduced": "[M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008]", "description": "Bosonic rotation codes designed to approximately protect against errors consisting of powers of raising and lowering operators up to some maximum power. Binomial codes can be thought of as spin-coherent states embedded into an oscillator [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].\n\nA simple example of a binomial code is the \"0-2-4\" qubit code with codewords \\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{2}}\\left(|0\\rangle+|4\\rangle\\right)\\\\\n  |\\overline{1}\\rangle&=|2\\rangle~.\n\\end{split}\n\\end{align}\n\nGeneral \\(q\\)-dimensional qudit \\((N, S)\\) binomial codeword states are \\(\\{|\\overline{i}\\rangle\\mid i\\in \\mathbb Z_q \\}\\), where \\begin{align}\n    |\\overline{i}\\rangle = \\frac{1}{\\sqrt{q^N}} \\sum_{\\substack{p=0\\\\p\\equiv i \\pmod{q}}}^{(q-1)(N+1)} \\sqrt{\\binom{N+1}{p}_q} \\ket{p(S+1)}.\n  \\end{align} The set \\( \\ket{i} \\mid i \\in \\mathbb{N}\\) is the set of Fock states. Also, \\(\\binom{N+1}{p}_q\\) are extended binomial coefficients, or polynomial coeffiients, defined recursively as \\begin{align}\n    \\binom{n}{m}_1 \\equiv 1,\\quad \\binom{n}{m}_q \\equiv \\sum_{k=0}^n \\binom{n}{k}\\binom{k}{m-k}_{q-1}.\n  \\end{align} The extended binomial coefficients \\( \\binom{n}{m}_q \\) are also the coefficients of \\( x^m \\) in the polynomial \\( (1 + x + \\cdots + x^{q-1})^n \\).", "parents_code_id": "bosonic_rotation", "parents_detail": "One can verify by direct calculation that the logical states are eigenstates of the discrete rotation operator. One has freedom in the exact form of the primitive state to choose; see Appendix B.2 of Ref. [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "cousins_code_id": "cat\nnumber_phase\nchuang-leung-yamamoto", "cousins_detail": "For a fixed \\(S\\), binomial codes with \\(N \\to \\infty\\) coincide with cat codes as \\(\\alpha \\to \\infty\\) [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008].\nIn the limit as \\(N,S \\to \\infty\\), phase measurement in the binomial code has vanishing variance, just like in a number-phase code [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nTwo-mode version of binomial codes correspond to two-mode \"0-2-4\" CLY codes (see Sec. IV.A of Ref. [M. H. Michael et al., \u201cNew Class of Quantum Error-Correcting Codes for a Bosonic Mode\u201d, Physical Review X 6, (2016). DOI; 1602.00008]).", "cousin_of_code_id": "chebyshev\ngnu_permutation_invariant\nstab_4_2_2", "cousin_of_detail": "Chebyshev codes resemble binomial codes, and a class of binomial codes have similar error-correcting properties [D. Layden et al., \u201cAncilla-Free Quantum Error Correction Codes for Quantum Metrology\u201d, Physical Review Letters 122, (2019). DOI; 1811.01450].\nBinomial codes and GNU codes are both related to spin-coherent states, and a qudit generalization can be obtained from qudit binomial codes ([V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010], Appx. C).\n\\([[4,1,2]]\\) subcode consisting of \\(\\{|\\overline{00}\\rangle\\) and any other codeword reduces to the \\(0,2,4\\) binomial code when the basis labels in each codeword are written as in base-ten. Such a mapping can be generalized [Linshu Li, private communication, 2018].", "_type": "ecc", "_page_id": "c_binomial", "_href": "c/binomial"}, "c_bosonic_rotation": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "The logical Pauli-\\(Z\\) gate can be the discrete rotation operator \\(\\mathrm{e}^{\\mathrm{i} \\pi \\hat n /N}\\), and the logical Pauli-\\(X\\) gate can be the (note: non-unitary) number-translation operator \\(\\sum_{n=0}^\\infty |n\\rangle\\bra{n+N}\\).\nFor qubit codes, a logical phase gate is \\(S = \\mathrm{e}^{\\pi \\mathrm{i} \\hat n^2 / 2N^2}\\).\nThe \\(T = \\mathrm{diag}(1,\\exp(\\mathrm{i}\\pi/4))\\) gate can be done via gate teleportation and a resource state \\(\\vert 0_N\\rangle + \\exp(\\mathrm{i}\\pi/4) \\vert 1_N \\rangle\\).\nA controlled-rotation gate between an order \\(N\\) rotation code and an order \\(M\\) rotation code is \\(\\mathrm{CROT}_{NM} = \\mathrm{e}^{(2\\pi\\mathrm{i} / qNM) \\hat n \\otimes \\hat n}\\).", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "The optimal way to prepare codewords depends on the exact rotation code in question [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "features_decoders": "One can distinguish (destructively) the codewords by performing a Fock-state number measurement. If a Fock state state \\(|n\\rangle\\) is measured, then one rounds to the nearest integer of the form \\((kq+j)/N\\), and deduces that the true state was \\(|\\overline{j}\\rangle\\).\nOne can distinguish states in the dual basis by performing phase estimation on \\(\\mathrm{e}^{\\mathrm{i} \\theta \\hat n}\\). One then rounds the resulting \\(\\theta\\) to the nearest number \\(2\\pi j / qN\\) in order to determine which dual basis state \\(j \\in \\mathbb Z_q\\) it came from.\nAutonomous quantum error correction schemes for \\(S=1\\) codes [S. Kwon, S. Watabe, and J.-S. Tsai, \u201cAutonomous quantum error correction in a four-photon Kerr parametric oscillator\u201d, npj Quantum Information 8, (2022). DOI; 2203.09234].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Bosonic rotation code", "code_id": "bosonic_rotation", "realizations": "", "protection": "Losses or gains less than \\(N\\) are detectable. Dephasing rotations \\(\\exp(\\mathrm{i}\\theta \\hat{n})\\) can be detected whenever \\(\\theta\\) is roughly less than \\(\\pi/N\\). To get precise bounds on \\(\\theta\\), one needs to analyze the particular bosonic rotation code.", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071]", "description": "A single-mode Fock-state bosonic code whose codespace is preserved by a phase-space rotation by a multiple of \\(2\\pi/N\\) for some \\(N\\). The rotation symmetry ensures that encoded states have support only on every \\(N^{\\textrm{th}}\\) Fock state. For example, single-mode Fock-state codes for \\(N=2\\) encoding a qubit admit basis states that are, respectively, supported on Fock state sets \\(\\{|0\\rangle,|4\\rangle,|8\\rangle,\\cdots\\}\\) and \\(\\{|2\\rangle,|6\\rangle,|10\\rangle,\\cdots\\}\\).\n\nEncoding of a \\(q\\)-dimensional logical qudit admit a basis whose elements are eigenstates of the rotation operator \\(\\exp\\left(\\mathrm{i} 2\\pi \\hat{n}/qN \\right)\\), where \\(\\hat{n}\\) is the number operator diagonal in the Fock basis. Basis elements are of the form \\(\\sum_{j=0}^\\infty c_j |(kq+j)N \\rangle\\) for some coefficients \\(c_j\\) and \\(k\\). This is because the rotation acting on a general Fock-state superposition \\(\\sum_n a_n |n\\rangle\\) yields \\(\\sum_n a_n \\exp\\left(\\mathrm{i} 2\\pi n / qN \\right) |n\\rangle\\). In order for a codeword to be an eigenvector of this operation, \\(a_n\\) must be zero whenever \\(n \\neq (kq+j)N\\) for some \\(k\\).\n\nCodewords can be uniquely specified by choosing a primitive state \\(|\\Theta\\rangle\\). To ensure valid (orthogonal and nonzero) codewords, \\(|\\Theta\\rangle\\) must satisfy the following requirement: for each \\(j \\in \\mathbb{Z}_q\\), \\(|\\Theta\\rangle\\) must have support on the Fock state \\(|(k_j q+j)N\\rangle\\) for at least one \\(k_j \\in \\mathbb{N}_0\\). From such a primitive, the codewords \\(\\{|\\overline{j}\\rangle \\mid j \\in \\mathbb{Z}_q\\}\\) are constructed as \\begin{align}\n|\\overline{j}\\rangle \\propto \\sum_{m=0}^{2N-1} \\mathrm{e}^{2\\pi \\mathrm{i} m (\\hat n  / N + j) / q} |\\Theta\\rangle~.\n\\end{align}", "parents_code_id": "single-mode\nfock_state", "parents_detail": "\nSingle-mode Fock-state codes are typically rotationally invariant.", "parent_of_code_id": "binomial\ncat\nchebyshev\nnumber_phase", "parent_of_detail": "One can verify by direct calculation that the logical states are eigenstates of the discrete rotation operator. One has freedom in the exact form of the primitive state to choose; see Appendix B.2 of Ref. [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nThe cat code is a bosonic rotation code whose primitive state is the coherent state \\(|\\alpha\\rangle\\) [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\n\nNumber-phase codes are bosonic rotation codes with the primitive state is a Pegg-Barnett phase state [S. M. Barnett and D. T. Pegg, \u201cPhase in quantum optics\u201d, Journal of Physics A: Mathematical and General 19, 3849 (1986). DOI].", "_type": "ecc", "_page_id": "c_bosonic_rotation", "_href": "c/bosonic_rotation"}, "c_number_phase": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Modular phase measurement done in the logical \\(X\\), or dual, basis has zero uncertainty in the case of ideal number phase codes. This is equivalent to a quantum measurement of the spectrum of the phase operator [L. Susskind and J. Glogower, \u201cQuantum mechanical phase and time operator\u201d, Physics Physique \u0444\u0438\u0437\u0438\u043a\u0430 1, 49 (1964). DOI]. Approximate number-phase codes are characterized by vanishing phase uncertainty. Such measurements can be utilized for Knill error correction (a.k.a. telecorrection [C. M. Dawson, H. L. Haselgrove, and M. A. Nielsen, \u201cNoise thresholds for optical cluster-state quantum computation\u201d, Physical Review A 73, (2006). DOI; quant-ph/0601066]), which is based on teleportation [E. Knill, \u201cQuantum computing with realistically noisy devices\u201d, Nature 434, 39 (2005). DOI; quant-ph/0410199][E. Knill, \u201cScalable Quantum Computation in the Presence of Large Detected-Error Rates\u201d. quant-ph/0312190]. This type of error correction substitutes the complicated correction procedures typical in Fock-state codes for necessity of clean codewords [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nNumber measurement can be done by extracting modular number information using a CROT gate \\(\\mathrm{e}^{(2\\pi \\mathrm{i} / NM) \\hat n \\otimes \\hat n}\\) and performing phase measurements [C. W. Helstrom, \u201cQuantum detection and estimation theory\u201d, Journal of Statistical Physics 1, 231 (1969). DOI][A. Holevo, Probabilistic and Statistical Aspects of Quantum Theory (Edizioni della Normale, 2011). DOI] on an ancillary mode. See Section 4.B.1 of Ref. [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "features_transversal_gates": "", "features_fault_tolerance": "Fault-tolerant computation schemes with number-phase codes have been proposed based on concatenation with Bacon-Shor subsystem codes [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "name": "Number-phase code", "code_id": "number_phase", "realizations": "", "protection": "Number-phase codes of order \\(N\\) detect up to \\(N\\) photon loss or gain errors, and dephasing up to \\(\\theta = \\pi/N\\).", "notes": "", "physical": "oscillators", "short_name": "", "introduced": "[A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071]", "description": "Bosonic rotation code consisting of superpositions of Pegg-Barnett phase states [S. M. Barnett and D. T. Pegg, \u201cPhase in quantum optics\u201d, Journal of Physics A: Mathematical and General 19, 3849 (1986). DOI], \\begin{align}\n|\\phi\\rangle \\equiv \\frac{1}{\\sqrt{2\\pi}}\\sum_{n=0}^{\\infty} \\mathrm{e}^{\\mathrm{i} n \\phi} \\ket{n}.\n\\end{align} Since phase states and thus the ideal codewords are not normalizable, approximate versions need to be constructed. The codes' key feature is that, in the ideal case, phase measurement has zero uncertainty, making it a good canditate for a syndrome measurement.\n\nLogical states of an order-\\(N\\) number-phase qubit encoding are \\(|\\overline{0}\\rangle= \\sum_{m=0}^{2N-1} |\\phi = m\\pi/N\\rangle\\) and \\(|\\overline{1}\\rangle = \\sum_{m=0}^{2N-1} (-1)^m |\\phi=m\\pi/N\\rangle\\). By performing the summation over \\(m\\), one finds that \\(|\\overline{0}\\rangle\\) is supported on Fock states \\(|2kN\\rangle\\), while \\(|\\overline{1}\\rangle\\) is supported on states \\(|(2k+1)N\\rangle\\), for \\(k \\geq 0\\). ", "parents_code_id": "bosonic_rotation", "parents_detail": "Number-phase codes are bosonic rotation codes with the primitive state is a Pegg-Barnett phase state [S. M. Barnett and D. T. Pegg, \u201cPhase in quantum optics\u201d, Journal of Physics A: Mathematical and General 19, 3849 (1986). DOI].", "cousins_code_id": "rotor_gkp\noscillator_stabilizer\ngkp", "cousins_detail": "Number-phase codes are a manifestation of planar-rotor GKP codes in an oscillator. Both codes protect against small shifts in angular degrees of freedom.\nNumber-phase codewords span the joint right eigenspace of the \\(N\\)th power of the Pegg-Barnett phase operator and the bosonic rotation operator [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071]. These operators no longer form a group since the phase operator is not unitary.\nGKP codes utilize translational symmetry in phase space, while number-phase codes utilize rotational symmetry. The two are related via a mapping [Allan D. C. Tosta, Thiago O. Maciel, and Leandro Aolita, \u201cGrand Unification of continuous-variable codes\u201d. 2206.01751].", "cousin_of_code_id": "binomial\ncat", "cousin_of_detail": "In the limit as \\(N,S \\to \\infty\\), phase measurement in the binomial code has vanishing variance, just like in a number-phase code [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].\nIn the limit as \\(N,S \\to \\infty\\), phase measurement in the cat code has vanishing variance, just like in a number-phase code [A. L. Grimsmo, J. Combes, and B. Q. Baragiola, \u201cQuantum Computing with Rotation-Symmetric Bosonic Codes\u201d, Physical Review X 10, (2020). DOI; 1901.08071].", "_type": "ecc", "_page_id": "c_number_phase", "_href": "c/number_phase"}, "c_rotor": {"logical": "groups", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Rotor code", "code_id": "rotor", "realizations": "", "protection": "", "notes": "", "physical": "groups", "short_name": "", "introduced": "", "description": "Encodes a logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space of \\(\\ell^2\\)-normalizable functions on either the integers \\(\\mathbb Z\\) or the circle group \\(U(1)\\).", "parents_code_id": "group_quantum", "parents_detail": "", "parent_of_code_id": "rotor_gkp\nrotor_3_1_2\nrotor_5_1_3", "parent_of_detail": "\n\n", "_type": "ecc", "_page_id": "c_rotor", "_href": "c/rotor"}, "c_rotor_5_1_3": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\([[5,1,3]]_{\\mathbb Z}\\) rotor code", "code_id": "rotor_5_1_3", "realizations": "", "protection": "Normalized codewords approximately protect against erasure while maintaining covariance [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]. ", "notes": "", "physical": "", "short_name": "", "introduced": "[P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]", "description": "Extension of the five-qubit stabilizer code to the integer alphabet, i.e., the angular momentum states of a planar rotor. The code is \\(U(1)\\)-covariant and ideal codewords are not normalizable. ", "parents_code_id": "rotor\ncovariant", "parents_detail": "\nThe \\([[5,1,3]]_{\\mathbb Z}\\) code is \\(U(1)\\)-covariant.", "cousins_code_id": "stab_5_1_3", "cousins_detail": "", "_type": "ecc", "_page_id": "c_rotor_5_1_3", "_href": "c/rotor_5_1_3"}, "c_group_quantum": {"logical": "groups", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Group-based quantum code", "code_id": "group_quantum", "realizations": "", "protection": "", "notes": "", "physical": "groups", "short_name": "", "introduced": "", "description": "Encodes a logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space of \\(\\ell^2\\)-normalizable functions on a second-countable unimodular group. For \\(K\\)-dimensional logical subspace and for groups \\(G^{n}\\), can be denoted as \\(((n,K))_G\\). When the logical subspace is the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(G^{ k}\\), can be denoted as \\([[n,k]]_G\\). Ideal codewords may not be normalizable, depending on whether \\(G\\) is continuous and/or noncompact, so approximate versions have to be constructed in practice.", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "group_gkp\nrotor", "parent_of_detail": "\n", "cousins_code_id": "qubits_into_qubits\nqudits_into_qudits\noscillators", "cousins_detail": "Group quantum codes whose physical spaces are constructed using the group \\(\\mathbb{Z}_2\\) are qubit codes.\nGroup quantum codes whose physical spaces are constructed using modular-integer groups \\(\\mathbb{Z}_q\\) are modular-qudit codes.\nGroup quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes.", "cousin_of_code_id": "group_classical", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_group_quantum", "_href": "c/group_quantum"}, "c_rotor_gkp": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Rotor GKP code", "code_id": "rotor_gkp", "realizations": "", "protection": "", "notes": "", "physical": "groups", "short_name": "", "introduced": "[D. Gottesman, A. Kitaev, and J. Preskill, \u201cEncoding a qubit in an oscillator\u201d, Physical Review A 64, (2001). DOI; quant-ph/0008040][V. V. Albert, J. P. Covey, and J. Preskill, \u201cRobust Encoding of a Qubit in a Molecule\u201d, Physical Review X 10, (2020). DOI; 1911.00099]", "description": "GKP code protecting against small angular position and momentum shifts of a planar rotor.", "parents_code_id": "rotor", "parents_detail": "", "cousins_code_id": "gkp", "cousins_detail": "GKP (rotor GKP) codes protect against shifts in linear (angular) degrees of freedom.", "cousin_of_code_id": "group_gkp\nnumber_phase", "cousin_of_detail": "Rotor GKP codes correspond to the \\(\\mathbb{Z}_{k_1} \\subseteq \\mathbb{Z}_{k_2} \\subset U(1)\\) group construction, where \\(k=k_2/k_1\\).\nNumber-phase codes are a manifestation of planar-rotor GKP codes in an oscillator. Both codes protect against small shifts in angular degrees of freedom.", "_type": "ecc", "_page_id": "c_rotor_gkp", "_href": "c/rotor_gkp"}, "c_molecular": {"logical": "rigid_bodies", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Molecular code", "code_id": "molecular", "realizations": "", "protection": "Protects against generalized bit-flip errors \\(g\\in SO_3\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "notes": "Physical space characterizes orientations of a rigid body in 3D, which correspond to rotational states of an asymmetric molecule. See APS Physics Synopsis [E. K. Carlson, \u201cProtecting Molecular Qubits from Noise\u201d, Physics 13, (2020). DOI] and Physical Review Journal club discussing molecular applications.", "physical": "groups", "short_name": "", "introduced": "[V. V. Albert, J. P. Covey, and J. Preskill, \u201cRobust Encoding of a Qubit in a Molecule\u201d, Physical Review X 10, (2020). DOI; 1911.00099]", "description": "Encodes finite-dimensional Hilbert space into the Hilbert space of \\(\\ell^2\\)-normalizable functions on the group \\(SO_3\\). Construction is based on nested subgroups \\(H\\subset K \\subset SO_3\\), where \\(H,K\\) are finite. The \\(|K|/|H|\\)-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\).", "parents_code_id": "group_gkp", "parents_detail": "", "_type": "ecc", "_page_id": "c_molecular", "_href": "c/molecular"}, "c_quantum_double": {"logical": "groups", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit [G. K. Brennen, M. Aguado, and J. I. Cirac, \u201cSimulations of quantum double models\u201d, New Journal of Physics 11, 053009 (2009). DOI; 0901.1345][M. Aguado, \u201cFrom entanglement renormalisation to the disentanglement of quantum double models\u201d, Annals of Physics 326, 2444 (2011). DOI; 1101.0527] or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates [M. Aguado and G. Vidal, \u201cEntanglement Renormalization and Topological Order\u201d, Physical Review Letters 100, (2008). DOI; 0712.0348].\nFor any solvable group \\(G\\), ground-state preparation and anyon-pair creation can be done with an adaptive constant-depth circuit with geometrically local gates and measurements throughout [Sergey Bravyi et al., \u201cAdaptive constant-depth circuits for manipulating non-abelian anyons\u201d. 2205.01933] (see Ref. [Ruben Verresen, Nathanan Tantivasadakarn, and Ashvin Vishwanath, \u201cEfficiently preparing Schr\u00f6dinger's cat, fractons and non-Abelian topological order in quantum devices\u201d. 2112.03061] for specific dihedral groups). Anyon-pair creation requires an adaptive circuit for any nonabelian \\(G\\) [Sergey Bravyi et al., \u201cAdaptive constant-depth circuits for manipulating non-abelian anyons\u201d. 2205.01933].", "features_decoders": "For any solvable group \\(G\\), topological charge measurements can be done with an adaptive constant-depth circuit with geometrically local gates and measurements throughout [Sergey Bravyi et al., \u201cAdaptive constant-depth circuits for manipulating non-abelian anyons\u201d. 2205.01933].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum-double code", "code_id": "quantum_double", "realizations": "", "protection": "Error-correcting properties established in Ref. [S. X. Cui et al., \u201cKitaev's quantum double model as an error correcting code\u201d, Quantum 4, 331 (2020). DOI; 1908.02829]. The code distance is the number of edges in the shortest non contractible cycle in the tesselation or dual tesselation [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143].", "notes": "The \\( \\Phi, \\Lambda \\) Decodoku game is based on the quantum double model for the group \\(S_3\\) of permutations on three letters.", "physical": "groups", "short_name": "", "introduced": "[A. Y. Kitaev, \u201cFault-tolerant quantum computation by anyons\u201d, Annals of Physics 303, 2 (2003). DOI; quant-ph/9707021]", "description": "A family of topological codes, defined by a finite group \\( G \\), whose generators are few-body operators associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit of dimension \\( |G| \\) located at each edge of the tesselation).\n\nThe physical Hilbert space has dimension \\( |G|^E  \\), where \\( E \\) is the number of edges in the tessellation. The dimension of the code space is the number of orbits of the conjugation action of \\( G \\) on \\( \\text{Hom}(\\pi_1(\\Sigma),G) \\), the set of group homomorphisms from the fundamental group of the surface \\( \\Sigma \\) into the finite group \\( G \\) [S. X. Cui et al., \u201cKitaev's quantum double model as an error correcting code\u201d, Quantum 4, 331 (2020). DOI; 1908.02829]. When \\( G \\) is abelian, the formula for the dimension simplifies to \\( |G|^{2g} \\), where \\( g \\) is the genus of the surface \\( \\Sigma \\).\n\nThe codespace is the ground-state subspace of the quantum double model Hamiltonian. For nonabelian groups, alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model [R. Walter Ogburn and J. Preskill, \u201cTopological Quantum Computation\u201d, Quantum Computing and Quantum Communications 341 (1999). DOI][C. Mochon, \u201cAnyon computers with smaller groups\u201d, Physical Review A 69, (2004). DOI; quant-ph/0306063][J. K. Pachos, Introduction to Topological Quantum Computation (Cambridge University Press, 2012). DOI]. The fusion space of such nonabelian anyons has dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.", "parents_code_id": "group_gkp\ntopological", "parents_detail": "Quantum-double models admit stabilizer-like \\(X\\)- and \\(Z\\)-type operators [Victor V. Albert et al., \u201cSpin chains, defects, and quantum wires for the quantum-double edge\u201d. 2111.12096], and the codes can be formulated as group GKP codes.\nQuantum-double code Hamiltonians admit topological phases associated with finite groups \\(G\\).", "cousins_code_id": "qudit_surface\nstring_net", "cousins_detail": "A quantum-double model with \\(G=\\mathbb{Z}_q\\) is the qudit surface code.\nString-net model reduces to the quantum-double model for group categories.", "cousin_of_code_id": "surface", "cousin_of_detail": "A quantum-double model with \\(G=\\mathbb{Z}_2\\) is the surface code.", "_type": "ecc", "_page_id": "c_quantum_double", "_href": "c/quantum_double"}, "c_rotor_3_1_2": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\([[3,1,2]]_{\\mathbb Z}\\) rotor code", "code_id": "rotor_3_1_2", "realizations": "", "protection": "Normalized codewords approximately protect against erasure while maintaining covariance [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]. ", "notes": "", "physical": "", "short_name": "", "introduced": "[P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471]", "description": "Extension of the \\([[3,1,2]]_3\\) qutrit CSS code to the integer alphabet, i.e., the angular momentum states of a planar rotor. The code is \\(U(1)\\)-covariant and ideal codewords are not normalizable. ", "parents_code_id": "rotor\ncovariant", "parents_detail": "\nThe \\([[3,1,2]]_{\\mathbb Z}\\) code is \\(U(1)\\)-covariant.", "cousins_code_id": "stab_3_1_2", "cousins_detail": "", "_type": "ecc", "_page_id": "c_rotor_3_1_2", "_href": "c/rotor_3_1_2"}, "c_group_gkp": {"logical": "groups", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "Group-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{ k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates representing \\(G\\) [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].", "features_fault_tolerance": "", "name": "Group GKP code", "code_id": "group_gkp", "realizations": "", "protection": "Protects against generalized bit-flip errors \\(g\\in G\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "notes": "", "physical": "groups", "short_name": "", "introduced": "[V. V. Albert, J. P. Covey, and J. Preskill, \u201cRobust Encoding of a Qubit in a Molecule\u201d, Physical Review X 10, (2020). DOI; 1911.00099]", "description": "Group code whose construction is based on nested subgroups \\(H\\subset K\n\\subset G\\). Logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\), and can be finite- or infinite-dimensional.\n\nThe group GKP code was originally formulated as an extension of the GKP code construction, and has turned out to encompass a wide variety of codes, tabulated in Table\u00a0I.\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n    Space\n    \\(G\\)\n    \\(H\\)\n    Related code\n    \\(n\\) qubits\n    \\(\\mathbb{Z}_2^n\\)\n    \\(\\mathbb{Z}_2^m\\)\n    qubit CSS\n    \\(n\\) modular qudits\n    \\(\\mathbb{Z}_q^n\\)\n    \\(\\mathbb{Z}_q^m\\)\n    modular-qudit CSS\n    \\(n\\) modes\n    \\( \\mathbb{R}^n \\)\n    \\( \\mathbb{R}^m \\)\n    analog stabilizer\n    \\(n\\) modes\n    \\( \\mathbb{R}^n \\)\n    \\( \\mathbb{Z}^n \\)\n    multimode GKP\n    \\(n\\) modes\n    \\( \\mathbb{R}^n \\)\n    \\( \\mathbb{Z}^{m<n} \\)\n    GKP-stabilizer\n    planar rotor\n    \\(U(1)\\)\n    \\(\\mathbb{Z}_n\\)\n    rotor GKP\n    rigid body\n    \\(SO(3)\\)\n    point group\n    molecular\n\nTable\u00a0I: Special cases of group GKP codes\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7", "parents_code_id": "group_quantum", "parents_detail": "", "parent_of_code_id": "molecular\nquantum_double", "parent_of_detail": "\nQuantum-double models admit stabilizer-like \\(X\\)- and \\(Z\\)-type operators [Victor V. Albert et al., \u201cSpin chains, defects, and quantum wires for the quantum-double edge\u201d. 2111.12096], and the codes can be formulated as group GKP codes.", "cousins_code_id": "oscillator_stabilizer\ncss\nqudit_css\nrotor_gkp", "cousins_detail": "The group-GKP construction encompasses all bosonic CSS codes. A singlemode qubit GKP code corresponds to the \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\) group construction, and multimode GKP codes can be similarly described. An \\([[n,k,d]]_{\\mathbb{R}}\\) analog stabilizer code corresponds to the \\(\\mathbb{R}^{ k_1} \\subseteq \\mathbb{R}^{ k_2} \\subset \\mathbb{R}^{n}\\) group construction, where \\(k=k_2/k_1\\). GKP stabilizer codes for \\(n\\) modes correspond to subgroups \\(\\mathbb{Z}^m\\) for \\(m<n\\).\nAn \\(n\\)-qubit CSS code corresponds to the \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{n}\\) group construction.\nAn \\(n\\) modular-qubit CSS code corresponds to the \\(\\mathbb{Z}_q^{k_1} \\subseteq \\mathbb{Z}_q^{k_2} \\subset \\mathbb{Z}_q^{n}\\) group construction, where \\(k=k_2/k_1\\).\nRotor GKP codes correspond to the \\(\\mathbb{Z}_{k_1} \\subseteq \\mathbb{Z}_{k_2} \\subset U(1)\\) group construction, where \\(k=k_2/k_1\\).", "cousin_of_code_id": "covariant\ngroup_linear", "cousin_of_detail": "Group-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates that represent the group \\(G\\), and are thus \\(G\\)-covariant [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].\n", "_type": "ecc", "_page_id": "c_group_gkp", "_href": "c/group_gkp"}, "c_stab_3_1_2": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "In addition to thinking about the encoding of states, it is also interesting to look at the trasformation of operators from the physical space into the logical space. Due to the unique structure and recovery protocol of the three qutrit code, the representation of a logical operator \\( \\overline{O} \\) is not unique. Instead, \\( \\overline{O} \\) can be constructed from unitary matricies with support on only two out of the three qutrits. Therefore, the logical operator has valid representations constructed from support on different sets of two qutrits. This operator construction is directly analogous to the construction of operators in the bulk (at the center) of the AdS\\(_3\\)-Rindler reconstruction. The three-qutrit code can then be used to describe how these local bulk operators are protected against localized boundary errors [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041].\nThis construction is related to the cleaning lemma [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983], which was introduced in the context of constructing self-correcting quantum memories from stabilizer codes with geometrically-local generators. In this lemma, subspaces can be cleaned out by removing operators with support on a subset of qutrits.", "features_decoders": "The quantum information (the secret) can be recovered from a unitary transformation acting on only two qutrits, \\( U_{ij} \\otimes I \\), where \\(U_{ij}\\) acts on qutrits \\(i,j\\) and \\(I\\) is the identity on the remaining qutrit. By the cyclic structure of the codewords, this unitary transformation performs a permutation that recovers the information and stores it in one of the two qutrits involved in recovery.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Three qutrit code", "code_id": "stab_3_1_2", "realizations": "", "protection": "Detects single qutrit errors and protects against a single-qutrit erasure. There does not exist a three-qubit code with analogous properties.\n\nThe code is an example of a \\( ((n = 3, k = 2)) \\) threshold scheme where a secret (the quantum information) is split into \\( n \\) shares and can be reconstructed by \\( k \\) pieces.\n\nThey key property of this code is that the reduced density matrix of any single qutrit is maximally mixed, meaning no information can be extracted from that qutrit. Therefore, a single qutrit tells you nothing about the encoded message, but access to any two pairs of qutrits will reveal the secret.", "notes": "Connections to Ads/CFT from the perspetive of how arbitrary operators are encoded into the logical space. This encoding is analagous and helps explain why operators acting on the bulk are protected against localized boundary errors [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041].", "physical": "qudits", "short_name": "\\([[3,1,2]]_3\\)", "introduced": "[R. Cleve, D. Gottesman, and H.-K. Lo, \u201cHow to Share a Quantum Secret\u201d, Physical Review Letters 83, 648 (1999). DOI; quant-ph/9901025]", "description": "A \\([[3,1,2]]_3\\) prime-qudit CSS code with stabilizer generators \\(ZZZ\\) and \\(XXX\\). The code defines a quantum secret-sharing scheme and serves as a minimal model for the AdS/CFT holographic duality. It is also the smallest non-trivial instance of a quantum maximum distance separable code (QMDS), saturating the quantum Singleton bound. The codewords are \\begin{align}\n  \\begin{split}\n    | \\overline{0} \\rangle &= \\frac{1}{\\sqrt{3}} (| 000 \\rangle + | 111 \\rangle + | 222 \\rangle) \\\\\n    | \\overline{1} \\rangle &= \\frac{1}{\\sqrt{3}} (| 012 \\rangle + | 120 \\rangle + | 201 \\rangle) \\\\\n    | \\overline{2} \\rangle &= \\frac{1}{\\sqrt{3}} (| 021 \\rangle + | 102 \\rangle + | 210 \\rangle)~.\n  \\end{split}\n\\end{align} The elements in the superposition of each logical codeword are related to each other via cyclic permutations. ", "parents_code_id": "qudit_css\nholographic\nquantum_mds", "parents_detail": "Smallest single-erasure correcting qudit code for \\(q>2\\).\nThree-qutrit code is a minimal model for holography [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][D. Harlow, \u201cThe Ryu\u2013Takayanagi Formula from Quantum Error Correction\u201d, Communications in Mathematical Physics 354, 865 (2017). DOI; 1607.03901].\nThe three-qutrit code is the smallest nontrivial quantum MDS code.", "cousins_code_id": "quantum_secret_sharing", "cousins_detail": "Three-qutrit code defines a minimal secret-sharing scheme [R. Cleve, D. Gottesman, and H.-K. Lo, \u201cHow to Share a Quantum Secret\u201d, Physical Review Letters 83, 648 (1999). DOI; quant-ph/9901025] that is substantially generalized by approximate secret-sharing codes.", "cousin_of_code_id": "rotor_3_1_2", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_stab_3_1_2", "_href": "c/stab_3_1_2"}, "c_qudit_hamming_css": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) prime-qudit CSS code", "code_id": "qudit_hamming_css", "realizations": "", "protection": "", "notes": "", "physical": "qudits", "short_name": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\)", "introduced": "[Arun J. Moorthy and Lane G. Gunderman, \u201cLocal-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise\u201d. 2110.11510]", "description": "A family of CSS codes extending Hamming-based CSS codes to prime qudits of dimension \\(p\\) by expressing the qubit code stabilizers in local-dimension-invariant (LDI) form [Arun J. Moorthy and Lane G. Gunderman, \u201cLocal-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise\u201d. 2110.11510].", "parents_code_id": "qudit_css", "parents_detail": "", "cousins_code_id": "quantum_hamming_css", "cousins_detail": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) codes are prime-qudit extensions of \\([[2^r-1, 2^r-2r-1, 3]]\\) codes.", "_type": "ecc", "_page_id": "c_qudit_hamming_css", "_href": "c/qudit_hamming_css"}, "c_frobenius": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Adapted from the Berlekamp decoding algorithm for classical BCH codes. There exists a polynomial time quantum algorithm to correct errors of weight at most \\(\\tau\\), where \\(\\delta=2\\tau+1\\) is the BCH distance of the code [Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code of length dividing $p^{t}+1$\u201d. 1011.5814]. ", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Frobenius code", "code_id": "frobenius", "realizations": "", "protection": "Protects against Pauli noise.", "notes": "Frobenius codes that are also stabilizer codes have been completely classified. No such codes exist when \\(t\\) is odd. All such codes with even \\(t\\) can be directly constructed.", "physical": "qudits", "short_name": "", "introduced": "[Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code of length dividing $p^{t}+1$\u201d. 1011.5814]", "description": "Let \\(C\\) be a quantum cyclic code on \\(n\\) prime-dimensional qudits. \\(C\\) is a Frobenius code if there exists a positive integer \\(t\\) such that \\(n\\) divides \\(p^t +1\\).", "parents_code_id": "qudit_stabilizer\nquantum_cyclic", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_frobenius", "_href": "c/frobenius"}, "c_qudit_stabilizer": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "The structure of stabilizer codes allows for syndrome-based decoding, where errors are corrected based on the results of stabilizer measurements (syndromes).\nTrellis decoder for prime-dimensional qudits, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) [Eric Sabo, Arun B. Aloshious, and Kenneth R. Brown, \u201cTrellis Decoding For Qudit Stabilizer Codes And Its Application To Qubit Topological Codes\u201d. 2106.08251].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Modular-qudit stabilizer code", "code_id": "qudit_stabilizer", "realizations": "", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "notes": "A standardized definition of the qudit stabilizer group is developed in [V. Gheorghiu, \u201cStandard form of qudit stabilizer groups\u201d, Physics Letters A 378, 505 (2014). DOI; 1101.1519].\nThe number of modular-qudit stabilizer codes was determined in Ref. [Tanmay Singal et al., \u201cCounting stabiliser codes for arbitrary dimension\u201d. 2209.01449].", "physical": "qudits", "short_name": "", "introduced": "[Daniel Gottesman, \u201cStabilizer Codes and Quantum Error Correction\u201d. quant-ph/9705052]", "description": "An \\(((n,K,d))_q\\) modular-qudit code whose logical subspace is the joint eigenspace of commuting qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code.\n\nA modular-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{q}\\) or \\([[n,k,d]]_{q}\\). For composite \\(q\\), such codes need not encode an integer number of qudits, with \\(K=q^n/|\\mathsf{S}|\\) [V. Gheorghiu, \u201cStandard form of qudit stabilizer groups\u201d, Physics Letters A 378, 505 (2014). DOI; 1101.1519]. This is because \\(|{\\mathsf{S}}|\\) need not be a power of \\(q\\), as group generators may have different orders. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\). Prime-qudit stabilizer codes, where \\(q=p\\) for some prime \\(p\\), do not suffer from this issue and encode \\(n-k\\) logical qudits, with \\(K=p^{n-k}\\).\n\nEach code can be represented by a check matrix (a.k.a. stabilizer generator matrix) \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(q\\)-ary symplectic representation of a stabilizer generator. The check matrix can be brought into standard form via Gaussian elimination [V. Gheorghiu, \u201cStandard form of qudit stabilizer groups\u201d, Physics Letters A 378, 505 (2014). DOI; 1101.1519].", "parents_code_id": "stabilizer\nqudits_into_qudits\nquantum_lego", "parents_detail": "\n\nModular-qudit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qudit repetition code, single-qudit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state.", "parent_of_code_id": "double_semion\nfrobenius\nqudit_css", "parent_of_detail": "Double-semion code can be realized as a modular-qudit stabilizer code with \\(q=4\\) [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394].\n\n", "cousin_of_code_id": "topological_abelian\ngalois_stabilizer\nqubit_stabilizer\nqudit_subsystem_stabilizer\ntranslationally_invariant_stabilizer", "cousin_of_detail": "All non-chiral abelian topological orders can be realized as modular-qudit stabilizer codes [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394].\nRecalling that \\(q=p^m\\), Galois-qudit stabilizer codes can also be treated as prime-qudit stabilizer codes on \\(mn\\) qudits, giving \\(k=nm-r\\) [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]. The case \\(m=1\\) reduces to conventional prime-qudit stabilizer codes on \\(n\\) qudits.\nModular-qudit stabilizer codes for prime-dimensional qudits \\(q=p\\) inherit most of the features of qubit stabilizer codes, including encoding an integer number of qudits and a Pauli group with a unique number of generators. Conversely, qubit codes can be extended to modular-qudit codes by decorating appropriate generators with powers. For example, \\([[4,2,2]]\\) qubit code generators can be adjusted to \\(ZZZZ\\) and \\(XX^{-1} XX^{-1}\\). A systematic procedure extending a qubit code to prime-qudit codes involves putting its generator matrix into local-dimension-invariant (LDI) form [L. G. Gunderman, \u201cLocal-dimension-invariant qudit stabilizer codes\u201d, Physical Review A 101, (2020). DOI; 1910.08122]. Various bounds exist on the distance of the resulting codes [Arun J. Moorthy and Lane G. Gunderman, \u201cLocal-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise\u201d. 2110.11510][L. G. Gunderman, \u201cDegenerate local-dimension-invariant stabilizer codes and an alternative bound for the distance preservation condition\u201d, Physical Review A 105, (2022). DOI; 2110.15274].\nSubsystem modular-qudit stabilizer codes reduce to modular-qudit stabilizer codes when there are no gauge qubits.\nModular-qudit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site.", "_type": "ecc", "_page_id": "c_qudit_stabilizer", "_href": "c/qudit_stabilizer"}, "c_polynomial": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum Reed-Solomon code", "code_id": "polynomial", "realizations": "", "protection": "", "notes": "", "physical": "qudits", "short_name": "Quantum RS", "introduced": "[M. Grassl, W. Geiselmann, and T. Beth, \u201cQuantum Reed\u2014Solomon Codes\u201d, Applied Algebra, Algebraic Algorithms and Error-Correcting Codes 231 (1999). DOI; quant-ph/9910059]", "description": "Also called prime-qudit polynomial code (QPyC). Prime-qudit CSS code constructed using two Reed-Solomon codes.\n\nThe original construction [M. Grassl, W. Geiselmann, and T. Beth, \u201cQuantum Reed\u2014Solomon Codes\u201d, Applied Algebra, Algebraic Algorithms and Error-Correcting Codes 231 (1999). DOI; quant-ph/9910059] was for a qubit code (\\(p=2\\)) by using a basis for a larger Galois field over \\(GF(2)\\), yielding an \\([[kN,k(N-2K),K+1]]\\) qubit code from a \\([N,K,\\delta]_{GF(2^k)}\\) RS code with \\(N=2^k-1\\) and \\(K=N-\\delta+1\\).\n\nAn alternative construction [D. Gottesman. Surviving as a quantum computer in a classical world] yields an \\([[n,k,n-k+1]]_p\\) (with prime \\(p>n\\)) prime-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(p)=\\mathbb{Z}_p\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(\\mathbb{Z}_p\\), and let \\(g\\) be a number satisfying \\(0\\leq k \\leq g < n\\). Then, define degree-\\(g\\) polynomials \\begin{align}\n  f_{\\mu\\cup c}\\left(x\\right)=\\mu_{0}+\\mu_{1}x+\\cdots+\\mu_{k-1}x^{k-1}+c_{k}x^{k}+\\cdots+c_{g}x^{g}\\,,\n\\end{align} where the first \\(k\\) coefficients are indexed by the coefficient vector \\(\\mu\\in\\mathbb{Z}_p^{ k}\\), and the remaining coefficients are indexed by the vector \\(c\\in\\mathbb{Z}_p^{ (g+1-k)}\\). Logical states, labeled by \\(\\mu\\), are superpositions of canonical basis states whose \\(i\\)th bit is \\(f_{\\mu\\cup c}\\), evaluated at \\(\\alpha_i\\) and summed over all possible vectors \\(c\\), \\begin{align}\n  |\\overline{\\mu}\\rangle=\\sum_{c\\in\\mathbb{Z}_{p}^{(g+1-k)}}|f_{\\mu\\cup c}(\\alpha_{1}),|f_{\\mu\\cup c}(\\alpha_{2}),\\cdots,|f_{\\mu\\cup c}(\\alpha_{n})\\rangle.\n\\end{align}", "parents_code_id": "qudit_css", "parents_detail": "", "cousins_code_id": "reed_solomon\nquantum_mds", "cousins_detail": "Polynomial codes are CSS codes constructed from Reed-Solomon codes.\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).", "cousin_of_code_id": "galois_polynomial", "cousin_of_detail": "Polynomial codes can be defined for modular qudits of prime dimension or, more generally, for Galois qudits.", "_type": "ecc", "_page_id": "c_polynomial", "_href": "c/polynomial"}, "c_qudit_subsystem_stabilizer": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Subsystem modular-qudit stabilizer code", "code_id": "qudit_subsystem_stabilizer", "realizations": "", "protection": "", "notes": "", "physical": "qudits", "short_name": "", "introduced": "", "description": "Modular qudit version of a subsystem qubit stabilizer code. Can be obtained by taking a modular qudit stabilizer code and assigning some of its logical qubits to be gauge qubits. ", "parents_code_id": "oecc", "parents_detail": "", "cousins_code_id": "qudit_stabilizer\nsubsystem_stabilizer", "cousins_detail": "Subsystem modular-qudit stabilizer codes reduce to modular-qudit stabilizer codes when there are no gauge qubits.\nSubsystem modular-qudit stabilizer codes reduce to subsystem qubit stabilizer codes for qudit dimension \\(q=2\\).", "_type": "ecc", "_page_id": "c_qudit_subsystem_stabilizer", "_href": "c/qudit_subsystem_stabilizer"}, "c_qudit_surface": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Modular-qudit surface code", "code_id": "qudit_surface", "realizations": "", "protection": "", "notes": "The simplest Decodoku game is based on the qudit surface code with \\( q=10\\).", "physical": "qudits", "short_name": "", "introduced": "[A. Y. Kitaev, \u201cFault-tolerant quantum computation by anyons\u201d, Annals of Physics 303, 2 (2003). DOI; quant-ph/9707021][S. S. Bullock and G. K. Brennen, \u201cQudit surface codes and gauge theory with finite cyclic groups\u201d, Journal of Physics A: Mathematical and Theoretical 40, 3481 (2007). DOI; quant-ph/0609070][Haruki Watanabe, Meng Cheng, and Yohei Fuji, \u201cGround state degeneracy on torus in a family of $\\mathbb{Z}_N$ toric code\u201d. 2211.00299]", "description": "Extension of the surface code to prime-dimensional [A. Y. Kitaev, \u201cFault-tolerant quantum computation by anyons\u201d, Annals of Physics 303, 2 (2003). DOI; quant-ph/9707021][S. S. Bullock and G. K. Brennen, \u201cQudit surface codes and gauge theory with finite cyclic groups\u201d, Journal of Physics A: Mathematical and Theoretical 40, 3481 (2007). DOI; quant-ph/0609070] and more general modular qudits [Haruki Watanabe, Meng Cheng, and Yohei Fuji, \u201cGround state degeneracy on torus in a family of $\\mathbb{Z}_N$ toric code\u201d. 2211.00299]. Stabilizer generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface. Since qudits have more than one \\(X\\) and \\(Z\\)-type operator, various sets of stabilizer generators can be defined. Ground-state degeneracy and the associated phase depends on the qudit dimension and the stabilizer generators.", "parents_code_id": "qudit_css", "parents_detail": "Plaquette and star operators are stabilizer generators.", "cousins_code_id": "topological_abelian\nsurface\nstring_net", "cousins_detail": "Modular-qudit surface code Hamiltonians can admit topological phases associated with \\(\\mathbb{Z}_q\\) [S. S. Bullock and G. K. Brennen, \u201cQudit surface codes and gauge theory with finite cyclic groups\u201d, Journal of Physics A: Mathematical and Theoretical 40, 3481 (2007). DOI; quant-ph/0609070].\nThe qudit surface code with \\(q=2\\) is the surface code.\nString-net model reduces to the qudit surface code when the category is the group \\(\\mathbb{Z}_q\\).", "cousin_of_code_id": "quantum_double\ntranslationally_invariant_stabilizer", "cousin_of_detail": "A quantum-double model with \\(G=\\mathbb{Z}_q\\) is the qudit surface code.\nTranslation-invariant 2D prime-qudit topological stabilizer codes are equivalent to several copies of the prime-qudit surface code via a local constant-depth Clifford circuit [J. Haah, \u201cClassification of translation invariant topological Pauli stabilizer codes for prime dimensional qudits on two-dimensional lattices\u201d, Journal of Mathematical Physics 62, 012201 (2021). DOI; 1812.11193].", "_type": "ecc", "_page_id": "c_qudit_surface", "_href": "c/qudit_surface"}, "c_qudits_into_qudits": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Modular-qudit code", "code_id": "qudits_into_qudits", "realizations": "", "protection": "A convenient and often considered error set is the modular-qudit analogue of the Pauli string basis for qubit codes. For a single qudit, this set consists of products of powers of the qudit Pauli matrices \\(X\\) and \\(Z\\), which act on computational basis states \\(|k\\rangle\\) for \\(k\\in\\mathbb{Z}_q\\) as \\begin{align}\n  X\\left|k\\right\\rangle =\\left|k+1\\right\\rangle \\,\\,\\text{ and }\\,\\,Z\\left|k\\right\\rangle =e^{i\\frac{2\\pi}{q}k}\\left|k\\right\\rangle ~,\n\\end{align} with addition performed modulo \\(q\\). For multiple qudits, error set elements are tensor products of elements of the single-qudit error set.\n\nThe Pauli error set is a unitary basis for linear operators on the multi-qudit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a nice error basis [E. Knill, \u201cNon-binary Unitary Error Bases and Quantum Codes\u201d. quant-ph/9608048]. The distance associated with this set is often the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code. ", "notes": "See Refs. [\u201cFull length article\u201d, Chaos, Solitons &amp; Fractals 10, 1749 (1999). DOI; quant-ph/9802007][E. Hostens, J. Dehaene, and B. De Moor, \u201cStabilizer states and Clifford operations for systems of arbitrary dimensions and modular arithmetic\u201d, Physical Review A 71, (2005). DOI; quant-ph/0408190] for descriptions of the qudit Clifford group.\nWeight distribution of a code depends on the average entanglement of codewords [A. J. Scott, \u201cMultipartite entanglement, quantum-error-correcting codes, and entangling power of quantum evolutions\u201d, Physical Review A 69, (2004). DOI; quant-ph/0310137][Louis Schatzki et al., \u201cA Hierarchy of Multipartite Correlations Based on Concentratable Entanglement\u201d. 2209.07607].", "physical": "qudits", "short_name": "", "introduced": "", "description": "Also called a \\(\\mathbb{Z}_q\\)-qudit code. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the group \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\). Usually denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined, and with \\(q=p\\) when the dimension is prime. ", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "qudit_stabilizer", "parent_of_detail": "", "cousin_of_code_id": "eaqecc\ngalois_into_galois\ngroup_quantum", "cousin_of_detail": "Pure modular-qudit codes can be used to make EA-QECCs with the same distance and dimension; see Thm. 10 of Ref. [M. Grassl, F. Huber, and A. Winter, \u201cEntropic Proofs of Singleton Bounds for Quantum Error-Correcting Codes\u201d, IEEE Transactions on Information Theory 68, 3942 (2022). DOI; 2010.07902].\nA Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]; see Sec. 5.3 of Ref. [Annika Niehage, \u201cQuantum Goppa Codes over Hyperelliptic Curves\u201d. quant-ph/0501074]. The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently.\nGroup quantum codes whose physical spaces are constructed using modular-integer groups \\(\\mathbb{Z}_q\\) are modular-qudit codes.", "_type": "ecc", "_page_id": "c_qudits_into_qudits", "_href": "c/qudits_into_qudits"}, "c_w_state": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "All logical gates can be implemented transversally. The logical unitary \\(U_L\\) can be performed with the physical unitary \\(U_L\\otimes U_L\\otimes\\cdots\\otimes U_L\\), where on the physical space \\(U_L\\) is taken to act trivially on \\(\\ket\\perp\\), i.e., \\( U_L\\ket\\perp = \\ket\\perp\\).", "features_fault_tolerance": "", "name": "W-state code", "code_id": "w_state", "realizations": "", "protection": "The W state code is an approximate error-correcting code. Intuitively, if a subsystem is lost to the environment, the environment only gains access to \\(\\ket\\psi\\) with probability of order \\(1/n\\). Under a single located erasure, the worst-cast entanglement infidelity of the W state code can be upper bound as \\begin{align}\n  \\epsilon_{\\mathrm{worst}} \\leq \\frac{\\sqrt{2} + d_L}{\\sqrt{n}}\\ .\n\\end{align}\n\nIn contrast to the Eigenstate thermalization hypothesis (ETH) code, the W state code does not saturate the scaling \\(1/n\\) in worst-case entanglement infidelity which is known to be optimal for covariant approximate error-correcting codes\u00a0[P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].", "notes": "", "physical": "qudits", "short_name": "", "introduced": "[P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]", "description": "Encodes a quantum state of a \\(d_L\\)-dimensional Hilbert space into \\(n\\) physical quantum systems, each associated with a Hilbert space of dimension \\(d_L+1\\). The encoding resembles the structure of the W state\u00a0[W. D\u00fcr, G. Vidal, and J. I. Cirac, \u201cThree qubits can be entangled in two inequivalent ways\u201d, Physical Review A 62, (2000). DOI; quant-ph/0005115]: \\begin{align}\n  \\ket\\psi\n  \\to \\frac{1}{\\sqrt{n}}\\bigl(\\ket{\\psi\\perp\\perp\\ldots}\n  + \\ket{\\perp\\psi\\perp\\ldots} + \\cdots\n  + \\ket{\\perp\\perp\\ldots\\psi}\\bigr)\\ ,\n\\end{align} where on each physical system, \\(\\ket\\perp\\) denotes the \\((d_L+1)\\)-th basis state and \\(\\ket\\psi\\) is encoded using the first \\(d_L\\) basis states.\n\nThis code enables universal quantum computation with transversal gates. Indeed, to apply any logical unitary \\(U\\) it suffices to apply \\(U\\) on each physical system, where the unitary is taken to act nontrivially only on the \\(d_L\\) first basis states of each system. Universal computation with transversal gates does not violate the Eastin-Knill theorem because this code is an approximate error-correcting code\u00a0[P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471][P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714] rather than an exact error-correcting code.", "parents_code_id": "approximate_qecc\ncovariant", "parents_detail": "The W-state code approximately protects against a single erasure while allowing for a universal transversal set of gates.\nThe W-state code approximately protects against a single erasure while allowing for a universal transversal set of gates.", "_type": "ecc", "_page_id": "c_w_state", "_href": "c/w_state"}, "c_stabilizer_over_gfqsq": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Stabilizer code over \\(GF(q^2)\\)", "code_id": "stabilizer_over_gfqsq", "realizations": "", "protection": "", "notes": "", "physical": "galois", "short_name": "", "introduced": "[Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070]", "description": "An \\([[n,k,d]]_{GF(q)}\\) Galois-qudit stabilizer code constructed from a classical code over \\(GF(q^2)\\) using the one-to-one correspondence between the Galois-qudit Pauli matrices and elements of the Galois field \\(GF(q^2)\\).\n\nAn \\(n\\) Galois-qudit Pauli stabilizer can be represented as a length-\\(n\\) vector over \\(GF(q^2)\\). The stabilizer commutation condition corresponds to a zero trace-alternating inner product between the corresponding vectors. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from classical trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\) [Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070]. Hermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal, and applying this construction to such codes yields a class of true stabilizer codes. ", "parents_code_id": "galois_true_stabilizer", "parents_detail": "Trace-alternating self-orthogonal linear codes over \\(GF(q^2)\\) are equivalent to a class of true stabilizer codes [D. Gottesman. Surviving as a quantum computer in a classical world]. Hermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal and can be used to construct true stabilizer codes via the stabilizer-over-\\(GF(q^2)\\) construction ([Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19).", "cousins_code_id": "dual_additive\nstabilizer_over_gf4", "cousins_detail": "The stabilizer commutation condition for stabilizer codes over \\(GF(q^2)\\) can equivalently be stated in the representation of stabilizers as vectors over \\(GF(q^2)\\). A pair of \\(n\\) Galois-qudit stabilizers commute iff the trace-alternating inner product of their their corresponding vectors is zero. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\).\nStabilizer codes over \\(GF(q^2)\\) are Galois-qudit extensions of those over \\(GF(4)\\).", "_type": "ecc", "_page_id": "c_stabilizer_over_gfqsq", "_href": "c/stabilizer_over_gfqsq"}, "c_qudit_css": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Modular-qudit CSS code", "code_id": "qudit_css", "realizations": "", "protection": "", "notes": "", "physical": "qudits", "short_name": "", "introduced": "[A. R. Calderbank and P. W. Shor, \u201cGood quantum error-correcting codes exist\u201d, Physical Review A 54, 1098 (1996). DOI; quant-ph/9512032][A. M. Steane, \u201cError Correcting Codes in Quantum Theory\u201d, Physical Review Letters 77, 793 (1996). DOI][\u201cMultiple-particle interference and quantum error correction\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 452, 2551 (1996). DOI; quant-ph/9601029]", "description": "An \\(((n,K,d))_q\\) modular-qudit stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The stabilizer generator matrix, taking values from \\(\\mathbb{Z}_q\\), is of the form \\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityq}\n\\end{align} such that the rows of the two blocks must be orthogonal \\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commQ}\n\\end{align} The above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nFor composite \\(q\\), such codes need not encode an integer number of qudits. For prime \\(q=p\\), properties reminiscent of qubit CSS codes are restored: encoding is based on two related \\(p\\)-ary linear codes, an \\([n,k_X,d_X]_p \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_p \\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\(\\eqref{eq:parityq}\\) is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\(\\eqref{eq:commQ}\\). Basis states for the code are, for \\(\\gamma \\in C_X\\), \\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align} ", "parents_code_id": "qudit_stabilizer", "parents_detail": "", "parent_of_code_id": "qudit_surface\npolynomial\nstab_3_1_2\nqudit_hamming_css", "parent_of_detail": "Plaquette and star operators are stabilizer generators.\n\nSmallest single-erasure correcting qudit code for \\(q>2\\).\n", "cousins_code_id": "css\nq-ary_linear", "cousins_detail": "Extension of CSS codes to modular-integer qudits.\nConstruction for prime \\(q=p\\) uses two related \\(p\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).", "cousin_of_code_id": "group_gkp", "cousin_of_detail": "An \\(n\\) modular-qubit CSS code corresponds to the \\(\\mathbb{Z}_q^{k_1} \\subseteq \\mathbb{Z}_q^{k_2} \\subset \\mathbb{Z}_q^{n}\\) group construction, where \\(k=k_2/k_1\\).", "_type": "ecc", "_page_id": "c_qudit_css", "_href": "c/qudit_css"}, "c_galois_topological": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-qudit topological code", "code_id": "galois_topological", "realizations": "", "protection": "", "notes": "", "physical": "galois", "short_name": "", "introduced": "[S. S. Bullock and G. K. Brennen, \u201cQudit surface codes and gauge theory with finite cyclic groups\u201d, Journal of Physics A: Mathematical and Theoretical 40, 3481 (2007). DOI; quant-ph/0609070][P. Sarvepalli, \u201cTopological color codes over higher alphabet\u201d, 2010 IEEE Information Theory Workshop (2010). DOI][Iryna Andriyanova, Denise Maurice, and Jean-Pierre Tillich, \u201cNew constructions of CSS codes obtained by moving to higher alphabets\u201d. 1202.3338]", "description": "Abelian topological code, such as a surface [S. S. Bullock and G. K. Brennen, \u201cQudit surface codes and gauge theory with finite cyclic groups\u201d, Journal of Physics A: Mathematical and Theoretical 40, 3481 (2007). DOI; quant-ph/0609070][Iryna Andriyanova, Denise Maurice, and Jean-Pierre Tillich, \u201cNew constructions of CSS codes obtained by moving to higher alphabets\u201d. 1202.3338] or color [P. Sarvepalli, \u201cTopological color codes over higher alphabet\u201d, 2010 IEEE Information Theory Workshop (2010). DOI] code, constructed on lattices of Galois qudits. ", "parents_code_id": "galois_css\ntopological", "parents_detail": "\n", "cousins_code_id": "surface\ncolor", "cousins_detail": "Surface code has been extended to Galois qudits.\nColor code has been extended to Galois qudits.", "_type": "ecc", "_page_id": "c_galois_topological", "_href": "c/galois_topological"}, "c_skew-cyclic_galois_css": {"logical": "qudits", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Skew-cyclic CSS code", "code_id": "skew-cyclic_galois_css", "realizations": "", "protection": "", "notes": "", "physical": "qudits", "short_name": "", "introduced": "[H. Q. Dinh et al., \u201cA class of skew cyclic codes and application in quantum codes construction\u201d, Discrete Mathematics 344, 112189 (2021). DOI]", "description": "Stub.", "parents_code_id": "galois_css", "parents_detail": "", "cousins_code_id": "skew_cyclic", "cousins_detail": "Skew-cyclic CSS codes are constructed from classical skew-cylic codes.", "_type": "ecc", "_page_id": "c_skew-cyclic_galois_css", "_href": "c/skew-cyclic_galois_css"}, "c_galois_bch": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-qudit BCH code", "code_id": "galois_bch", "realizations": "", "protection": "", "notes": "", "physical": "galois", "short_name": "Galois-qudit BCH", "introduced": "[Salah Aly, Andreas Klappenecker, and Pradeep Kiran Sarvepalli, \u201cPrimitive Quantum BCH Codes over Finite Fields\u201d. quant-ph/0501126][Salah A. Aly, Andreas Klappenecker, and Pradeep Kiran Sarvepalli, \u201cOn Quantum and Classical BCH Codes\u201d. quant-ph/0604102][S. A. Aly, A. Klappenecker, and P. K. Sarvepalli, \u201cOn Quantum and Classical BCH Codes\u201d, IEEE Transactions on Information Theory 53, 1183 (2007). DOI][R. Li et al., \u201cHermitian dual containing BCH codes and Construction of new quantum codes\u201d, Quantum Information and Computation 13, 21 (2013). DOI][G. G. La Guardia, \u201cConstructions of new families of nonbinary quantum codes\u201d, Physical Review A 80, (2009). DOI][X. Zhao et al., \u201cHermitian dual-containing constacyclic BCH codes and related quantum codes of length $\\frac{q^{2m}-1}{q+1}$\u201d. 2007.13309]", "description": "True Galois-qudit stabilizer code constructed from BCH codes via either the Hermitian construction or the Galois-qudit CSS construction. ", "parents_code_id": "galois_true_stabilizer", "parents_detail": "Galois-qudit BCH codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes.", "cousins_code_id": "quantum_bch\nq-ary_bch\ngalois_css", "cousins_detail": "\n\nSome Galois-qudit BCH codes are CSS.", "_type": "ecc", "_page_id": "c_galois_bch", "_href": "c/galois_bch"}, "c_galois_stabilizer": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "As opposed to modular qudits for composite \\(q\\), Galois qudits inherit most of the properties of the prime-qudit Clifford group due to the correspondence between a \\(q=p^m\\) Galois qudit and \\(m\\) prime qudits of dimension \\(p\\) [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Encoder with \\(O(n^2)\\) gates can be determined in classical runtime of order \\(O(n^3)\\) [M. GRASSL, M. R\u00d6TTELER, and T. BETH, \u201cEFFICIENT QUANTUM CIRCUITS FOR NON-QUBIT QUANTUM ERROR-CORRECTING CODES\u201d, International Journal of Foundations of Computer Science 14, 757 (2003). DOI; quant-ph/0211014].", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-qudit stabilizer code", "code_id": "galois_stabilizer", "realizations": "", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. Corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qudits.", "notes": "The number of Galois-qudit stabilizer codes was determined in Ref. [D. Gross, \u201cHudson\u2019s theorem for finite-dimensional quantum systems\u201d, Journal of Mathematical Physics 47, 122107 (2006). DOI; quant-ph/0602001].", "physical": "galois", "short_name": "", "introduced": "[A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI][Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070]", "description": "An \\(((n,K,d))_{GF(q)}\\) Galois-qudit code whose logical subspace is the joint eigenspace of commuting Galois-qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a Galois-qudit Pauli string that implements a nontrivial logical operation in the code.\n\nA Galois-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{GF(q)}\\) or \\([[n,k,d]]_{GF(q)}\\). This notation differentiates between Galois-qudit and modular-qudit stabilizer codes, although the same notation, \\([[n,k,d]]_q\\), is usually used for both. Galois-qudit stabilizer codes need not encode an integer number of qudits, with \\(K=q^{n-\\frac{r}{m}}\\), where \\(r\\) is the number of generators of the stabilizer group, and \\(q=p^m\\) given prime \\(p\\) for all Galois qudits. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\).\n\nThe stabilizer commutation condition can equivalently be stated in the symplectic representation. A pair of Galois-qudit stabilizers on \\(n\\) Galois qudits with symplectic representation vectors \\((a|b)\\) and \\((a^{\\prime}|b^{\\prime})\\) commute iff their trace symplectic inner product is zero, \\begin{align}\n\\text{tr}(a \\cdot b^{\\prime} - a^{\\prime}\\cdot b) = \\sum_{j=1}^{n} \\text{tr}(a_j b^{\\prime}_j - a^{\\prime}_i b_i) = 0~.\n\\end{align} Symplectic representations of stabilizer group elements thus form a self-orthogonal subspace of \\(GF(q)^{2n}\\) with respect to the trace-symplectic inner product.\n\nNote that the above trace-symplectic inner product reduces to the symplectic inner product when the trace is removed, and a symplectic self-orthogonal set of vectors is automatically trace-symplectic self-orthogonal. More generally, any additive classical code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code (see children).", "parents_code_id": "stabilizer\nnon_stabilizer", "parents_detail": "\nA non-stabilizer code is also a stabilizer code if its Fourier description \\(\\mathsf{B}\\) is a subgroup of some Gottesman subgroup \\(\\mathsf{S}\\). When \\(\\mathsf{B}\\) is just a subset, the code is explicitly not a stabilizer code.", "parent_of_code_id": "galois_true_stabilizer", "parent_of_detail": "", "cousins_code_id": "qubit_stabilizer\nqudit_stabilizer\nq-ary_additive\ndual_additive", "cousins_detail": "Galois-qudit stabilizer codes reduce to qubit stabilizer codes for \\(q=2\\).\nRecalling that \\(q=p^m\\), Galois-qudit stabilizer codes can also be treated as prime-qudit stabilizer codes on \\(mn\\) qudits, giving \\(k=nm-r\\) [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]. The case \\(m=1\\) reduces to conventional prime-qudit stabilizer codes on \\(n\\) qudits.\nA Galois-qudit stabilizer code is the closest quantum analogue of an additive code over \\(GF(q)\\) because addition in the field corresponds to multiplication of stabilizers in the quantum case.\nAn additive code of length \\(2n\\) over \\(GF(q)\\) that is self-orthogonal with respect to the trace-symplectic inner product corresponds to symplectic representations of an \\(n\\) Galois-qudit stabilizer group [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]. Moreover, any additive code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code.", "_type": "ecc", "_page_id": "c_galois_stabilizer", "_href": "c/galois_stabilizer"}, "c_galois_true_stabilizer": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "True Galois-qudit stabilizer code", "code_id": "galois_true_stabilizer", "realizations": "", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.", "notes": "", "physical": "galois", "short_name": "True stabilizer", "introduced": "[A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI][Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070][D. Gottesman. Surviving as a quantum computer in a classical world]", "description": "Also called a linear stabilizer code. A \\([[n,k,d]]_{GF(q)}\\) stabilizer code whose stabilizer's symplectic representation forms a linear subspace. In other words, the set of \\(q\\)-ary vectors representing the stabilizer group is closed under both addition and multiplication by elements of \\(GF(q)\\). In contrast, Galois-qudit stabilizer codes admit sets of vectors that are closed under addition only.\n\nThe number of generators \\(r\\) for a true stabilizer code is a multiple of \\(m\\) (recall that \\(q=p^m\\) for Galois qudits). As a result, the number \\(k=n-r/m\\) of logical qudits is an integer.\n\nEach code can be represented by a stabilizer generator matrix \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(GF(q)\\)-valued symplectic representation of a stabilizer generator.\n\nA Hermitian self-orthogonal linear \\([n,k,d]_{GF(q^2)}\\) code can be used to construct an \\([[n,n-2k]]_{GF(q)}\\) true stabilizer code with distance no less than \\(d\\). This Hermitian construction was first proven via the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI], Corr. 1), and later proven via the stabilizer-over-\\(GF(q^2)\\) construction (showing self-orthogonality under the trace-alternating inner product; see Ref. [Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19). There is an isomorphism between the symplectic and stabilizer-over-\\(GF(q^2)\\) representations (Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.8). The Hermitian construction has been extended to \\(q^{2m}\\)-ary Hermitian self-orthogonal linear codes [Carlos Galindo and Fernando Hernando, \u201cOn the generalization of the construction of quantum codes from Hermitian self-orthogonal codes\u201d. 2012.11998] and similar constructions exist [M. F. Ezerman, S. Ling, and P. Sole, \u201cAdditive Asymmetric Quantum Codes\u201d, IEEE Transactions on Information Theory 57, 5536 (2011). DOI; 1002.4088].", "parents_code_id": "galois_stabilizer", "parents_detail": "", "parent_of_code_id": "galois_bch\ngalois_css\ngalois_grs\nstabilizer_over_gfqsq", "parent_of_detail": "Galois-qudit BCH codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes.\nGalois-qudit CSS codes are true stabilizer codes [D. Gottesman. Surviving as a quantum computer in a classical world].\nGalois-qudit GRS codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes.\nTrace-alternating self-orthogonal linear codes over \\(GF(q^2)\\) are equivalent to a class of true stabilizer codes [D. Gottesman. Surviving as a quantum computer in a classical world]. Hermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal and can be used to construct true stabilizer codes via the stabilizer-over-\\(GF(q^2)\\) construction ([Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19).", "cousins_code_id": "q-ary_linear\ndual\nquantum_mds\nmatrix_product", "cousins_detail": "A true Galois-qudit stabilizer code is the closest quantum analogue of a linear code over \\(GF(q)\\) because the \\(q\\)-ary vectors corresponding to the symplectic representation of the stabilizers form a linear subspace.\nHermitian self-orthogonal linear codes over \\(GF(q^2)\\) yield true stabilizer codes via either the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI], Corr. 1) or the stabilizer-over-\\(GF(q^2)\\) construction (showing self-orthogonality under the trace-alternating inner product; see Ref. [Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070], Corr. 19 or Ref. [W. C. Huffman, J.-L. Kim, and P. Sol\u00e9, Concise Encyclopedia of Coding Theory (Chapman and Hall/CRC, 2021). DOI], Thm. 27.3.8).\nMany MDS codes are constructed from Hermitian self-orthogonal codes over \\(GF(q^2)\\) using the Hermitian construction [M. GRASSL, T. BETH, and M. R\u00d6TTELER, \u201cON OPTIMAL QUANTUM CODES\u201d, International Journal of Quantum Information 02, 55 (2004). DOI; quant-ph/0312164][R. Li and Z. Xu, \u201cConstruction of<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mo stretchy=\"false\">[</mml:mo><mml:mo stretchy=\"false\">[</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>\u2212</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy=\"false\">]</mml:mo><mml:mo stretchy=\"false\">]</mml:mo><mml:msub><mml:mrow /><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>quantum codes for odd prime power<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:math>\u201d, Physical Review A 82, (2010). DOI; 0906.2509][Xianmang He, Liqing Xu, and Hao Chen, \u201cNew $q$-ary Quantum MDS Codes with Distances Bigger than $\\frac{q}{2}$\u201d. 1507.08355][Liangdong Lu et al., \u201cNew Quantum MDS codes constructed from Constacyclic codes\u201d. 1803.07927], in particular from cyclic [G. G. La Guardia, \u201cNew Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 57, 5551 (2011). DOI], constacyclic [X. Kai, S. Zhu, and P. Li, \u201cConstacyclic Codes and Some New Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 60, 2080 (2014). DOI][B. Chen, S. Ling, and G. Zhang, \u201cApplication of Constacyclic Codes to Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 61, 1474 (2015). DOI] and negacyclic [X. Kai and S. Zhu, \u201cNew Quantum MDS Codes From Negacyclic Codes\u201d, IEEE Transactions on Information Theory 59, 1193 (2013). DOI] codes.\nHermitian self-orthogonal matrix-product codes over \\(GF(q^2)\\) can be used to construct true stabilizer codes [M. Cao and J. Cui, \u201cConstruction of new quantum codes via Hermitian dual-containing matrix-product codes\u201d, Quantum Information Processing 19, (2020). DOI][Xiusheng Liu, Hualu Liu, and Long Yu, \u201cOn New Quantum Codes From Matrix Product Codes\u201d. 1604.05823].", "_type": "ecc", "_page_id": "c_galois_true_stabilizer", "_href": "c/galois_true_stabilizer"}, "c_galois_grs": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-qudit GRS code", "code_id": "galois_grs", "realizations": "", "protection": "", "notes": "", "physical": "galois", "short_name": "Galois GRS", "introduced": "[Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129][Lingfei Jin and Chaoping Xing, \u201cA Construction of New Quantum MDS Codes\u201d. 1311.3009]", "description": "True \\(q\\)-Galois-qudit stabilizer code constructed from generalized Reed-Solomon (GRS) codes via either the Hermitian construction [Lingfei Jin and Chaoping Xing, \u201cA Construction of New Quantum MDS Codes\u201d. 1311.3009][X. Liu, L. Yu, and H. Liu, \u201cNew quantum codes from Hermitian dual-containing codes\u201d, International Journal of Quantum Information 17, 1950006 (2019). DOI][L. Jin et al., \u201cApplication of Classical Hermitian Self-Orthogonal MDS Codes to Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 56, 4735 (2010). DOI] or the Galois-qudit CSS construction [Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129]. ", "parents_code_id": "galois_true_stabilizer", "parents_detail": "Galois-qudit GRS codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes.", "parent_of_code_id": "galois_polynomial", "parent_of_detail": "", "cousins_code_id": "generalized_reed_solomon\nquantum_mds", "cousins_detail": "Hermitian self-orthogonal GRS codes are used to construct Galois-qudit GRS codes in the Hermitian construction.\nSome Galois-qudit GRS codes are quantum MDS [Lingfei Jin and Chaoping Xing, \u201cA Construction of New Quantum MDS Codes\u201d. 1311.3009].", "_type": "ecc", "_page_id": "c_galois_grs", "_href": "c/galois_grs"}, "c_binary_quantum_goppa": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Encoding defined in Ref. [R. Matsumoto, \u201cImprovement of Ashikhmin-Litsyn-Tsfasman bound for quantum codes\u201d, IEEE Transactions on Information Theory 48, 2122 (2002). DOI; quant-ph/0107129] uses a technique from Ref. [Alexei Ashikhmin and Emanuel Knill, \u201cNonbinary Quantum Stabilizer Codes\u201d. quant-ph/0005008] to encode quantum stabilizer codes.", "features_decoders": "Farran algorithm [J. I. Farran, \u201cDecoding Algebraic Geometry codes by a key equation\u201d. math/9910151].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Binary quantum Goppa code", "code_id": "binary_quantum_goppa", "realizations": "", "protection": "Protects against weight \\(t\\) errors where \\( 0 < t \\leq  \\lfloor \\frac{d^*-g-1}{2} \\rfloor \\) where \\( d^* = \\text{deg} G + 2 -2g \\) and \\(g\\) is the genus of the function field and \\(d \\geq n - \\lfloor \\frac{deg G}{2} \\rfloor\\).", "notes": "", "physical": "galois", "short_name": "", "introduced": "[Annika Niehage, \u201cQuantum Goppa Codes over Hyperelliptic Curves\u201d. quant-ph/0501074][A. Niehage, \u201cNonbinary Quantum Goppa Codes Exceeding the Quantum Gilbert-Varshamov Bound\u201d, Quantum Information Processing 6, 143 (2006). DOI]", "description": "Also known as a quantum AG code. Binary quantum Goppa codes are a family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes for \\( q=2^m \\), generated using classical Goppa codes.\n\nLet \\( F/GF(q) \\) be an algebraic function field of one variable, \\(\\sigma \\) be an automorphism of order 2 of \\(F\\) which leaves \\(GF(q)\\) invariant, and \\(P_1, \\cdots, P_n \\) be pairwise distinct places of degree one such that \\( \\sigma P_i = P_j\\) for all \\(i,j = 1, \\cdots, n\\). A place \\( P_i \\) of \\( F/ GF(q) \\) is the unique maximal ideal of a discrete valuation ring of the function field. Let \\( \\nu \\) be a differential that satisfies the properties guaranteed by the strong approximation theorem of discrete evaluations. Let \\(G\\) be a divisor such that \\( \\sigma G = G \\) and the discrete valuation corresponding to place \\(P_i \\) of \\(G\\) and the discrete valuation corresponding to place \\(\\sigma P_i \\) of \\(G\\) are both 0 for all \\(i\\). Then we can define a code \\( C(G)  = \\{ f(P_1), \\cdots, f(P_n), f(\\sigma P_1), \\cdots , f(\\sigma P_n) | f \\in \\mathcal{L}(G)\\} \\subset GF(q^{2n})\\) and a code \\(C(H)\\) where \\(H = (P_1 + \\cdots + P_n + \\sigma P_1 + \\cdots + \\sigma P_n) - G + \\nu \\). Then the dual of \\(C(G)\\) with respect to the weighted symplectic inner product with weights \\(s_i\\) on \\( GF(q^n) \\) is equivalent to \\(C(H)\\). Therefore, the orthogonal code of \\(C(G)\\) is generated by \\(H\\). Using these properties and the assumption that \\(H\\) is a subgroup of \\(G\\), we can construct a classical Goppa code \\(C(D,G)\\), where \\(D\\) is the sum of all \\(P_i\\). Using \\(C(D,G)\\), we can construct a \\([[n,k,d]]_{GF(q)}\\) quantum stabilizer code such that \\(k  = \\text{dim} G - \\text{dim}(G-P_1 - \\cdots - P_n - \\sigma P_1 - \\cdots  - \\sigma P_n) - n~.\\) ", "parents_code_id": "galois_css", "parents_detail": "Goppa codes can be realized in the CSS code construction [A. Niehage, \u201cNonbinary Quantum Goppa Codes Exceeding the Quantum Gilbert-Varshamov Bound\u201d, Quantum Information Processing 6, 143 (2006). DOI].", "cousins_code_id": "goppa", "cousins_detail": "Classical Goppa codes are used to construct their quantum versions.", "_type": "ecc", "_page_id": "c_binary_quantum_goppa", "_href": "c/binary_quantum_goppa"}, "c_galois_into_galois": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-qudit code", "code_id": "galois_into_galois", "realizations": "", "protection": "A convenient and often considered error set is the Galois-qudit analogue of the Pauli string set for qubit codes. For a single Galois qudit, this set consists of products of \\(X\\)-type and \\(Z\\)-type operators labeled by elements \\(\\beta \\in GF(q)\\), which act on computational basis states \\(|\\gamma\\rangle\\) for \\(\\gamma\\in GF(q)\\) as \\begin{align}\n  X_{\\beta}\\left|\\gamma\\right\\rangle =\\left|\\gamma+\\beta\\right\\rangle \\,\\,\\text{ and }\\,\\,Z_{\\beta}\\left|\\gamma\\right\\rangle =e^{i\\frac{2\\pi}{p}\\text{tr}(\\beta\\gamma)}\\left|\\gamma\\right\\rangle~,\n\\end{align} where the trace maps elements of the field to elements of \\(\\mathbb{Z}_p\\) as \\begin{align}\n  \\text{tr}(\\gamma)=\\sum_{k=0}^{m-1}\\gamma^{p^{k}}~.\n\\end{align} For multiple Galois qudits, error set elements are tensor products of elements of the single-qudit error set.\n\nThe Galois-qudit Pauli error set is a unitary basis for linear operators on the multi-qudit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a nice error basis [E. Knill, \u201cNon-binary Unitary Error Bases and Quantum Codes\u201d. quant-ph/9608048]. The distance associated with this set is often the minimum weight of a Galois qudit Pauli string that implements a nontrivial logical operation in the code. ", "notes": "Introduction to Galois qudits by Gottesman.\nWigner function for Galois qudits [K. S. Gibbons, M. J. Hoffman, and W. K. Wootters, \u201cDiscrete phase space based on finite fields\u201d, Physical Review A 70, (2004). DOI; quant-ph/0401155].", "physical": "galois", "short_name": "", "introduced": "[J. Bierbrauer and Y. Edel, \u201cQuantum twisted codes\u201d, Journal of Combinatorial Designs 8, 174 (2000). DOI][Avanti Ketkar et al., \u201cNonbinary stabilizer codes over finite fields\u201d. quant-ph/0508070]", "description": "Also called a \\(GF(q)\\)- or \\(\\mathbb{F}_q\\)-qudit code. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the Galois field \\(GF(q)\\) and with \\(q\\) being a power of a prime \\(p\\). A Galois field can be thought of as a vector space whose basis vectors are the \\(m\\) roots of some polynomial and whose coefficients (i.e., field) are \\(p\\)th roots of unity. Codes can be denoted as \\(((n,K))_{GF(q)}\\) or \\(((n,K,d))_{GF(q)}\\), whenever the code's distance \\(d\\) is defined. This notation differentiates between Galois-qudit and modular-qudit codes, although the same notation, \\(((n,K,d))_q\\), is usually used for both.", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "non_stabilizer", "parent_of_detail": "", "cousins_code_id": "qudits_into_qudits", "cousins_detail": "A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits [A. Ashikhmin and E. Knill, \u201cNonbinary quantum stabilizer codes\u201d, IEEE Transactions on Information Theory 47, 3065 (2001). DOI]; see Sec. 5.3 of Ref. [Annika Niehage, \u201cQuantum Goppa Codes over Hyperelliptic Curves\u201d. quant-ph/0501074]. The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently.", "_type": "ecc", "_page_id": "c_galois_into_galois", "_href": "c/galois_into_galois"}, "c_non_stabilizer": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "The encoding circuit involves the application of quantum Fourier transform.", "features_decoders": "The decoding circuit involves the application of phase estimation.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-qudit non-stabilizer code", "code_id": "non_stabilizer", "realizations": "", "protection": "", "notes": "", "physical": "galois", "short_name": "Non-stabilizer", "introduced": "[V. Arvind, Piyush P Kurur, and K. R. Parthasarathy, \u201cNonstabilizer Quantum Codes from Abelian Subgroups of the Error Group\u201d. quant-ph/0210097]", "description": "The projection onto a stabilizer code is proportional to an equal sum over all elements of the stabilizer group \\(\\mathsf{S}\\). Non-stabilizer codes generalize stabilizer codes by modifying the code projection with elements of a subset \\(\\mathsf{B}\\subset\\mathsf{S}\\) called the Fourier description (see proof of Thm. 2.7 in Ref. [V. Arvind, Piyush P Kurur, and K. R. Parthasarathy, \u201cNonstabilizer Quantum Codes from Abelian Subgroups of the Error Group\u201d. quant-ph/0210097]). When \\(\\mathsf{B}\\) is a subgroup of \\(\\mathsf{S}\\), then the code reduces to an ordinary stabilizer code.\n\nThe following non-stabilizer codes were constructed in Ref. [V. Arvind, Piyush P Kurur, and K. R. Parthasarathy, \u201cNonstabilizer Quantum Codes from Abelian Subgroups of the Error Group\u201d. quant-ph/0210097]: \\(((33, 155, 3))\\), \\(((15, 8, 3))\\), \\(((n, \\lceil\\frac{q^n}{n(q^2-1)}\\rceil,2))_{GF(q)}\\) and \\(((n, 1+n(q-1),2))_{GF(q)}\\), where \\(n\\) is odd. The last code family is a Galois-qudit extension of the non-additive \\(((5,6,2))\\) qubit code from Ref. [E. M. Rains et al., \u201cA Nonadditive Quantum Code\u201d, Physical Review Letters 79, 953 (1997). DOI; quant-ph/9703002]. ", "parents_code_id": "galois_into_galois", "parents_detail": "", "parent_of_code_id": "galois_stabilizer", "parent_of_detail": "A non-stabilizer code is also a stabilizer code if its Fourier description \\(\\mathsf{B}\\) is a subgroup of some Gottesman subgroup \\(\\mathsf{S}\\). When \\(\\mathsf{B}\\) is just a subset, the code is explicitly not a stabilizer code.", "_type": "ecc", "_page_id": "c_non_stabilizer", "_href": "c/non_stabilizer"}, "c_quantum_secret_sharing": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Uses a quantum authentication scheme, which is a keyed system in which a valid state has high fidelity, and a classical secret-sharing scheme.", "features_decoders": "Decoding is analagous to reconstruction in a secret sharing scheme and is done in polynomial time. The only required operations are verification of quantum authentication, which is a pair of polynomial-time quantum algorithms that check if the fidelity of the received state is close to 1, and erasure correction for a stabilizer code, which involves solving a system of linear equations.", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Approximate secret-sharing code", "code_id": "quantum_secret_sharing", "realizations": "", "protection": "Corrects up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors with fidelity exponentially lose to 1.", "notes": "", "physical": "galois", "short_name": "", "introduced": "[Claude Crepeau, Daniel Gottesman, and Adam Smith, \u201cApproximate Quantum Error-Correcting Codes and Secret Sharing Schemes\u201d. quant-ph/0503139]", "description": "A family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes approximately correcting errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) qubits, i.e., with approximate distance approaching the no-cloning bound \\(n/2\\). Constructed using a non-degenerate CSS code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an \\(t\\)-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.", "parents_code_id": "galois_css", "parents_detail": "The code required to construct this code must be a non-degenerate Galois-qubit CSS code.", "cousins_code_id": "approximate_qecc\ngalois_polynomial\nreed_solomon", "cousins_detail": "Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors.\nPolynomial codes can be used for a specific construction of this code.\nThe classical information in this code is encoded using a Reed-Solomon code.", "cousin_of_code_id": "stab_3_1_2", "cousin_of_detail": "Three-qutrit code defines a minimal secret-sharing scheme [R. Cleve, D. Gottesman, and H.-K. Lo, \u201cHow to Share a Quantum Secret\u201d, Physical Review Letters 83, 648 (1999). DOI; quant-ph/9901025] that is substantially generalized by approximate secret-sharing codes.", "_type": "ecc", "_page_id": "c_quantum_secret_sharing", "_href": "c/quantum_secret_sharing"}, "c_galois_css": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-qudit CSS code", "code_id": "galois_css", "realizations": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "notes": "", "physical": "galois", "short_name": "", "introduced": "[A. R. Calderbank and P. W. Shor, \u201cGood quantum error-correcting codes exist\u201d, Physical Review A 54, 1098 (1996). DOI; quant-ph/9512032][A. M. Steane, \u201cError Correcting Codes in Quantum Theory\u201d, Physical Review Letters 77, 793 (1996). DOI][\u201cMultiple-particle interference and quantum error correction\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 452, 2551 (1996). DOI; quant-ph/9601029][M. GRASSL, T. BETH, and M. R\u00d6TTELER, \u201cON OPTIMAL QUANTUM CODES\u201d, International Journal of Quantum Information 02, 55 (2004). DOI; quant-ph/0312164][J.-L. Kim and J. Walker, \u201cNonbinary quantum error-correcting codes from algebraic curves\u201d, Discrete Mathematics 308, 3115 (2008). DOI]", "description": "An \\([[n,k,d]]_{GF(q)} \\) Galois-qudit true stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Galois-qudit Pauli strings. The stabilizer generator matrix, taking values from \\(GF(q)\\), is of the form \\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityg}\n\\end{align} such that the rows of the two blocks must be orthogonal \\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commG}\n\\end{align} The above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related \\(q\\)-ary linear codes, an \\([n,k_X,d_X]_q \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_q \\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\(\\eqref{eq:parityg}\\) is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\(\\eqref{eq:commG}\\). Basis states for the code are, for \\(\\gamma \\in C_X\\), \\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align} ", "parents_code_id": "galois_true_stabilizer", "parents_detail": "Galois-qudit CSS codes are true stabilizer codes [D. Gottesman. Surviving as a quantum computer in a classical world].", "parent_of_code_id": "quantum_secret_sharing\nbinary_quantum_goppa\ngalois_polynomial\ngalois_topological\nlifted_product\nskew-cyclic_galois_css", "parent_of_detail": "The code required to construct this code must be a non-degenerate Galois-qubit CSS code.\nGoppa codes can be realized in the CSS code construction [A. Niehage, \u201cNonbinary Quantum Goppa Codes Exceeding the Quantum Gilbert-Varshamov Bound\u201d, Quantum Information Processing 6, 143 (2006). DOI].\n\n\n\n", "cousins_code_id": "css\nq-ary_linear\nq-ary_cyclic", "cousins_detail": "Extension of qubit CSS codes to Galois qudits.\nConstruction uses two related \\(q\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).\nGalois CSS codes can be constructed using self-orthogonal \\(q\\)-ary cyclic codes [Yongsheng Tang et al., \u201cNew quantum codes from dual-containing cyclic codes over finite rings\u201d. 1608.06674].", "cousin_of_code_id": "galois_bch", "cousin_of_detail": "Some Galois-qudit BCH codes are CSS.", "_type": "ecc", "_page_id": "c_galois_css", "_href": "c/galois_css"}, "c_galois_polynomial": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Galois-qudit RS code", "code_id": "galois_polynomial", "realizations": "", "protection": "", "notes": "", "physical": "galois", "short_name": "Galois RS", "introduced": "[Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129]", "description": "Also called polynomial code (QPyC). An \\([[n,k,n-k+1]]_{GF(q)}\\) (with \\(q>n\\)) Galois-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(q)\\).\n\nLet \\(C_1\\) be a \\([n,k_1,d_1]_q\\) Reed-Solomon code and \\(C_2^\\perp\\) be a \\([n,k_2,d_2]_q\\) Reed-Solomon code, modified such that \\(C_2^\\perp \\subseteq C_1\\) and \\(0\\le k_2 \\le k_1 \\le n\\). Then, a polynomial code is a non-degenerate \\([[n,k_2,d]]_{GF(q)}\\) Galois-qudit CSS code with \\(d=\\min(n-k_1+1,k_1-k_2+1)\\). The polynomial code is the span of the basis codewords over GF(\\(q\\)) \\begin{align}\n|\\overline{\\beta_0,\\cdots,\\beta_{k_2-1}}\\rangle\n=\n\\sum_{(\\beta_{k_2},\\cdots,\\beta_{k_1-1})\\in GF(q) }\n\\bigotimes_{i=1}^{n}\n\\left|\\sum_{j=0}^{k_1-1} \\beta_j \\alpha_i^j \\right\\rangle,\n\\end{align} where \\((\\alpha_1, \\cdots, \\alpha_n)\\) are \\(n\\) distinct points chosen for code \\(C_1\\) from \\(GF(q)\\setminus \\{0\\}\\).' ", "parents_code_id": "galois_grs\ngalois_css", "parents_detail": "\n", "cousins_code_id": "polynomial\nreed_solomon\nquantum_mds", "cousins_detail": "Polynomial codes can be defined for modular qudits of prime dimension or, more generally, for Galois qudits.\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).", "cousin_of_code_id": "quantum_secret_sharing", "cousin_of_detail": "Polynomial codes can be used for a specific construction of this code.", "_type": "ecc", "_page_id": "c_galois_polynomial", "_href": "c/galois_polynomial"}, "c_expander_lifted_product": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Expander lifted-product codes include the first examples [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654] of (asymptotically) good QLDPC codes, i.e., codes with asymptotically constant rate and linear distance. The existence of such codes proves the QLDPC conjecture [N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309]. Another notable family encodes \\(k \\in \\Theta(n^\\alpha \\log n)\\) logical qubits with distance \\(d \\in \\Omega(n^{1 - \\alpha} / \\log n)\\) for any number of physical qubits \\(n\\) and any real parameter \\(0 \\leq \\alpha < 1\\) [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Linear-time decoder [Anthony Leverrier and Gilles Z\u00e9mor, \u201cEfficient decoding up to a constant fraction of the code length for asymptotically good quantum codes\u201d. 2206.07571].\nLogarithmic-time subroutine [Anthony Leverrier and Gilles Z\u00e9mor, \u201cA parallel decoder for good quantum LDPC codes\u201d. 2208.05537].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Expander lifted-product code", "code_id": "expander_lifted_product", "realizations": "", "protection": "Code performance strongly depends on \\(G\\). Certain nonabelian groups yield asymptotically good QLDPC codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n)]]\\) [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654]. Abelian groups like \\(\\mathbb{Z}_{\\ell}\\) for \\(\\ell=\\Theta(n / \\log n)\\) yield constant-rate codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n / \\log n)]]\\) [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068]; this construction can be derandomized by being reformulated as a balanced product code [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].", "notes": "Construction outlined in talk by R. O'Donnell.\nPopular summary in Quanta Magazine.", "physical": "galois", "short_name": "", "introduced": "[Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654]", "description": "Family of \\(G\\)-lifted product codes constructed using two random classical Tanner codes defined on expander graphs. For certain parameters, this construction yields the first asymptotically good QLDPC codes. Classical codes resulting from this construction are one of the first two families of \\(c^3\\)-LTCs.\n\nAn expander lifted-product code family is constructed as follows. First, take the Cayley graph of a finite group \\(G\\). Second, take the double cover of the graph, resulting in a graph that satisfies the requirements of participating in a \\(G\\)-lifted product (i.e., the resulting graph is a free \\({\\mathbb{F}}_q G\\)-module). Third, create a Tanner code out of the graph, in which parity-check supports are defined by the graph, and bitstrings satisfying a particular parity check are defined to be the codewords of a small classical code (chosen to be a random code in the construction). Fourth, take the \\(G\\)-lifted product of two copies of the Tanner code.\n\nThe small classical codes used in the construction of good QLDPC codes are required to have a certain product-expansion property (Lemma 10 in Ref. [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654]); it is proven that random codes satisfy said property in the thermodynamic limit.", "parents_code_id": "lifted_product", "parents_detail": "", "cousins_code_id": "good_qldpc\nq-ary_ltc\ntanner\nrandom", "cousins_detail": "Lifted products of certain classical Tanner codes are the first asymptotically good QLDPC codes.\nClassical codes resulting from the expander lifted-product construction are one of the first two families of \\(c^3\\)-LTCs.\nExpander lifted-product codes are products of \\(q\\)-ary Tanner codes defined on expander graphs.\nExpander lifted-product codes are quantum CSS codes that utilize short classical codes in their construction which need to satisfy some properties (Ref. [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654], Lemma 10). It is shown that such codes exist, but they are not explicitly constructed. Such codes can be obtained by repeated random sampling or by performing a search of all codes of desired length. Nevertheless, since the length of the desired short codes does not scale with \\(n\\), this construction is effectively explicit.", "cousin_of_code_id": "quantum_tanner", "cousin_of_detail": "Quantum Tanner codes are an attempt to construct asymptotically good QLDPC codes that are similar to but simpler than expander lifted-product codes; see Ref. [Anthony Leverrier and Gilles Z\u00e9mor, \u201cEfficient decoding up to a constant fraction of the code length for asymptotically good quantum codes\u201d. 2206.07571] for connection between the codes.", "_type": "ecc", "_page_id": "c_expander_lifted_product", "_href": "c/expander_lifted_product"}, "c_lifted_product": {"logical": "galois", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "There is no known simple way to compute the logical dimension \\(k\\) in the general case [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Lifted-product (LP) code", "code_id": "lifted_product", "realizations": "", "protection": "Code performance strongly depends on the group \\(G\\) used in the product [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068].", "notes": "Formerly known as generalized hypergraph product codes [P. Panteleev and G. Kalachev, \u201cDegenerate Quantum LDPC Codes With Good Finite Length Performance\u201d, Quantum 5, 585 (2021). DOI; 1904.02703], and later renamed to lifted-product codes [P. Panteleev and G. Kalachev, \u201cQuantum LDPC Codes With Almost Linear Minimum Distance\u201d, IEEE Transactions on Information Theory 68, 213 (2022). DOI; 2012.04068][N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309].", "physical": "galois", "short_name": "", "introduced": "[P. Panteleev and G. Kalachev, \u201cDegenerate Quantum LDPC Codes With Good Finite Length Performance\u201d, Quantum 5, 585 (2021). DOI; 1904.02703][Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654]", "description": "Also called a Panteleev-Kalachev (PK) code. Code that utilizes the notion of a lifted product in its construction. Lifted products of certain classical Tanner codes are the first (asymptotically) good QLDPC codes.\n\nA lifted product over a ring \\(R\\) is a product of two chain complexes whose chains are free modules over \\(R\\). An interesting case is when \\(R=\\mathbb{F}_q G\\), the group-\\(G\\) algebra over the finite field \\({\\mathbb{F}}_q = GF(q)\\); in this case, the product can be called a \\(G\\)-lifted product. Just like its further generalization the balanced product, a lifted product code generalizes a hypergraph product code in that a reduction of symmetry is exploited to decrease the number of physical qubits required.\n\nThe key operation behind the \\(G\\)-lifted product is the \\(G\\)-lift. A \\(G\\)-lift of a \\(\\mathbb{F}_q\\)-valued matrix \\(A\\) substitutes matrix elements of \\(A\\) with matrices forming the regular representation of the group algebra \\({\\mathbb{F}}_q G\\) according to some rule. A combination of the lift and the usual hypergraph product yields lifted-product codes. The two operations commute: one can first take the usual hypergraph product of two chain complexes, and then lift the resulting product complex; equivalently, one can take the hypergraph product of the two lifted complexes.", "parents_code_id": "balanced_product\ngalois_css", "parents_detail": "\n", "parent_of_code_id": "expander_lifted_product\nhypergraph_product", "parent_of_detail": "\nLifted-product codes for trivial group \\(G\\) are hypergraph-product codes.", "cousins_code_id": "surface\nhaah_cubic", "cousins_detail": "A lifted product code for the ring \\(R=\\mathbb{F}_2[x,y]/(x^L-1,y^L-1)\\) is the toric code.\nA lifted product code for the ring \\(R=\\mathbb{F}_2[x,y,z]/(x^L-1,y^L-1,z^L-1)\\) is the cubic code.", "_type": "ecc", "_page_id": "c_lifted_product", "_href": "c/lifted_product"}, "c_quantum_concatenated": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "The first method to achieve a fault-tolerant computational threshold uses concatenated stabilizer codes [E. Knill, R. Laflamme, and W. H. Zurek, \u201cResilient quantum computation: error models and thresholds\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 454, 365 (1998). DOI; quant-ph/9702058][Dorit Aharonov and Michael Ben-Or, \u201cFault-Tolerant Quantum Computation With Constant Error Rate\u201d. quant-ph/9906129][J. Preskill, \u201cReliable quantum computers\u201d, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 454, 385 (1998). DOI; quant-ph/9705031][Panos Aliferis, Daniel Gottesman, and John Preskill, \u201cQuantum accuracy threshold for concatenated distance-3 codes\u201d. quant-ph/0504218].", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Concatenated quantum code", "code_id": "quantum_concatenated", "realizations": "", "protection": "", "notes": "Concatenated codes can achieve the Gilbert-Varshamov bound [Y. Ouyang, \u201cConcatenated Quantum Codes Can Attain the Quantum Gilbert\u2013Varshamov Bound\u201d, IEEE Transactions on Information Theory 60, 3117 (2014). DOI; 1004.1127].", "physical": "", "short_name": "", "introduced": "", "description": "A combination of two codes, an inner code \\(C\\) and an outer code \\(C^\\prime\\), where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code \\(C^\\prime\\), and then one encodes each of the physical registers of \\(C^\\prime\\) in an inner code \\(C\\).", "parents_code_id": "quantum_lego", "parents_detail": "", "parent_of_code_id": "gkp-stabilizer", "parent_of_detail": "GKP-stabilizer oscillator-into-oscillator codes concantenated with GKP qubit-into-mode codes can outperform the more conventional concatenations of GKP codes with qubit stabilizer codes [Yijia Xu et al., \u201cQubit-oscillator concatenated codes: decoding formalism & code comparison\u201d. 2209.04573].", "cousin_of_code_id": "coherent_constellation\nconcatenated\ngkp-cluster-state\nquantum_divisible\nquantum_parity\nshor_nine", "cousin_of_detail": "Coherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the quantum capacity of the thermal noise channel [F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent-state constellations and polar codes for thermal Gaussian channels\u201d, Physical Review A 95, (2017). DOI; 1603.05970][F. Lacerda, J. M. Renes, and V. B. Scholz, \u201cCoherent state constellations for Bosonic Gaussian channels\u201d, 2016 IEEE International Symposium on Information Theory (ISIT) (2016). DOI].\n\n\nA fault-tolerant \\(T\\) gate on the five-qubit or Steane code can be obtained by concatenating with particular quantum divisible codes.\nA QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code.\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.", "_type": "ecc", "_page_id": "c_quantum_concatenated", "_href": "c/quantum_concatenated"}, "c_qecc_finite": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "Universal gate set cannot be transversal for any code that detects single-qubit errors due to Eastin-Knill theorem [B. Eastin and E. Knill, \u201cRestrictions on Transversal Encoded Quantum Gate Sets\u201d, Physical Review Letters 102, (2009). DOI; 0811.4262].", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "The operation \\(\\cal{D}\\) in the definition of this code is called the decoder. However, the term decoder can sometimes be used for the inverse of an encoder, which does not correct errors.\nQuantum machine-learning based decoders such as quantum convolutional neural networks [I. Cong, S. Choi, and M. D. Lukin, \u201cQuantum convolutional neural networks\u201d, Nature Physics 15, 1273 (2019). DOI; 1810.03787] and quantum autoencoders [David F. Locher, Lorenzo Cardarelli, and Markus M\u00fcller, \u201cQuantum Error Correction with Quantum Autoencoders\u201d. 2202.00555].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Finite-dimensional quantum error-correcting code", "code_id": "qecc_finite", "realizations": "", "protection": "Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a finite-dimensional quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{K}\\to\\mathsf{H}_{N}\\) with a set of correctable errors \\({\\cal{E}}:\\mathsf{H}_N\\to\\mathsf{H}_M\\) with the following property: there exists a quantum operation \\({\\cal{D}}:\\mathsf{H}_M\\to \\mathsf{H}_K\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{K}\\), \\begin{align}\n{\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\end{align} for some constant \\(c\\) [D. Gottesman. Surviving as a quantum computer in a classical world]. A code is said to protect against or correct the errors \\(\\mathcal{E}\\).\n\nKnill-Laflamme error correction conditions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nEquivalently, correction capability is determined by of the quantum error-correction conditions [E. Knill, R. Laflamme, and L. Viola, \u201cTheory of Quantum Error Correction for General Noise\u201d, Physical Review Letters 84, 2525 (2000). DOI; quant-ph/9604034][C. H. Bennett et al., \u201cMixed-state entanglement and quantum error correction\u201d, Physical Review A 54, 3824 (1996). DOI; quant-ph/9604024], which may admit infinite terms due to non-normalizability of ideal code states. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an approximate code.\n\nKnill-Laflamme conditions: In a finite-dimensional Hilbert space, there are necessary and sufficient conditions for a code to successfully correct a set of errors. These are called the Knill-Laflamme conditions\u00a0[E. Knill, R. Laflamme, and L. Viola, \u201cTheory of Quantum Error Correction for General Noise\u201d, Physical Review Letters 84, 2525 (2000). DOI; quant-ph/9604034][J. Preskill. Lecture notes on Quantum Computation. (1997\u20132020) URL][M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum Information (Cambridge University Press, 2012). DOI; Thm. 10.1]. A code defined by a partial isometry \\(U\\) with code space projector \\(\\Pi = U U^\\dagger\\) can correct a set of errors \\(\\{ E_j \\}\\) if and only if \\begin{align}\n  \\Pi E_i^\\dagger E_j \\Pi = c_{ij}\\, \\Pi\\qquad\\text{for all \\(i,j\\),}\n\\end{align} where \\(c_{ij}\\) can be arbitrary numbers.\n\nA code is degenerate with respect to a noise model if different errors map code states to the same error subspace. For a linearly independent error set \\(\\cal{E}\\), degeneracy is equivalent to \\(\\text{rank}(c_{ij}) < |\\cal{E}|\\).", "notes": "", "physical": "", "short_name": "Finite QECC", "introduced": "", "description": "Encodes quantum information in a \\(K\\)-dimensional (logical) subspace of an \\(N\\)-dimensional (physical) Hilbert space such that it is possible to recover said information from errors. The logical subspace is spanned by a basis comprised of code basis states or codewords.", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "category_quantum\nmetopt\nfermions\ngalois_into_galois\nqudits_into_qudits\nquantum_perfect\nquantum_mds\nqubits_into_qubits\nspins_into_spins", "parent_of_detail": "\nSemidefinite-program optimization procedure for finding a metrologically optimal code holds for finite-dimensional spaces.\n\n\n\n\n\n\n", "cousins_code_id": "ecc_finite", "cousins_detail": "", "_type": "ecc", "_page_id": "c_qecc_finite", "_href": "c/qecc_finite"}, "c_symmetry_protected_self_correct": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Symmetry-protected self-correcting quantum code", "code_id": "symmetry_protected_self_correct", "realizations": "", "protection": "The code is intended to be used as a self-correcting quantum memory when the symmetry is enforced, and protection is characterized by the scaling of the memory time \\(\\tau\\) in the system size.\n\nAnother characterization of the protection property is the symmetric version of the energy barrier \\(\\Delta\\), defined as follows. For a given logical operator and a given decomposition into a product of local operators, we consider the maximal energy attained when implementing this logical operator stepwise with this decomposition. Then, \\(\\Delta\\) is defined by minimizing this quantity over all logical operators and over those decompositions for which each local operator respects the symmetry. For some models [S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474], the linear growth of \\(\\Delta\\) with system size \\(n\\) implies the exponential growth of \\(\\tau\\) below a critical temperature.", "notes": "", "physical": "", "short_name": "", "introduced": "[S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]", "description": "Also called a symmetry-protected self-correcting memory. An restricted notion of thermal stability against symmetric perturbations, i.e., perturbations that commute with a set of operators forming a group \\(G\\) called the symmetry group.\n\nGiven a symmetry group \\(G\\) and its unitary representation \\(S\\) on the \\(n\\)-site physical Hilbert space (in this case, a lattice), an operator \\(O\\) is \\(G\\)-symmetric (a.k.a. respects the \\(G\\) symmetry) if \\([S(g),O]=0\\) for all \\(g\\in G\\). A symmetry-protected self-correcting memory is a ground-state encoding of an \\(n\\)-body \\(G\\)-symmetric geometrically local Hamiltonian whose logical information is recoverable for arbitrary long times in the \\(n\\to\\infty\\) limit after a \\(G\\)-symmetric interaction with a thermal environment at sufficiently low temperature.\n\nTensor-product symmetries of the form \\(S(g)=u(g)^{\\otimes n}\\), where \\(u\\) is a unitary representation of \\(G\\ni g\\) on a site, cannot support symmetry-protected self-correction. One can instead use 1-form symmetries, i.e., symmetries generated by operators of the form \\begin{align}\n  S_{\\mathcal{M}}(g)=\\bigotimes_{\\text{sites}\\in\\mathcal{M}}u(g),\n\\end{align} where \\(\\mathcal{M}\\) runs over all closed codimension-one submanifolds of the lattice. Recent work further relaxed the requirement so that symmetries need only be enforced on the system's boundaries [Charles Stahl, \u201cSelf-correction from higher-form symmetry protection on a boundary\u201d. 2206.05294].", "parents_code_id": "self_correct", "parents_detail": "", "cousin_of_code_id": "rbh\nsubsystem_color", "cousin_of_detail": "\nA particular gauge-fixed version of this code on a 3D lattice yields a self-correcting memory protected by one-form symmetries (see Sec. IV D of Ref. [S. Roberts and S. D. Bartlett, \u201cSymmetry-Protected Self-Correcting Quantum Memories\u201d, Physical Review X 10, (2020). DOI; 1805.01474]). The symmetric energy barrier grows linearly with the length of a side of the lattice. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the side length.", "_type": "ecc", "_page_id": "c_symmetry_protected_self_correct", "_href": "c/symmetry_protected_self_correct"}, "c_stabilizer": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Stabilizer code", "code_id": "stabilizer", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "A code whose logical subspace is the joint eigenspace (usually with eigenvalue \\(+1\\)) of a set of commuting unitary operators forming the code's stabilizer group. Stabilizer codes have been defined for qubits, modular qudits, Galois qudits, and oscillators using their respective Pauli-type groups.\n\nThe coding theory motivation for stabilizer codes came from linear binary codes, whose codewords form a closed subspace in the space of binary strings. Stabilizer codes extend this property, in various ways, to quantum error correction. The stabilizer formalism is applicable to the qubit, modular-qudit, Galois-qudit, bosonic, and fermionic kingdoms; see list of stabilizer codes for a list of all stabilizer codes in the zoo.\n\nStabilizer codes were originally defined for qubits, where the relevant commuting operators are tensor products of Pauli matrices. The Pauli stabilizer structure is immensely useful in providing standardized encoding, gates, decoding, and performance bounds. Elements of this structure remain in qudit extensions, in particular for prime-dimensional modular qudits and Galois qudits. Other qubit-based extensions, such as XS and XP stabilizer codes, relax the mutual commutation property. Still other extensions defined for qudits include non-stabilizer codes.\n\nAn important property of qubit and qudit stabilizer codes is the QLDPC property, which means (roughly) that working with them remains not too hard as number of qudits grows; these remain as the primary ingredients for a quantum memory.", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "oscillator_stabilizer\ngalois_stabilizer\nqudit_stabilizer\nqldpc\nqubit_stabilizer", "parent_of_detail": "\n\n\n\n", "cousin_of_code_id": "linear\nmajorana_stab", "cousin_of_detail": "Linear (stabilizer) codes form a large and well-studied subset of all classical (quantum) codes because features such as decoding and level of protection are typically easier to determine than those of nonlinear (non-stabilizer) codes.\nMajorana stabilizer codes are useful for Majorana-based architectures, where the degrees of freedom are electrons, and the notion of locality is different than all other code kingdoms.", "_type": "ecc", "_page_id": "c_stabilizer", "_href": "c/stabilizer"}, "c_qecc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum error-correcting code (QECC)", "code_id": "qecc", "realizations": "", "protection": "Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{\\text{logical}}\\to\\mathsf{H}_{\\text{physical}}\\) with a set of correctable errors \\(\\cal{E}\\) with the following property: there exists a quantum operation \\(\\cal{D}\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{\\text{logical}}\\), \\begin{align}\n  {\\cal D} (EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})\n  = c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\n\\end{align} for some constant \\(c\\).\n\nEquivalently, correction capability is determined by the Knill-Laflamme conditions, which may admit infinite terms due to non-normalizability of ideal code states in the case of codes with infinite-dimenional physical spaces. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an approximate code. These conditions can also be formulated in terms of a dual Heisenberg picture, where correctability is checked for some algebra of observables [C. B\u00e9ny, A. Kempf, and D. W. Kribs, \u201cQuantum error correction on infinite-dimensional Hilbert spaces\u201d, Journal of Mathematical Physics 50, 062108 (2009). DOI; 0811.0421].", "notes": "", "physical": "", "short_name": "QECC", "introduced": "", "description": "Encodes quantum information in a (logical) subspace of a (physical) Hilbert space such that it is possible to recover said information from errors that act as linear maps on the physical space. The logical subspace is spanned by a basis comprised of code basis states or codewords. Codewords may not be normalizable if the physical Hilbert space in infinite, so approximate versions have to be constructed in practice. ", "parents_code_id": "oaecc\nmetrological", "parents_detail": "\nMetrological codes satisfy the Knill-Laflamme conditions conditions only partially, and codes that satisfy them fully are QECCs.", "parent_of_code_id": "approximate_qecc\noscillators\ncovariant\ndynamic_gen\nqecc_finite\ngroup_quantum\nhamiltonian\nquantum_lego\nquantum_quasi_cyclic\nquantum_random\nstabilizer", "parent_of_detail": "\n\n\n\n\n\n\n\n\n\n", "cousins_code_id": "ecc", "cousins_detail": "", "cousin_of_code_id": "eaqecc\noecc", "cousin_of_detail": "EA-QECCs are QECCs utilizing pre-shared entanglement.\nA subsystem code reduces to an ordinary error-correcting code when the gauge subsystem is trivial, \\(\\mathsf{B} = \\mathbb{C}\\). Conversely, any QECC with a tensor-product logical subspace can be turned into a subsystem code by treating a logical tensor factor as a gauge subsystem.", "_type": "ecc", "_page_id": "c_qecc", "_href": "c/qecc"}, "c_approximate_qecc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Given a decoder, an encoding that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [K. Audenaert and B. De Moor, \u201cOptimizing completely positive maps using semidefinite programming\u201d, Physical Review A 65, (2002). DOI; quant-ph/0109155][M. Reimpell and R. F. Werner, \u201cIterative Optimization of Quantum Error Correcting Codes\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0307138] (see also Ref. [Andrew S. Fletcher, \u201cChannel-Adapted Quantum Error Correction\u201d. 0706.3400]).", "features_decoders": "Given an encoding, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [K. Audenaert and B. De Moor, \u201cOptimizing completely positive maps using semidefinite programming\u201d, Physical Review A 65, (2002). DOI; quant-ph/0109155][M. Reimpell and R. F. Werner, \u201cIterative Optimization of Quantum Error Correcting Codes\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0307138] (see also Ref. [Andrew S. Fletcher, \u201cChannel-Adapted Quantum Error Correction\u201d. 0706.3400]).\nThe Petz recovery map (a.k.a. the transpose map) [D. Petz, \u201cSufficient subalgebras and the relative entropy of states of a von Neumann algebra\u201d, Communications in Mathematical Physics 105, 123 (1986). DOI][D. PETZ, \u201cSUFFICIENCY OF CHANNELS OVER VON NEUMANN ALGEBRAS\u201d, The Quarterly Journal of Mathematics 39, 97 (1988). DOI], a quantum channel determined by the codespace and noise channel, recovers information perfectly for strictly correctable noise and yields an infidelity of recovery that is at most twice away from the infidelity of the best possible recovery [H. Barnum and E. Knill, \u201cReversing quantum dynamics with near-optimal quantum and classical fidelity\u201d. quant-ph/0004088]. The infidelity of a modified Petz recovery map can be bounded using relative entropies between uncorrupted and corrupted code states on countably infinite Hilbert spaces [M. Junge et al., \u201cUniversal Recovery Maps and Approximate Sufficiency of Quantum Relative Entropy\u201d, Annales Henri Poincar\u00e9 19, 2955 (2018). DOI; 1509.07127].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Approximate quantum error-correcting code (AQECC)", "code_id": "approximate_qecc", "realizations": "", "protection": "There exist approximate versions of the Knill-Laflamme conditions that can be used to determine the degree to which a code is an approximate error-correcting code\u00a0[C. B\u00e9ny and O. Oreshkov, \u201cGeneral Conditions for Approximate Quantum Error Correction and Near-Optimal Recovery Channels\u201d, Physical Review Letters 104, (2010). DOI; 0907.5391]. Various sufficient criteria have also been derived; see for instance refs.\u00a0[D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002][Claude Crepeau, Daniel Gottesman, and Adam Smith, \u201cApproximate Quantum Error-Correcting Codes and Secret Sharing Schemes\u201d. quant-ph/0503139][F. G. S. L. Brand\u00e3o et al., \u201cQuantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains\u201d, Physical Review Letters 123, (2019). DOI; 1710.04631][P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714]. ", "notes": "See review [Akshaya Jayashankar and Prabha Mandayam, \u201cQuantum Error Correction: Noise-adapted Techniques and Applications\u201d. 2208.00365].", "physical": "", "short_name": "AQECC", "introduced": "[D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002][A. Y. Kitaev, \u201cQuantum computations: algorithms and error correction\u201d, Russian Mathematical Surveys 52, 1191 (1997). DOI][M. Reimpell and R. F. Werner, \u201cIterative Optimization of Quantum Error Correcting Codes\u201d, Physical Review Letters 94, (2005). DOI; quant-ph/0307138][Claude Crepeau, Daniel Gottesman, and Adam Smith, \u201cApproximate Quantum Error-Correcting Codes and Secret Sharing Schemes\u201d. quant-ph/0503139][C\u00e9dric B\u00e9ny, \u201cConditions for the approximate correction of algebras\u201d. 0907.4207][C. B\u00e9ny and O. Oreshkov, \u201cGeneral Conditions for Approximate Quantum Error Correction and Near-Optimal Recovery Channels\u201d, Physical Review Letters 104, (2010). DOI; 0907.5391]", "description": "Stub.", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "eth\nw_state\nnonabelian_covariant_erasure", "parent_of_detail": "ETH codes approximately protect against erasures in the thermodynamic limit.\nThe W-state code approximately protects against a single erasure while allowing for a universal transversal set of gates.\n", "cousin_of_code_id": "quantum_secret_sharing\ncovariant\ngnu_permutation_invariant\ngkp\nt-designs\nmultimodegkp\nqudits_into_oscillators\nstab_4_2_2", "cousin_of_detail": "Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors.\nNormalizable constructions of infinite-dimensional \\(G\\)-covariant codes for continuous \\(G\\) are approximately error-correcting.\nGNU codes protect approximately against amplitude damping errors.\nGKP codes approximately protect against photon loss [B. M. Terhal and D. Weigand, \u201cEncoding a qubit into a cavity mode in circuit QED using phase estimation\u201d, Physical Review A 93, (2016). DOI; 1506.05033][V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].\n\nApproximate error-correction offered by GKP codes yields achievable rates that are a constant away from the capacity of Guassian loss channels [J. Harrington and J. Preskill, \u201cAchievable rates for the Gaussian quantum channel\u201d, Physical Review A 64, (2001). DOI; quant-ph/0105058][K. Sharma et al., \u201cBounding the energy-constrained quantum and private capacities of phase-insensitive bosonic Gaussian channels\u201d, New Journal of Physics 20, 063025 (2018). DOI; 1708.07257][M. Rosati, A. Mari, and V. Giovannetti, \u201cNarrow bounds for the quantum capacity of thermal attenuators\u201d, Nature Communications 9, (2018). DOI; 1801.04731][K. Noh, V. V. Albert, and L. Jiang, \u201cQuantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev-Preskill Codes\u201d, IEEE Transactions on Information Theory 65, 2563 (2019). DOI; 1801.07271].\nApproximate QEC techniques of finding the entanglement fidelity can be adapted to bosonic codes with a finite-dimensional codespace [V. V. Albert et al., \u201cPerformance and structure of single-mode bosonic codes\u201d, Physical Review A 97, (2018). DOI; 1708.05010].\n\\([[4,1,2]]\\) subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [D. W. Leung et al., \u201cApproximate quantum error correction can lead to better codes\u201d, Physical Review A 56, 2567 (1997). DOI; quant-ph/9704002] and \\(\\{|\\overline{01}\\rangle,|\\overline{11}\\rangle\\}\\) [G. Alber et al., \u201cStabilizing Distinguishable Qubits against Spontaneous Decay by Detected-Jump Correcting Quantum Codes\u201d, Physical Review Letters 86, 4402 (2001). DOI; quant-ph/0103042] approximately correct a single amplitude damping error.", "_type": "ecc", "_page_id": "c_approximate_qecc", "_href": "c/approximate_qecc"}, "c_holographic": {"logical": "", "features_code_capacity_threshold": "The ideal holographic code (perfect representation of AdS/CFT) should be able to protect a central bulk operator against erasures of half of the physical qubits on the boundary, in line with AdS-Rindler reconstruction [F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237].\nHolographic codes are argued to have a algebraic threshold, for which the error rate scales polynomially (as opposed to exponentially) in the thermodynamic limit [Ning Bao, ChunJun Cao, and Guanyu Zhu, \u201cDeconfinement and Error Thresholds in Holography\u201d. 2202.04710]. Such a threshold is governed by the underlying conformal field theory describing the boundary.", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "There exist holographic approximate codes with arbitrary transversal gate sets for any compact Lie group [K. Dolev et al., \u201cGauging the bulk: generalized gauging maps and holographic codes\u201d, Journal of High Energy Physics 2022, (2022). DOI; 2108.11402]. However, for sufficiently localized logical subsystems of holographic stabilizer codes, the set of transversally implementable logical operations is contained in the Clifford group [S. Cree et al., \u201cFault-Tolerant Logical Gates in Holographic Stabilizer Codes Are Severely Restricted\u201d, PRX Quantum 2, (2021). DOI; 2103.13404].", "features_fault_tolerance": "", "name": "Holographic code", "code_id": "holographic", "realizations": "", "protection": "Protects against erasure errors on the boundary. Error-correction properties are often stated in the Heisenberg picture, i.e., in terms of which logical operators can be reconstructed after erasures. Specifically, bulk operators outside the entanglement wedges of the erased boundary operators can be reconstructed using the remaining boundary operators. However, the protection can be nontrivial, and may only apply to a subalgebra of bulk operators [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][F. Pastawski and J. Preskill, \u201cCode Properties from Holographic Geometries\u201d, Physical Review X 7, (2017). DOI; 1612.00017].", "notes": "All Boundary global symmetries must be dual to bulk gauge symmetries, and vice versa [Daniel Harlow and Hirosi Ooguri, \u201cSymmetries in quantum field theory and quantum gravity\u201d. 1810.05338].", "physical": "", "short_name": "", "introduced": "[F. Pastawski et al., \u201cHolographic quantum error-correcting codes: toy models for the bulk/boundary correspondence\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1503.06237]", "description": "A code whose encoding isometry serves to model aspects of the AdS/CFT holographic duality. Encodes operators in the bulk of the Anti de Sitter (AdS) space, represented by logical qudits, into operators on the boundary of the corresponding Conformal Field Theory (CFT), represented by physical qudits. Encoding can often be represented by a tensor network associated with a tiling of hyperbolic space. See Defn 4.3 of Ref. [K. Dolev et al., \u201cGauging the bulk: generalized gauging maps and holographic codes\u201d, Journal of High Energy Physics 2022, (2022). DOI; 2108.11402] for a technical formulation.\n\nTypically, the encoding isometry \\(U\\) obeys the entanglement-wedge reconstruction condition, which states that for any boundary region \\(R\\), any bulk operator \\(O\\) localized to the entanglement wedge of \\(R\\) must be implementable by some boundary operator \\(\\tilde{O}\\) localized to \\(R\\). Formally, \\(UO = \\tilde{O}U\\) and \\([\\tilde{O},UU^\\dagger] = 0\\). The entanglement wedge is the space enclosed within the Ryu\u2013Takayanagi surface in the bulk (minimal surface) with boundary \\(R\\). ", "parents_code_id": "oaecc", "parents_detail": "Properties of holographic codes are often quantified in the Heisenberg picture, i.e., in terms of operator algebras [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][F. Pastawski and J. Preskill, \u201cCode Properties from Holographic Geometries\u201d, Physical Review X 7, (2017). DOI; 1612.00017].", "parent_of_code_id": "happy\nstab_3_1_2", "parent_of_detail": "\nThree-qutrit code is a minimal model for holography [A. Almheiri, X. Dong, and D. Harlow, \u201cBulk locality and quantum error correction in AdS/CFT\u201d, Journal of High Energy Physics 2015, (2015). DOI; 1411.7041][D. Harlow, \u201cThe Ryu\u2013Takayanagi Formula from Quantum Error Correction\u201d, Communications in Mathematical Physics 354, 865 (2017). DOI; 1607.03901].", "cousin_of_code_id": "hyperbolic_surface\nquantum_lego", "cousin_of_detail": "Both holographic and hyperbolic surface codes utilize tesselations of hyperbolic surfaces. Encodings for the former are hyperbolically tiled tensor networks, while the latter is defined on hyperbolically tiled physical-qubit lattices.\nHolographic codes whose encoders are tensor networks discretizing hyperbolic space are quantum Lego codes.", "_type": "ecc", "_page_id": "c_holographic", "_href": "c/holographic"}, "c_quantum_random": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Random quantum code", "code_id": "quantum_random", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Quantum code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes (e.g., random-circuit codes), to codes whose multi-step construction is deterministic with the exception of a single step (e.g., expander lifter-product codes).", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "random_circuit", "parent_of_detail": "", "cousins_code_id": "random", "cousins_detail": "", "cousin_of_code_id": "clifford-deformed_surface\ncovariant\nfiber_bundle\nhomological_product", "cousin_of_detail": "Many useful CDSCs are constructed using random Clifford circuits.\nRandom \\(U(d)\\)-covariant almost exactly error-correcting codes exist [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][L. Kong and Z.-W. Liu, \u201cNear-Optimal Covariant Quantum Error-Correcting Codes from Random Unitaries with Symmetries\u201d, PRX Quantum 3, (2022). DOI; 2112.01498].\n\n", "_type": "ecc", "_page_id": "c_quantum_random", "_href": "c/quantum_random"}, "c_fusion": {"logical": "qubits", "features_code_capacity_threshold": "", "features_general_gates": "Clifford gates by creating topological features such as boundaries, defects, or twists, which can be done by single qubit measurements.\nLogical gates can be performed by code deformation.\nNon Clifford gates by Magic-state injection\nLogical Clifford operations can be kept track of using the classical Pauli-frame register and need not be explicitly applied at the quantum level.", "features_threshold": "\\(11.98\\%\\) against erasure in fusion measurements.\n\\(1.07\\%\\) against Pauli error.\nIn linear optical systems, can tolerate \\(10.4\\%\\) probability of photon loss in each fusion.\n\\(43.2\\%\\) against fusion failure.", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Resource state generators, which produce small constant size cluster states, and Fusion measurements (Bell fusions).", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "Fusion networks are constructed in a fault tolerant way (as a stabilizer code), and they can be created in a way that naturally encodes topological fault tolerance.", "name": "Fusion-based quantum computing (FBQC) code", "code_id": "fusion", "realizations": "", "protection": "Protects against erasure, Pauli errors, photon loss, fusion failure from non-determinism, and faulty resource states. Redundancy in fusion outcomes is captured by the check operator group. Fusion measurement outcomes form a syndrome that allows to correct for Pauli errors. There is no physical error correction, and decoding output is simply used to update the Pauli frame.", "notes": "", "physical": "qubits", "short_name": "FBQC", "introduced": "[Sara Bartolucci et al., \u201cFusion-based quantum computation\u201d. 2101.09310]", "description": "Fusion Based Quantum Computing, or FBQC, describes a fault tolerant way to produce fusion networks, or large entangled states starting from small constant-sized entangled resource states along with destructive measurements called fusions. These large states can be produced asychronously in the fusion framework and can be used as resources, as in measurement-based quantum computation (MBQC), or as logical states of topological codes. The difference from ordinary MBQC is that error-correction is baked into the state-generation protocol.", "parents_code_id": "qubit_stabilizer", "parents_detail": "The resource states in FBQC are small stabilizer states, and after fusion measurements, the outputs are stabilizers (conditioned on measurement outcomes.", "cousins_code_id": "topological\nfock_state\ndynamic_gen", "cousins_detail": "Arbitrary topological codes can be created using FBQC, as can topological features such as defects and boundaries, by modifying fusion measurements or adding single qubit measurements.\nWhile FBQC is a general framework, an intended application to linear-optical quantum computing will likely utilize small Fock-state bosonic codes such as the dual-rail code.\nBuilding a fusion network is done using a measurement-based dynamical process.", "_type": "ecc", "_page_id": "c_fusion", "_href": "c/fusion"}, "c_quantum_perfect": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "\\(k/n\\to 1\\) asymptotically with \\(n\\).", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Perfect quantum code", "code_id": "quantum_perfect", "realizations": "", "protection": "Perfect codes have been classified. For qubits (\\(q=2\\)), the only codes are the stabilizer code family \\([[(4^r-1)/3, (4^r-1)/3 - 2r, 3]]\\) for \\(r \\geq 2\\) [Daniel Gottesman, \u201cPasting Quantum Codes\u201d. quant-ph/9607027][A. R. Calderbank et al., \u201cQuantum Error Correction via Codes over GF(4)\u201d. quant-ph/9608006]. For qudits, the family is parameterized by \\(K=q^{n-2r}\\) for \\(n=\\frac{q^{2r}-1}{q^{2}-1}\\) and \\(r \\geq 2\\); all codes correct a single error (\\(t=1\\)) [Zhuo Li and Lijuan Xing, \u201cNo More Perfect Codes: Classification of Perfect Quantum Codes\u201d. 0907.0049][J. Bierbrauer and Y. Edel, \u201cQuantum twisted codes\u201d, Journal of Combinatorial Designs 8, 174 (2000). DOI]. The trivial code (\\(k=n\\)) is also perfect. ", "notes": "Codes that are not non-degenerate can in principle violate the quantum Hamming bound. It was shown that qubit stabilizer codes up to distance \\(d\\leq 85\\) must obey the bound [Emanuel Dallas, Faidon Andreadakis, and Daniel Lidar, \u201cNo [[n, k, d < 86]] code can violate the quantum Hamming bound\u201d. 2208.11800].", "physical": "", "short_name": "", "introduced": "", "description": "A non-degenerate code constructed out of \\(q\\)-dimensional qudits and having parameters \\(((n,K,2t+1))\\) is perfect if \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the quantum Hamming bound \\begin{align}\n\\sum_{j=0}^{t}(q^2-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align} becomes an equality. For example, for a qubit \\(q=2\\) code with one logical qubit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(3n+1 \\leq 2^{n-1}\\). The bound can be saturated only at certain \\(n\\).\n\nFor qubit codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit, \\begin{align}\n\\frac{k}{n}\\leq 1-\\frac{t}{n}\\log_{2}3-h(t/n),\n\\end{align} where \\(h\\) is the binary entropy function. ", "parents_code_id": "qecc_finite", "parents_detail": "", "cousins_code_id": "perfect", "cousins_detail": "A classical (quantum) perfect code saturates the classical (quantum) Hamming bound.", "cousin_of_code_id": "stab_5_1_3\nquantum_hamming", "cousin_of_detail": "The five-qubit codes is the smallest perfect code.\nQuantum Hamming codes saturate the asymptotic Hamming bound.", "_type": "ecc", "_page_id": "c_quantum_perfect", "_href": "c/quantum_perfect"}, "c_quantum_mds": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum maximum-distance-separable (MDS) code", "code_id": "quantum_mds", "realizations": "", "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error correction properties.", "notes": "The five-qubit code and \\([[n,n-2,2]]\\) codes, where \\(n\\) is even, are the only examples of MDS qubit codes.", "physical": "", "short_name": "Quantum MDS", "introduced": "", "description": "An \\(((n,q^k,d))\\) code constructed out of \\(q\\)-dimensional qudits is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the quantum Singleton bound \\begin{align}\n2(d-1) \\leq n-k\n\\end{align} becomes an equality. ", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "stab_5_1_3\nstab_3_1_2", "parent_of_detail": "The five-qubit codes is the smallest qubit quantum MDS code.\nThe three-qutrit code is the smallest nontrivial quantum MDS code.", "cousins_code_id": "mds\nq-ary_cyclic", "cousins_detail": "\nQuantum MDS codes can be constructed from \\(q\\)-ary cyclic codes using the Hermitian construction [G. G. La Guardia, \u201cNew Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 57, 5551 (2011). DOI].", "cousin_of_code_id": "galois_grs\ngalois_polynomial\npolynomial\ngalois_true_stabilizer", "cousin_of_detail": "Some Galois-qudit GRS codes are quantum MDS [Lingfei Jin and Chaoping Xing, \u201cA Construction of New Quantum MDS Codes\u201d. 1311.3009].\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).\nMany MDS codes are constructed from Hermitian self-orthogonal codes over \\(GF(q^2)\\) using the Hermitian construction [M. GRASSL, T. BETH, and M. R\u00d6TTELER, \u201cON OPTIMAL QUANTUM CODES\u201d, International Journal of Quantum Information 02, 55 (2004). DOI; quant-ph/0312164][R. Li and Z. Xu, \u201cConstruction of<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mo stretchy=\"false\">[</mml:mo><mml:mo stretchy=\"false\">[</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>\u2212</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy=\"false\">]</mml:mo><mml:mo stretchy=\"false\">]</mml:mo><mml:msub><mml:mrow /><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>quantum codes for odd prime power<mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:math>\u201d, Physical Review A 82, (2010). DOI; 0906.2509][Xianmang He, Liqing Xu, and Hao Chen, \u201cNew $q$-ary Quantum MDS Codes with Distances Bigger than $\\frac{q}{2}$\u201d. 1507.08355][Liangdong Lu et al., \u201cNew Quantum MDS codes constructed from Constacyclic codes\u201d. 1803.07927], in particular from cyclic [G. G. La Guardia, \u201cNew Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 57, 5551 (2011). DOI], constacyclic [X. Kai, S. Zhu, and P. Li, \u201cConstacyclic Codes and Some New Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 60, 2080 (2014). DOI][B. Chen, S. Ling, and G. Zhang, \u201cApplication of Constacyclic Codes to Quantum MDS Codes\u201d, IEEE Transactions on Information Theory 61, 1474 (2015). DOI] and negacyclic [X. Kai and S. Zhu, \u201cNew Quantum MDS Codes From Negacyclic Codes\u201d, IEEE Transactions on Information Theory 59, 1193 (2013). DOI] codes.", "_type": "ecc", "_page_id": "c_quantum_mds", "_href": "c/quantum_mds"}, "c_quantum_lego": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Unitary-circuit encoding exists for a restricted class of tensor networks contractible via isometries [C. Cao and B. Lackey, \u201cQuantum Lego: Building Quantum Error Correction Codes from Tensor Networks\u201d, PRX Quantum 3, (2022). DOI; 2109.08158].", "features_decoders": "The decoder is created by creating a decoding quantum circuit with dangling legs replaced with input/output wires, and tensors converted to unitary gates. Maximum likelihood decoding can be used when the tensors are stabilizer codes.\nTensor-network decoder when the tensor network is contractible via stabilizer isometries [T. Farrelly et al., \u201cTensor-Network Codes\u201d, Physical Review Letters 127, (2021). DOI; 2009.10329].\nTensor-network-based decoder when the encoding unitary is known [A. J. Ferris and D. Poulin, \u201cTensor Networks and Quantum Error Correction\u201d, Physical Review Letters 113, (2014). DOI; 1312.4578].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum Lego code", "code_id": "quantum_lego", "realizations": "", "protection": "", "notes": "Many known codes can be created using this code's methods in order to further their understanding, including a 6 qubit implementaion of the generalized Bacon-Shor code, the Toric code, and the \\([[7,1,3]]\\) Steane code.\nFor example, a simple \\( [[4,2,2]] \\) stabilizer code can be written as a rank 6 tensor. Attaching two of these via gluing together one logical leg from each can produce a \\( [[6,4,2]] \\) stabilizer code.\nTensor-network codes are types of LEGO codes made from stabilizer codes where logical and physical legs are pre-assigned and logical legs are not contracted. In other words, logical legs resulting from the conversion of codes to tensors must remain logical in the final tensor network, and the same for physical. Contracting logical legs is another word for gluing two logical legs together.", "physical": "", "short_name": "", "introduced": "[C. Cao and B. Lackey, \u201cQuantum Lego: Building Quantum Error Correction Codes from Tensor Networks\u201d, PRX Quantum 3, (2022). DOI; 2109.08158]", "description": "Code constructed using a tensor-network-based graphical framework from quantum lego blocks, which are smaller quantum codes over qubits or qudits. The class of codes constructed using the framework depends on the choice of atomic lego blocks. For instance, any stabilizer code can be built out of atomic blocks like the 2-site repetition code, single-site trivial stabilizer codes, and tensor products of the \\(|0\\rangle\\) state. Specifically, the HaPPY code is a quantum Lego code whose atomic Lego block is the five-qubit perfect code.\n\nThe individual lego blocks and resulting quantum lego codes can be stabilizer or non-stabilizer. However, both the logical and physical degrees of freedom must have the same local dimension.\n\nTo construct a Lego code, the encoding map \\(V\\) for each code that is to be used in the construction is converted to a tensor by decomposing it using the formula \\begin{align}\nV = \\sum_{i_j} V_{i_1 \\ldots i_{n+k}} | i_{k+1} \\ldots i_{k+n} \\rangle \\langle i_1 \\ldots i_k |~.\n\\end{align} We then look at the codes graphically, treating each \\(i_j\\) as an edge dangling out of the tensor vertex \\(V_{i_1 \\ldots i_{n+k}}\\). These edges are either connected to another tensor vertex's edges or left dangling. If the block codes are stabilizer, then each local tensor has unitary product stabilizers (UPS). The goal is to push each UPS through the tensor network until each dangling edge has only trivial support. Otherwise, a matching value is pushed through the edge and the process is repeated on the next tensor. If a UPS can be pushed through the whole network, then a UPS for the larger network has been found. The dangling legs (edges) and UPS of the whole network can then be converted to physical/logical elements and stabilizers/logical operators for a new quantum code.", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "quantum_concatenated\nqudit_stabilizer\nqubit_stabilizer", "parent_of_detail": "\nModular-qudit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qudit repetition code, single-qudit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state.\nQubit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qubit repetition code, single-qubit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state.", "cousins_code_id": "holographic", "cousins_detail": "Holographic codes whose encoders are tensor networks discretizing hyperbolic space are quantum Lego codes.", "_type": "ecc", "_page_id": "c_quantum_lego", "_href": "c/quantum_lego"}, "c_self_correct": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Self-correcting quantum code", "code_id": "self_correct", "realizations": "", "protection": "Self-correcting classical memories exist in two and higher dimensions, with the canonical example being the classical Ising model. In that model, a classical bit is stored in the overall magnetization. The magnetization is thermally stable due to the fact that there is an \\(n\\)-dependent (i.e., macroscopic) energy cost of flipping a contiguous region of physical bits [R. Peierls, \u201cOn Ising's model of ferromagnetism\u201d, Mathematical Proceedings of the Cambridge Philosophical Society 32, 477 (1936). DOI][B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643]. This cost scales with the surface area of the region, and the surface area is \\(n\\)-dependent for dimensions greater than one.\n\nSelf-correcting quantum memories currently exist in four and higher dimensions, with their existence in three dimensions being an open question. For similar reasons as the classical Ising model, the four-dimensional toric code is a self-correcting quantum memory due to an order \\(O(n)\\) energy cost of creating a logical error [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][R. Alicki et al., \u201cOn thermal stability of topological qubit in Kitaev's 4D model\u201d. 0811.0033]. On the other hand, the 2D toric code is not thermally stable [R. Alicki, M. Fannes, and M. Horodecki, \u201cA statistical mechanics view on Kitaev's proposal for quantum memories\u201d, Journal of Physics A: Mathematical and Theoretical 40, 6451 (2007). DOI; quant-ph/0702102][Z. Nussinov and G. Ortiz, \u201cAutocorrelations and thermal fragility of anyonic loops in topologically quantum ordered systems\u201d, Physical Review B 77, (2008). DOI; 0709.2717][Fernando Pastawski et al., \u201cLimitations of Passive Protection of Quantum Information\u201d. 0911.3843] because its string-like logical operators anti-commite with stabilizer generators supported only at their ends, and thus have a constant energy cost of creation.\n\nAn \\(n\\)-dependent energy barrier to creating all logical errors is likely necessary for a thermally stable memory, having been shown as such for a large class of 2D topological phases [Kristan Temme, \u201cThermalization time bounds for Pauli stabilizer Hamiltonians\u201d. 1412.2858][A. K\u00f3m\u00e1r, O. Landon-Cardinal, and K. Temme, \u201cNecessity of an energy barrier for self-correction of Abelian quantum doubles\u201d, Physical Review A 93, (2016). DOI; 1601.01324][Angelo Lucia, David P\u00e9rez-Garc\u00eda, and Antonio P\u00e9rez-Hern\u00e1ndez, \u201cThermalization in Kitaev's quantum double models via Tensor Network techniques\u201d. 2107.01628]. Two-dimensional stabilizer codes [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983] and encodings of frustration-free code Hamiltonians [O. Landon-Cardinal and D. Poulin, \u201cLocal Topological Order Inhibits Thermal Stability in 2D\u201d, Physical Review Letters 110, (2013). DOI; 1209.5750] admit only constant-energy excitations, and so do not have admit such a barrier. No-go theorems for 3D models are much more restrictive, and there exist several candidates for self-correction as well as several partially self-correcting memories (see cousins below).", "notes": "", "physical": "", "short_name": "", "introduced": "[E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][R. Alicki et al., \u201cOn thermal stability of topological qubit in Kitaev's 4D model\u201d. 0811.0033]", "description": "Also called a self-correcting quantum memory or thermally stable encoding. A ground-state encoding of an \\(n\\)-body geometrically local Hamiltonian whose logical information is recoverable for arbitrary long times in the \\(n\\to\\infty\\) limit after interaction with a sufficiently cold thermal environment. Typically, one also requires a decoder whose decoding time scales polynomially with \\(n\\) and a finite energy density. The original criteria for a self-correcting quantum memory, informally known as the Caltech rules [C. G. Brell, \u201cA proposal for self-correcting stabilizer quantum memories in 3 dimensions (or slightly less)\u201d, New Journal of Physics 18, 013050 (2016). DOI; 1411.7046][O. Landon-Cardinal et al., \u201cPerturbative instability of quantum memory based on effective long-range interactions\u201d, Physical Review A 91, (2015). DOI; 1501.04112], also required finite-spin Hamiltonians.\n\nThe effect of a Markovian thermal environment consists of a Lindbladian in Davies form admitting a Gibbs steady state at some temperature \\(T\\) [B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643]. To test whether a system is self-correcting, an initial codeword \\(\\rho(0)\\) is evolved under the Davies Lindbladian and the code Hamiltonian (or, if we are to allow extra passive protection, the code Lindbladian) to the state \\(\\rho(t)\\) at time \\(t\\), after which it is decoded via decoding map \\(\\cal{D}\\). The memory time \\(\\tau\\) is defined to be \\begin{align}\n  \\tau=\\sup\\left\\{ t>0\\,|\\left\\Vert {\\cal D}(\\rho(t))-\\rho(0)\\right\\Vert _{1}<\\epsilon\\right\\}\n\\end{align} for some fixed \\(\\epsilon\\). For a self-correcting memory, there exists a critical temperature \\(T_\\star>0\\) such that \\(\\tau\\to\\infty\\) (typically, exponentially with \\(n\\)) as \\(n\\to\\infty\\) for any temperature \\(T<T_{\\star}\\) and any codeword \\(\\rho(0)\\). A memory is partially self-correcting if \\(\\tau\\) scales polynomially with \\(n\\) up to some cutoff \\(n_{max}\\). A self-correcting memory is typically associated with a (stable) phase of quantum matter. ", "parents_code_id": "hamiltonian", "parents_detail": "", "parent_of_code_id": "symmetry_protected_self_correct", "parent_of_detail": "", "cousins_code_id": "translationally_invariant_stabilizer\nhigher_dimensional_surface\n3d_surface\ncolor\nhaah_cubic\nquantum_repetition\nrepetition\nbacon_shor", "cousins_detail": "3D translationally-invariant qubit stabilizer code families with constant \\(k\\) support logical string operators and thus cannot be self-correcting [B. Yoshida, \u201cFeasibility of self-correcting quantum memory and thermal stability of topological order\u201d, Annals of Physics 326, 2566 (2011). DOI; 1103.1885]. For non-constant \\(k\\), such families can support at most a logarithmic energy barrier [J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962].\nThe 4D toric code is a self-correcting quantum memory [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][R. Alicki et al., \u201cOn thermal stability of topological qubit in Kitaev's 4D model\u201d. 0811.0033].\nThe 3D welded solid code is partially self-correcting with a power-law energy barrier [K. P. Michnicki, \u201c3D Topological Quantum Memory with a Power-Law Energy Barrier\u201d, Physical Review Letters 113, (2014). DOI; 1406.4227]. The 3D toric code is a classical self-correcting memory, whose protected bit admits a membrane-like logical operator [O. Landon-Cardinal et al., \u201cPerturbative instability of quantum memory based on effective long-range interactions\u201d, Physical Review A 91, (2015). DOI; 1501.04112].\nThe 6D color code is a self-correcting quantum memory [H. Bombin et al., \u201cSelf-Correcting Quantum Computers\u201d. 0907.5228].\nCubic code 1 is partially self-correcting with a logarithmic energy barrier [S. Bravyi and J. Haah, \u201cQuantum Self-Correction in the 3D Cubic Code Model\u201d, Physical Review Letters 111, (2013). DOI; 1112.3252].\nThe bit-flip repetition code associated with the 2D classical Ising model is a self-correcting classical memory [B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643; Sec. V.A].\nThe repetition code associated with the 2D classical Ising model is a self-correcting classical memory [B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643; Sec. V.A].\n3D Bacon-Shor codes were conjectured to be self-correcting [D. Bacon, \u201cOperator quantum error-correcting subsystems for self-correcting quantum memories\u201d, Physical Review A 73, (2006). DOI; quant-ph/0506023], but there remain issues to be resolved in order to validate this conjecture (see [B. J. Brown et al., \u201cQuantum memories at finite temperature\u201d, Reviews of Modern Physics 88, (2016). DOI; 1411.6643; Sec. IX.B]).", "cousin_of_code_id": "qltc", "cousin_of_detail": "The notion of an energy barrier in a self-correcting memory is intimately related to the soundness of a QLTC.", "_type": "ecc", "_page_id": "c_self_correct", "_href": "c/self_correct"}, "c_quantum_cyclic": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Adapted from the Berlekamp decoding algorithm for classical BCH codes [Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code\u201d. 1007.1697].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum cyclic code", "code_id": "quantum_cyclic", "realizations": "", "protection": "Cyclic symmetry guarantees that if a single subsystem is protected against some noise, then all other subsystems are also.", "notes": "Many examples have been found by computer algebra programs. Ref. [Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code\u201d. 1007.1697] give examples of \\([[17,1,7]]\\) and \\([[17,9,3]]\\) quantum cyclic codes.", "physical": "", "short_name": "", "introduced": "[Sagarmoy Dutta and Piyush P Kurur, \u201cQuantum Cyclic Code\u201d. 1007.1697]", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) such that cyclic permutations of the subsystems leave the codespace invariant.", "parents_code_id": "quantum_quasi_cyclic", "parents_detail": "", "parent_of_code_id": "frobenius\npermutation_invariant", "parent_of_detail": "\nThe cyclic group of these codes is a subgroup of the \\(S_n\\) symmetric group used in permutation invariant codes.", "cousins_code_id": "cyclic", "cousins_detail": "", "cousin_of_code_id": "stab_5_1_3", "cousin_of_detail": "The five-qubit code is the smallest known example of quantum cyclic code.", "_type": "ecc", "_page_id": "c_quantum_cyclic", "_href": "c/quantum_cyclic"}, "c_quantum_quasi_cyclic": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum quasi-cyclic code", "code_id": "quantum_quasi_cyclic", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[M. Hagiwara and H. Imai, \u201cQuantum Quasi-Cyclic LDPC Codes\u201d, 2007 IEEE International Symposium on Information Theory (2007). DOI; quant-ph/0701020]", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) such that cyclic shifts of the subsystems by \\(\\ell\\) leave the codespace invariant.", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "quantum_cyclic\ntranslationally_invariant_stabilizer", "parent_of_detail": "\nTranslationally-invariant stabilizer codes are invariant under translations by a unit cell.", "cousins_code_id": "quasi_cyclic", "cousins_detail": "", "_type": "ecc", "_page_id": "c_quantum_quasi_cyclic", "_href": "c/quantum_quasi_cyclic"}, "c_permutation_invariant": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "With quantum harmonic oscillators (superconducting charge qubits in a ultrastrong coupling regime) in \\(O(N)\\) as in [C. Wu et al., \u201cInitializing a permutation-invariant quantum error-correction code\u201d, Physical Review A 99, (2019). DOI]. Can be done in \\(O(N^2)\\) steps using quantum circuits [A. B\u00e4rtschi and S. Eidenbenz, \u201cDeterministic Preparation of Dicke States\u201d, Fundamentals of Computation Theory 126 (2019). DOI; 1904.07358], or using geometric phase gates in \\(O(N)\\) [M. T. Johnsson et al., \u201cGeometric Pathway to Scalable Quantum Sensing\u201d, Physical Review Letters 125, (2020). DOI; 1908.01120].", "features_decoders": "For a family of codes, using projection, probability amplitude rebalancing, and gate teleportation can be done in \\(O(N^2)\\) [Y. Ouyang, \u201cPermutation-invariant quantum coding for quantum deletion channels\u201d, 2021 IEEE International Symposium on Information Theory (ISIT) (2021). DOI; 2102.02494].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Permutation-invariant code", "code_id": "permutation_invariant", "realizations": "", "protection": "Depends on the family. The GNU permutation-invariant family (parameterized by \\(t\\)) protects against arbitrary weight \\(t\\) qubit errors and approximately corrects spontaneous decay errors [Y. Ouyang, \u201cPermutation-invariant quantum codes\u201d, Physical Review A 90, (2014). DOI; 1302.3247][Y. Ouyang and J. Fitzsimons, \u201cPermutation-invariant codes encoding more than one qubit\u201d, Physical Review A 93, (2016). DOI]. Other related codes protect against amplitude damping [Y. Ouyang and R. Chao, \u201cPermutation-Invariant Constant-Excitation Quantum Codes for Amplitude Damping\u201d, IEEE Transactions on Information Theory 66, 2921 (2020). DOI; 1809.09801] while admitting a constant number of excitations, and against deletion errors [Y. Ouyang, \u201cPermutation-invariant quantum coding for quantum deletion channels\u201d, 2021 IEEE International Symposium on Information Theory (ISIT) (2021). DOI; 2102.02494][T. Shibayama and M. Hagiwara, \u201cPermutation-Invariant Quantum Codes for Deletion Errors\u201d, 2021 IEEE International Symposium on Information Theory (ISIT) (2021). DOI; 2102.03015].", "notes": "Can be constructed using real polynomials for high-dimensional qudit spaces [Y. Ouyang, \u201cPermutation-invariant qudit codes from polynomials\u201d, Linear Algebra and its Applications 532, 43 (2017). DOI].", "physical": "", "short_name": "", "introduced": "[Harriet Pollatsek and Mary Beth Ruskai, \u201cPermutationally Invariant Codes for Quantum Error Correction\u201d. quant-ph/0304153]", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) such that any permutation of the subsystems leaves any codeword invariant.", "parents_code_id": "quantum_cyclic", "parents_detail": "The cyclic group of these codes is a subgroup of the \\(S_n\\) symmetric group used in permutation invariant codes.", "parent_of_code_id": "constant_excitation_permutation_invariant\ngnu_permutation_invariant", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_permutation_invariant", "_href": "c/permutation_invariant"}, "c_dynamic_gen": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Dynamically-generated QECC", "code_id": "dynamic_gen", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "Dynamically-generated", "introduced": "[P. Hayden and J. Preskill, \u201cBlack holes as mirrors: quantum information in random subsystems\u201d, Journal of High Energy Physics 2007, 120 (2007). DOI; 0708.4025]", "description": "Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process. Such processes, which are often non-deterministic, update the code structure and can include random unitary evolution or non-commuting projective measurements.", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "crystalline_dynamic_gen\nrandom_circuit", "parent_of_detail": "\n", "cousin_of_code_id": "clifford-deformed_surface\nfusion\nqldpc", "cousin_of_detail": "To create CDSCs, a dynamical process is applied on top of the surface code.\nBuilding a fusion network is done using a measurement-based dynamical process.\nQLDPC codes can arise from a dynamical process [M. Ippoliti et al., \u201cEntanglement Phase Transitions in Measurement-Only Dynamics\u201d, Physical Review X 11, (2021). DOI; 2004.09560].", "_type": "ecc", "_page_id": "c_dynamic_gen", "_href": "c/dynamic_gen"}, "c_random_circuit": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Random-circuit code", "code_id": "random_circuit", "realizations": "", "protection": "A useful proxy and upper bound to the code distance \\(d\\) is the contiguous code distance: the contiguous length (with periodic boundary conditions) of the shortest logical operator [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983][M. J. Gullans and D. A. Huse, \u201cDynamical Purification Phase Transition Induced by Quantum Measurements\u201d, Physical Review X 10, (2020). DOI; 1905.05195].", "notes": "", "physical": "", "short_name": "", "introduced": "", "description": "Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.", "parents_code_id": "dynamic_gen\nquantum_random", "parents_detail": "\n", "parent_of_code_id": "haar_random\nt-designs\nnonlocal_lowdepth\nmonitored_random_circuits", "parent_of_detail": "\n\n\nMonitored random circuits are random circuits where projective measurements are interspersed throughout the circuit and measurement results are recorded.", "cousin_of_code_id": "crystalline_dynamic_gen", "cousin_of_detail": "Crystalline-circuit codes can be thought of as random-circuit codes with symmetries.", "_type": "ecc", "_page_id": "c_random_circuit", "_href": "c/random_circuit"}, "c_topological": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "The unitary circuit depth required to initialize in a general topologically ordered state using geometrically local gates on an \\(L\\times L\\) lattice is \\(\\Omega(L)\\) [S. Bravyi, M. B. Hastings, and F. Verstraete, \u201cLieb-Robinson Bounds and the Generation of Correlations and Topological Quantum Order\u201d, Physical Review Letters 97, (2006). DOI; quant-ph/0603121], irrespective of whether the ground state admits Abelian or non-Abelian anyonic excitations. However, only a finite-depth circuit and one round of measurements is required for nonabelian topological orders with a Lagrangian subgroup [Nathanan Tantivasadakarn, Ruben Verresen, and Ashvin Vishwanath, \u201cThe Shortest Route to Non-Abelian Topological Order on a Quantum Processor\u201d. 2209.03964].", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Topological code", "code_id": "topological", "realizations": "", "protection": "Topological order cannot be stabilized via weight-two or weight-three stabilizer generators on nearly Euclideam geometries of qubits or qutrits [S. Bravyi and M. Vyalyi, \u201cCommutative version of the k-local Hamiltonian problem and common eigenspace problem\u201d. quant-ph/0308021][Dorit Aharonov and Lior Eldar, \u201cOn the complexity of Commuting Local Hamiltonians, and tight conditions for Topological Order in such systems\u201d. 1102.0770].", "notes": "", "physical": "", "short_name": "", "introduced": "", "description": "Stub.", "parents_code_id": "hamiltonian", "parents_detail": "Codespace is either the ground-state or low-energy subspace of a geometrically local Hamiltonian admitting a topological phase.", "parent_of_code_id": "topological_abelian\ngalois_topological\nquantum_double\nstring_net", "parent_of_detail": "\n\nQuantum-double code Hamiltonians admit topological phases associated with finite groups \\(G\\).\nString-net codes can be realized using Levin-Wen model Hamiltonians, which realize various topological phases [M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816][Alexander Kirillov Jr, \u201cString-net model of Turaev-Viro invariants\u201d. 1106.6033].", "cousin_of_code_id": "eth\nfracton\nfusion\nt-designs\nmonitored_random_circuits\nqldpc", "cousin_of_detail": "ETH codewords, like topological codewords, are locally indistinguishable.\nFracton phases can be understood as topological defect networks, meaning that they can be described in the language of topological quantum field theory [D. Aasen et al., \u201cTopological defect networks for fractons of all types\u201d, Physical Review Research 2, (2020). DOI; 2002.05166].\nArbitrary topological codes can be created using FBQC, as can topological features such as defects and boundaries, by modifying fusion measurements or adding single qubit measurements.\nLocal Haar-random codewords, like topological codewords, are locally indistinguishable [F. G. S. L. Brand\u00e3o, A. W. Harrow, and M. Horodecki, \u201cLocal Random Quantum Circuits are Approximate Polynomial-Designs\u201d, Communications in Mathematical Physics 346, 397 (2016). DOI].\nTopological order can be generated in 2D monitored random circuits [A. Lavasani, Y. Alavirad, and M. Barkeshli, \u201cTopological Order and Criticality in <mml:math xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><mml:mrow><mml:mo stretchy=\"false\">(</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy=\"false\">)</mml:mo><mml:mi mathvariant=\"normal\">D</mml:mi></mml:mrow></mml:math> Monitored Random Quantum Circuits\u201d, Physical Review Letters 127, (2021). DOI; 2011.06595].\nTopological codes are not generally defined using Pauli strings. However, for appropriate tesselations, the codespace is the ground-state subspace of a geometrically local Hamiltonain. In this sense, topological codes are QLDPC codes. On the other hand, chain complexes describing some QLDPC codes can be 'lifted' into higher-dimensional manifolds admitting some notion of geometric locality [Michael Freedman and Matthew B. Hastings, \u201cBuilding manifolds from quantum codes\u201d. 2012.02249]. This opens up the possibility that some QLDPC codes, despite not being geometrically local, can in fact be associated with a geometrically local theory described by a category.", "_type": "ecc", "_page_id": "c_topological", "_href": "c/topological"}, "c_fracton": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Fracton code", "code_id": "fracton", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "", "description": "A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.", "parents_code_id": "hamiltonian\nqldpc", "parents_detail": "Codespace is the ground-state subspace of a geometrically local commuting-projector Hamiltonian admitting a fracton phase.\nFracton codes admit geometrically local stabilizer generators on a cubic lattice.", "parent_of_code_id": "haah_cubic", "parent_of_detail": "Haah cubic codes are the first examples of Type-II fracton phases [M. Pretko, X. Chen, and Y. You, \u201cFracton phases of matter\u201d, International Journal of Modern Physics A 35, 2030003 (2020). DOI; 2001.01722].", "cousins_code_id": "topological", "cousins_detail": "Fracton phases can be understood as topological defect networks, meaning that they can be described in the language of topological quantum field theory [D. Aasen et al., \u201cTopological defect networks for fractons of all types\u201d, Physical Review Research 2, (2020). DOI; 2002.05166].", "cousin_of_code_id": "translationally_invariant_stabilizer\nxzzx", "cousin_of_detail": "Translationally-invariant stabilizer codes can realize fracton orders. Conversely, fracton codes need not be translationally invariant, and can realize multiple phases on one lattice.\nSubsystem symmetries play a role in finite-bias decoders for both codes [B. J. Brown and D. J. Williamson, \u201cParallelized quantum error correction with fracton topological codes\u201d, Physical Review Research 2, (2020). DOI; 1901.08061].", "_type": "ecc", "_page_id": "c_fracton", "_href": "c/fracton"}, "c_hamiltonian": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Lindbladian-based dissipative encoding can be constructed for a codespace that is the ground-state subspace of a frustration-free Hamiltonian [Francesco Ticozzi and Lorenza Viola, \u201cAnalysis and synthesis of attractive quantum Markovian dynamics\u201d. 0809.0613][F. Ticozzi and L. Viola, \u201cStabilizing entangled states with quasi-local quantum dynamical semigroups\u201d, Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 370, 5259 (2012). DOI; 1112.4860][Frank Verstraete, Michael M. Wolf, and J. Ignacio Cirac, \u201cQuantum computation, quantum state engineering, and quantum phase transitions driven by dissipation\u201d. 0803.1447][Victor V. Albert, \u201cLindbladians with multiple steady states: theory and applications\u201d. 1802.00010].", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Hamiltonian-based code", "code_id": "hamiltonian", "realizations": "", "protection": "Often determined from the underlying physical properties of the Hamiltonian.", "notes": "", "physical": "", "short_name": "", "introduced": "", "description": "Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy.\n\nWhen the physical space is a tensor product of subsystems, the Hamiltonian is typically local, consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., QLDPC codes). When the physical space is endowed with a geometry, the Hamiltonian is typically geometrically local, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., topological codes). When the terms in a geometrically local Hamiltonian commute and can be expressed as projectors (i.e., having eigenvalues 0 or 1), the Hamiltonian is called commuting-projector. ", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "constant_excitation\neth\nfracton\nmovassagh_ouyang\nqltc\nqldpc\nself_correct\ntopological", "parent_of_detail": "Constant-excitation codes are associated with a Hamiltonian governing the total excitations of the system.\nETH codewords are eigenstates of a local Hamiltonian whose eigenstates satisfy ETH.\nCodespace is the ground-state subspace of a geometrically local commuting-projector Hamiltonian admitting a fracton phase.\nMovassagh-Ouyang codes reside in the ground space of a Hamiltonian.\nQuantum LTC codespaces are ground-state spaces of \\(u\\)-local Hamiltonians.\nQLDPC codespaces are ground-state subspaces of a local Hamiltonain consisting of commuting terms.\n\nCodespace is either the ground-state or low-energy subspace of a geometrically local Hamiltonian admitting a topological phase.", "cousin_of_code_id": "bacon_shor\nmetopt\nstab_5_1_3\ngnu_permutation_invariant\npaircat\nquantum_repetition\nqubit_stabilizer\ntwo-legged-cat", "cousin_of_detail": "The 2D Bacon-Shor code Hamiltonian is the compass model [K. I. Kugel' and D. I. Khomski\u012d, \u201cThe Jahn-Teller effect and magnetism: transition metal compounds\u201d, Soviet Physics Uspekhi 25, 231 (1982). DOI][J. Dorier, F. Becca, and F. Mila, \u201cQuantum compass model on the square lattice\u201d, Physical Review B 72, (2005). DOI; cond-mat/0501708].\nMetrologically optimal codes admit a \\(U(1)\\) set of gates generated by a signal Hamiltonian \\(H\\), meaning that there exists a basis of codewords that are eigenstates of the \\(H\\).\nThe five-qubit code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].\nGNU codes lie within the ground state of ferromagnetic Heisenberg models without an external magnetic field [Y. Ouyang, \u201cQuantum storage in quantum ferromagnets\u201d, Physical Review B 103, (2021). DOI; 1904.01458].\nTwo-legged pair-cat codewords form ground-state subspace of a multimode Kerr Hamiltonian.\nBit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions.\nCodespace is the ground-state space of the code Hamiltonian, which consists of an equal linear combination of stabilizer generators and which can be made into a commuting projector Hamiltonian.\nTwo-legged cat codewords form ground-state subspace of a Kerr Hamiltonian [S. Puri, S. Boutin, and A. Blais, \u201cEngineering the quantum states of light in a Kerr-nonlinear resonator by two-photon driving\u201d, npj Quantum Information 3, (2017). DOI; 1605.09408].", "_type": "ecc", "_page_id": "c_hamiltonian", "_href": "c/hamiltonian"}, "c_topological_abelian": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Abelian topological code", "code_id": "topological_abelian", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Code whose codewords realize topological order associated with an abelian group. Stub.\n\nAny local quantum circuit connecting ground states of topological orders with non-isomorphic abelian groups must have depth that is at least linear in the system\u2019s diameter [J. Haah, \u201cAn Invariant of Topologically Ordered States Under Local Unitary Transformations\u201d, Communications in Mathematical Physics 342, 771 (2016). DOI; 1407.2926]. ", "parents_code_id": "topological\nsubsystem_stabilizer", "parents_detail": "\nAll premodular abelian topological orders can be realized as modular-qudit subsystem stabilizer codes [Tyler D. Ellison et al., \u201cPauli topological subsystem codes from Abelian anyon theories\u201d. 2211.03798].", "parent_of_code_id": "clifford-deformed_surface\ncolor\ndouble_semion\nsurface\nmatching", "parent_of_detail": "Local deformations of the surface code preserve its \\(\\mathbb{Z}_2\\) topological order.\nWhen treated as ground states of the code Hamiltonian, 2D color code states on realize \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) topological order [M. Kargarian, H. Bombin, and M. A. Martin-Delgado, \u201cTopological color codes and two-body quantum lattice Hamiltonians\u201d, New Journal of Physics 12, 025018 (2010). DOI; 0906.4127], equivalent to the phase realized by two copies of the surface code [A. Kubica, B. Yoshida, and F. Pastawski, \u201cUnfolding the color code\u201d, New Journal of Physics 17, 083026 (2015). DOI; 1503.02065].\nWhen treated as ground states of the code Hamiltonian, the code states realize double-semion topological order, a topological phase of matter that also exists in twisted \\(\\mathbb{Z}_2\\) gauge theory [R. Dijkgraaf and E. Witten, \u201cTopological gauge theories and group cohomology\u201d, Communications in Mathematical Physics 129, 393 (1990). DOI].\nWhen treated as ground states of the code Hamiltonian, the code states realize \\(\\mathbb{Z}_2\\) topological order, a topological phase of matter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory [F. J. Wegner, \u201cDuality in Generalized Ising Models and Phase Transitions without Local Order Parameters\u201d, Journal of Mathematical Physics 12, 2259 (1971). DOI]. Codewords correspond to ground state of the code Hamiltonian, and error operators correspond to spontaneous creation and annihilation of pairs of charges or vortices. \nMatching codes were inspired by the Kitaev honeycomb model [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438], which realizes \\(\\mathbb{Z}_2\\) topological order.", "cousins_code_id": "qudit_stabilizer\nqldpc", "cousins_detail": "All non-chiral abelian topological orders can be realized as modular-qudit stabilizer codes [T. D. Ellison et al., \u201cPauli Stabilizer Models of Twisted Quantum Doubles\u201d, PRX Quantum 3, (2022). DOI; 2112.11394].\nTopological-code Hamiltonians are geometrically local for appropriate tesselations.", "cousin_of_code_id": "qudit_surface\ntranslationally_invariant_stabilizer\nxs_stabilizer\nxzzx", "cousin_of_detail": "Modular-qudit surface code Hamiltonians can admit topological phases associated with \\(\\mathbb{Z}_q\\) [S. S. Bullock and G. K. Brennen, \u201cQudit surface codes and gauge theory with finite cyclic groups\u201d, Journal of Physics A: Mathematical and Theoretical 40, 3481 (2007). DOI; quant-ph/0609070].\nTranslationally-invariant stabilizer codes can realize abelian topological orders. Conversely, abelian topological codes need not be translationally invariant, and can realize multiple topological phases on one lattice.\nTwisted quantum double models for the groups \\(\\mathbb{Z}_2^k\\) can be realized as XS stabilizer codes.\nExample of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [X.-G. Wen, \u201cQuantum Orders in an Exact Soluble Model\u201d, Physical Review Letters 90, (2003). DOI; quant-ph/0205004].", "_type": "ecc", "_page_id": "c_topological_abelian", "_href": "c/topological_abelian"}, "c_constant_excitation": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "Fock-state CE codes can be used in a protocol that achieves the two-way quantum capacity of the pure-loss Gaussian channel [Matthew S. Winnel et al., \u201cAchieving the ultimate end-to-end rates of lossy quantum communication networks\u201d. 2203.13924].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Constant-excitation (CE) code", "code_id": "constant_excitation", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[M. B. Plenio, V. Vedral, and P. L. Knight, \u201cQuantum error correction in the presence of spontaneous emission\u201d, Physical Review A 55, 67 (1997). DOI; quant-ph/9603022][P. Zanardi and M. Rasetti, \u201cNoiseless Quantum Codes\u201d, Physical Review Letters 79, 3306 (1997). DOI; quant-ph/9705044][D. A. Lidar, D. Bacon, and K. B. Whaley, \u201cConcatenating Decoherence-Free Subspaces with Quantum Error Correcting Codes\u201d, Physical Review Letters 82, 4556 (1999). DOI; quant-ph/9809081]", "description": "Code whose codewords lie in an excited-state eigenspace of a Hamiltonian governing the total energy or total number of excitations of the underlying quantum system. For qubit codes, such a Hamiltonian is often the total spin Hamiltonian, \\(H=\\sum_i Z_i\\). For spin-\\(S\\) codes, this generalizes to \\(H=\\sum_i J_z^{(i)}\\), where \\(J_z\\) is the spin-\\(S\\) \\(Z\\)-operator. For bosonic codes, such as Fock-state codes, codewords are often in an eigenspace with eigenvalue \\(N>0\\) of the total excitation or energy Hamiltonian, \\(H=\\sum_i \\hat{n}_i\\).\n\nOne of the first such codes [M. B. Plenio, V. Vedral, and P. L. Knight, \u201cQuantum error correction in the presence of spontaneous emission\u201d, Physical Review A 55, 67 (1997). DOI; quant-ph/9603022] is a \\(((8,1,3))\\) qubit code, with codewords \\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&= |00001111\\rangle + |11101000\\rangle \u2212 |10010110\\rangle \u2212 |01110001\\rangle\\\\\n                    & +|11010100\\rangle + |00110011\\rangle + |01001101\\rangle + |10101010\\rangle\\\\\n|\\overline{1}\\rangle&= X^{\\otimes 8} |\\overline{0}\\rangle~.\n\\end{split}\n\\end{align} Each logical state is a superposition of computational basis states with four excitations. ", "parents_code_id": "hamiltonian", "parents_detail": "Constant-excitation codes are associated with a Hamiltonian governing the total excitations of the system.", "parent_of_code_id": "chuang-leung-yamamoto", "parent_of_detail": "Chuang-Leung-Yamamoto codewords are constructed out of Fock states with the same total excitation number.", "cousin_of_code_id": "constant_weight", "cousin_of_detail": "Constant-weight codes are classical analogues of qubit constant-excitation codes.", "_type": "ecc", "_page_id": "c_constant_excitation", "_href": "c/constant_excitation"}, "c_qltc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Quantum locally testable code (QLTC)", "code_id": "qltc", "realizations": "", "protection": "", "notes": "It was shown in Ref. [L. Eldar and A. W. Harrow, \u201cLocal Hamiltonians Whose Ground States Are Hard to Approximate\u201d, 2017 IEEE 58th Annual Symposium on Foundations of Computer Science (FOCS) (2017). DOI] that existence of a QLTC with constant parameters would implies resolution of the No low-energy trivial states (NLTS) conjecture [M. H. Freedman and M. B. Hastings, \u201cQuantum Systems on Non-$k$-Hyperfinite Complexes: A Generalization of Classical Statistical Mechanics on Expander Graphs\u201d. 1301.1363].", "physical": "", "short_name": "QLTC", "introduced": "[Dorit Aharonov and Lior Eldar, \u201cQuantum Locally Testable Codes\u201d. 1310.5664]", "description": "A local commuting-projector Hamiltonian-based quantum error-correcting code on a finite-tensor-product space of \\(n\\) identical factors (e.g., qubits, modular qudits, or Galois qudits) which has a nonzero average-energy penalty for creating large errors. Informally, QLTC error states that are far away from the codespace have to be excited states of many of the code's local projectors.\n\nThe average-energy penalty is quantified by the code's soundness \\(R\\). Typically, one looks at how \\(R\\) scales with increasing code size for infinite families of codes, defining QLTC families as those for which the soundness is asymptotically constant. QLTC families that also have asymptotically constant distance, rate, and weight of local projectors are called \\(c^3\\)-QLTCs; none have been found so far.\n\nMore technically, a QLTC is a code \\(\\mathsf{C}\\) defined as the ground-state space of a commuting-projector Hamiltonian \\(H\\) consisting of a sum of \\(r\\) local projectors, each of which acts on exactly \\(u\\) qubits (for some constant \\(u\\)). Such a code is a \\((u,R)\\)-QLTC with soundness function \\(R(\\delta)\\in[0,1]\\) if \\begin{align}\n\\label{eq:qltc}\n  \\forall \\delta > 0,|\\psi\\rangle~:~\\text{dist}(|\\psi\\rangle,C) \\geq \\delta n \\Rightarrow \\frac{1}{r}\\langle\\psi|H|\\psi\\rangle\\geq R(\\delta)~,\n\\end{align} where \\(\\text{dist}(|\\psi\\rangle,\\mathsf{C})\\) is a particular distance function between the state \\(|\\psi\\rangle\\) and the codespace \\(\\mathsf{C}\\) [Dorit Aharonov and Lior Eldar, \u201cQuantum Locally Testable Codes\u201d. 1310.5664; Def. 13]. The locality parameter \\(u\\) is called the query complexity of the code.\n\nA qubit, modular-qudit, or Galois-qudit stabilizer code that is locally testable is called a stabilizer locally testable code (SLTC). In other words, the code admits a set of \\(r\\) \\(u\\)-local stabilizer generators \\(S_i\\) whose corresponding code Hamiltonian \\(H=\\frac{1}{2}\\sum_{i=1}^r I-S_i\\) satisfies the requirement of being QLTC.\n\nFor example, the \\([[n=2L^2,k=2,d=L]]\\) toric code on an \\(L\\times L\\) lattice is not a QLTC because of the following argument. Let \\(|\\psi\\rangle\\) be a ground state that is excited by \\(L/3\\) Pauli strings, each of length \\(L/2\\). In order to fit on the lattice, such strings can, e.g., be horizontal and aligned next to each other in the vertical direction. The distance function \\(\\text{dist}(|\\psi\\rangle,\\mathsf{C})\\) is the weight of the smallest Pauli string that multiplies \\(|\\psi\\rangle\\) to yield a state in the codespace. In this case, that weight is the same as the weight of the perturbing string, i.e., \\(L^2/6\\), requiring \\(\\delta = 1/12\\) to satisfy \\(\\eqref{eq:qltc}\\). There are \\(2L/3\\) violated Hamiltonian terms because each of the \\(L/3\\) strings violates only two stabilizer generators. However, there are \\(r = 2(L^2-1)\\) stabilizer generators, so the implication of \\(\\eqref{eq:qltc}\\) is not satisfied for nonzero soundness as \\(L\\to\\infty\\) because \\(\\frac{1}{r}\\langle\\psi|H|\\psi\\rangle = \\frac{2L/3}{2(L^2-1)}\\to 0\\).", "parents_code_id": "hamiltonian", "parents_detail": "Quantum LTC codespaces are ground-state spaces of \\(u\\)-local Hamiltonians.", "parent_of_code_id": "check_product", "parent_of_detail": "Quantum check-product constructions yield a sLTC code with constant soundness \\(2\\rho\\) from a classical LTC code with soundness \\(\\rho\\). While these are the first bona-fide QLTC code family because they admit asymptotically constant soundess, they are not practical because their distance is two.", "cousins_code_id": "qldpc\nself_correct", "cousins_detail": "Stabilizer LTCs are QLDPC. More general QLTCs are not defined using Pauli strings, but the codespace is the ground-state subspace of a local Hamiltonain. In this sense, QLTCs are QLDPC codes.\nThe notion of an energy barrier in a self-correcting memory is intimately related to the soundness of a QLTC.", "cousin_of_code_id": "hemicubic\nhypersphere_product\nltc", "cousin_of_detail": "A hemicubic code family has asymptotically diminishing soundness that scales as order \\(\\Omega(1/\\log n)\\).\nThe hypersphere product code family has asymptotically diminishing soundness that scales as order \\(O(1/(\\log n)^2)\\), locality of stabilizer generators scaling as order \\(O(\\log n)\\), and distance \\(\\Theta(\\sqrt{n})\\).\n", "_type": "ecc", "_page_id": "c_qltc", "_href": "c/qltc"}, "c_distance_balanced": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Distance-balanced code", "code_id": "distance_balanced", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[M. B. Hastings, \u201cWeight Reduction for Quantum Codes\u201d. 1611.03790][Shai Evra, Tali Kaufman, and Gilles Z\u00e9mor, \u201cDecodable quantum LDPC codes beyond the $\\sqrt{n}$ distance barrier using high dimensional expanders\u201d. 2004.07935]", "description": "CSS stabilizer code constructed from a CSS code and a classical code using a distance-balancing procedure based on a generalized homological product. The initial code is said to be unbalanced, i.e., tailored to noise biased toward either bit- or phase-flip errors, and the procedure can result in a code that is treats both types of errors on a more equal footing. The original distance-balancing procedure [M. B. Hastings, \u201cWeight Reduction for Quantum Codes\u201d. 1611.03790], later generalized in Ref. [Shai Evra, Tali Kaufman, and Gilles Z\u00e9mor, \u201cDecodable quantum LDPC codes beyond the $\\sqrt{n}$ distance barrier using high dimensional expanders\u201d. 2004.07935], can yield QLDPC codes; see Thm. 1 in Ref. [M. B. Hastings, \u201cWeight Reduction for Quantum Codes\u201d. 1611.03790].", "parents_code_id": "css\nhomological_product", "parents_detail": "\nDistance balancing relies on taking homological product of chain complexes corresponding to a classical and a quantum code.", "cousins_code_id": "subsystem_stabilizer", "cousins_detail": "", "cousin_of_code_id": "balanced_product\nfiber_bundle\ncheck_product\nramanujan_tensor_product", "cousin_of_detail": "Distance balancing is used to form balanced-product subsystem codes [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].\nFiber-bundle code constructions use distance balancing to increase distance.\nQuantum check-product code constructions use distance balancing to increase distance.\nRamanujan tensor-product constructions use distance balancing to increase distance.", "_type": "ecc", "_page_id": "c_distance_balanced", "_href": "c/distance_balanced"}, "c_translationally_invariant_stabilizer": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Clustering decoder [J. W. Harrington, Analysis of Quantum Error-correcting Codes: Symplectic Lattice Codes and Toric Codes, California Institute of Technology, 2004. DOI][S. Bravyi and J. Haah, \u201cQuantum Self-Correction in the 3D Cubic Code Model\u201d, Physical Review Letters 111, (2013). DOI; 1112.3252].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Translationally-invariant stabilizer code", "code_id": "translationally_invariant_stabilizer", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962][J. Haah, \u201cCommuting Pauli Hamiltonians as Maps between Free Modules\u201d, Communications in Mathematical Physics 324, 351 (2013). DOI; 1204.1063][J. Haah, Lattice Quantum Codes and Exotic Topological Phases of Matter, California Institute of Technology, 2013. DOI]", "description": "A geometrically local qubit or qudit stabilizer code with qudits organized on a lattice modeled by the additive group \\(\\mathbb{Z}^D\\) for spatial dimension \\(D\\) such that each lattice point, referred to as a site, contains \\(m\\) qudits of dimension \\(q\\). The stabilizer group of the translationally invariant code is generated by site-local Pauli operators and their translations.\n\nA single-qudit Pauli operator can be specified by the lattice coordinate of the site and the symplectic vector representation of the Pauli operator within the site. In an extension of the sympletic representation, each lattice coordinate can be represented by a Laurent monomial of \\(D\\) formal variables. For example, when \\(D=2\\) and \\(m=1\\), the product of an \\(X\\) acting on the qubit at lattice coordinate \\((-1,2)\\) and a \\(Z\\) acting on the qubit at \\((1,0)\\) can be represented by the vector \\( (x^{-1} y^2 | x) \\). The multiplicative group of finitely supported Pauli operators modulo phase factors on the lattice of dimension \\(D\\) with \\(m\\) prime-dimensional qubits per site is isomorphic to the additive group of Laurent polynomial column vectors of length \\(2m\\) in \\(D\\) formal variables (see Ref. [J. Haah, \u201cAlgebraic Methods for Quantum Codes on Lattices\u201d, Revista Colombiana de Matem\u00e1ticas 50, 299 (2017). DOI; 1607.01387] and Sec. IV of Ref. [Jeongwan Haah, Lukasz Fidkowski, and Matthew B. Hastings, \u201cNontrivial Quantum Cellular Automata in Higher Dimensions\u201d. 1812.01625]).\n\nTranslationally-invariant prime-qudit (\\(q=p\\)) stabilizer codes have been classified in dimensions \\(D\\in\\{1,2\\}\\), up to equivalence under local constant-depth Clifford circuits. Any 1D (2D) code can be converted to several copies of the 1D repetition code (prime-qudit 2D surface code) along with some trivial codes [J. Haah, \u201cAlgebraic Methods for Quantum Codes on Lattices\u201d, Revista Colombiana de Matem\u00e1ticas 50, 299 (2017). DOI; 1607.01387] ([J. Haah, \u201cClassification of translation invariant topological Pauli stabilizer codes for prime dimensional qudits on two-dimensional lattices\u201d, Journal of Mathematical Physics 62, 012201 (2021). DOI; 1812.11193]). Three-dimensional qubit codes can be characterized by four coarse classes [A. Dua et al., \u201cSorting topological stabilizer models in three dimensions\u201d, Physical Review B 100, (2019). DOI; 1908.08049]:\n\n1. Abelian topological phase: Excitations are mobile in all 3 dimensions, as is typical in a topological code. Such codes are conjectured to be equivalent to a \\(\\mathbb{Z}_2\\) gauge theory, i.e., multiple copies of the 3D surface code or its variant where the charge excitation is a fermion.\n\n2. Foliated type-I fracton phase: Excitations are mobile in less than 3 dimensions, but codes can be grown by foliation, i.e., stacking copies of the 2D surface code.\n\n3. Fractal type-I fracton phase: Excitations are mobile in less than 3 dimensions, and codes are not foliated.\n\n4. Type-II fracton phase: Excitations are not mobile in any dimension and there are no string operators.", "parents_code_id": "qldpc\nquantum_quasi_cyclic", "parents_detail": "Translationally-invariant stabilizer codes are geometrically local.\nTranslationally-invariant stabilizer codes are invariant under translations by a unit cell.", "parent_of_code_id": "crystalline_dynamic_gen\nquantum_parity\ntfim", "parent_of_detail": "\n\n", "cousins_code_id": "qubit_stabilizer\nqudit_stabilizer\nsurface\nqudit_surface\ntopological_abelian\nfracton", "cousins_detail": "Qubit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site.\nModular-qudit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site.\nTranslation-invariant 2D qubit topological stabilizer codes are equivalent to several copies of the Kitaev surface code via a local constant-depth Clifford circuit [H. Bombin, G. Duclos-Cianci, and D. Poulin, \u201cUniversal topological phase of two-dimensional stabilizer codes\u201d, New Journal of Physics 14, 073048 (2012). DOI; 1103.4606][H. Bomb\u00edn, \u201cStructure of 2D Topological Stabilizer Codes\u201d, Communications in Mathematical Physics 327, 387 (2014). DOI; 1107.2707][J. Haah, \u201cAlgebraic Methods for Quantum Codes on Lattices\u201d, Revista Colombiana de Matem\u00e1ticas 50, 299 (2017). DOI; 1607.01387].\nTranslation-invariant 2D prime-qudit topological stabilizer codes are equivalent to several copies of the prime-qudit surface code via a local constant-depth Clifford circuit [J. Haah, \u201cClassification of translation invariant topological Pauli stabilizer codes for prime dimensional qudits on two-dimensional lattices\u201d, Journal of Mathematical Physics 62, 012201 (2021). DOI; 1812.11193].\nTranslationally-invariant stabilizer codes can realize abelian topological orders. Conversely, abelian topological codes need not be translationally invariant, and can realize multiple topological phases on one lattice.\nTranslationally-invariant stabilizer codes can realize fracton orders. Conversely, fracton codes need not be translationally invariant, and can realize multiple phases on one lattice.", "cousin_of_code_id": "self_correct", "cousin_of_detail": "3D translationally-invariant qubit stabilizer code families with constant \\(k\\) support logical string operators and thus cannot be self-correcting [B. Yoshida, \u201cFeasibility of self-correcting quantum memory and thermal stability of topological order\u201d, Annals of Physics 326, 2566 (2011). DOI; 1103.1885]. For non-constant \\(k\\), such families can support at most a logarithmic energy barrier [J. Haah, \u201cLocal stabilizer codes in three dimensions without string logical operators\u201d, Physical Review A 83, (2011). DOI; 1101.1962].", "_type": "ecc", "_page_id": "c_translationally_invariant_stabilizer", "_href": "c/translationally_invariant_stabilizer"}, "c_qldpc": {"logical": "", "features_code_capacity_threshold": "Bounds on code capacity thresholds using maximum-likelihood (ML) decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model [E. Dennis et al., \u201cTopological quantum memory\u201d, Journal of Mathematical Physics 43, 4452 (2002). DOI; quant-ph/0110143][A. A. Kovalev and L. P. Pryadko, \u201cFault tolerance of quantum low-density parity check codes with sublinear distance scaling\u201d, Physical Review A 87, (2013). DOI; 1208.2317][Alexey A. Kovalev and Leonid P. Pryadko, \u201cSpin glass reflection of the decoding transition for quantum error correcting codes\u201d. 1311.7688].\nBounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights [I. Dumer, A. A. Kovalev, and L. P. Pryadko, \u201cThresholds for Correcting Errors, Erasures, and Faulty Syndrome Measurements in Degenerate Quantum Codes\u201d, Physical Review Letters 115, (2015). DOI; 1412.6172].", "features_general_gates": "", "features_threshold": "QLDPC codes with a constant encoding rate can reduce the overhead of fault-tolerant quantum computation to be constant [Daniel Gottesman, \u201cFault-Tolerant Quantum Computation with Constant Overhead\u201d. 1310.2984].", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Belief-propagation (BP) decoder [David Poulin and Yeojin Chung, \u201cOn the iterative decoding of sparse quantum codes\u201d. 0801.1241].\nNon-binary decoding algorithm for CSS-type QLDPC codes [Z. Babar et al., \u201cFifteen Years of Quantum LDPC Coding and Improved Decoding Strategies\u201d, IEEE Access 3, 2492 (2015). DOI].\nBP-OSD decoder adds a post-processing step based on ordered statistics decoding (OSD) to the belief propogation (BP) decoder [P. Panteleev and G. Kalachev, \u201cDegenerate Quantum LDPC Codes With Good Finite Length Performance\u201d, Quantum 5, 585 (2021). DOI; 1904.02703].\nSoft (i.e., analog) syndrome iterative belief propagation for CSS-type QLDPC codes, utilizing the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) [Nithin Raveendran et al., \u201cSoft Syndrome Decoding of Quantum LDPC Codes for Joint Correction of Data and Syndrome Errors\u201d. 2205.02341].\nMessage-passing decoder utilizing stabilizer inactivation (MP-SI) for CSS-type QLDPC qubit codes [Julien du Crest, Mehdi Mhalla, and Valentin Savin, \u201cStabilizer Inactivation for Message-Passing Decoding of Quantum LDPC Codes\u201d. 2205.06125].\nExtension of the union-find decoder for qubit QLDPC codes, as well as a related heuristic decoder [Lucas Berent, Lukas Burgholzer, and Robert Wille, \u201cSoftware Tools for Decoding Quantum Low-Density Parity Check Codes\u201d. 2209.01180].", "features_transversal_gates": "", "features_fault_tolerance": "Lattice surgery techniques with ancilla qubits [L. Z. Cohen et al., \u201cLow-overhead fault-tolerant quantum computing using long-range connectivity\u201d, Science Advances 8, (2022). DOI; 2110.10794].\nFault-tolerance with constant overhead can be performed on certain QLDPC codes [Daniel Gottesman, \u201cFault-Tolerant Quantum Computation with Constant Overhead\u201d. 1310.2984], e.g., quantum expander codes [O. Fawzi, A. Grospellier, and A. Leverrier, \u201cConstant Overhead Quantum Fault-Tolerance with Quantum Expander Codes\u201d, 2018 IEEE 59th Annual Symposium on Foundations of Computer Science (FOCS) (2018). DOI; 1808.03821].", "name": "Quantum low-density parity-check (QLDPC) code", "code_id": "qldpc", "realizations": "", "protection": "Detects errors on \\(d-1\\) sites, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) sites. Asymptotic scaling of \\(k\\) and \\(d\\) with \\(n\\) is often of interest, and this depends heavily on the code construction. Geometrically local qubit codes are limited by the BPT bound [S. Bravyi and B. Terhal, \u201cA no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes\u201d, New Journal of Physics 11, 043029 (2009). DOI; 0810.1983], which states that \\(d=O(n^{1-1/D})\\) for \\(D\\)-dimensional lattice geometries. For general graphs, distance is limited by graphs' connectivity, and a constant relative minimum distance can be achieved only for graphs that contain expanders [N. Baspin and A. Krishna, \u201cConnectivity constrains quantum codes\u201d, Quantum 6, 711 (2022). DOI; 2106.00765]. Conversely, a code with parameters \\(k\\) and \\(d\\) requires a graph with \\(\\Omega(d)\\) edges of length \\(\\Omega(d/n^{1/D})\\) [N. Baspin and A. Krishna, \u201cQuantifying Nonlocality: How Outperforming Local Quantum Codes Is Expensive\u201d, Physical Review Letters 129, (2022). DOI; 2109.10982].\n\nCode distance may not be a reliable marker of code performance. QLDPC codes with generator weights bounded by some constant can correct many stochastic errors far beyond the distance, which may not scale as favorably. Together with more accurate, faster, and easier-to-parallelize measurements than those of general stabilizer codes, this property makes QLDPC codes interesting in practice.", "notes": "Links to code tables of notable QLDPC codes [N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309].\nReviews of QLDPC codes provided in Refs. [Z. Babar et al., \u201cFifteen Years of Quantum LDPC Coding and Improved Decoding Strategies\u201d, IEEE Access 3, 2492 (2015). DOI][N. P. Breuckmann and J. N. Eberhardt, \u201cQuantum Low-Density Parity-Check Codes\u201d, PRX Quantum 2, (2021). DOI; 2103.06309].", "physical": "", "short_name": "QLDPC", "introduced": "[D. J. C. MacKay, G. Mitchison, and P. L. McFadden, \u201cSparse-Graph Codes for Quantum Error Correction\u201d, IEEE Transactions on Information Theory 50, 2315 (2004). DOI; quant-ph/0304161]", "description": "Family of \\([[n,k,d]]\\) stabilizer codes for which the number of sites (either qubit or qudit) participating in each stabilizer generator and the number of stabilizer generators that each site participates in are both bounded by a constant as \\(n\\to\\infty\\). A geometrically local stabilizer code is a QLDPC code where the sites involved in any syndrome bit are contained in a fixed volume that does not scale with \\(n\\). As opposed to general stabilizer codes, syndrome extraction of the constant-weight check operators of a QLDPC codes can be done using a constant-depth circuit.\n\nNotable \\([[n,k,d]]\\) QLDPC codes are summarized in Table\u00a0I, demonstrating the steady improvement in code parameters that culminated in the first asymptotically good QLDPC codes.\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n    \\(k\\)\n    \\(d\\)\n    Code\n    \\(2\\)\n    \\(\\sqrt{n}\\)\n    Kitaev toric\n    \\(2\\)\n    \\(\\sqrt{n\\sqrt{\\log n}}\\)\n    Freedman-Meyer-Luo\n    \\(n\\)\n    \\(\\sqrt{n}\\)\n    hypergraph product\n    \\(n\\)\n    \\(\\sqrt{n} \\log n\\)\n    Ramanujan-complex product\n    \\(\\sqrt{n}\\)\n    \\(\\sqrt{n} \\log^c n\\)\n    tensored-Ramanujan-complex product\n    \\(n^{3/5}/\\text{polylog}(n)\\)\n    \\(n^{3/5}/\\text{polylog}(n)\\)\n    fiber-bundle\n    \\(\\log n\\)\n    \\(n/\\log n\\)\n    lifted-product\n    \\(\\Theta(n)\\)\n    \\(\\Theta(n)\\)\n    expander lifted-product\n    \\(\\Theta(n)\\)\n    \\(\\Theta(n)\\)\n    quantum Tanner\n    \\(\\Theta(n)\\)\n    \\(\\Theta(n)\\)\n    Dinur-Hsieh-Lin-Vidick\n\nTable\u00a0I: Notable QLDPC codes; \\(c\\) is a positive integer.\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n\nStrictly speaking, the term parity check describes only bitwise qubit error syndromes. Nevertheless, qudit stabilizer codes satisfying the above criteria are also called QLDPC codes.", "parents_code_id": "stabilizer\nhamiltonian", "parents_detail": "\nQLDPC codespaces are ground-state subspaces of a local Hamiltonain consisting of commuting terms.", "parent_of_code_id": "fracton\ngeneralized_homological_product\ngood_qldpc\ntranslationally_invariant_stabilizer", "parent_of_detail": "Fracton codes admit geometrically local stabilizer generators on a cubic lattice.\nHomological products are a primary tool for generating QLDPC codes with favorable parameters. Typically, whenever the input codes are LDPC or QLDPC, the resulting code will be QLDPC with non geometrically local stabilizer generators.\n\nTranslationally-invariant stabilizer codes are geometrically local.", "cousins_code_id": "ldpc\ntopological\ndynamic_gen", "cousins_detail": "\nTopological codes are not generally defined using Pauli strings. However, for appropriate tesselations, the codespace is the ground-state subspace of a geometrically local Hamiltonain. In this sense, topological codes are QLDPC codes. On the other hand, chain complexes describing some QLDPC codes can be 'lifted' into higher-dimensional manifolds admitting some notion of geometric locality [Michael Freedman and Matthew B. Hastings, \u201cBuilding manifolds from quantum codes\u201d. 2012.02249]. This opens up the possibility that some QLDPC codes, despite not being geometrically local, can in fact be associated with a geometrically local theory described by a category.\nQLDPC codes can arise from a dynamical process [M. Ippoliti et al., \u201cEntanglement Phase Transitions in Measurement-Only Dynamics\u201d, Physical Review X 11, (2021). DOI; 2004.09560].", "cousin_of_code_id": "topological_abelian\nhoneycomb\nqltc", "cousin_of_detail": "Topological-code Hamiltonians are geometrically local for appropriate tesselations.\nThe Floquet check operators are weight-two, and each qubit participates in one check each round.\nStabilizer LTCs are QLDPC. More general QLTCs are not defined using Pauli strings, but the codespace is the ground-state subspace of a local Hamiltonain. In this sense, QLTCs are QLDPC codes.", "_type": "ecc", "_page_id": "c_qldpc", "_href": "c/qldpc"}, "c_good_qldpc": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Good QLDPC code", "code_id": "good_qldpc", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Also called asymptotically good QLDPC codes. A family of QLDPC codes \\([[n_i,k_i,d_i]]\\) whose asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.\n\nThe first good QLDPC codes are families of expander lifted-product codes, followed by quantum Tanner codes and Dinur-Hsieh-Lin-Vidick codes. ", "parents_code_id": "qldpc", "parents_detail": "", "cousin_of_code_id": "dhlv\nexpander_lifted_product\nquantum_tanner", "cousin_of_detail": "DHLV code construction yields asymptotically good QLDPC codes.\nLifted products of certain classical Tanner codes are the first asymptotically good QLDPC codes.\nQuantum Tanner code construction yields asymptotically good QLDPC codes.", "_type": "ecc", "_page_id": "c_good_qldpc", "_href": "c/good_qldpc"}, "c_generalized_homological_product": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Generalized homological product code", "code_id": "generalized_homological_product", "realizations": "", "short_name": "", "protection": "", "notes": "", "introduced": "", "physical": "", "description": "Stabilizer code formulated in terms a chain complex consisting of some type of product of other chain complexes. The CSS-to-homology correspondence yields an interpretation of codes in terms of manifolds, thus allowing for the use of various products from topology in constructing codes. The codes participating in the product can be quantum, classical, or mixed. Products can be of more than two codes, in which case the output code need not be of CSS type (e.g., for XYZ-product codes). The simplest product is a tensor product, with more general products imposing equivalence or symmetry relations on the outputs of the tensor product. A product of two codes can be interpreted as a fiber bundle, with one element of the product being the base and the other being the fiber. ", "parents_code_id": "qldpc", "parents_detail": "Homological products are a primary tool for generating QLDPC codes with favorable parameters. Typically, whenever the input codes are LDPC or QLDPC, the resulting code will be QLDPC with non geometrically local stabilizer generators.", "parent_of_code_id": "balanced_product\nquantum_tanner\ncheck_product\nramanujan_tensor_product\nxyz_product", "parent_of_detail": "Balanced product codes result from a tensor product of two classical-code chain complexes, followed by a factoring out of certain symmetries.\n\n\nRamanujan codes result from a tensor product of a classical-code and a quantum-code chain complex.\nXYZ product codes result from a tensor product of three classical-code chain complexes.", "cousins_code_id": "css", "cousins_detail": "The notion of homological products arose from interpreting CSS codes in terms of chain complexes over manifolds, but some generalized products no longer yield CSS codes.", "_type": "ecc", "_page_id": "c_generalized_homological_product", "_href": "c/generalized_homological_product"}, "c_balanced_product": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "A notable family of balanced product codes encode \\(k \\in \\Theta(n^{4/5})\\) logical qubits with distance \\(d \\in \\Omega(n^{3/5})\\) for any number of physical qubits \\(n\\). Additionally, it is known that the code constructed from the balanced product of two good classical LDPC codes over groups of order \\(\\Theta(n)\\) has a constant encoding rate [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "BP-OSD decoder [P. Panteleev and G. Kalachev, \u201cDegenerate Quantum LDPC Codes With Good Finite Length Performance\u201d, Quantum 5, 585 (2021). DOI; 1904.02703].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Balanced product code", "code_id": "balanced_product", "realizations": "", "protection": "Taking balanced products of two classical LDPC codes which have a symmetry group which grows linearly in their block lengths were known to give QLDPC codes with a linear rate and which were conjectured to have linear distance [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271]. This conjecture was proved in Ref. [Pavel Panteleev and Gleb Kalachev, \u201cAsymptotically Good Quantum and Locally Testable Classical LDPC Codes\u201d. 2111.03654].", "notes": "", "physical": "", "short_name": "", "introduced": "[N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271]", "description": "Family of CSS quantum codes based on products of two classical codes which share common symmetries. The balanced product can be understood as taking the usual tensor/hypergraph product and then factoring out the symmetries factored. This reduces the overall number of physical qubits \\(n\\), while, under certain circumstances, leaving the number of encoded qubits \\(k\\) and the code distance \\(d\\) invariant. This leads to a more favourable encoding rate \\(k/n\\) and normalized distance \\(d/n\\) compared to the tensor/hypergraph product.", "parents_code_id": "css\ngeneralized_homological_product", "parents_detail": "\nBalanced product codes result from a tensor product of two classical-code chain complexes, followed by a factoring out of certain symmetries.", "parent_of_code_id": "dhlv\nfiber_bundle\nlifted_product", "parent_of_detail": "\nFiber-bundle codes can be formulated in terms of a balanced product [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].\n", "cousins_code_id": "subsystem_stabilizer\ndistance_balanced", "cousins_detail": "Distance balancing is used to form balanced-product subsystem codes [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].\nDistance balancing is used to form balanced-product subsystem codes [N. P. Breuckmann and J. N. Eberhardt, \u201cBalanced Product Quantum Codes\u201d, IEEE Transactions on Information Theory 67, 6653 (2021). DOI; 2012.09271].", "cousin_of_code_id": "lr-cayley-complex", "cousin_of_detail": "Left-right Cayley complexes can be obtained via a balanced product of \\(G\\)-graphs [Irit Dinur et al., \u201cLocally Testable Codes with constant rate, distance, and locality\u201d. 2111.04808].", "_type": "ecc", "_page_id": "c_balanced_product", "_href": "c/balanced_product"}, "c_covariant": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "\\(G\\)-covariant codes defined on a tensor product space consisting of \\(n\\) subsystems are equivalent to codes with a transversal gate set realizing \\(G\\).", "features_fault_tolerance": "", "name": "Covariant code", "code_id": "covariant", "realizations": "", "protection": "Finite-dimensional codes correcting a single-subsystem erasure and admitting a continuous-parameter family of transversal gates (assuming \\(n>1\\)) cannot exist in finite dimensions due to the Eastin-Knill theorem. As a result, there is generally a tradeoff between covariance and error correction.\n\nExact error-correcting \\(G\\)-covariant codes can exist in infinite dimensions, but their codewords are non-normalizable, meaning that approximate constructions have to be considered that are only approximately error correcting. On the other hand, there exist exact error-correcting codes in finite dimensions that are approximately covariant [Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cApproximate symmetries and quantum error correction\u201d. 2111.06355]. Various bounds quantify the covariance-performance tradeoff [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][S. Zhou, Z.-W. Liu, and L. Jiang, \u201cNew perspectives on covariant quantum error correction\u201d, Quantum 5, 521 (2021). DOI; 2005.11918][A. Kubica and R. Demkowicz-Dobrza\u0144ski, \u201cUsing Quantum Metrological Bounds in Quantum Error Correction: A Simple Proof of the Approximate Eastin-Knill Theorem\u201d, Physical Review Letters 126, (2021). DOI; 2004.11893][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cApproximate symmetries and quantum error correction\u201d. 2111.06355].", "notes": "", "physical": "", "short_name": "", "introduced": "[P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471]", "description": "Code constructed in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits) that admits a group \\(G\\) of transversal gates. The group has to be finite for finite-dimensional codes due to the Eastin-Knill theorem. Continuous-\\(G\\) covariant codes, necessarily infinite-dimensional, are relevant to error correction of quantum reference frames [P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471] and error-corrected parameter estimation.\n\nDenoting the code's encoding map as \\(U\\), covariance is equivalent to \\begin{align}\n  \\left(\\bigotimes_{j=1}^{n}V_{j}\\left(g\\right)\\right)U=UV_{L}\\left(g\\right)\\quad\\quad\\forall g\\in G\\,,\n\\end{align} where \\(V_j(g)\\) is a unitary representation of \\(g\\) acting on the \\(j\\) subsystem, and \\(V_L\\) is a unitary representation acting on the unencoded logical information. In this way, covariant encoding maps are equivariant (i.e., commute) with group actions on the logical and physical spaces.\n\nAlmost always, the physical representation is defined to be the transversal one (with respect to some tensor-product decomposition), but can reduce to any representation when the code is a subspace of a larger space that is not expressed as a tensor product (\\(n=1\\)). More generally, a code is sometimes said to be time-covariant if it admits a continuous-parameter \\(U(1)\\) family of gates, not necessarily transversal [Philippe Faist et al., \u201cTime-energy uncertainty relation for noisy quantum metrology\u201d. 2207.13707].", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "w_state\ng_covariant_erasure\nnonabelian_covariant_erasure\nrotor_3_1_2\nrotor_5_1_3", "parent_of_detail": "The W-state code approximately protects against a single erasure while allowing for a universal transversal set of gates.\nIn a proof of principle demonstration, error-correcting codes that are finite-\\(G\\) covariant can be constructed from a base encoding \\(U_0\\).\n\nThe \\([[3,1,2]]_{\\mathbb Z}\\) code is \\(U(1)\\)-covariant.\nThe \\([[5,1,3]]_{\\mathbb Z}\\) code is \\(U(1)\\)-covariant.", "cousins_code_id": "approximate_qecc\nquantum_reed_muller\neth\nquantum_random\ngroup_gkp", "cousins_detail": "Normalizable constructions of infinite-dimensional \\(G\\)-covariant codes for continuous \\(G\\) are approximately error-correcting.\nQuantum RM codes are approximately covariant and nearly saturate certain covariance-performance bounds [Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360].\nETH codes consisting of Dicke states are approximately \\(U(1)\\)-covariant and nearly saturate certain covariance-performance bounds [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][Zi-Wen Liu and Sisi Zhou, \u201cQuantum error correction meets continuous symmetries: fundamental trade-offs and case studies\u201d. 2111.06360].\nRandom \\(U(d)\\)-covariant almost exactly error-correcting codes exist [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714][L. Kong and Z.-W. Liu, \u201cNear-Optimal Covariant Quantum Error-Correcting Codes from Random Unitaries with Symmetries\u201d, PRX Quantum 3, (2022). DOI; 2112.01498].\nGroup-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates that represent the group \\(G\\), and are thus \\(G\\)-covariant [P. Faist et al., \u201cContinuous Symmetries and Approximate Quantum Error Correction\u201d, Physical Review X 10, (2020). DOI; 1902.07714].", "cousin_of_code_id": "metrological", "cousin_of_detail": "Any time-covariant QECC, i.e., a code admitting a continuous-parameter \\(U(1)\\) family of gates, is automatically a metrological code.", "_type": "ecc", "_page_id": "c_covariant", "_href": "c/covariant"}, "c_metopt": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Error-corrected sensing code", "code_id": "metopt", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[R. Demkowicz-Dobrza\u0144ski, J. Czajkowski, and P. Sekatski, \u201cAdaptive Quantum Metrology under General Markovian Noise\u201d, Physical Review X 7, (2017). DOI; 1704.06280][S. Zhou et al., \u201cAchieving the Heisenberg limit in quantum metrology using quantum error correction\u201d, Nature Communications 9, (2018). DOI; 1706.02445]", "description": "Code that can be obtained via an optimization procedure that ensures correction against a set \\(\\cal{E}\\) of errors as well as guaranteeting optimal precision in locally estimating a parameter using a noiseless ancilla. For tensor-product spaces consisting of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits), the procedure can yield a code whose parameter estimation precision satisfies Heisenberg scaling, i.e., scales quadratically with the number \\(n\\) of subsystems.\n\nThe conditions required for a code are that it corrects errors in the set \\(\\cal{E}\\) and admits a continuous-parameter \\(U(1)\\) group of logical gates generated by some signal Hamiltonian \\(H\\) (with the time of evolution by \\(H\\) the parameter that is to be estimated). This means that \\(H\\) cannot itself be a detectable error, i.e., \\(H\\) cannot be expressed as a linear combination of the errors, a condition known as the Hamiltonian-not-in-Kraus-span condition [S. Zhou and L. Jiang, \u201cAsymptotic Theory of Quantum Channel Estimation\u201d, PRX Quantum 2, (2021). DOI; 2003.10559] (alternatively, Hamiltonian-not-in-Lindblad-span for Markovian noise [S. Zhou et al., \u201cAchieving the Heisenberg limit in quantum metrology using quantum error correction\u201d, Nature Communications 9, (2018). DOI; 1706.02445]). If these conditions are satisfied, a semidefinite-program based optimization procedure yields a metrologically optimal code. The procedure has been generalized to more general groups, corresponding to multiparameter estimation [W. G\u00f3recki et al., \u201cOptimal probes and error-correction schemes in multi-parameter quantum metrology\u201d, Quantum 4, 288 (2020). DOI; 1901.00896]. If these conditions are not satisfied, Heisenberg scaling is not achievable, but metrologically optimal codes can still be obtained via another semidefinite-program based optimization procedure [S. Zhou and L. Jiang, \u201cOptimal approximate quantum error correction for quantum metrology\u201d, Physical Review Research 2, (2020). DOI; 1910.08472][S. Zhou and L. Jiang, \u201cAsymptotic Theory of Quantum Channel Estimation\u201d, PRX Quantum 2, (2021). DOI; 2003.10559].\n\nMetrologically optimal QECCs require error-free ancillas for optimal local parameter estimation using an entangling gate. In this sense, such codes can be thought of as being entanglement-assisted. Ancilla-free versions exist in the case when the noise commutes with the signal Hamiltonian [D. Layden et al., \u201cAncilla-Free Quantum Error Correction Codes for Quantum Metrology\u201d, Physical Review Letters 122, (2019). DOI; 1811.01450].", "parents_code_id": "qecc_finite", "parents_detail": "Semidefinite-program optimization procedure for finding a metrologically optimal code holds for finite-dimensional spaces.", "parent_of_code_id": "chebyshev", "parent_of_detail": "", "cousins_code_id": "eaqecc\nhamiltonian", "cousins_detail": "Metrologically optimal codes can be thought of as being entanglement-assisted because they require error-free ancillas for optimal local parameter estimation, and the estimation procedure uses an entangling gate.\nMetrologically optimal codes admit a \\(U(1)\\) set of gates generated by a signal Hamiltonian \\(H\\), meaning that there exists a basis of codewords that are eigenstates of the \\(H\\).", "cousin_of_code_id": "metrological", "cousin_of_detail": "Error-corrected sensing codes are required to satisfy the Knill-Laflamme conditions, while metrological codes need only satisfy the conditions partially.", "_type": "ecc", "_page_id": "c_metopt", "_href": "c/metopt"}, "c_nonabelian_covariant_erasure": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(U(d)\\)-covariant approximate erasure code", "code_id": "nonabelian_covariant_erasure", "realizations": "", "protection": "", "notes": "", "physical": "", "short_name": "", "introduced": "[Y. Yang et al., \u201cOptimal universal quantum error correction via bounded reference frames\u201d, Physical Review Research 4, (2022). DOI; 2007.09154]", "description": "Stub. ", "parents_code_id": "covariant\napproximate_qecc", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_nonabelian_covariant_erasure", "_href": "c/nonabelian_covariant_erasure"}, "c_g_covariant_erasure": {"logical": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "\\(G\\)-covariant erasure code", "code_id": "g_covariant_erasure", "realizations": "", "protection": "Depends on the base encoding \\(U_0\\). ", "notes": "", "physical": "", "short_name": "", "introduced": "[P. Hayden et al., \u201cError Correction of Quantum Reference Frame Information\u201d, PRX Quantum 2, (2021). DOI; 1709.04471]", "description": "A \\(G\\)-covariant code constructed in a physical space consisting of a tensor product of identical subsystems (e.g., qubits, modular qudits, or Galois qudits). The code is a proof-of-principle construction to demonstrate the existence of \\(G\\)-covariant codes where \\(G\\) is a finite group, and the physical space is finite-dimensional.\n\nConsider a finite group \\(G\\) acting on a finite set \\(A\\) as a subgroup of the symmetric group on \\(|A|\\) elements, \\(G \\subset S_{|A|}\\). Let \\(U_0: \\mathsf{H}_{\\text{logical}} \\rightarrow \\mathsf{H}_{\\text{physical}}\n= \\mathsf{H}^{\\otimes n}\\) be any QECC, possibly non-covariant. Define the covariant encoder \\(U \\equiv U_0^{\\otimes |A|}: \\mathsf{H}_{\\text{logical}}^{\\otimes |A|}\n\\rightarrow \\mathsf{H}_{\\text{physical}}^{\\otimes |A|}\\) on \\(|A|\\). Then, the group acts on codewords by index permutation: \\begin{align}\nV(g) | \\phi_{a_1} \\rangle | \\phi_{a_2} \\rangle \\cdots | \\phi_{a_{|A|}} \\rangle = | \\phi_{g^{-1} a_1} \\rangle | \\phi_{g^{-1} a_2} \\rangle \\cdots | \\phi_{g^{-1} a_{|A|}} \\rangle~,\n\\end{align} where \\(V(g)\\) is the unitary representation of \\(g \\in G\\) acting on the physical space. The action of \\(V(g)\\) is transversal with respect to the partition \\(\\mathsf{H}_{\\text{physical}}^{\\otimes |A|}\\).", "parents_code_id": "covariant", "parents_detail": "In a proof of principle demonstration, error-correcting codes that are finite-\\(G\\) covariant can be constructed from a base encoding \\(U_0\\).", "_type": "ecc", "_page_id": "c_g_covariant_erasure", "_href": "c/g_covariant_erasure"}, "c_j_gross": {"logical": "spins", "features_code_capacity_threshold": "", "features_general_gates": "Universal computation results from being able to prepare a single logical state, perform one measurement, and the following logical gates: the phase gate (\\( \\overline{S} \\)), the Hadamard gate (\\(\\overline{H}\\)), the conditional phase gate (\\(\\overline{CZ}\\)), and the square root of the phase gate (\\(\\overline{T}\\)). Single-qubit Cliffords can be generated using \\(\\overline{S}\\) and \\(\\overline{H}\\), the extension to multiple-qubit Cliffords is done using \\(\\overline{CZ}\\), and \\(\\overline{T}\\) is to transform to non-Clifford states. Together these gates can be used to create all logical unitaries, while preparation and measurement complete universal quantum computation.", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Gross spin code", "code_id": "j_gross", "realizations": "", "protection": "", "notes": "", "physical": "spins", "short_name": "", "introduced": "[J. A. Gross, \u201cDesigning Codes around Interactions: The Case of a Spin\u201d, Physical Review Letters 127, (2021). DOI; 2005.10910]", "description": "A spin code designed to realize Clifford gates using \\(SU(2)\\) rotations. Codewords are subspaces of a spin's Hilbert space that house irreducible representations (irreps) of the single-qubit Clifford group (i.e., the binary octahedral (\\(2O\\)) subgroup of \\(SU(2)\\)). This is done by restricting the \\(SU(2)\\) irrep to \\(2O\\), and determining the carrier spaces of any nontrivial irreps of \\(2O\\). Since irreps of \\(2O\\) do not appear in integer spins, half-integer spins are used.\n\nA simple example of a codespace is a projection onto an instance of a particular irrep of \\(2O\\), referred to as either \\( \\varrho_4 \\) or \\( \\varrho_5 \\). In the case of only one instance of the desired irrep present in the spin, the projection is created as follows: \\begin{align}\n  P_\\varrho = \\frac{\\text{dim} \\varrho}{|2O|} \\sum_{g \\in 2O} \\chi_\\varrho (g)^* D(g)~,\n\\end{align} where \\(D(g)\\) is the \\(SU(2)\\) Wigner matrix corresponding to group element \\(g\\), and the character \\(\\chi_\\varrho (g) = \\text{tr}(\\varrho(g))\\) is the trace of the desired irrep evaluated at a group element.\n\nLogical Pauli matrices \\(\\overline{\\sigma}_w\\) are defined using the above projection and the angular momentum operators: \\begin{align}\n  \\overline{\\sigma}_w = i P_\\varrho e^{-i \\pi J_w} P_\\varrho~.\n\\end{align} Finally, \\(|\\overline{0} \\rangle\\) is defined as the \\(+1\\) eigenvalue of \\(\\overline{\\sigma}_z\\) and \\(|\\overline{1} \\rangle = \\overline{\\sigma}_x |\\overline{0} \\rangle \\).", "parents_code_id": "single_spin", "parents_detail": "", "_type": "ecc", "_page_id": "c_j_gross", "_href": "c/j_gross"}, "c_single_spin": {"logical": "spins", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "When the physical Hilbert space is thought of a collective spin, logical gates for spin codes have the form \\(U^{\\otimes N}\\), where \\(U\\) is a local rotation on the physical system.", "features_fault_tolerance": "", "name": "Single-spin code", "code_id": "single_spin", "realizations": "", "protection": "", "notes": "", "physical": "spins", "short_name": "", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2\\ell+1\\)-dimensional Hilbert space, where the latter is thought of as a spin-\\(\\ell\\) quantum system. This spin system can in turn be thought of as the maximally symmetric subspace or collective spin of \\(2\\ell\\) spin-half systems. ", "parents_code_id": "spins_into_spins", "parents_detail": "", "parent_of_code_id": "j_gross\nspin_gkp", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_single_spin", "_href": "c/single_spin"}, "c_spin_gkp": {"logical": "spins", "features_code_capacity_threshold": "", "features_general_gates": "Approximate Clifford-group generators are composed of Hamiltonians at most quadratic in angular momentum operators of two spin systems. Assuming that these generators can be implemented with high fidelity, a magic state can be prepared from an atomic ensemble analog of the vacuum state", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "Linear combination of unitaries method [D. W. Berry et al., \u201cSimulating Hamiltonian Dynamics with a Truncated Taylor Series\u201d, Physical Review Letters 114, (2015). DOI; 1412.4687][G. H. Low and I. L. Chuang, \u201cHamiltonian Simulation by Qubitization\u201d, Quantum 3, 163 (2019). DOI; 1610.06546][Z. Holmes et al., \u201cQuantum algorithms from fluctuation theorems: Thermal-state preparation\u201d, Quantum 6, 825 (2022). DOI; 2203.08882], which may be applicable to more general codewords.", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Spin GKP code", "code_id": "spin_gkp", "realizations": "", "protection": "Protect against errors native to spin systems like random rotations and stochastic relaxation.", "notes": "", "physical": "spins", "short_name": "", "introduced": "[Sivaprasad Omanakuttan and T. J. Volkoff, \u201cSpin squeezed GKP codes for quantum error correction in atomic ensembles\u201d. 2211.05181]", "description": "An analogue of the single-mode GKP code designed for atomic ensembles. Was designed by using the Holstein-Primakoff mapping [T. Holstein and H. Primakoff, \u201cField Dependence of the Intrinsic Domain Magnetization of a Ferromagnet\u201d, Physical Review 58, 1098 (1940). DOI] (see also [C. D. Cushen and R. L. Hudson, \u201cA quantum-mechanical central limit theorem\u201d, Journal of Applied Probability 8, 454 (1971). DOI]) to pull back the phase-space structure of a bosonic system to the compact phase space of a quantum spin. A different construction emerges depending on which particular expression for GKP codewords is pulled back. ", "parents_code_id": "single_spin", "parents_detail": "", "cousins_code_id": "gkp", "cousins_detail": "Spin-GKP code construcions utilize the Holstein-Primakoff mapping [T. Holstein and H. Primakoff, \u201cField Dependence of the Intrinsic Domain Magnetization of a Ferromagnet\u201d, Physical Review 58, 1098 (1940). DOI] (see also [C. D. Cushen and R. L. Hudson, \u201cA quantum-mechanical central limit theorem\u201d, Journal of Applied Probability 8, 454 (1971). DOI]) to convert various expressions for GKP states into codes for spin systems.", "_type": "ecc", "_page_id": "c_spin_gkp", "_href": "c/spin_gkp"}, "c_spins_into_spins": {"logical": "spins", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Spin code", "code_id": "spins_into_spins", "realizations": "", "protection": "Spin codes are often designed to protect against \\(SU(2)\\) rotations by small angles.", "notes": "", "physical": "spins", "short_name": "", "introduced": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, where the canonical qudit basis consists of states of a quantum mechanical spin. In other words, canonical single-qudit states \\(|^\\ell_m\\rangle\\) are labeled by total angular momentum \\(\\ell\\) (either integer or half-integer) and its \\(z\\)-axis projection \\(m\\), with \\(q=2\\ell+1\\).\n\nIn contrast to other qudit codes, spin codes are closely associated with the angular momentum Lie algebra and/or the Lie groups \\(SU(2)\\) or \\(SO(3)\\). ", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "single_spin", "parent_of_detail": "", "cousins_code_id": "qubits_into_qubits", "cousins_detail": "Spin codes with spin \\(\\ell=1/2\\) correspond to qubit codes.", "_type": "ecc", "_page_id": "c_spins_into_spins", "_href": "c/spins_into_spins"}, "c_fermions": {"logical": "fermions", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Fermionic code", "code_id": "fermions", "realizations": "", "protection": "", "notes": "", "physical": "fermions", "short_name": "", "introduced": "", "description": "Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators [S. B. Bravyi and A. Y. Kitaev, \u201cFermionic Quantum Computation\u201d, Annals of Physics 298, 210 (2002). DOI; quant-ph/0003137].", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "majorana_stab", "parent_of_detail": "", "cousins_code_id": "qubits_into_qubits\noscillators", "cousins_detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation [A. Y. Kitaev, \u201cUnpaired Majorana fermions in quantum wires\u201d, Physics-Uspekhi 44, 131 (2001). DOI; cond-mat/0010440], codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations.\nBosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom.", "_type": "ecc", "_page_id": "c_fermions", "_href": "c/fermions"}, "c_majorana_stab": {"logical": "fermions", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Majorana stabilizer code", "code_id": "majorana_stab", "realizations": "", "protection": "Detects products of Majorana operators with weight up to \\(d-1\\). Physically, protects against dephasing errors caused by coupling of fermion density to the environment and bit-flip errors caused by quasiparticle poisoning processes.", "notes": "", "physical": "fermions", "short_name": "", "introduced": "[S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791]", "description": "Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as Majorana stabilizers. The codespace is the mutual \\(+1\\) eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as \\([[n,k,d]]_{f}\\) [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459], where \\(n\\) is the number of fermionic modes.", "parents_code_id": "fermions\nqubit_stabilizer", "parents_detail": "\nThe Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code [A. Kitaev, \u201cAnyons in an exactly solved model and beyond\u201d, Annals of Physics 321, 2 (2006). DOI; cond-mat/0506438][S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791]. However, Pauli- and Majorana-based stabilizer codes have different notions of locality [A. Y. Kitaev, \u201cUnpaired Majorana fermions in quantum wires\u201d, Physics-Uspekhi 44, 131 (2001). DOI; cond-mat/0010440] and are thus useful for different physical platforms.", "cousins_code_id": "dual\ncss\nbinary_cyclic\nreed_muller\nstabilizer", "cousins_detail": "Classical self-orthogonal codes can be used to construct Majorana stabilizer codes [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a self-orthogonal classical code. A self-orthogonal classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\).\nWhen constructing a Majorana stabilizer code from a self-orthogonal classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space [S. Bravyi, B. M. Terhal, and B. Leemhuis, \u201cMajorana fermion codes\u201d, New Journal of Physics 12, 083039 (2010). DOI; 1004.3791][Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different self-orthogonal classical codes with an odd number of bits, as is often done in the CSS construction.\nCyclic binary linear codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also self-orthogonal [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459].\nMajorana stabilizer codes can be constructed by self-orthogonal RM codes [Sagar Vijay and Liang Fu, \u201cQuantum Error Correction for Complex and Majorana Fermion Qubits\u201d. 1703.00459]. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code.\nMajorana stabilizer codes are useful for Majorana-based architectures, where the degrees of freedom are electrons, and the notion of locality is different than all other code kingdoms.", "cousin_of_code_id": "stab_5_1_3\nfloquet\nhoneycomb\nsurface\nhappy\ntfim", "cousin_of_detail": "The five-qubit code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].\nFloquet codes are viable candidates for storage in Majorana-qubit devices [Adam Paetznick et al., \u201cPerformance of planar Floquet codes with Majorana-based qubits\u201d. 2202.11829].\nThe Honeycomb code admits a representation in terms of Majorana fermions. This leads to a possible physical realization of the code in terms of tetrons [T. Karzig et al., \u201cScalable designs for quasiparticle-poisoning-protected topological quantum computation with Majorana zero modes\u201d, Physical Review B 95, (2017). DOI; 1610.05289], where each physical qubit is composed of four Majorana modes.\nThe Majorana mapping can be used to construct efficient algorithms for simulating rounds of error correction for the surface code [S. Bravyi et al., \u201cCorrecting coherent errors with surface codes\u201d, npj Quantum Information 4, (2018). DOI; 1710.02270].\nHaPPY code Hamiltonian can be expressed in terms of mutually commuting two-body Majorana operators [A. Jahn et al., \u201cMajorana dimers and holographic quantum error-correcting codes\u201d, Physical Review Research 1, (2019). DOI; 1905.03268].\nThe TFIM code stabilizers can be expressed in terms of Majorana operators.", "_type": "ecc", "_page_id": "c_majorana_stab", "_href": "c/majorana_stab"}, "c_string_net": {"logical": "categories", "features_code_capacity_threshold": "", "features_general_gates": "Gates can be implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles for triangulations of toroidal [G. Zhu, A. Lavasani, and M. Barkeshli, \u201cUniversal Logical Gates on Topologically Encoded Qubits via Constant-Depth Unitary Circuits\u201d, Physical Review Letters 125, (2020). DOI; 1806.02358][G. Zhu, A. Lavasani, and M. Barkeshli, \u201cInstantaneous braids and Dehn twists in topologically ordered states\u201d, Physical Review B 102, (2020). DOI; 1806.06078] and hyperbolic [A. Lavasani, G. Zhu, and M. Barkeshli, \u201cUniversal logical gates with constant overhead: instantaneous Dehn twists for hyperbolic quantum codes\u201d, Quantum 3, 180 (2019). DOI; 1901.11029] manifolds. Whether or not a gate set is universal depends on the choice of input category; in some cases such as the Ising category, gates can be complemented by topological charge measurements to obtain a universal gate set.\nAlternatively, one could encode the logical quantum information into the degenerate fusion space of a number of computational anyons. In this case, a universal logical gate set can be implemented through the braiding of the computational anyons [Michael Freedman, Michael Larsen, and Zhenghan Wang, \u201cA modular functor which is universal for quantum computation\u201d. quant-ph/0001108][M. H. Freedman, M. J. Larsen, and Z. Wang, \u201cThe Two-Eigenvalue Problem and Density\u00b6of Jones Representation of Braid Groups\u201d, Communications in Mathematical Physics 228, 177 (2002). DOI; math/0103200][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816], e.g., for the case of the Fibonacci input category.", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit [Yu-Jie Liu et al., \u201cMethods for simulating string-net states and anyons on a digital quantum computer\u201d. 2110.02020].", "features_decoders": "Syndrome measurement circuits analyzed in Ref. [N. E. Bonesteel and D. P. DiVincenzo, \u201cQuantum circuits for measuring Levin-Wen operators\u201d, Physical Review B 86, (2012). DOI; 1206.6048].\nClustering decoder [G. Dauphinais and D. Poulin, \u201cFault-Tolerant Quantum Error Correction for non-Abelian Anyons\u201d, Communications in Mathematical Physics 355, 519 (2017). DOI; 1607.02159].", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "String-net code", "code_id": "string_net", "realizations": "", "protection": "Error-correcting properties established in Ref. [Y. Qiu and Z. Wang, \u201cGround subspaces of topological phases of matter as error correcting codes\u201d, Annals of Physics 422, 168318 (2020). DOI; 2004.11982].", "notes": "", "physical": "categories", "short_name": "", "introduced": "[M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816]", "description": "Also called a Turaev-Viro or Levin-Wen model code. A family of topological codes, defined by a finite unitary spherical category \\( \\mathcal{C} \\), whose generators are few-body operators acting on a cell decomposition dual to a triangulation of a two-dimensional surface (with a qudit of dimension \\( |\\mathcal{C}| \\) located at each edge of the decomposition).\n\nThe codespace is the ground-state subspace of the Levin-Wen model Hamiltonian [M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617], a many-body Hamiltonian realizing the 3-manifold Turaev-Viro invariant [R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816][Alexander Kirillov Jr, \u201cString-net model of Turaev-Viro invariants\u201d. 1106.6033]. Alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model [Michael Freedman, Michael Larsen, and Zhenghan Wang, \u201cA modular functor which is universal for quantum computation\u201d. quant-ph/0001108][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816]. The fusion space can have dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes. ", "parents_code_id": "category_quantum\ntopological", "parents_detail": "\nString-net codes can be realized using Levin-Wen model Hamiltonians, which realize various topological phases [M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816][Alexander Kirillov Jr, \u201cString-net model of Turaev-Viro invariants\u201d. 1106.6033].", "parent_of_code_id": "fibonacci", "parent_of_detail": "", "cousin_of_code_id": "surface\nqudit_surface\nquantum_double", "cousin_of_detail": "String-net model reduces to the surface code when the category is the group \\(\\mathbb{Z}_2\\).\nString-net model reduces to the qudit surface code when the category is the group \\(\\mathbb{Z}_q\\).\nString-net model reduces to the quantum-double model for group categories.", "_type": "ecc", "_page_id": "c_string_net", "_href": "c/string_net"}, "c_fibonacci": {"logical": "categories", "features_code_capacity_threshold": "", "features_general_gates": "Universal gate set for the ground-state encoding is implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles. These Dehn-twists can be implemented using constant-dept circuits when allowing long-range permutations of qubits [G. Zhu, A. Lavasani, and M. Barkeshli, \u201cUniversal Logical Gates on Topologically Encoded Qubits via Constant-Depth Unitary Circuits\u201d, Physical Review Letters 125, (2020). DOI; 1806.02358][G. Zhu, A. Lavasani, and M. Barkeshli, \u201cInstantaneous braids and Dehn twists in topologically ordered states\u201d, Physical Review B 102, (2020). DOI; 1806.06078].\nUniversal gate set for the fusion-space encoding is implemented through braiding of the computational anyons [Michael Freedman, Michael Larsen, and Zhenghan Wang, \u201cA modular functor which is universal for quantum computation\u201d. quant-ph/0001108][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816].", "features_threshold": "\\(4.7\\%\\) for depolarizing noise, \\(7.3\\%\\) for dephasing noise, and \\(3.8\\%\\) for bit-flip noise with clustering decoder, assuming perfect measurements and gates [Alexis Schotte et al., \u201cQuantum error correction thresholds for the universal Fibonacci Turaev-Viro code\u201d. 2012.04610]. See also Ref. [S. Burton, C. G. Brell, and S. T. Flammia, \u201cClassical simulation of quantum error correction in a Fibonacci anyon code\u201d, Physical Review A 95, (2017). DOI; 1506.03815].\n\\(3.0\\%\\) for depolarizing noise, \\(6.0\\%\\) for dephasing noise, and \\(2.5\\%\\) for bit-flip noise with fusion-aware iterative MWPM decoder, assuming perfect measurements and gates [Alexis Schotte et al., \u201cQuantum error correction thresholds for the universal Fibonacci Turaev-Viro code\u201d. 2012.04610].", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "Clustering decoder (provides best known threshold for this code) [S. Burton, C. G. Brell, and S. T. Flammia, \u201cClassical simulation of quantum error correction in a Fibonacci anyon code\u201d, Physical Review A 95, (2017). DOI; 1506.03815][G. Dauphinais and D. Poulin, \u201cFault-Tolerant Quantum Error Correction for non-Abelian Anyons\u201d, Communications in Mathematical Physics 355, 519 (2017). DOI; 1607.02159][Alexis Schotte et al., \u201cQuantum error correction thresholds for the universal Fibonacci Turaev-Viro code\u201d. 2012.04610].\nFusion-aware iterative minimum-weight perfect matching decoder. Note that ordinary MWPM decoders do not produce a threshold with this code [Alexis Schotte et al., \u201cQuantum error correction thresholds for the universal Fibonacci Turaev-Viro code\u201d. 2012.04610].", "features_transversal_gates": "A universal transversal gate set could be implemented in a folded version of this code using the techniques introduced in Ref.[G. Zhu, M. Hafezi, and M. Barkeshli, \u201cQuantum origami: Transversal gates for quantum computation and measurement of topological order\u201d, Physical Review Research 2, (2020). DOI; 1711.05752].", "features_fault_tolerance": "", "name": "Fibonacci string-net code", "code_id": "fibonacci", "realizations": "NMR: Implementation of braiding-based Hamamard gate on two qubits [Yu-ang Fan et al., \u201cExperimental realization of a topologically protected Hadamard gate via braiding Fibonacci anyons\u201d. 2210.12145].", "protection": "When defined on a \\(L \\times L\\) tailed honeycomb lattice on a torus, the code distance for ground-state encoding is \\(L\\).", "notes": "", "physical": "categories", "short_name": "", "introduced": "[M. A. Levin and X.-G. Wen, \u201cString-net condensation:\u2003A physical mechanism for topological phases\u201d, Physical Review B 71, (2005). DOI; cond-mat/0404617][R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816]", "description": "Quantum error correcting code associated with the Levin-Wen string-net model with the Fibonacci input category, admitting two types of encodings.\n\nThe first type of encoding is into the ground-state subspace of the Levin-Wen model Hamiltonian, defined on a cell decomposition (dual to a triangulation) of a manifold with a qubit on each link. The code space is the simultaneous \\(+1\\) eigenspace of a set of vertex operators and plaquette operators, which are defined by the fusion rules and the numerical data of the Fibonacci category, respectively. The degeneracy of the code space is \\(4g\\), were \\(g\\) is the genus of the surface on which the cell decomposition is defined.\n\nThe second type of encoding is into the degenerate fusion space of a number of anyonic quasiparticle excitations of the Levin-Wen model. This can equivalently constructed by braiding holes in a spherical geometry [R. Koenig, G. Kuperberg, and B. W. Reichardt, \u201cQuantum computation with Turaev\u2013Viro codes\u201d, Annals of Physics 325, 2707 (2010). DOI; 1002.2816; Sec. 5].", "parents_code_id": "string_net", "parents_detail": "", "_type": "ecc", "_page_id": "c_fibonacci", "_href": "c/fibonacci"}, "c_category_quantum": {"logical": "categories", "features_code_capacity_threshold": "", "features_general_gates": "", "features_threshold": "", "features_rate": "", "features_magic_scaling_exponent": "", "features_encoders": "", "features_decoders": "", "features_transversal_gates": "", "features_fault_tolerance": "", "name": "Category-based quantum code", "code_id": "category_quantum", "realizations": "", "protection": "", "notes": "", "physical": "categories", "short_name": "", "introduced": "", "description": "Encodes a finite-dimensional logical Hilbert space into a physical Hilbert space associated with a category. Often associated with a particular topological quantum field theory (TQFT), as the data of such theories is described by a category.", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "string_net", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_category_quantum", "_href": "c/category_quantum"}}