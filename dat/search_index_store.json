{"c_oaecc": {"name": "Operator-algebra error-correcting code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_oaecc", "_href": "c/oaecc"}, "c_ecc": {"name": "Error-correcting code", "description": "Encodes \\(K\\) states (codewords) over an alphabet with \\(N\\) elements such that it is possible to recover the codewords from errors \\(E\\) from some error set \\(\\mathcal{E}\\). Formally, an error-correcting code \\((u,\\mathcal{E})\\) is an encoder function \\(u:[1\\cdots K]\\to[1\\cdots N]\\) with a set of correctable errors \\(E:[1\\cdots N]\\to [1\\cdots M]\\) with the following property: there exists a decoder function \\(d:[1\\cdots M]\\to [1\\cdots K]\\) such that for all \\(E\\in\\cal{E}\\) and states \\(x\\in[1\\cdots K]\\), \\(d(E(e(x)))=x\\).", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_ecc", "_href": "c/ecc"}, "c_cyclic": {"name": "Cyclic code", "description": "A classical code \\(C\\) of length \\(n\\) over an alphabet is cyclic if, for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\in C\\).", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_cyclic", "_href": "c/cyclic"}, "c_q-ary_digits_into_q-ary_digits": {"name": "\\(q\\)-ary code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) \\(q\\)-ary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)_q\\). The distance is the minimum number of coordinates where two strings in the code differ.", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_q-ary_digits_into_q-ary_digits", "_href": "c/q-ary_digits_into_q-ary_digits"}, "c_q-ary_linear": {"name": "\\(q\\)-ary linear code", "description": "An \\((n,K,d)_q\\) linear code is denoted as \\([n,k,d]_q\\), where \\(k=\\log_{q}K\\) need not be an integer. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any \\(q\\)-ary digits \\(\\alpha,\\beta\\). Often defined in terms of a generator matrix \\(G\\), whose rows form a basis for the subspace. Given a codeword \\(x\\), the corresponding encoded codeword is \\(G^T x\\).", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set such that the difference of any pair of distinct elements of the set is a codeword.", "realizations": "", "notes": "Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\).", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_q-ary_linear", "_href": "c/q-ary_linear"}, "c_dual": {"name": "Dual linear code", "description": "For any \\(q\\)-ary linear code \\(C\\), the dual code\n\\begin{align}\nC^\\perp = \\{ y\\in\\mathbb{Z}_q^{\\times n} ~|~ x\\cdot y=0 \\forall x\\in C\\}~.\n\\end{align}\nA code that contains its dual, \\(C^\\perp \\subseteq C\\), is called weakly self-dual or self-orthogonal. A code that is equal to its dual, \\(C^\\perp = C\\), is called self-dual.", "protection": "The generator matrix of \\(C^\\perp\\) is the parity check matrix of \\(C\\), and visa versa.", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_dual", "_href": "c/dual"}, "c_perfect": {"name": "Perfect code", "description": "An \\((n,K,2t+1)_q\\) \\(q\\)-ary code is perfect if parameters \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the Hamming (a.k.a. sphere-packing) bound\n\\begin{align}\n\\sum_{j=0}^{t}(q-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a binary \\(q=2\\) code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\).\nFor binary codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-H(t/n),\n\\end{align}\nwhere \\(H\\) is the binary entropy function.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_perfect", "_href": "c/perfect"}, "c_skew_cyclic": {"name": "Skew-cyclic code", "description": "A classical code \\(C\\) of length \\(n\\) over \\(GF(q)\\) is skew-cyclic if there exists an automorphism, \\(\\theta\\), of \\(GF(q)\\), such that for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the skew-cyclically shifted string \\(\\theta(c_n) \\theta(c_1) \\cdots \\theta(c_{n-1})\\in C\\). We say that \\(C\\) is a \\(\\theta\\)-cyclic code over \\(GF(q)\\).", "protection": "", "realizations": "Not directly implemented, but BCH codes form a subclass, and are used in DVD, solid state drive storage, etc.", "notes": "Computer algebra software is used to find most codes of this type. Ref.  gives several examples of codes, which have slightly improved minimum distance for some \\((n,k)\\) codes.", "feature_decoders": "Only given for skew-BCH codes, adapted froom standard BCH codes.", "parent_detail": "For every skew-cyclic code there is an equivalent quasi-cyclic code .", "cousin_detail": "", "_type": "ecc", "_page_id": "c_skew_cyclic", "_href": "c/skew_cyclic"}, "c_gabidulin": {"name": "Rank code", "description": "Also called Gabidulin or (matrix) rank-metric code. The code corrects errors over rank metric instead of the traditional Hamming distance. The rank of an \\(n\\)-dimensional vector over \\(GF(q^N)\\) is the maximum number of its linearly independent coordinates.\nGiven \\(X^n\\), an \\(n\\)-dimensional vector space over \\(GF(q^N)\\) where \\(q\\) is a power of a prime number, the rank metric \\(d(x, y)\\) is defined via the rank norm \\(r(x, q) = \\mathrm{rank}(A(x))\\), where\n\\begin{align}\nA(x) = \\begin{pmatrix} a_{11} & a_{12} & \\ldots & a_{1n} \\\\ a_{21} & a_{22} & \\ldots & a_{2n} \\\\  a_{N1} & a_{N2} & \\ldots & a_{Nn} \\end{pmatrix}\n\\end{align}\nand \\(x_i = a_{1i} u_1 + a_{2i} u_2 + \\ldots + a_{Ni}u_N \\) for some fixed basis \\(\\{u_i\\}_{i=1}^N\\).\nIf the vector set \\(\\{x_1, x_2, \\ldots, x_M\\}\\) defines a \\(k\\)-dimensional subspace, then the code is \\([n,k]\\)-linear.", "protection": "Set of vectors \\(\\{x_1, x_2, \\ldots, x_M\\}\\) determines a rank code with distance \\(d=\\min d(x_i, x_j)\\). The code with distance \\(d\\) corrects all errors with rank of the error not greater than \\(\\lfloor (d-1)/2\\rfloor\\).", "realizations": "Useful for error and erasure correction in network coding", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_gabidulin", "_href": "c/gabidulin"}, "c_quasi_cyclic": {"name": "Quasi-cyclic code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_quasi_cyclic", "_href": "c/quasi_cyclic"}, "c_alternant": {"name": "Alternant Codes", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_alternant", "_href": "c/alternant"}, "c_goppa": {"name": "Goppa Code", "description": "Let \\( G(z) \\)  be a polynomial describing a projective plane curve with coefficients from \\( GF(q^m) \\) for some fixed integer \\(m\\). Let \\( L \\) be a finite subset of the extension field \\( GF(q^m) \\)  where \\(q\\) is prime, meaning \\( L  = \\{\\alpha_1, \\cdots, \\alpha_n\\} \\) is a subset of nonzero elements of \\( GF(q^m) \\). A Goppa code \\( \\Gamma(L,G) \\) is an \\([n,k,d]\\) linear code consisting of all vectors \\(a = a_1, \\cdots, a_n\\) such that \\( R_a(z) =0 \\) modulo \\(G(z)\\), where \\( R_a(z) = \\sum_{i=1}^n \\frac{a_i}{z - \\alpha_i} \\).", "protection": "The length \\( n = |L| \\) , dimension \\( k \\geq n-mr \\) where \\( r = \\text{deg} G(z) \\), and the minimum distance \\( d \\geq r +1 \\).", "realizations": "The binary version \\( (q=2) \\) is commonly used in post-quantum cryptosystems such as the McElise cryptosystem .", "notes": "GAP function GoppaCode(G,L) takes in a polynomial \\(G\\) that satisfies the necessary conditions for a Goppa code and a list \\(L\\) that contains elements in \\(GF(q)\\) that are not roots of \\(G\\). It returns a Goppa code.", "feature_rate": "There exist Goppa codes defined over larger alphabets that meet the Gilbert-Varshamov, or GV,  bound.", "feature_decoders": "Algebraic decoding algorithms .\n\nIf \\( \\text{deg} G(z) = 2t \\) , then there exists a \\(t\\)-correcting algebraic decoding algorithm for \\( \\Gamma(L,G) \\).", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_goppa", "_href": "c/goppa"}, "c_maximum_rank_distance": {"name": "Maximum-rank code", "description": "Linear rank-metric code with maximum rank \\([n,k,n-k+1]_q\\) over rank metric. For any vector \\(g=(g_1, \\ldots, g_n)\\) with linearly independent elements \\(g_i\\) over \\(GF(q)\\),\nthe generator matrix\n\\begin{align}\nG = \\begin{pmatrix} g_1^{[0]} & g_2^{[0]} & \\ldots & g_n^{[0]} \\\\ g_1^{[1]} & g_2^{[1]} & \\ldots & g_n^{[1]} \\\\ g_1^{[k-1]} & g_2^{[k-1]} & \\ldots & g_n^{[k-1]} \\end{pmatrix}~,\n\\end{align}\nwhere \\([i]:=q^i\\) and \\(k=n-d+1\\) defines a maximum rank distance code.", "protection": "\\(d\\)-distance codes protect agains all errors of rank not greater \\(\\lfloor (d-1)/2\\rfloor\\)", "realizations": "", "notes": "", "parent_detail": "Linear rank codes with maximum rank.", "cousin_detail": "The construction of the generators matrix of both codes uses a Vandermonde matrix.", "_type": "ecc", "_page_id": "c_maximum_rank_distance", "_href": "c/maximum_rank_distance"}, "c_mds": {"name": "Maximum distance separable (MDS) code", "description": "A \\([n,k,d]_q\\) \\(q\\)-ary linear code is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Singleton bound\n\\begin{align}\nd \\leq n-k+1\n\\end{align}\nbecomes an equality. A bound for general \\(q\\)-ary codes can also be formulated; see Thm. 1.9.10 in Ref. .", "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error correction properties.", "realizations": "", "notes": "The dual of an MDS codes is always MDS.\n\nThe codes \\( [[n,1,n]]_q, [[n,n-1,2]]_q, [[n,n,1]]_q \\) for any \\(q\\) are MDS codes. These are called the trivial MDS codes.\n\nThe only binary MDS codes are the trivial ones.", "parent_detail": "", "cousin_detail": "Every Reed Solomon code is MDS. If \\(k \\leq p\\) then all MDS codes \\( [n,k,n-k+1]_{p^m} \\) are Reed-Solomon codes .", "_type": "ecc", "_page_id": "c_mds", "_href": "c/mds"}, "c_reed_solomon": {"name": "Reed-Solomon code", "description": "\\([n,k,n-k+1]_q\\) linear code based on polynomials over \\(GF(q)\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(GF(q)\\) for prime \\(q>n\\). Encodes \\(\\mu=\\{\\mu_0,\\cdots,\\mu_{k-1}\\}\\) into \\(\\{f_\\mu(\\alpha_1),\\cdots,f_\\mu(\\alpha_n)\\}\\) with polynomial \\(f_\\mu(x)=\\mu_0+\\mu_1 x + \\cdots + \\mu_{k-1}x^{k-1}\\).", "protection": "Corrects erasures on \\(n-k\\) coordinates.", "realizations": "Numerous applications: computer hard-disks, DVDs, 3G telephone networks (IS-2000, Release D), NASA deep-space exploration, etc.", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_reed_solomon", "_href": "c/reed_solomon"}, "c_classical_abelian_group": {"name": "Classical Abelian group Code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_classical_abelian_group", "_href": "c/classical_abelian_group"}, "c_generalized_concatenated": {"name": "Generalized concatenated classical code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_generalized_concatenated", "_href": "c/generalized_concatenated"}, "c_single_parity_check": {"name": "Single parity-check code", "description": "An \\([n,n-1,2]\\) binary linear error-detecting code encoding an \\(n\\)-bit codeword into an \\((n+1)\\)-bit string. In this code, parity information of a codeword is sotred in an extra parity bit. If the Hamming weight of a codeword is odd, then its parity is 1. If the Hamming weight of a codeword is even, then its parity is 0. This code is inexpensive since it only requires an extra parity bit and a single parity check.", "protection": "This code cannot protect information, it can only detect 1-bit error.", "realizations": "Can be realized on almost every communication device.", "notes": "", "feature_rate": "The code rate is \\(\\frac{n}{n+1}\\to 1\\) as \\(n\\to\\infty\\). The code distance is 2.", "feature_encoders": "Concatenate the codeword with a parity bit which encodes the parity information of codeword.", "feature_decoders": "If the receiver finds that the parity information of a codeword disagrees with the parity bit, then the receiver will discard the information and request a resend.", "parent_detail": "", "cousin_detail": "Repetition code is dual to the single-parity check code.", "_type": "ecc", "_page_id": "c_single_parity_check", "_href": "c/single_parity_check"}, "c_tanner": {"name": "Tanner code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_tanner", "_href": "c/tanner"}, "c_polar": {"name": "Polar code", "description": "In its basic version, a binary linear polar code encodes \\(K\\) message bits into \\(N=2^n\\) bits. The linear transformation that defines the code is given by the matrix \\(G^{(n)}=B_N G^{\\otimes n}\\), where \\(B_N\\) is a certain \\(N\\times N\\) permutation matrix, and \\(G^{\\otimes n}\\) is the \\(n\\)th Kronecker power of the \\(2\\times 2\\) kernel matrix \\(G=\\left[\\begin{smallmatrix}1 & 0\\\\ 1 & 1 \\end{smallmatrix}\\right]\\). To encode \\(K\\) message bits, one forms an \\(N\\)-vector \\(u\\) in which \\(K\\) coordinates represent the message bits. The remaining \\(N-K\\) coordinates are set to some fixed values and are said to be frozen. The codeword \\(x \\in \\{0,1\\}^N\\) is obtained as \\(x=u G^{\\otimes n}\\). The choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.", "protection": "Protects against various types of noise in the communication channel, for instance, errors, erasures, or other types of noise. Distance plays no role in the analysis of its properties, and is much lower than the largest possible value given \\(K,N\\).", "realizations": "Code control channels for the 5G NR (New Radio) interfaces.", "notes": "There are multiple variants of the basic construction, in particular relying on other kernel matrices. The codes can be defined for nonbinary alphabets, and they can be adjusted to support tasks such as lossless and lossy compression, successive refinement, communication over the mulitple access channel, communication over the wiretap channel, and many others.\n\nDescribed in Ch. 32 of Ref. .", "feature_rate": "Supports reliable transmission at rates \\(K/N\\) approaching the Shannon capacity of the channel.", "feature_decoders": "Successive cancellation decoder .\n\nSuccessive cancellation list decoder .", "feature_threshold": "Achieves Shannon capacity of the binary-input memoryless channel under successive cancellation decoder .", "parent_detail": "", "cousin_detail": "Reed-Muller code relies on the same generator matrix, but places message bits in different coordinates.\n\nPolar codes can be represented as generalized concatenations of their kernels.", "_type": "ecc", "_page_id": "c_polar", "_href": "c/polar"}, "c_repetition": {"name": "Binary repetition code", "description": "\\([n,1,n]\\) binary linear code encoding one bit of information into an \\(n\\)-bit string. The length \\(n\\) needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a \\((n,1)\\)-Hamming code.", "protection": "Detects errors on up to \\(\\frac{n-1}{2}\\) coordinates, corrects erasure errors on up to \\(\\frac{n-1}{2}\\) coordinates. The generator matrix is \\(G=\\left[\\begin{smallmatrix}1 & 1&\\cdots& 1 & 1 \\end{smallmatrix}\\right]\\).", "realizations": "Repetition codes were used in magnetic disks.\n\nAlthough classical repetition code does not have many real-world applications, it still inspire the studies of quantum error correction. Quantum repetition code is widely studied in quantum computing community.", "notes": "", "feature_rate": "Code rate is \\(\\frac{1}{n}\\), code distance is \\(n\\).", "feature_decoders": "Calculate the Hamming weight \\(d_H\\) of the code. If \\(d_H\\leq \\frac{n-1}{2}\\), decode the code as 0. If \\(d_H\\geq \\frac{n+1}{2}\\), decode the code as 1.", "feature_threshold": "Suppose each bit has probability \\(p\\) of being received correctly, independent for each bit. The probability that a repetition code is received correctly is \\(\\sum_{k=0}^{(n-1)/2}\\frac{n!}{k!(n-k)!}p^{n-k}(1-p)^{k}\\). If \\(\\frac{1}{2}\\leq p\\), then people can always increase the probability of success by increasing the number of physical bit \\(n\\).", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_repetition", "_href": "c/repetition"}, "c_binary_linear": {"name": "Binary linear code", "description": "An \\((n,2^k,d)\\) linear code is denoted as \\([n,k,d]\\). Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword. Often defined in terms of a generator matrix \\(G\\), whose rows form a basis for the subspace. Given a codeword \\(x\\), the corresponding encoded codeword is \\(G^T x\\).", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set for which no two elements of the set add up to a codeword.", "realizations": "", "notes": "Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\).", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_binary_linear", "_href": "c/binary_linear"}, "c_parity_check": {"name": "Parity-check code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_parity_check", "_href": "c/parity_check"}, "c_ldpc": {"name": "Low-density parity-check (LDPC) code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_ldpc", "_href": "c/ldpc"}, "c_bch": {"name": "Bose\u2013Chaudhuri\u2013Hocquenghem (BCH) code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "\n\n", "_type": "ecc", "_page_id": "c_bch", "_href": "c/bch"}, "c_reed_muller": {"name": "Reed-Muller code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_reed_muller", "_href": "c/reed_muller"}, "c_expander": {"name": "Expander code", "description": "Expander codes are binary linear codes whose parity check matrices are derived from the adjacency matrix of bipartite expander graphs. In particular, the rows of the parity check matrix correspond to the right nodes of the bipartite graph and the columns correspond to the left nodes. The codespace is equivalent to all subsets of the left nodes in the graph that have an even number of edges going into every right node of the graph. Since the expander graph is only left regular, these codes do not qualify as LDPC codes.\nExpander codes are important because they admit efficient encoding and decoding algorithms and have the desirable property that their rate and relative distance are constant. The rate and distance of the expander code depend on specific parameters of the corresponding graph. A (\\(n, m, D, \\gamma, \\alpha\\)) bipartite expander graph is defined as a \\(D\\)-left-regular graph with \\(n\\) left nodes, and \\(m\\) right nodes such that for any subset of left nodes \\(S\\) of size at most \\(\\gamma n\\) the neighborhood \\(N(S)\\) is at least of size \\(\\alpha|S|\\). Given a (\\(n, m, D, \\gamma, (1-\\epsilon)D\\)) expander graph, the corresponding expander code has rate of \\(1 - m/n\\) and a distance of at least \\(2(1-\\epsilon)\\gamma n\\) for any \\(\\epsilon < 1/2\\). Explicit constructions for expander graphs with any ratio \\(n/m\\) are known where \\(D = \\text{polylog}(n/m)\\), \\(\\gamma = \\Omega(1/D)\\) and arbitrary \\(\\epsilon\\) .", "protection": "Bit flip errors of weight at most \\((d-1)/2\\) where \\(d\\) is the distance of the code and is linear in \\(n\\), the number of physical bits.", "realizations": "", "notes": "", "feature_rate": "The rate is \\(1 - m/n\\) where \\(n\\) is the number of left nodes and \\(m\\) is the number of right nodes in the bipartite expander graph.", "feature_encoders": "Multiplication by generator matrix with runtime \\(O(n^2)\\)", "feature_decoders": "Decoding can be done in \\(O(n)\\) runtime using a greedy algorithm. The algorithm consists of flipping a bit of the received word if it will result in a greater number of satisfied parity checks. This is repeated until a codeword is reached.", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_expander", "_href": "c/expander"}, "c_bits_into_bits": {"name": "Binary code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) binary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)\\). The distance is the minimum Hamming distance between a pair of distinct codewords.", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_bits_into_bits", "_href": "c/bits_into_bits"}, "c_oecc": {"name": "Operator quantum error-correcting code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_oecc", "_href": "c/oecc"}, "c_qecc_finite": {"name": "Finite-dimensional quantum code", "description": "A quantum error-correcting code that encodes quantum information in a \\(K\\)-dimensional (logical) subspace \\(\\mathsf{H}_K\\) of an \\(N\\)-dimensional (physical) Hilbert space \\(\\mathsf{H}_N\\) such that it is possible to recover said information from errors. Formally, a finite-dimensional quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{K}\\to\\mathsf{H}_{N}\\) with a set of correctable errors \\({\\cal{E}}:\\mathsf{H}_N\\to\\mathsf{H}_M\\) with the following property: there exists a quantum operation \\({\\cal{D}}:\\mathsf{H}_M\\to \\mathsf{H}_K\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{K}\\), \\({\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\) for some constant \\(c\\).", "protection": "Correction capability is determined by the Knill-Laflamme error correction criteria . A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an approximate code.", "realizations": "", "notes": "", "feature_general_gates": "Universal gate set cannot be transversal due to Eastin-Knill theorem .", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_qecc_finite", "_href": "c/qecc_finite"}, "c_qecc": {"name": "Quantum error-correcting code (QECC)", "description": "Encodes quantum information in a (logical) subspace of a (physical) Hilbert space such that it is possible to recover said information from errors that act as linear maps on the physical space. The logical subspace is spanned by a basis comprised of code basis states or codewords. More formally, denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{\\text{logical}}\\to\\mathsf{H}_{\\text{physical}}\\) with a set of correctable errors \\(\\cal{E}\\) with the following property: there exists a quantum operation \\(\\cal{D}\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{\\text{logical}}\\), \\({\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\) for some constant \\(c\\). Ideal code states \\(|\\psi\\rangle\\) may not be normalizable if the physical Hilbert space in infinite, so approximate versions have to be constructed.", "protection": "Correction capability is determined by of the Knill-Laflamme error-correction criteria , which may admit infinite terms due to non-normalizability of ideal code states. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an approximate code.", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_qecc", "_href": "c/qecc"}, "c_quantum_convolutional": {"name": "Quantum convolutional code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_quantum_convolutional", "_href": "c/quantum_convolutional"}, "c_color": {"name": "Color code", "description": "Color code is a topological stabilizer code defined on a \\(D\\)-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial \\(D\\)-complex obtained as a triangulation of the interior of a \\(D\\)-simplex and (2) is \\(D+1\\)-colorable. Qubits are placed on the \\(D\\)-simplices and generators are supported on suitable simplices . For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face .", "protection": "As with the surface code, the code distance depends on the specific kind of lattice used to define the code. More precisely, the distance depends on the homology of logical string operators .", "realizations": "", "notes": "", "feature_transversal_gates": "Transversal CNOT can be implemented via braiding . Universal transversal gates can be achieved in 3D color code using gauge fixing , lattice surgery , or code deformation .", "feature_general_gates": "Magic-state distillation protocols .\n\nNon-clifford gates can be implemented via code switching .", "feature_decoders": "Projection decoder .\n\nMatching decoder gives low logical failure rate .\n\nInteger-program-based decoder .\n\nRestriction decoder .", "feature_fault_tolerance": "Syndrome measurement .\n\nSteane's ancilla-coupled measurement method", "feature_threshold": "\\(\\geq 6.25\\%\\) threshold for 2d color codes with error-free syndrome extraction, and \\(0.1\\%\\) with faulty syndrome extraction .\n\n\\(0.46\\%\\) for 3d codes with clustering decoder .\n\n\\(1.9\\%\\) for 1D string-like logical operators and \\(27.6\\%\\) for 2D sheet-like operators for 3D codes with noise models using optimal decoding and perfect measurements .\n\n\\(0.31\\%\\) noise threshold error rate for gauge code using clustering decoder .\n\n\\(0.143\\%\\) with depolarising circuit-level noise using perfect-matching decoder .\n\n\\(>0\\%\\) threshold with sweep decoder .", "parent_detail": "\n\nDefined on a lattice with geometrically local stabilizer generators .", "cousin_detail": "Stabilizer generator weights and qubit degrees are given by the properties of the tessellation, and most tesselations yield QLDPC codes.\n\nColor code is equivalent to surface code in several ways . For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D\\)-dimensional surface code.", "_type": "ecc", "_page_id": "c_color", "_href": "c/color"}, "c_ramanujan_tensor_product": {"name": "Ramanujan tensor-product code", "description": "Constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.", "protection": "Without distance balancing, a Ramanujan code can have \\(d_X =\\Omega(\\log n)\\) and \\(d_Z = \\Omega (n)\\). For 2D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}\\). For 3D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d= \\Omega(n^{1/2}\\log n )\\).", "realizations": "", "notes": "Codes were first to break a 20-year record set by the Freedman-Meyer-Lou code for the lower bound on scaling of the minimum distance .", "feature_rate": "For 2D Ramanujan complexes, the rate is \\(\\Omega(\\sqrt{ \\frac{1}{n \\log n} })\\), with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}) \\). For 3D, the rate is \\( \\Omega(\\frac{1}{\\sqrt{n}\\log n}) \\) with minimum distance \\(d \\geq \\sqrt{n} \\log n \\).", "feature_decoders": "For 2D simplicial complexes, cycle code decoder admitting a polynomial-time decoding algorithm can be used .", "parent_detail": "Code is constructed using product of complexes .\n\n\\(Z\\)- and \\(X\\)- row and column weights are bounded from above by the weights of the two codes that are used in the construction of this code .", "cousin_detail": "Ramanujan tensor-product constructions use distance balancing to increase distance.", "_type": "ecc", "_page_id": "c_ramanujan_tensor_product", "_href": "c/ramanujan_tensor_product"}, "c_stab_4_2_2": {"name": "\\([[4,2,2]]\\) CSS code", "description": "Four-qubit CSS stabilizer code with generators \\(\\{XXXX, ZZZZ\\} \\) and codewords \\begin{align} \\begin{split} |\\overline{00}\\rangle = (|0000\\rangle + |1111\\rangle)/\\sqrt{2}\\\\ |\\overline{01}\\rangle = (|0011\\rangle + |1100\\rangle)/\\sqrt{2}\\\\ |\\overline{10}\\rangle = (|0101\\rangle + |1010\\rangle)/\\sqrt{2}\\\\ |\\overline{11}\\rangle = (|0110\\rangle + |1001\\rangle)/\\sqrt{2} \\end{split}.\\end{align} Its subcode is the \\([[4,1,2]]\\) code, whose \\(\\pm\\)-basis codewords can be written as \\begin{align} |\\overline{\\pm}\\rangle = \\frac{1}{2}(|00\\rangle \\pm |11\\rangle)^{\\otimes 2}\\\\\\end{align} This code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code.", "protection": "Detects a single-qubit error  or single erasure . Not able to correct arbitrary single-qubit errors because \\( \\lfloor \\frac{d-1}{2} \\rfloor =0 \\). Approximately corrects a single amplitude damping error .", "realizations": "Realized in trapped-ion quantum devices .", "notes": "Concatenating \\([[4,2,2]]\\) code with surface code can generate 2D topological code with a reasonable circuit-based threshold .", "feature_transversal_gates": "Transversal Pauli, Hadamard, and two-qubit \\(R\\) gates .", "feature_fault_tolerance": "Preparation of certain states along with transversal gates can be performed fault-tolerantly, but requires post-selection because the code cannot correct errors .", "parent_detail": "\\([[4,1,2]]\\) subcode is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "cousin_detail": "\\([[4,2,2]]\\) code is the smallest toric code.\n\n\\([[4,2,2]]\\) can be derived from \\([[5,1,3]]\\) code using a protocal that converts \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman .\n\n\\([[4,2,2]]\\) code is a small quantum polar code .\n\n\\([[4,2,2]]\\) code approximately corrects a single amplitude damping error .", "_type": "ecc", "_page_id": "c_stab_4_2_2", "_href": "c/stab_4_2_2"}, "c_fiber_bundle": {"name": "Fiber-bundle code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_fiber_bundle", "_href": "c/fiber_bundle"}, "c_stabilizer": {"name": "Stabilizer code", "description": "An \\(((n,2^k,d))\\) stabilizer code is denoted as \\([[n,k]]\\) or \\([[n,k,d]]\\), where \\(d\\) is the code's distance. Logical subspace is the joint \\(+1\\) eigenspace of a set of \\(2^{n-k}\\) commuting Pauli operators \\(S\\) forming the code's stabilizer group \\(\\mathsf{S}\\), which cannot contain \\(-I\\). The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation on the code.", "protection": "Detects errors on up to \\(d-1\\) qubits, and corrects erasure errors on up to \\(d-1\\) qubits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{\\hat{N}(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "realizations": "", "notes": "", "feature_encoders": "Dissipative preparation, for which codespace is steady-state space of a Lindbladian .", "parent_detail": "If the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code.", "cousin_detail": "Qubit stabilizer codes are quantum analogues of binary linear codes.\n\nCodespace is the ground-state space of the code Hamiltonian, consisting of an equal linear combination of stabilizer generators.", "_type": "ecc", "_page_id": "c_stabilizer", "_href": "c/stabilizer"}, "c_gauge_stabilizer": {"name": "Gauge stabilizer code", "description": "Also called a subsystem stabilizer code. A stabilizer code with some of its logical qubits denoted as gauge qubits and not used for storage of logical information. Note that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by \\([[n,k,r,d]]\\), similar to stabilizer codes, but with an extra parameter \\(r\\) denoting the number of gauge qubits.\nTo create these codes proceed as follows. Choose \\(2n\\) operators \\(\\{ \\tilde{X}_j,\\tilde{Z}_j\\}_{j=1}^n\\) from \\(\\mathsf{P}_n\\), the Pauli group on \\(n\\) qubits, such that they obey the same commutation relations as the regular \\(n\\)-qubit Pauli generators \\( \\{X_j,Z_j\\}_{j=1}^n \\) (the subscript on these latter operators indicates the single qubit the Pauli matrix acts on). The tilde operators might act on more than one physical (or bare) qubit but they behave as if they acted only on a single qubit. WLOG we can choose a stabilizer group as \\( \\mathsf{S} = \\langle Z_1,\\dots,Z_s \\rangle \\). It follows that the normalizer of \\(\\mathsf{S} \\) is \\( N(\\mathsf{S}) = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_n, \\tilde{X}_{s+1},\\dots, \\tilde{X}_n \\rangle \\). We now choose a gauge group as \\( \\mathsf{G} = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_s, \\tilde{X}_{s+1}, \\tilde{Z}_{s+1}, \\dots, \\tilde{X}_{s+r}, \\tilde{Z}_{s+r} \\rangle \\) with \\( s + r \\leq n \\). The logical group is choosen as \\( \\mathsf{L} = N(\\mathsf{S})/\\mathsf{G} \\simeq \\langle \\tilde{X}_{s+r+1},\\tilde{Z}_{s+r+1}, \\dots, \\tilde{X}_n,\\tilde{Z}_n \\rangle \\). Now the codespace \\( C \\) is as usual the \\(+1\\) eigenspace of the stabilizer \\( \\mathsf{S} \\). But the gauge and logical groups have further decomposed this space into \\( C = A \\otimes B \\simeq (\\mathbb{C}^2)^{\\otimes k} \\otimes (\\mathbb{C}^2)^{\\otimes r} \\). Thus the Hilbert space is partitioned into 3 sets; \\(k\\) logical qubits, \\(r\\) gauge qubits, and \\(s\\) stabilizer qubits, with \\(s+r+k=n\\).", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. More generally, a set of errors \\( \\{ E_a \\} \\) is correctable iff \\( E_aE_b \\not\\in N(\\mathsf{S}) \\setminus \\mathsf{G} \\) for all pairs \\(a,b\\). The distance of the code is the minimal weight of operators in \\( N(\\mathsf{S}) \\setminus \\mathsf{G}\\).", "realizations": "", "notes": "When the gauge group \\( \\mathsf{G} \\) is abelian, the above is reduced to the standard stabilizer formalism.", "parent_detail": "", "cousin_detail": "Gauge stabilizer codes reduce to stabilizer codes when there are no gauge qubits.", "_type": "ecc", "_page_id": "c_gauge_stabilizer", "_href": "c/gauge_stabilizer"}, "c_t-designs": {"name": "Local Haar-random circuit code", "description": "An \\(n\\)-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal \\(n\\)-qubit states and acting with a random unitary circuit of depth polynomial in \\(n\\). Two states are locally indistinguishable if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about \\(n/2\\) two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries.\nThe above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (\\(D=1\\), while codes for higher-dimensional geometries require \\(O(n^{1/D})\\)-depth circuits . Follow-up work  revealed that optimal code properties require only \\(O(\\sqrt{n})\\)-depth circuits for that case, and \\(O(\\sqrt{n})\\)-depth circuits for a two-dimensional square-lattice geometry.", "protection": "In a 1D geometry, the code approximately detects any error with support on a segment of length \\(\\leq n/4\\), with deviations exponentially suppressed in \\(n\\).", "realizations": "", "notes": "", "feature_encoders": "Random local circuit of depth proportional to \\(n^{\\alpha}\\), with \\(\\alpha\\) depending on system geometry.", "parent_detail": "", "cousin_detail": "Local Haar-random codewords, like topological codewords, are locally indistinguishable .\n\n", "_type": "ecc", "_page_id": "c_t-designs", "_href": "c/t-designs"}, "c_qubits_into_qubits": {"name": "Qubit code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2^n\\)-dimensional (i.e., \\(n\\)-qubit) Hilbert space. Usually denoted as \\(((n,K))\\) or \\(((n,K,d))\\), where \\(d\\) is the code's distance.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_qubits_into_qubits", "_href": "c/qubits_into_qubits"}, "c_xzzx": {"name": "XZZX surface code", "description": "A family of stabilizer codes whose generators are \\(XZXZ\\) Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "realizations": "", "notes": "Originally formulated as an example of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model .", "feature_threshold": "\\(50\\%\\) with pure \\(X\\) or \\(Z\\) errors and both a maximum-likelihood decoder and a minimum-weight perfect-matching decoder.\n\n\\(18.7\\%\\) at standard depolarising noise with a maximum-likelihood decoder.\n\nFor large but finite \\(X\\)- or \\(Z\\)-biased noise, the code's thresholds exceed the zero-rate hashing bound.\nThe gap exceeds \\(2.9\\%\\) when \\(X\\) (\\(Z\\)) error is \\(300\\) times more frequent than other Paulis.", "parent_detail": "\\(XZZX\\) code is obtained from the surface code by Hadamard gates.", "cousin_detail": "Subsystem symmetries play a role in finite-bias decoders for both codes.", "_type": "ecc", "_page_id": "c_xzzx", "_href": "c/xzzx"}, "c_quantum_reed_muller": {"name": "Quantum Reed-Muller code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "feature_fault_tolerance": "Gate switching protocol for universal computation .", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_quantum_reed_muller", "_href": "c/quantum_reed_muller"}, "c_movassagh_ouyang": {"name": "Movassagh-Ouyang Hamiltonian code", "description": "This is a family of codes derived via an algorithm that takes as input any binary classical code and outputs a quantum code (note that this framework can be extended to \\(q\\)-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.\nThis family strictly generalizes CSS codes (because CSS codes come only from linear or self orthogonal classical codes). These codes can be shown to be realized as a subspace of the ground space of a (geometrically) local Hamiltonian.", "protection": "Let \\(C \\subset \\{0,1,\\dots,q-1\\}^n\\) be a classical code with distance \\(d_x\\). Let \\(d_z\\) satisfy \\(q^n > 2 V_q(d_z-1) -1\\), where \\(V_q(r)\\) is the volume of the \\(q\\)-ary Hamming ball of radius \\(r\\). Then the algorithm produces a quantum code with distance \\(d = \\text{min}(d_x,d_z)\\). Asymptotically, the distance scales linearly with \\(n\\).", "realizations": "", "notes": "", "feature_rate": "The rate depends on the classical code, but distance can scale linearly with \\(n\\).", "parent_detail": "Movassagh-Ouyang codes reside in the ground space of a local Hamiltonian.", "cousin_detail": "Movassagh-Ouyang codes overlap the CWS (code-word stabilized) codes but neither family is contained in the other.\n\nMany, but not all, Movassagh-Ouyang codes are stabilizer codes.\n\nMovassagh-Ouyang codes are constructed from classical binary codes.", "_type": "ecc", "_page_id": "c_movassagh_ouyang", "_href": "c/movassagh_ouyang"}, "c_bacon_shor": {"name": "Bacon-Shor code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_bacon_shor", "_href": "c/bacon_shor"}, "c_real_projective_plane": {"name": "Projective-plane surface code", "description": "A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold \\(\\mathbb{R}P^2\\) (in contrast to a genus-\\(g\\) surface). Whereas genus-\\(g\\) surface codes require \\(2g\\) logical qubits, qubit codes on \\(\\mathbb{R}P^2\\) are made from a single logical qubit.", "protection": "If \\(\\mathcal{C}\\) is a cellulation of \\(\\mathbb{R}P^2\\), then the bit-flip distance \\(d_X\\) is the shortest cycle in \\(\\mathcal{C}\\), and the phase-flip distance \\(d_Z\\) is the shortest cycle in the dual cellulation \\(\\mathcal{C}^*\\).", "realizations": "", "notes": "", "feature_rate": "The rate is \\(1/n\\), where \\(n\\) is the number of edges of the particular cellulation.", "parent_detail": "Surface code on the real projective plane.", "cousin_detail": "", "_type": "ecc", "_page_id": "c_real_projective_plane", "_href": "c/real_projective_plane"}, "c_quantum_hamming": {"name": "\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming code", "description": "A family of stabilizer codes of distance \\(3\\) that asymptotically saturate quantum Hamming bound.", "protection": "Protects against any single qubit error.", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "Quantum Hamming codes saturate the asymptotic Hamming bound.", "_type": "ecc", "_page_id": "c_quantum_hamming", "_href": "c/quantum_hamming"}, "c_quantum_expander": {"name": "Quantum expander code", "description": "CSS codes constructed from bipartite expander graphs with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as \\(X\\) checks, and the parity check matrix of the other as \\(Z\\) checks.", "protection": "Pauli errors of weight \\(\\leq t\\), distance scales as \\(\\Omega(n^{1/2})\\).", "realizations": "", "notes": "", "feature_rate": "\\([[n,k=\\Theta(n),d=O(\\sqrt{n})]]\\) code with asymptotically constant rate.", "feature_decoders": "Ref.  details a linear time decoder, which corrects \\(\\Omega(n^{1/2})\\) adversarial errors.", "feature_threshold": "Current estimate of \\(2.7 \\cdot 10^{-16}\\) in locally stochastic noise model .", "parent_detail": "", "cousin_detail": "Quantum expander codes are constructed from classical expander codes.", "_type": "ecc", "_page_id": "c_quantum_expander", "_href": "c/quantum_expander"}, "c_stab_5_1_3": {"name": "\\([[5,1,3]]\\) code", "description": "Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, \\begin{align} \\begin{split} S_1 &= IXZZX \\\\ S_2 &= XZZXI \\\\ S_3 &= ZZXIX \\\\ S_4 &= ZXIXZ. \\end{split}\\end{align}", "protection": "Smallest stabilizer code that protects against a single error on any one qubit. Detects two-qubit errors.", "realizations": "First realized in NMR .\n\nDemonstration with superconducting qubits .", "notes": "", "feature_transversal_gates": "Pauli gates are transversal.", "parent_detail": "\\([[5,1,3]]\\) code is the smallest stabilizer code to correct a single qubit error.", "cousin_detail": "The smallest perfect code.\n\n\\([[5,1,3]]\\) code is the smallest known example of quantum cyclic code .\n\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of Majorana operators .\n\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of Majorana operators .", "_type": "ecc", "_page_id": "c_stab_5_1_3", "_href": "c/stab_5_1_3"}, "c_freedman_meyer_lou": {"name": "Freedman-Meyer-Lou code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_freedman_meyer_lou", "_href": "c/freedman_meyer_lou"}, "c_surface": {"name": "Kitaev surface code", "description": "A family of CSS stabilizer codes whose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a cellulation of a two-dimensional surface (with a qubit located at each edge of the cellulation). Toric code often either refers to the construction on the two-dimensional torus or is an alternative name for the general construction. The construction on surfaces with boundaries is often called the planar code .", "protection": "When defined on an \\(L\\times L\\) square tiling of the torus, protects against \\(L\\) errors. More generally, the code distance is related to the homology of the cellulation .", "realizations": "Distance-two surface codes have been implemented by Andersen et al. , Erhard et al. , and Google Quantum AI .\n\nSignatures of corresponding topological phase of matter detected in superconducting circuits  and two-dimensional arrays of Rydberg atoms .\n\nDistance-three surface code implemented at ETH Zurich .", "notes": "2D and 3D surface code visualization tool.\n\nToric code introductions from error-correction perspective by J. Haah and condensed-matter perspective by M. Levin and C. Nayak.", "feature_transversal_gates": "Pauli gates on torus geometry.", "feature_general_gates": "Clifford gates can be implemented via lattice surgery  or braiding defects .\n\nNon-Clifford gates require magic state distillation  or just-in-time decoding .", "feature_threshold": "\\(10.9\\%\\) with independent \\(X/Z\\) errors for square tiling .\n\n\\(18.9\\%\\) with depolarizing noise for square tiling .\n\n\\(50\\%\\) with loss errors for square tiling .\n\n\\(3.3\\%\\) with phenomenological noise for square tiling .\n\n\\(0.5-1.1\\%\\) for various error models .", "feature_encoders": "Unitary .\n\nDissipative .\n\nStabilizer measurement-based .", "feature_decoders": "Minimum weight perfect-matching , union-find , renormalization group , tensor network , Markov chain Monte Carlo , cellular automaton , machine learning .", "parent_detail": "Plaquette and star operators are stabilizer generators.\n\nWhen treated as ground states of the code Hamiltonian, the code states realize \\(\\mathbb{Z}_2\\) topological order, a topological phase of matter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory .", "cousin_detail": "Stabilizer generator weights and qubit degrees are given by the properties of the cellulation, and most cellulations yield QLDPC codes.\n\nPlanar (toric) code obtained from hypergraph product of two repetition (cyclic) codes.", "_type": "ecc", "_page_id": "c_surface", "_href": "c/surface"}, "c_cws": {"name": "Codeword stabilized (CWS) code", "description": "This family of codes strictly generalizes stabilizer codes. They are usually denoted by \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\) where \\(\\mathcal{G}\\) is a graph and \\(\\mathcal{C}\\) is a \\( (n,K,d) \\) binary classical code. From the graph we form the unique graph state (stabilizer state) \\( |G \\rangle \\). From the classical code we form Pauli \\(Z\\)-type operators \\( W_i = Z^{c_{i,1}} \\otimes \\cdots \\otimes Z^{c_{i,n}} \\), where \\(c_{i,j} \\) is the \\(j\\)-th bit of the \\(i\\)-th classical codeword. The CWS codewords are then \\( | i \\rangle =  W_i | G \\rangle \\).\nThere is an alternative description to the one above that is locally Clifford-equivalent. In particular, we can describe CWS codes as \\( \\mathcal{Q} = (S,\\mathcal{W})\\) where \\(S\\) is a stabilizer group and \\( \\mathcal{W} = \\{ w_\\ell \\}_{\\ell = 1}^K \\) is a family of \\(K\\) \\(n\\)-qubit Pauli strings. We then form CWS codeswords as \\( | i \\rangle = w_i | S \\rangle \\), where \\( | S \\rangle \\) is the (unique) stabilizer state of \\(S\\).", "protection": "Code distance \\(\\mathcal{Q} = ( \\mathcal{G},\\mathcal{C}) \\) is upper bounded by the distance of the classical code \\(\\mathcal{C} \\).", "realizations": "", "notes": "", "feature_encoders": "If \\( \\mathcal{C} \\) has an efficient classical encoder, then so does the CWS code \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\).", "feature_decoders": "There is no known efficient algorithm to decode non-additive (non-stabilizer) CWS codes.", "parent_detail": "", "cousin_detail": "The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other.", "_type": "ecc", "_page_id": "c_cws", "_href": "c/cws"}, "c_homological_product": {"name": "Homological product code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "feature_fault_tolerance": "Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state .", "feature_decoders": "Union-find .", "parent_detail": "\n\n", "cousin_detail": "", "_type": "ecc", "_page_id": "c_homological_product", "_href": "c/homological_product"}, "c_css": {"name": "Calderbank-Shor-Steane (CSS) stabilizer code", "description": "An \\([[n,k,d]]\\) stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The parity check matrix is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}~.\n\\label{eq:parity}\n\\end{align}\nEncoding is based on two binary linear codes, an \\([n,k_X,d_X]\\) code \\(C_X\\) and \\([n,k_Z,d_Z]\\) code \\(C_Z\\) with \\(C_X^\\perp \\subseteq C_Z\\), such that \\(k=k_X+k_Z-n\\) and \\(d\\geq\\min\\{d_X,d_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parity} is associated with the code \\(C_X\\) (\\(C_Z\\)), and the requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees that the \\(X\\)-stabilizers of \\(C_X\\) commute with the \\(Z\\)-stabilizers of \\(C_Z\\).\nA CSS code has stabilizer weight \\(w\\) if the highest weight of any stabilizer generator is \\(w\\), i.e., any row and column of \\(H_X\\) and \\(H_Z\\) has weight at most \\(w\\). In the context of comparing weight as well as of noise models biased toward \\(X\\)- or \\(Z\\)-type errors, an extended notation for CSS codes is \\([[n,k,(d_X,d_Z),w]]\\).", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "realizations": "", "notes": "Original requirement of \\(C_X^\\perp \\subset C_Z\\)  has been relaxed to absorb hypergraph product codes.", "feature_encoders": "Stabilizer measurement .", "parent_detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) weakly self-dual CSS code, with the mapping preserving geometric locality of a code up to a constant factor .\n\nMovassagh-Ouyang codes stem from a prescription that converts an arbitrary classical code into a quantum code.", "cousin_detail": "Construction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\).\n\nCSS codes for which \\(C_X=C_Z \\equiv C\\) are called weakly self-dual since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\).", "_type": "ecc", "_page_id": "c_css", "_href": "c/css"}, "c_shor_nine": {"name": "Shor \\([[9,1,3]]\\) code", "description": "Nine-qubit CSS code that is the smallest such code to correct a single-qubit error. Shor's code works by concatenating each qubit of a phase-flip with a bit-flip repetition code. Therefore, the code can correct both type of errors simultaneously. To be specific, a state is phase-flip error-corrected by a three-qubit phase-flip correction code, with parity checks of \\(X_0 X_1I_2\\) and \\(X_0I_1X_2\\) in \\(X\\) basis, where the subscript represents the qubit index. Each logical qubit is encoded using \\begin{align} \\label{eq:phase-flip} \\begin{split} |0\\rangle_{L_P} &= |+_0+_1+_2\\rangle \\\\ |1\\rangle_{L_P} &= |-_0-_1-_2\\rangle . \\end{split}\\end{align} Then, each physical qubit used in \\eqref{eq:phase-flip} is further encoded in the three-qubit bit-flip correction code: \\begin{align} |\\pm _j \\rangle  = \\frac{1}{\\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\\rangle \\pm |1_{j0}1_{j1}1_{j2}\\rangle),\\end{align} each with bit-flip error parity check \\(Z_{j0}Z_{j1}I_{j2}\\) and  \\(Z_{j0}I_{j1}Z_{j2} \\), where \\(j=0,1,2\\). Notice now the phase-flip error parity check is extended as \\(X_j = X_{j0}X_{j1}X_{j2}\\). As a result, the overall parity checks with the flattened qubit index are \\begin{align} \\begin{split} Z_{j0}Z_{j1}I_{j2} &\\rightarrow \\{Z_0Z_1, Z_3Z_4, Z_6Z_7\\} \\\\ Z_{j0}I_{j1}Z_{j2} &\\rightarrow \\{Z_0Z_2, Z_3Z_5, Z_6Z_8\\} \\\\ X_0 X_1I_2  &\\rightarrow  \\{X_0X_1X_2X_3X_4X_5\\}\\\\ X_0 I_1X_2  &\\rightarrow  \\{X_0X_1X_2X_6X_7X_8\\}. \\end{split}\\end{align} The logical state is encoded using \\begin{align} \\begin{split} |\\overline{0}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right)^{\\otimes3}\\\\ |\\overline{1}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle-|111\\rangle\\right)^{\\otimes3} \\end{split}\\end{align}", "protection": "The code detects two-qubit errors or corrects an arbitrary single-qubit error.", "realizations": "Realized in trapped-ion quantum devices, with 98.8(1)% and 98.5(1)% fidelity for state \\(|\\overline{0}\\rangle\\) and \\(|\\overline{1}\\rangle\\), respectively .", "notes": "Shor's code is the first known quantum error correction code.", "parent_detail": "Shor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "cousin_detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\n\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\n\nShor's code is the smallest surface code defined on the projective plane .", "_type": "ecc", "_page_id": "c_shor_nine", "_href": "c/shor_nine"}, "c_quantum_parity": {"name": "Quantum parity code (QPC)", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "\n\nA QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code.", "cousin_detail": "", "_type": "ecc", "_page_id": "c_quantum_parity", "_href": "c/quantum_parity"}, "c_quantum_repetition": {"name": "Quantum repetition code", "description": "Encodes \\(1\\) qubit into \\(n\\) qubits according to \\(|0\\rangle\\to|\\phi_0\\rangle^{\\otimes n}\\) and \\(|1\\rangle\\to|\\phi_1\\rangle^{\\otimes n}\\). Also known as a bit-flip code when \\(|\\phi_i\\rangle = |i\\rangle\\), and a phase-flip code when \\(|\\phi_0\\rangle = |+\\rangle\\) and \\(|\\phi_1\\rangle = |-\\rangle\\).", "protection": "Bit-flip code detects bit-flip errors \\(X\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any phase-flip errors \\(Z\\). Phase-flip code detects phase-flip errors \\(Z\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any bit-flip errors \\(X\\).", "realizations": "Implemented on Sycamore processor by Google Quantum AI  and earlier in other devices (see Table S6 in said paper).", "notes": "Logical basis for the bit-flip code is spanned by GHz (a.k.a. cat) states \\(|0\\rangle^{\\otimes n}\\pm|1\\rangle^{\\otimes n}\\), which are used in Shor error correction.", "parent_detail": "", "cousin_detail": "Bit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions.", "_type": "ecc", "_page_id": "c_quantum_repetition", "_href": "c/quantum_repetition"}, "c_balanced_product": {"name": "Balanced-product code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "Some special cases of balanced product codes are fiber bundle codes .\n\nAccording to , distance balancing is a construction for forming balanced-product subsystem codes.", "_type": "ecc", "_page_id": "c_balanced_product", "_href": "c/balanced_product"}, "c_hypergraph_product": {"name": "Hypergraph product code", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two binary linear seed codes \\(C_1\\) and \\(C_2\\).", "protection": "The hypergraph product has distance \\(d=O(\\sqrt{n})\\). The number of encoded logical qubits is \\(k=O(k_1k_2)\\) where \\(k_1\\) and \\(k_2\\) are the dimensions of the classical seed codes \\(C_1\\) and \\(C_2\\).", "realizations": "", "notes": "", "parent_detail": "Lifted-product codes for trivial group \\(G\\) are hypergraph-product codes.\n\nHypergraph product obtained from the homological product of two length-two chain complexes, i.e., classical binary codes.", "cousin_detail": "", "_type": "ecc", "_page_id": "c_hypergraph_product", "_href": "c/hypergraph_product"}, "c_quantum_polar": {"name": "Quantum polar code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_quantum_polar", "_href": "c/quantum_polar"}, "c_stabilizer_over_gf4": {"name": "Stabilizer code over \\(GF(4)\\)", "description": "An \\([[n,k,d]]\\) stabilizer code whose encoding is based on a self-orthogonal \\([n, n-k, d^*]\\) code over \\(GF(4)^n\\) with respect to the trace inner product where \\(d \\ge d^*\\).\n\\(GF(4)\\) consists of \\(\\{0, 1, w, \\bar{w}\\}\\), with \\(\\bar{w} = w^2 = w + 1\\), \\(\\mathrm{Tr}(x) = x+\\bar{x}\\), and trace inner product \\(u * v = \\mathrm{Tr}(u \\cdot \\bar{v})\\).\nThere is a mapping \\(L\\) between Pauli matrices \\(I, Y, Z, X\\) and \\(0, 1, \\bar{w}, w\\), in turn \\([A, B] \\Leftrightarrow Tr\\langle L(A), L(A)\\rangle\\).\nThe classical self-orthogonal code \\(C\\) over \\(GF(4)^n\\) corresponds to the stabilizer group \\(\\mathsf{S}\\) while \\(C^{\\perp}\\) corresponds to \\(\\mathsf{N(S)}\\).", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "With \\(q=4\\), \\(q\\)-ary linear codes are used in this construction.", "_type": "ecc", "_page_id": "c_stabilizer_over_gf4", "_href": "c/stabilizer_over_gf4"}, "c_quantum_ldpc": {"name": "Quantum low-density parity-check (QLDPC) code", "description": "Family of \\([[n,k,d]]\\) stabilizer codes for which the number of qubits participating in each stabilizer generator and the number of stabilizer generators that each qubit participates in are both bounded by a constant as \\(n\\to\\infty\\).", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. Asymptotic scaling of \\(k\\) and \\(d\\) with \\(n\\) is often of interest, and this depends heavily on the code construction.\nA good quantum LDPC code family satisfies \\(k \\in \\theta(n) \\) and \\(d \\in \\theta(n)\\) , and the first examples of good codes are a family of lifted-product codes.\nA geometrically local LDPC code is an LDPC code where the qubits involved in any syndrome bit are contained in a fixed volume that does not scale with \\(n\\); such codes are limited to having \\(d=O(n^{1-1/D})\\) for \\(D\\)-dimensional lattice geometries .", "realizations": "", "notes": "Links to code tables .", "feature_threshold": "Quantum LDPC codes with a constant encoding rate can reduce the overhead of fault-tolerant quantum computation to be constant .", "parent_detail": "", "cousin_detail": "\n\nCodespace is the ground-state space of a local code Hamiltonian, consisting of an equal linear combination of stabilizer generators.\n\nQLDPC codes can arise form a dynamical process .", "_type": "ecc", "_page_id": "c_quantum_ldpc", "_href": "c/quantum_ldpc"}, "c_stab_15_1_3": {"name": "\\([[15,1,3]]\\) Reed-Muller code", "description": "\\([[15,1,3]]\\) CSS code that is most easily thought of as a tetrahedral 3D color code. This code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center. The tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers. Each colored cell corresponds to a weight-8 \\(X\\)-check, and each face corresponds to a weight-4 \\(Z\\)-check. A logical \\(Z\\) is any weight-3 \\(Z\\)-string along an edge of the entire tetrahedron. The logical \\(X\\) is any weight-7 \\(X\\)-face of the entire tetrahedron.", "protection": "", "realizations": "", "notes": "The \\([[15,1,3]]\\) code can be converted into the smallest known stabilizer code with a fault-tolerant logical \\(T\\) gate (i.e., the \\([[10,1,2]]\\) code) through a \"morphing procedure\" .", "feature_rate": "Magic-state distillation scaling exponent \\( \\gamma= \\log_d (n/k)\\approx 2.46\\) .", "feature_transversal_gates": "A transversal logical \\(T^\\dagger\\) is implemented by applying a \\(T\\) gate on every qubit .", "feature_general_gates": "Code is often used in magic-state distillation protocols because of its transversal \\(T\\) gate .", "feature_fault_tolerance": "Combining the Steane code and the 15-qubit Reed-Muller code through a fault-tolerant conversion can result in a universal transversal gate set that does not need magic state distillation .", "parent_detail": "The \\([[15,1,3]]\\) code is often noted as the 15-qubit quantum Reed-Muller code in the literature.", "cousin_detail": "", "_type": "ecc", "_page_id": "c_stab_15_1_3", "_href": "c/stab_15_1_3"}, "c_lifted_product": {"name": "Lifted product code", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two linear seed codes \\(C_1\\) and \\(C_2\\) with a free action of a group \\(G\\). Lifted product codes can also be defined over arbitrary matrix rings.", "protection": "Code performance strongly depends on \\(G\\), but lifted product codes contain  families of QLDPC codes with the parameters \\([[n, k = \\Theta(n), d = \\Theta(n)]]\\).", "realizations": "", "notes": "", "feature_rate": "Lifted product codes include the first examples  of good QLDPC codes, i.e., codes with asymptotically constant rate and linear distance. The existence of such codes proves the QLDPC conjecture .", "feature_decoders": "BP-OSD decoder .", "parent_detail": "Lifted product obtained from the homological product over a group algebra \\(\\mathbb{F}_2 G\\) of two length-two chain complexes over \\(\\mathbb{F}_2 G\\), i.e., classical binary codes with a free action of the group \\(G\\).", "cousin_detail": "", "_type": "ecc", "_page_id": "c_lifted_product", "_href": "c/lifted_product"}, "c_chuang-leung-yamamoto": {"name": "Chuang-Leung-Yamamoto code", "description": "Bosonic Fock-state code that encodes \\(k\\) qubits into \\(n\\) oscillators, with each oscillator restricted to having at most \\(N\\) excitations. Codewords are superpositions of oscillator Fock states, either balanced (i.e., uniform) or unbalanced. Codes can be denoted as \\([[N,n,2^k,d]]\\), which conflicts with stabilizer code notation.", "protection": "Protects against amplitude damping for up to \\(t = d-1\\) excitation losses. Defining the spacing between two Fock states \\(|u_1\\cdots u_n\\rangle\\) and \\(|v_1\\cdots v_n\\rangle\\),\n\\begin{align}\n\\text{Spacing}(u,v) = \\frac{1}{2}\\sum_{i=1}^n |u_i - v_i|,\n\\end{align}\nthe code distance \\(d\\) can be defined as the minimial spacing between Fock states making up the codewords.", "realizations": "", "notes": "", "feature_rate": "Code rate is \\(\\frac{k}{n \\log_2(N+1)}\\). To correct the loss of up to \\(t\\) excitations with \\(K+1\\) codewords, a code exists with scaling \\(N \\sim t^3 K/2\\).", "feature_encoders": "Photon Fock state input into a network of beamsplitters, phase shifters, and Kerr media. These operations all preserve total photon number. Beamsplitters and phase shifters take annihilation operators to linear combinations of annihilation operators, and the transformation matrix is unitary. The operations corresponding to Kerr nonlinear media are diagonal in the Fock basis, but they implement phases that in general depend nonlinearly on the number of photons in each mode. State preparation may require ancillary modes and be conditioned on photon-number measurement results.", "feature_decoders": "Destructive decoding with a photon number measurement on each mode.\n\nState can be decoded with a network of beamsplitters, phase shifters, and Kerr media.", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_chuang-leung-yamamoto", "_href": "c/chuang-leung-yamamoto"}, "c_wasilewski-banaszek": {"name": "Wasilewski-Banaszek code", "description": "Three-oscillator Fock-state code encoding a single logical qubit using codewords \\begin{align} \\begin{split} |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{3}}(|003\\rangle+|030\\rangle+|300\\rangle)\\\\ |\\overline{1}\\rangle &= |111\\rangle \\end{split}.\\end{align}", "protection": "Protects against single photon loss in any one mode.", "realizations": "", "notes": "", "feature_encoders": "A qubit in the dual-rail code can be transferred to this code via a linear optical network using four ancillary modes, each with one photon input. Successful encoding is conditioned on measuring the state \\(|110\\rangle\\) on the last three modes.", "feature_general_gates": "Single-qubit gates implemented using linear optical networks, sometimes with the addition of auxiliary modes with vacuum input and (conditional) output.", "feature_decoders": "Destructive measurement with photon number measurements on each mode.", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_wasilewski-banaszek", "_href": "c/wasilewski-banaszek"}, "c_hybrid_qudit_oscillator": {"name": "Hybrid qudit-oscillator code", "description": "Encodes a \\(K\\)-dimensional logical Hilbert space into \\(n_1\\) qudits of dimension \\(q\\) and \\(n_2 \\neq 0\\) oscillators, i.e., the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{Z}_q^{n_1} \\times \\mathbb{R}^{n_2}\\).", "protection": "", "realizations": "", "notes": "", "parent_detail": "The physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator.", "cousin_detail": "Hybrid code with \\(n_1=0\\).", "_type": "ecc", "_page_id": "c_hybrid_qudit_oscillator", "_href": "c/hybrid_qudit_oscillator"}, "c_bosonic_rotation": {"name": "Bosonic rotation code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "Single-mode Fock-state codes are typically rotationally invariant.", "cousin_detail": "", "_type": "ecc", "_page_id": "c_bosonic_rotation", "_href": "c/bosonic_rotation"}, "c_cat": {"name": "Cat code", "description": "Rotation-symmetric bosonic Fock-state code encoding a logical qubit into one oscillator. Codewords consists of a coherent state \\(|\\alpha\\rangle\\) projected onto a subspace of Fock state number modulo \\(2(S+1)\\). Hence, the logical state \\(|\\overline{0}\\rangle\\) is in the \\(\\{|0\\rangle , |2(S+1)\\rangle , |4(S+1)\\rangle \\cdots \\}\\) subspace, while \\(|\\overline{1}\\rangle\\) is in the \\(\\{|(S+1)\\rangle, |3(S+1)\\rangle , |5(S+1)\\rangle , |7(S+1)\\rangle \\cdots \\}\\) subspace.", "protection": "Due to the spacing between the two sets of Fock states, the distance between two distinct logical states is \\(d=S+1\\). Hence, this code is able to detect \\(S\\)-photon loss error.", "realizations": "Two-legged (\\(S=1\\)) cat code has been realized by two superconducting cavities coupled through a Josephson junction .\n\nFour-legged (\\(S=2\\)) cat code has been realized in superconducting circuit . This paper is the first break-even point of quantum error-correction, where the lifetime of a logical qubit is on par with the lifetime of the noisiest constituent of the system.", "notes": "", "feature_encoders": "Lindbladian-based dissipative encoding utilizing multi-photon absorption .\n\nHamiltonian-based 'Kerr-cat' encoding utilizing the Kerr effect .\n\nCombined dissipative and Hamiltonian-based encoding utilizing two-photon exchange for \\(S=1\\) codes .", "feature_general_gates": "For \\(S=1\\), universal gates can be performed using displacement operators and a rotation based on the Kerr nonlinearity . For \\(S=2\\), squeezing replaces displacements.\n\nHolonomic gates utilizing the Berry phase of coherent states are universal .\n\nBias-preserving CNOT gate utilizing a topological Berry phase .", "feature_fault_tolerance": "Bias-preserving CNOT gate  is part of a universal bias-preserving gate set that can be made fault tolerant using concatenation .", "feature_decoders": "Measurement in the Fock basis. For a \\(2(S+1)\\) cat code, a number measurement returns outcome \\(2(S+1)k\\), if \\(k\\) is even, then it corresponds to logical 0 state; if \\(k\\) is odd, then it corresponds to logical 1 state.", "parent_detail": "", "cousin_detail": "Two-legged cat codewords form ground-state subspace of a Kerr Hamiltonian .", "_type": "ecc", "_page_id": "c_cat", "_href": "c/cat"}, "c_gkp": {"name": "Gottesman-Kitaev-Preskill (GKP) code", "description": "Bosonic qudit-into-oscillator code whose stabilizers are oscillator displacement operators \\(\\hat{S}_q(2\\alpha)=e^{-2i\\alpha \\hat{p}}\\) and \\(\\hat{S}_p(2\\beta)=e^{2i\\beta \\hat{q}}\\). To ensure \\(\\hat{S}_q(2\\alpha)\\) and \\(\\hat{S}_p(2\\beta)\\) generate a stabilizer group that is Abelian, there is another constraint that \\(\\alpha\\beta=2k\\pi\\) where \\(k\\) is an integer. Codewords can be expressed as equal weight superpositions of coherent states on an infinite lattice, such as a square lattice in phase space with spatial period \\(2\\sqrt{\\pi}\\). The exact GKP state is non-normalizable, so approximate constructs have to be considered.", "protection": "For stabilizer \\(\\hat{S}_q(2\\alpha),\\hat{S}_p(2\\beta)\\), code can correct displacement errors up to \\(\\frac{\\alpha}{2}\\) in the \\(q\\)-direction and \\(\\frac{\\beta}{2}\\) at \\(p\\)-direction. Approximately protects against photon loss errors , outperforming most other codes designed to explicitly protect against loss . Very sensitive to dephasing errors . A biased-noise GKP error correcting code can be prepared by choosing \\(\\alpha\\neq \\beta\\).", "realizations": "Approximate GKP code is realized on a superconducting microwave cavity  and a trapped-ion oscillator .", "notes": "", "feature_encoders": "Preparation of approximate GKP states is studied both theoretically and experimentally on circuit-QED platforms, by putting the GKP lattice inside a Gaussian envelope , , .", "feature_transversal_gates": "Clifford gates can be realized by performing linear optics operations, sympletic transformations and displacements , all of which are Gaussian operations. Pauli gates can be performed using displacement operators.", "feature_general_gates": "By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements .", "feature_decoders": "Syndrome measruement of displacement error can be done by applying a controlled-displacement controlled by an ancilla qubit. The syndrome information can be obtained by measuring the ancilla qubit after controlled-displacement opearation. See Section. 2D in .\n\nPauli \\(X\\),\\(Y\\) and \\(Z\\) measurements can be performed by measuring \\(-\\hat{p},\\hat{q}-\\hat{p}\\) and \\(\\hat{q}\\) repectively. If the measurement outcome is closed to an even multiple of \\(\\sqrt{\\pi}\\), then the outcome is +1. If the measurement outcome is closed to an odd multiple of \\(\\sqrt{\\pi}\\), then the outcome is -1. See Section. 2D in .", "parent_detail": "", "cousin_detail": "GKP codes approximately protect against photon loss .\n\nGKP codes are a continuous-variable analogue of stabilizer codes.", "_type": "ecc", "_page_id": "c_gkp", "_href": "c/gkp"}, "c_oscillators_into_oscillators": {"name": "Oscillator-into-oscillator code", "description": "Encodes Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}^k\\) into that on \\(\\mathbb{R}^n\\). Usually denoted as \\(((n,k))_{\\mathbb{R}}\\).", "protection": "", "realizations": "", "notes": "", "parent_detail": "Bosonic code with infinite-dimensional logical subspace.", "cousin_detail": "", "_type": "ecc", "_page_id": "c_oscillators_into_oscillators", "_href": "c/oscillators_into_oscillators"}, "c_fock_state": {"name": "Fock-state bosonic code", "description": "Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. For example, single-mode Fock-state codes include any qubit codes whose basis states are, respectively, supported on Fock state sets \\(\\{|0\\rangle,|4\\rangle,|8\\rangle,\\cdots\\}\\) and \\(\\{|2\\rangle,|6\\rangle,|10\\rangle,\\cdots\\}\\).", "protection": "Code distance \\(d\\) is the minimum distance (assuming some metric) between any two labels of Fock states corresponding to different code basis states. For a single mode, \\(d\\) is the minimum absolute value of the difference between any two Fock-state labels; such codes can detect up to \\(d-1\\) loss events. Multimode distances can be defined analogously; see, e.g., Chuang-Leung-Yamamoto codes.", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "Fock-state code distance is a natural extension of Hamming distance between binary strings.\n\nFock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators . However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations .", "_type": "ecc", "_page_id": "c_fock_state", "_href": "c/fock_state"}, "c_oscillators": {"name": "Bosonic code", "description": "Also called an oscillator or a continuous-variable (CV) code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one oscillator or mode (i.e., one copy of the space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}\\)). Ideal codewords may not be normalizable, so approximate versions have to be constructed.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_oscillators", "_href": "c/oscillators"}, "c_qudits_into_oscillators": {"name": "Qudit-into-oscillator code", "description": "Encodes \\(K\\)-dimensional Hilbert space into Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}^n\\).", "protection": "", "realizations": "", "notes": "", "parent_detail": "Bosonic code with finite-dimensional logical subspace.", "cousin_detail": "", "_type": "ecc", "_page_id": "c_qudits_into_oscillators", "_href": "c/qudits_into_oscillators"}, "c_very-small-logical-qubit": {"name": "Very small logical qubit (VSLQ) code", "description": "The two logical codewords are \\(|\\pm\\rangle \\propto (|0\\rangle\\pm|2\\rangle)(|0\\rangle\\pm|2\\rangle)|0\\rangle|0\\rangle\\), where the total Hilbert space is the tensor product of two qudits (whose ground states \\(|0\\rangle\\) and second excited states \\(|2\\rangle\\) are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.", "protection": "Passively protects against single photon loss.", "realizations": "", "notes": "", "feature_encoders": "Engineering a circuit made of two transmons and two oscillators coupled through three driven superconducting quantum interference devices (SQUIDs) results in passive stabilization of the logical states.", "feature_general_gates": "Single logical qubit operations implemented by resonant physical qubit driving and phase shifting the SQUID drives.\n\nA CZ gate between two logical qubits implemented by coupling devices through another driven SQUID and applying a pulse to the coupling squid simultaneously with a single qubit operation on one of the logical qubits.", "feature_decoders": "Logical qubit can be measured with physical qubit measurements along \\(X\\). Can be implemented by engineering a coupling of one of the qubits to a readout cavity via the interaction \\(\\sigma_x (a+a^\\dagger)\\) . This results in an \\(X\\)-dependent shift of the readout cavity resonance which can be measured.", "parent_detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators.", "cousin_detail": "Parts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss.", "_type": "ecc", "_page_id": "c_very-small-logical-qubit", "_href": "c/very-small-logical-qubit"}, "c_group_quantum": {"name": "Group quantum code", "description": "Encodes a logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space of \\(\\ell^2\\)-normalizable functions on a second-countable unimodular group. For \\(K\\)-dimensional logical subspace and for groups \\(G^{\\times n}\\), can be denoted as \\(((n,K))_G\\). When the logical subspace is the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(G^{\\times k}\\), can be denoted as \\([[n,k]]_G\\). Ideal codewords may not be normalizable, depending on whether \\(G\\) is continuous and/or noncompact, so approximate versions have to be constructed.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "Group quantum codes whose physical spaces are constructed using finite groups are finite-dimensional.\n\nGroup quantum codes whose physical spaces are constructed using modular-integer groups are \\(\\mathbb{Z}_q\\)-qudit codes.\n\nGroup quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes.", "_type": "ecc", "_page_id": "c_group_quantum", "_href": "c/group_quantum"}, "c_molecular": {"name": "Molecular code", "description": "Encodes finite-dimensional Hilbert space into the Hilbert space of \\(\\ell^2\\)-normalizable functions on the group \\(SO_3\\). Construction is based on nested subgroups \\(H\\subset K \\subset SO_3\\), where \\(H,K\\) are finite. The \\(|K|/|H|\\)-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\).", "protection": "Protects against generalized bit-flip errors \\(g\\in SO_3\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "realizations": "", "notes": "Physical space characterizes orientations of a rigid body in 3D, which correspond to rotational states of an asymmetric molecule.", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_molecular", "_href": "c/molecular"}, "c_group_gkp": {"name": "Group GKP code", "description": "Group code whose construction is based on nested subgroups \\(H\\subset K \\subset G\\). Logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\), and can be finite- or infinite-dimensional. Extension of the GKP code construction.", "protection": "Protects against generalized bit-flip errors \\(g\\in G\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "For logical and physical spaces based on the real line \\(\\mathbb{R}\\).\n\nFor an \\(n\\)-qubit CSS code, the nested group construction \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{\\times n}\\).\n\nFor a single-mode qubit GKP code, the nested group construction is \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\).", "_type": "ecc", "_page_id": "c_group_gkp", "_href": "c/group_gkp"}, "c_frobenius": {"name": "Frobenius code", "description": "Let \\(C\\) be a quantum cyclic code on \\(n\\) \\(\\mathbb{Z}_p\\)-qudits. \\(C\\) is a Frobenius code if there exists a positive integer \\(t\\) such that \\(n\\) divides \\(p^t +1\\).", "protection": "Protects against Pauli noise.", "realizations": "", "notes": "Frobenius codes that are also stabilizer codes have been completely classified. No such codes exist when \\(t\\) is odd. All such codes with even \\(t\\) can be directly constructed.", "feature_decoders": "Adapted from the Berlekamp decoding algorithm for classical BCH codes. There exists a polynomial time quantum algorithm to correct errors of weight at most \\(\\tau\\), where \\(\\delta=2\\tau+1\\) is the BCH distance of the code .", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_frobenius", "_href": "c/frobenius"}, "c_qudit_stabilizer": {"name": "\\(\\mathbb{Z}_q\\)-qudit stabilizer code", "description": "An \\(((n,p^k,d))_q\\) (with \\(q\\) not necessarily prime) stabilizer code is denoted as \\([[n,k]]_q\\) or \\([[n,k,d]]_q\\), where \\(d\\) is the code's distance. Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_qudit_stabilizer", "_href": "c/qudit_stabilizer"}, "c_polynomial": {"name": "\\(\\mathbb{Z}_p\\)-qudit polynomial code", "description": "Also called quantum Reed-Solomon code. Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "\n\n", "_type": "ecc", "_page_id": "c_polynomial", "_href": "c/polynomial"}, "c_prime_qudit_stabilizer": {"name": "\\(\\mathbb{Z}_p\\)-qudit stabilizer code", "description": "An \\(((n,p^k,d))_p\\) (with \\(p\\) prime) stabilizer code is denoted as \\([[n,k]]_p\\) or \\([[n,k,d]]_p\\), where \\(d\\) is the code's distance. Logical subspace is the joint \\(+1\\) eigenspace of a set of \\(p^{n-k}\\) commuting qudit Pauli operators forming the code's stabilizer group, which cannot contain \\(-I\\). The distance is the minimum weight of an error that implements a nontrivial logical operation on the code.", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.  More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a generalized Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{\\hat{N}(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "realizations": "", "notes": "", "parent_detail": "\n\nA prime-qudit stabilizer code is a Galois-qudit stabilizer code with \\(m=1\\).", "cousin_detail": "", "_type": "ecc", "_page_id": "c_prime_qudit_stabilizer", "_href": "c/prime_qudit_stabilizer"}, "c_qudits_into_qudits": {"name": "\\(\\mathbb{Z}_q\\)-qudit code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the group \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\). Usually denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined, and with \\(q=p\\) when the dimension is prime.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_qudits_into_qudits", "_href": "c/qudits_into_qudits"}, "c_qudit_css": {"name": "\\(\\mathbb{Z}_q\\)-qudit CSS code", "description": "Often, but not always, defined for prime qudits (\\(q=p\\)). Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "Extension of CSS codes to modular-integer qudits.", "_type": "ecc", "_page_id": "c_qudit_css", "_href": "c/qudit_css"}, "c_skew-cyclic_galois_css": {"name": "Skew-cyclic CSS code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "Skew-cyclic CSS codes are constructed from classical skew-cylic codes.", "_type": "ecc", "_page_id": "c_skew-cyclic_galois_css", "_href": "c/skew-cyclic_galois_css"}, "c_galois_stabilizer": {"name": "Galois-qudit stabilizer code", "description": "An \\(((n,p^k,d))_{GF(q)}\\) stabilizer code is denoted as \\([[n,k]]_{GF(q)}\\) or \\([[n,k,d]]_{GF(q)}\\), where \\(d\\) is the code's distance. Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_galois_stabilizer", "_href": "c/galois_stabilizer"}, "c_binary_quantum_goppa": {"name": "Binary quantum Goppa Code", "description": "Also known as a quantum AG code. Binary quantum Goppa codes are a family of \\( [[n,k,d]]_{GF(q)} \\) Galois-qudit stabilizer codes for \\( q=2^m \\), generated using classical Goppa codes.\nLet \\( F/GF(q) \\) be an algebraic function field of one variable, \\(\\sigma \\) be an automorphism of order 2\nof \\(F\\) which leaves \\(GF(q)\\) invariant, and \\(P_1, \\cdots, P_n \\) be pairwise distinct places of degree one such that \\( \\sigma P_i = P_j\\) for all\n\\(i,j = 1, \\cdots, n\\). A place \\( P_i \\) of \\( F/ GF(q) \\) is the unique maximal ideal of a discrete valuation ring of the function field. Let \\( \\nu \\) be a  differential\nthat satisfies the properties guaranteed by  the strong approximation theorem of discrete evaluations. Let \\(G\\) be a divisor such that \\( \\sigma G = G \\) and the\ndiscrete valuation corresponding to place \\(P_i \\) of \\(G\\) and the discrete valuation corresponding to place \\(\\sigma P_i \\) of \\(G\\) are both 0 for all \\(i\\). Then we can define\na code \\( C(G)  = \\{ f(P_1), \\cdots, f(P_n), f(\\sigma P_1), \\cdots , f(\\sigma P_n) | f \\in \\mathcal{L}(G)\\} \\subset GF(q^{2n})\\) and\na code \\(C(H)\\) where \\(H = (P_1 + \\cdots + P_n + \\sigma P_1 + \\cdots + \\sigma P_n) - G + \\nu \\). Then the dual of \\(C(G)\\) with respect to the weighted symplectic inner\nproduct with weights \\(s_i\\) on \\( GF(q^n) \\) is equivalent to \\(C(H)\\). Therefore, the orthogonal code of \\(C(G)\\) is generated by \\(H\\). Using these properties and the assumption\nthat \\(H\\) is a subgroup of \\(G\\), we can construct a classical Goppa code \\(C(D,G)\\), where \\(D\\) is the sum of all \\(P_i\\). Using \\(C(D,G)\\), we can construct a \\([[n,k,d]]_{GF(q)}\\) quantum stabilizer code such that\n\\(k  = \\text{dim} G - \\text{dim}(G-P_1 - \\cdots - P_n - \\sigma P_1 - \\cdots  - \\sigma P_n) - n~.\\)", "protection": "Protects against weight t errors where \\( 0 < t \\leq  \\lfloor \\frac{d^*-g-1}{2} \\rfloor \\) where \\( d^* = \\text{deg} G + 2 -2g \\) and \\(g\\) is the genus of the function field and \\(d \\geq n - \\lfloor \\frac{deg G}{2} \\rfloor\\).", "realizations": "", "notes": "", "feature_encoders": "Encoding defined in Matsumoto  uses a technique from Ashikhmin and Knill  to encode quantum stabilizer codes.", "feature_decoders": "Farran algorithm .", "parent_detail": "", "cousin_detail": "Goppa codes can be constructed using CSS codes over hyperelliptic curves . The construction provided here is Matsumoto's construction.\n\nClassical Goppa codes are used to construct their quantum versions.", "_type": "ecc", "_page_id": "c_binary_quantum_goppa", "_href": "c/binary_quantum_goppa"}, "c_galois_into_galois": {"name": "Galois-qudit code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the Galois field \\(GF(q)\\) and with \\(q\\) being a power of a prime \\(p\\). A Galois field can be thought of as a vector space whose basis vectors are the \\(m\\) roots of some polynomial and whose coefficients (i.e., field) are \\(p\\)th roots of unity. Codes can be denoted as \\(((n,K))_{GF(q)}\\) or \\(((n,K,d))_{GF(q)}\\), whenever the code's distance \\(d\\) is defined.", "protection": "", "realizations": "", "notes": "Introduction to Galois qudits by Gottesman.", "parent_detail": "", "cousin_detail": "A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) \\(\\mathbb{Z}_q\\)-qudits ; see Sec. 5.3 of Ref. . The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently.", "_type": "ecc", "_page_id": "c_galois_into_galois", "_href": "c/galois_into_galois"}, "c_quantum_secret_sharing": {"name": "Approximate secret-sharing code", "description": "An approximate family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes approximately correcting errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) qubits, i.e., with approximate distance approaching the no-cloning bound \\(n/2\\). Constructed using a quantum code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an \\(t\\)-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.", "protection": "Corrects up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors with fidelity exponentially lose to 1.", "realizations": "", "notes": "", "feature_encoders": "Uses a quantum authentication scheme, which is a keyed system in which a valid state has high fidelity, and a classical secret-sharing scheme.", "feature_decoders": "Decoding is analagous to reconstruction in a secret sharing scheme and is done in polynomial time. The only required operations are verification of quantum authentication, which is a pair of polynomial-time quantum algorithms that check if the fidelity of the received state is close to 1, and erasure correction for a stabilizer code, which involves solving a system of linear equations.", "parent_detail": "The code required to construct this code must be a non-degenerate css code.", "cousin_detail": "Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors.\n\nPolynomial codes can be used for a specific construction of this code.\n\nThe classical information in this code is encoded using a reed_solomon code.", "_type": "ecc", "_page_id": "c_quantum_secret_sharing", "_href": "c/quantum_secret_sharing"}, "c_galois_css": {"name": "Galois-qudit CSS code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "Extension of qubit CSS codes to Galois qudits.\n\n", "_type": "ecc", "_page_id": "c_galois_css", "_href": "c/galois_css"}, "c_galois_polynomial": {"name": "Galois-qudit polynomial code", "description": "Stub.", "protection": "Also called quantum Reed-Solomon code.", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "\n\n\n\n", "_type": "ecc", "_page_id": "c_galois_polynomial", "_href": "c/galois_polynomial"}, "c_distance_balanced": {"name": "Distance-balanced code", "description": "CSS stabilizer code constructed from another CSS code using a distance-balancing procedure.", "protection": "", "realizations": "", "notes": "", "parent_detail": "\n\nDistance-balancing procedure can yield QLDPC codes; see Thm. 1 in Ref. .", "cousin_detail": "According to , distance balancing is used to form balanced-product subsystem codes.\n\nDistance-balancing procedure can yield QLDPC codes; see Thm. 1 in Ref. .\n\n", "_type": "ecc", "_page_id": "c_distance_balanced", "_href": "c/distance_balanced"}, "c_dynamic_gen": {"name": "Dynamically-generated quantum error-correcting code", "description": "Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_dynamic_gen", "_href": "c/dynamic_gen"}, "c_quantum_concatenated": {"name": "Concatened code", "description": "A concatened code is a combination of two codes, an inner code \\(C\\) and an outer code \\(C^\\prime\\), where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code \\(C^\\prime\\), and then one encodes each of the physical registers of \\(C^\\prime\\) in an inner code \\(C\\).", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_quantum_concatenated", "_href": "c/quantum_concatenated"}, "c_quantum_cyclic": {"name": "Quantum cyclic code", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits) is cyclic if a cyclic permutation of the subsystems leaves the code subspace invariant.", "protection": "Cyclic symmetry guarantees that if a single subsystem is protected against some noise, then all other subsystems are also.", "realizations": "", "notes": "Many examples have been found by computer algebra programs. Ref.  give examples of \\([[17,1,7]]\\) and \\([[17,9,3]]\\) quantum cyclic codes.", "feature_decoders": "Adapted from the Berlekamp decoding algorithm for classical BCH codes .", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_quantum_cyclic", "_href": "c/quantum_cyclic"}, "c_topological": {"name": "Topological code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "Codespace is either the ground-state or low-energy subspace of a geometrically local Hamiltonian admitting a topological phase.", "cousin_detail": "Stabilizer-based topological codes (e.g., the surface code) on appropriate tesselations are QLDPC.", "_type": "ecc", "_page_id": "c_topological", "_href": "c/topological"}, "c_random_circuit": {"name": "Random-circuit code", "description": "Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_random_circuit", "_href": "c/random_circuit"}, "c_approximate_qecc": {"name": "Approximate quantum code", "description": "Stub.", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_approximate_qecc", "_href": "c/approximate_qecc"}, "c_fracton": {"name": "Fracton code", "description": "A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.", "protection": "", "realizations": "", "notes": "", "parent_detail": "Codespace is the ground-state subspace of a geometrically local Hamiltonian admitting a fracton phase.", "cousin_detail": "", "_type": "ecc", "_page_id": "c_fracton", "_href": "c/fracton"}, "c_hamiltonian": {"name": "Hamiltonian-based code", "description": "Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy. When the physical space is a tensor product of subsystems, the Hamiltonian is typically local, consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., quantum LDPC codes). When the physical space is endowed with a geometry, the Hamiltonian is typically geometrically local, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., topological codes).", "protection": "Typically determined from the underlying physical properties of the Hamiltonian.", "realizations": "", "notes": "", "feature_encoders": "Lindbladian-based dissipative encoding can be constructed for a codespace that is the ground-state subspace of a frustration-free Hamiltonian .", "parent_detail": "", "cousin_detail": "", "_type": "ecc", "_page_id": "c_hamiltonian", "_href": "c/hamiltonian"}, "c_quantum_perfect": {"name": "Perfect quantum code", "description": "A non-degenerate code constructed out of \\(q\\)-dimensional qudits and having parameters \\(((n,K,2t+1))\\) is perfect if \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the quantum Hamming bound\n\\begin{align}\n\\sum_{j=0}^{t}(q^2-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a qubit \\(q=2\\) code with one logical qubit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(3n+1 \\leq 2^{n-1}\\). The bound can be saturated only at certain \\(n\\).\nFor qubit codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-\\frac{t}{n}\\log_{2}3-H(t/n),\n\\end{align}\nwhere \\(H\\) is the binary entropy function.", "protection": "Perfect codes have been classified. For qubits (\\(q=2\\)), the only codes are the stabilizer code family \\([[(4^r-1)/3, (4^r-1)/3 - 2r, 3]]\\) for \\(r \\geq 2\\) . For qudits, the family is parameterized by \\(K=q^{n-2r}\\) for \\(n=\\frac{q^{2r}-1}{q^{2}-1}\\) and \\(r \\geq 2\\); all codes correct a single error (\\(t=1\\)) . The trivial code (\\(k=n\\)) is also perfect.", "realizations": "", "notes": "", "feature_rate": "\\(k/n\\to 1\\) asymptotically with \\(n\\).", "parent_detail": "", "cousin_detail": "A classical (quantum) perfect code saturates the classical (quantum) Hamming bound.", "_type": "ecc", "_page_id": "c_quantum_perfect", "_href": "c/quantum_perfect"}, "c_fermions": {"name": "Fermionic code", "description": "Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators .", "protection": "", "realizations": "", "notes": "", "parent_detail": "", "cousin_detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation , codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations.\n\nBosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom.", "_type": "ecc", "_page_id": "c_fermions", "_href": "c/fermions"}, "c_majorana_stab": {"name": "Majorana stabilizer code", "description": "Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as Majorana stabilizers. The codespace is the mutual \\(+1\\) eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as \\([[n,k,d]]_{f}\\) , where \\(n\\) is the number of fermionic modes.", "protection": "Detects products of Majorana operators with weight up to \\(d-1\\). Physically, protects against dephasing errors caused by coupling of fermion density to the environment and bit-flip errors caused by quasiparticle poisoning processes.", "realizations": "", "notes": "", "parent_detail": "\n\nThe Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code . However, Pauli- and Majorana-based stabilizer codes have different notions of locality  and are thus useful for different physical platforms.", "cousin_detail": "Classical weakly self-dual codes can be used to construct Majorana stabilizer codes . The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a weakly self-dual classical code. A weakly self-dual classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\).\n\nWhen constructing a Majorana stabilizer code from a weakly self-dual classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space . Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different weakly self-dual classical codes with an odd number of bits, as is often done in the CSS construction.\n\nCyclic codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also weakly self-dual .\n\nMajorana stabilizer codes can be constructed by weakly self-dual Reed-Muller codes . These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code.", "_type": "ecc", "_page_id": "c_majorana_stab", "_href": "c/majorana_stab"}}