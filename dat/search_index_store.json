{"c_oaecc": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "[quant-ph/0203105,0705.1574]", "notes": "", "realizations": "", "name": "Operator-algebra error-correcting code", "physical": "", "short_name": "Operator-algebra QECC", "protection": "", "description": "Stub.", "code_id": "oaecc", "logical": "", "parent_of_code_id": "ecc\nholographic\nqecc\noecc", "parent_of_detail": "\nProperties of holographic codes are often quantified in the Heisenberg picture, i.e., in terms of operator algebras [1411.7041,1612.00017].\n\n", "_type": "ecc", "_page_id": "c_oaecc", "_href": "c/oaecc"}, "c_ecc": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "The modern theory of error-correcting codes is rooted in the foundational work of C. Shannon [10.1002/j.1538-7305.1948.tb01338.x], but error-correcting codes have been used prior to that work [10.1007/bf03025254].", "realizations": "", "name": "Error-correcting code", "physical": "", "short_name": "", "protection": "A code corrects errors associated with a noise channel if it is possible to recover any codeword after its coordinates have been changed after going through the channel. More technically, an error-correcting code \\((u,\\mathcal{E})\\) is an encoder function \\(u:[1\\cdots K]\\to[1\\cdots N]\\) with a set of correctable errors \\(E:[1\\cdots N]\\to [1\\cdots M]\\) with the following property: there exists a decoder function \\(d:[1\\cdots M]\\to [1\\cdots K]\\) such that for all \\(E\\in\\cal{E}\\) and states \\(x\\in[1\\cdots K]\\), \\(d(E(e(x)))=x\\).", "description": "A code is a subset of a set or alphabet, with each element called a codeword. An error-correcting code consists of \\(K\\) codewords over an alphabet with \\(N\\) elements such that it is possible to recover the codewords from errors \\(E\\) from some error set \\(\\mathcal{E}\\).", "code_id": "ecc", "logical": "", "parents_code_id": "oaecc", "parents_detail": "", "parent_of_code_id": "bits_into_bits\ndistributed_storage\ndual\nq-ary_digits_into_q-ary_digits\ngeneralized_concatenated\ngroup_classical\nipp\npoints_into_lattices\nldpc\nmatrices_into_matrices\nparallel_concatenated\nperfect\nquasi_cyclic\nrandom\nrings_into_rings\npoints_into_spheres", "parent_of_detail": "\n\n\n\n\n\n\nError-correcting codes are defined for a finite alphabet, so only finite lattice-based codes are children.\n\n\n\n\n\n\n\n", "_type": "ecc", "_page_id": "c_ecc", "_href": "c/ecc"}, "c_regenerating": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Regenerating code (RGC)", "physical": "matrices", "short_name": "", "protection": "", "description": "Stub.", "code_id": "regenerating", "logical": "q-ary_digits", "parents_code_id": "distributed_storage\nmatrices_into_matrices", "parents_detail": "\n", "parent_of_code_id": "mbr\nmsr", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_regenerating", "_href": "c/regenerating"}, "c_matrices_into_matrices": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Matrix code", "physical": "matrices", "short_name": "", "protection": "", "description": "Encodes \\(K\\) states (codewords) in an \\(m\\times n\\)-dimensional matrix of coordinates over a field (e.g., the Galois field \\(GF(q)\\) or the complex numbers \\(\\mathbb{C}\\)).", "code_id": "matrices_into_matrices", "logical": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "regenerating\nspacetime", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_matrices_into_matrices", "_href": "c/matrices_into_matrices"}, "c_spacetime": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Spacetime code", "physical": "matrices", "short_name": "", "protection": "", "description": "Code designed for wireless transmission of information (via, e.g., radio waves) such that the sender can send multiple times from multiple locations. A spacetime code uses a modulation scheme to encode a message into signals that are sent at different times through different antennas, thereby utilizing both spatial and temporal (i.e., spacetime) degrees of freedom.", "code_id": "spacetime", "logical": "points", "parents_code_id": "matrices_into_matrices", "parents_detail": "", "_type": "ecc", "_page_id": "c_spacetime", "_href": "c/spacetime"}, "c_mbr": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Minimum-bandwidth regenerating (MBR) code", "physical": "matrices", "short_name": "", "protection": "", "description": "Stub.", "code_id": "mbr", "logical": "q-ary_digits", "parents_code_id": "regenerating", "parents_detail": "", "_type": "ecc", "_page_id": "c_mbr", "_href": "c/mbr"}, "c_msr": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Minimum-storage regenerating (MSR) code", "physical": "matrices", "short_name": "", "protection": "", "description": "Stub.", "code_id": "msr", "logical": "q-ary_digits", "parents_code_id": "regenerating", "parents_detail": "", "_type": "ecc", "_page_id": "c_msr", "_href": "c/msr"}, "c_residue": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Residue AG code", "physical": "q-ary_digits", "short_name": "", "protection": "", "description": "Also called a differential code. Stub.", "code_id": "residue", "logical": "q-ary_digits", "parents_code_id": "ag", "parents_detail": "", "parent_of_code_id": "goppa", "parent_of_detail": "", "cousins_code_id": "evaluation", "cousins_detail": "Evaluation and residue codes are dual to each other.", "_type": "ecc", "_page_id": "c_residue", "_href": "c/residue"}, "c_folded_reed_solomon": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Folder Reed-Solomon code", "physical": "q-ary_digits", "short_name": "", "protection": "", "description": "Stub.", "code_id": "folded_reed_solomon", "logical": "q-ary_digits", "parents_code_id": "reed_solomon", "parents_detail": "", "_type": "ecc", "_page_id": "c_folded_reed_solomon", "_href": "c/folded_reed_solomon"}, "c_q-ary_digits_into_q-ary_digits": {"notes": "Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by Brouwer [Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.], are maintained by M. Grassl at this website <http://codetables.markus-grassl.de/>.", "realizations": "", "physical": "q-ary_digits", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) \\(q\\)-ary coordinates over the field \\(GF(q)=\\mathbb{F}_q\\) and has distance \\(d\\). Usually denoted as \\((n,K,d)_q\\). The distance is the minimum number of coordinates where two strings in the code differ.", "code_id": "q-ary_digits_into_q-ary_digits", "logical": "q-ary_digits", "introduced": "", "name": "Galois-field \\(q\\)-ary code", "short_name": "", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "For small \\(n\\), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.\nGiven a received string \\(x\\) and an error bound \\(e\\), a list decoder returns a list of all codewords that are at most \\(e\\) from \\(x\\). The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\).", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "ag\nq-ary_linear\ngabidulin", "parent_of_detail": "\n\n", "_type": "ecc", "_page_id": "c_q-ary_digits_into_q-ary_digits", "_href": "c/q-ary_digits_into_q-ary_digits"}, "c_q-ary_linear": {"notes": "Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\).", "realizations": "", "physical": "q-ary_digits", "description": "An \\((n,K,d)_q\\) linear code is denoted as \\([n,k,d]_q\\), where \\(k=\\log_{q}K\\) need not be an integer. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any \\(q\\)-ary digits \\(\\alpha,\\beta\\).\n\nLinear codes can be defined in terms of a generator matrix \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a codeword \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its standard or systematic form \\(G = [I_k A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) \\(q\\)-ary matrix.\n", "code_id": "q-ary_linear", "logical": "q-ary_digits", "introduced": "", "name": "Linear \\(q\\)-ary code", "short_name": "", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set such that the difference of any pair of distinct elements of the set is a codeword.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "alternant\nmds\ngroup", "parent_of_detail": "\n\n", "cousin_of_code_id": "galois_css\nqudit_css\nstabilizer_over_gf4\nstabilizer_over_gfqsq\ngalois_true_stabilizer", "cousin_of_detail": "Construction uses two related \\(q\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).\nConstruction for prime \\(q=p\\) uses two related \\(p\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).\nQuaternary \\(q=4\\) linear codes are used in this construction.\n\\(q\\)-ary linear codes are used in this construction.\nA true Galois-qudit stabilizer code is the closest quantum analogue of a linear code over \\(GF(q)\\) because the \\(q\\)-ary vectors defining each code form a linear subspace.", "_type": "ecc", "_page_id": "c_q-ary_linear", "_href": "c/q-ary_linear"}, "c_generalized_reed_solomon": {"notes": "", "realizations": "", "physical": "q-ary_digits", "description": "Stub.", "code_id": "generalized_reed_solomon", "logical": "q-ary_digits", "introduced": "[F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977]", "name": "Generalized Reed-Solomon code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "alternant", "parents_detail": "", "parent_of_code_id": "reed_solomon", "parent_of_detail": "", "cousins_code_id": "goppa\nbch", "cousins_detail": "\n", "cousin_of_code_id": "quantum_mds", "cousin_of_detail": "Quantum MDS codes can be constructed through classical generalized Reed-Solomon codes [2002.06040].", "_type": "ecc", "_page_id": "c_generalized_reed_solomon", "_href": "c/generalized_reed_solomon"}, "c_gabidulin": {"notes": "", "realizations": "Useful for error and erasure correction in network coding", "physical": "q-ary_digits", "description": "Also called Gabidulin or vector rank-metric code. The code corrects errors over rank metric instead of the traditional Hamming distance. The rank of an \\(n\\)-dimensional vector over \\(GF(q)^N\\) is the maximum number of its linearly independent coordinates.\n\nGiven \\(X^n=\\text{span}\\{x_i\\}\\), an \\(n\\)-dimensional vector space over \\(GF(q)^N\\) where \\(q\\) is a power of a prime number, the rank metric \\(d(x, y)\\) is defined via the rank norm \\(r(x, q) = \\mathrm{rank}(A(x))\\), where\n\\begin{align}\nA(x) = \\begin{pmatrix} a_{11} & a_{12} & \\ldots & a_{1n} \\\\ a_{21} & a_{22} & \\ldots & a_{2n} \\\\  a_{N1} & a_{N2} & \\ldots & a_{Nn} \\end{pmatrix}\n\\end{align}\nand \\(x_i = a_{1i} u_1 + a_{2i} u_2 + \\ldots + a_{Ni}u_N \\) for some fixed basis \\(\\{u_i\\}_{i=1}^N\\).\n\nIf the vector set \\(\\{x_1, x_2, \\ldots, x_M\\}\\) defines a \\(k\\)-dimensional subspace, then the code is \\([n,k]\\)-linear.\n", "code_id": "gabidulin", "logical": "q-ary_digits", "introduced": "[E. M. Gabidulin, \"Theory of Codes with Maximum Rank Distance\", Problemy Peredachi Informacii, Volume 21, Issue 1, 3\u201316 (1985),10.1109/18.75248]", "name": "Vector code", "short_name": "", "protection": "Set of vectors \\(\\{x_1, x_2, \\ldots, x_M\\}\\) determines a rank code with distance \\(d=\\min d(x_i, x_j)\\). The code with distance \\(d\\) corrects all errors with rank of the error not greater than \\(\\lfloor (d-1)/2\\rfloor\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "maximum_rank_distance", "parent_of_detail": "Vector rank-metric codes with maximum rank.", "_type": "ecc", "_page_id": "c_gabidulin", "_href": "c/gabidulin"}, "c_evaluation": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Evaluation AG code", "physical": "q-ary_digits", "short_name": "", "protection": "", "description": "Stub.", "code_id": "evaluation", "logical": "q-ary_digits", "parents_code_id": "ag", "parents_detail": "", "cousin_of_code_id": "residue", "cousin_of_detail": "Evaluation and residue codes are dual to each other.", "_type": "ecc", "_page_id": "c_evaluation", "_href": "c/evaluation"}, "c_goppa": {"notes": "GAP function GoppaCode(G,L) <https://www.gap-system.org/Manuals/pkg/guava/doc/chap5.html#X7EE808BB7D1E487A> takes in a polynomial \\(G\\) that satisfies the necessary conditions for a Goppa code and a list \\(L\\) that contains elements in \\(GF(q)\\) that are not roots of \\(G\\). It returns a Goppa code.", "realizations": "The binary version \\( (q=2) \\) is commonly used in post-quantum cryptosystems such as the McElise cryptosystem [10.1007/BF00173300].", "physical": "q-ary_digits", "description": "Let \\( G(z) \\)  be a polynomial describing a projective plane curve with coefficients from \\( GF(q^m) \\) for some fixed integer \\(m\\). Let \\( L \\) be a finite subset of the extension field \\( GF(q^m) \\)  where \\(q\\) is prime, meaning \\( L  = \\{\\alpha_1, \\cdots, \\alpha_n\\} \\) is a subset of nonzero elements of \\( GF(q^m) \\). A Goppa code \\( \\Gamma(L,G) \\) is an \\([n,k,d]\\) linear code consisting of all vectors \\(a = a_1, \\cdots, a_n\\) such that \\( R_a(z) =0 \\) modulo \\(G(z)\\), where \\( R_a(z) = \\sum_{i=1}^n \\frac{a_i}{z - \\alpha_i} \\).", "code_id": "goppa", "logical": "q-ary_digits", "introduced": "[V. D. Goppa, \"A new class of linear error-correcting codes\", Probl. Peredach. Inform., vol. 6, no. 3, pp. 24-30, Sept. 1970.,V. D. Goppa, \"Rational representation of codes and (Lg) codes\", Probl. Peredach. Inform., vol. 7, no. 3, pp. 41-49, Sept. 1971.,10.1109/TIT.1973.1055088]", "name": "Goppa code", "short_name": "", "protection": "The length \\( n = |L| \\) , dimension \\( k \\geq n-mr \\) where \\( r = \\text{deg} G(z) \\), and the minimum distance \\( d \\geq r +1 \\).", "features_rate": "There exist Goppa codes defined over larger alphabets that meet the Gilbert-Varshamov, or GV,  bound.", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Algebraic decoding algorithms [10.1109/TIT.1975.1055350].\nIf \\( \\text{deg} G(z) = 2t \\) , then there exists a \\(t\\)-correcting algebraic decoding algorithm for \\( \\Gamma(L,G) \\).", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "alternant\nresidue", "parents_detail": "\n", "cousin_of_code_id": "binary_quantum_goppa\nbch\ngeneralized_reed_solomon", "cousin_of_detail": "Classical Goppa codes are used to construct their quantum versions.\n\n", "_type": "ecc", "_page_id": "c_goppa", "_href": "c/goppa"}, "c_ag": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Algebraic-geometry (AG) code", "physical": "q-ary_digits", "short_name": "", "protection": "", "description": "Stub.", "code_id": "ag", "logical": "q-ary_digits", "parents_code_id": "q-ary_digits_into_q-ary_digits", "parents_detail": "", "parent_of_code_id": "evaluation\nresidue", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_ag", "_href": "c/ag"}, "c_group": {"notes": "See Ch. 16 of Ref. [10.1201/9781315147901] for an introduction to group codes.\nNot all abelian group codes are for cyclic groups (cyclic codes) or for elementary abelian \\( p \\) groups (e.g. Reed Muller codes [10.1007/BF01119999]). For example, there is a binary code with parameters \\( [45,13,16] \\) which is an abelian group code for the group \\( G = \\mathbb{Z}_3 \\times \\mathbb{Z}_{15} \\). ", "realizations": "", "physical": "q-ary_digits", "description": "An \\( [n,k]_{q} \\) code based on a finite group \\( G \\) of size \\(n \\). A group code for an abelian group is called an abelian group code.\n\nThe code is a \\( k \\)-dimensional linear subspace of the group algebra of \\( G\\) with coefficients in the field \\(GF(q) = \\mathbb{F}_q\\) with \\(q\\) elements. To be precise, the code must be closed under permutations corresponding to the elements of the group \\( G \\); therefore, \\( G \\) must be a subgroup of the permutation automorphism group of the code, which is defined as the group of permutations of the physical bits that preserve the code space. This leads us to the formal definition of a group code: a group code is an ideal in the group algebra \\( \\mathbb{F}_q G \\).\n", "code_id": "group", "logical": "q-ary_digits", "introduced": "", "name": "\\(q\\)-ary group code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "q-ary_linear", "parents_detail": "", "cousins_code_id": "cyclic\nreed_muller", "cousins_detail": "A length-\\(n\\) cyclic code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).\nConsider a binary vector space of dimension \\( m \\). Under addition, this forms a finite group with \\( 2^m \\) elements known as an elementary abelian 2-group -- the direct product of \\( m \\) two-element cyclic groups \\( \\mathbb{Z}_2 \\times \\dots \\times \\mathbb{Z}_2 \\). Denote this group by \\( G_m \\). Let \\( J \\) be the Jacobson radical of the group algebra \\( \\mathbb{F}_2 G_m \\). Then, the binary Reed-Muller codes \\( \\text{RM}(r,m) \\) correspond to the ideal \\( J^{m-r} \\). The length of the code is \\( |G_m| = 2^m \\), the distance is \\( 2^{m-r} \\), and the dimension is \\( \\sum_{i=0}^r {m \\choose i} \\). A similar construction exists for choices of a prime \\( p\\neq 2 \\).", "_type": "ecc", "_page_id": "c_group", "_href": "c/group"}, "c_maximum_rank_distance": {"notes": "", "realizations": "", "physical": "q-ary_digits", "description": "Linear rank-metric code with maximum rank \\([n,k,n-k+1]_q\\) over rank metric. For any vector \\(g=(g_1, \\ldots, g_n)\\) with linearly independent elements \\(g_i\\) over \\(GF(q)\\),\nthe generator matrix\n\\begin{align}\nG = \\begin{pmatrix} g_1^{[0]} & g_2^{[0]} & \\ldots & g_n^{[0]} \\\\ g_1^{[1]} & g_2^{[1]} & \\ldots & g_n^{[1]} \\\\ g_1^{[k-1]} & g_2^{[k-1]} & \\ldots & g_n^{[k-1]} \\end{pmatrix}~,\n\\end{align}\nwhere \\([i]:=q^i\\) and \\(k=n-d+1\\) defines a maximum rank distance code.\n", "code_id": "maximum_rank_distance", "logical": "q-ary_digits", "introduced": "[E. M. Gabidulin, \"Theory of Codes with Maximum Rank Distance\", Problemy Peredachi Informacii, Volume 21, Issue 1, 3\u201316 (1985),10.1109/18.75248]", "name": "Maximum-rank vector code", "short_name": "", "protection": "\\(d\\)-distance codes protect agains all errors of rank not greater \\(\\lfloor (d-1)/2\\rfloor\\)", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "gabidulin", "parents_detail": "Vector rank-metric codes with maximum rank.", "cousins_code_id": "reed_solomon", "cousins_detail": "The construction of the generators matrix of both codes uses a Vandermonde matrix.", "_type": "ecc", "_page_id": "c_maximum_rank_distance", "_href": "c/maximum_rank_distance"}, "c_mds": {"notes": "The dual of an MDS codes is always MDS.\nThe codes \\( [[n,1,n]]_q, [[n,n-1,2]]_q, [[n,n,1]]_q \\) for any \\(q\\) are MDS codes. These are called the trivial MDS codes.\nThe only binary MDS codes are the trivial ones.", "realizations": "", "physical": "q-ary_digits", "description": "A \\([n,k,d]_q\\) \\(q\\)-ary linear code is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Singleton bound\n\\begin{align}\nd \\leq n-k+1\n\\end{align}\nbecomes an equality. A bound for general \\(q\\)-ary codes can also be formulated; see Thm. 1.9.10 in Ref. [10.1201/9781315147901].\n", "code_id": "mds", "logical": "q-ary_digits", "introduced": "[10.1109/TIT.1964.1053661]", "name": "Maximum distance separable (MDS) code", "short_name": "MDS", "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error correction properties.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "q-ary_linear\ndistributed_storage", "parents_detail": "\nMDS codes are most efficient in terms of minimizing storage overhead for handling erasures.", "parent_of_code_id": "reed_solomon", "parent_of_detail": "Every Reed-Solomon code is MDS. If \\(k \\leq p\\) then all MDS codes \\( [n,k,n-k+1]_{p^m} \\) are Reed-Solomon codes [10.4171/JEMS/316].", "cousin_of_code_id": "quantum_mds", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_mds", "_href": "c/mds"}, "c_reed_solomon": {"notes": "Decoding Reed-Solomon codes is equivalent to the problem of Polynomial Reconstruction and has applications to cryptography [10.1007/3-540-45465-9_21].", "realizations": "Numerous applications: computer hard-disks, DVDs, digital audio tapes, 3G telephone networks (IS-2000, Release D), NASA deep-space exploration, etc.\nCorrecting pooled testing results for SARS-CoV-2 [10.1126/sciadv.abc5961].", "physical": "q-ary_digits", "description": "An \\([n,k,n-k+1]_q\\) linear code based on polynomials over \\(GF(q)\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(GF(q)\\) with \\(q>n\\). Encodes \\(\\mu=\\{\\mu_0,\\cdots,\\mu_{k-1}\\}\\) into \\(\\{f_\\mu(\\alpha_1),\\cdots,f_\\mu(\\alpha_n)\\}\\), with polynomial\n\\begin{align}\nf_\\mu(x)=\\mu_0+\\mu_1 x + \\cdots + \\mu_{k-1}x^{k-1}.\n\\end{align}\n", "code_id": "reed_solomon", "logical": "q-ary_digits", "introduced": "[10.1214/aoms/1177729387,10.1137/0108018]", "name": "Reed-Solomon (RS) code", "short_name": "", "protection": "Corrects erasures on \\(n-k\\) coordinates.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Berlekamp-Welch decoder [E. R. Berlekamp and L. Welch, Error Correction of Algebraic Block Codes. U.S. Patent, Number 4,633,470 1986.], assuming that \\(t \\geq (n+k)/2\\).", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "generalized_reed_solomon\nmds\ndistributed_storage", "parents_detail": "\nEvery Reed-Solomon code is MDS. If \\(k \\leq p\\) then all MDS codes \\( [n,k,n-k+1]_{p^m} \\) are Reed-Solomon codes [10.4171/JEMS/316].\n", "parent_of_code_id": "folded_reed_solomon", "parent_of_detail": "", "cousins_code_id": "hamming\ncyclic", "cousins_detail": "\nReed-Solomon codes are cyclic whenever the length divides \\(q-1\\).", "cousin_of_code_id": "quantum_secret_sharing\nbch\nconvolutional\ngalois_polynomial\nmaximum_rank_distance\npolynomial", "cousin_of_detail": "The classical information in this code is encoded using a Reed-Solomon code.\n\nConvolutional codes are often used in concatenation with Reed-Solomon codes for communication [10.1002/0470866969].\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.\nThe construction of the generators matrix of both codes uses a Vandermonde matrix.\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.", "_type": "ecc", "_page_id": "c_reed_solomon", "_href": "c/reed_solomon"}, "c_group_classical": {"notes": "", "realizations": "", "physical": "groups", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates labeled by elements of a group \\(G\\).", "code_id": "group_classical", "logical": "points", "introduced": "", "name": "Group-based code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "ecc", "parents_detail": "", "cousins_code_id": "bits_into_bits\npoints_into_lattices", "cousins_detail": "Group-based codes whose alphabet is based on the group \\(\\mathbb{Z}_2\\) are binary codes.\nGroup-based codes whose alphabet is based on the group \\(\\mathbb{R}\\) are lattice-based codes.", "_type": "ecc", "_page_id": "c_group_classical", "_href": "c/group_classical"}, "c_points_into_spheres": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Spherical code", "physical": "points", "short_name": "", "protection": "", "description": "Encodes states (codewords) into points on an \\(n\\)-dimensional sphere \\(S^n\\).", "code_id": "points_into_spheres", "logical": "spheres", "parents_code_id": "ecc", "parents_detail": "", "_type": "ecc", "_page_id": "c_points_into_spheres", "_href": "c/points_into_spheres"}, "c_dual": {"notes": "", "realizations": "", "physical": "q-ary_digits", "description": "For any  \\([n,k]\\) binary or \\(q\\)-ary linear code \\(C\\), the dual code,\n\\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{\\times n} ~|~ x\\cdot y=0 \\forall x\\in C\\},\n\\end{align}\nis the row space of the parity check matrix of \\(C\\). The dual code is the kernel of the encoding map for \\(C\\), and \\(\\dim C^\\perp = n-k\\).\n\nA code that contains its dual, \\(C^\\perp \\subseteq C\\), is called weakly self-dual or self-orthogonal. A code that is equal to its dual, \\(C^\\perp = C\\), is called self-dual. The dual of a dual code is the original code.\n", "code_id": "dual", "logical": "q-ary_digits", "introduced": "[10.1201/9781315147901]", "name": "Dual linear code", "short_name": "", "protection": "The dual of an \\([n,k,d] \\) code is an \\([n,n-k,d']\\) code, where \\(d'\\) is not always related to \\(d\\). The generator matrix of \\(C^\\perp\\) is the parity check matrix of \\(C\\), and visa versa.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "ecc", "parents_detail": "", "cousin_of_code_id": "css\nhadamard\nmajorana_stab", "cousin_of_detail": "CSS codes for which \\(C_X=C_Z \\equiv C\\) are called weakly self-dual since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\).\nThe Hadamard code is the dual of the extended Hamming Code.\nClassical weakly self-dual codes can be used to construct Majorana stabilizer codes [1703.00459]. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a weakly self-dual classical code. A weakly self-dual classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\).", "_type": "ecc", "_page_id": "c_dual", "_href": "c/dual"}, "c_perfect": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Perfect code", "physical": "", "short_name": "", "protection": "", "description": "An \\((n,K,2t+1)_q\\) \\(q\\)-ary code is perfect if parameters \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the Hamming (a.k.a. sphere-packing) bound\n\\begin{align}\n\\sum_{j=0}^{t}(q-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a binary \\(q=2\\) code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\). Any nontrivial perfect linear code is either a Hamming code or a binary or ternary Golay code.\n\nPerfect codes are those for which balls of Hamming radius \\(t\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings. Quasi-perfect codes are those for which balls of Hamming radius \\(t\\) are disjoint, while balls of radius \\(t+1\\) cover the space with possible overlaps.\n\nFor binary codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-H(t/n),\n\\end{align}\nwhere \\(H\\) is the binary entropy function.\n", "code_id": "perfect", "logical": "", "parents_code_id": "ecc", "parents_detail": "", "cousin_of_code_id": "homological_classical\nhamming\nquantum_perfect", "cousin_of_detail": "A family of homology codes saturate the asymptotic Hamming bound [quant-ph/0605094].\n\nA classical (quantum) perfect code saturates the classical (quantum) Hamming bound.", "_type": "ecc", "_page_id": "c_perfect", "_href": "c/perfect"}, "c_ldpc": {"notes": "", "realizations": "", "physical": "bits", "description": "Stub.\n\nStrictly speaking, the term parity check describes only bitwise qubit error syndromes. Nevertheless, \\(q\\)-ary linear codes satisfying the above criteria are also called LDPC codes.\n", "code_id": "ldpc", "logical": "bits", "introduced": "", "name": "Low-density parity-check (LDPC) code", "short_name": "LDPC", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "ecc", "parents_detail": "", "cousins_code_id": "parity_check", "cousins_detail": "Binary LDPC codes are parity check codes.", "cousin_of_code_id": "qldpc", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_ldpc", "_href": "c/ldpc"}, "c_ipp": {"notes": "", "realizations": "", "physical": "q-ary_digits", "description": "Stub.", "code_id": "ipp", "logical": "q-ary_digits", "introduced": "[10.1006/jcta.1997.2851]", "name": "Identifiable parent property (IPP) code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "ecc", "parents_detail": "", "_type": "ecc", "_page_id": "c_ipp", "_href": "c/ipp"}, "c_alternant": {"notes": "", "realizations": "", "physical": "q-ary_digits", "description": "Stub.", "code_id": "alternant", "logical": "q-ary_digits", "introduced": "[10.1016/S0019-9958(74)80005-7]", "name": "Alternant code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "q-ary_linear", "parents_detail": "", "parent_of_code_id": "bch\ngeneralized_reed_solomon\ngoppa", "parent_of_detail": "\n\n", "_type": "ecc", "_page_id": "c_alternant", "_href": "c/alternant"}, "c_random": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Random code", "physical": "", "short_name": "", "protection": "", "description": "Code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes, to codes whose multi-step construction is deterministic with the exception of a single step.", "code_id": "random", "logical": "", "parents_code_id": "ecc", "parents_detail": "", "cousin_of_code_id": "quantum_random", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_random", "_href": "c/random"}, "c_cyclic": {"notes": "", "realizations": "", "physical": "q-ary_digits", "description": "A classical code \\(C\\) of length \\(n\\) over an alphabet is cyclic if, for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\in C\\).", "code_id": "cyclic", "logical": "q-ary_digits", "introduced": "", "name": "Cyclic code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "quasi_cyclic", "parents_detail": "", "parent_of_code_id": "quad_residue", "parent_of_detail": "", "cousin_of_code_id": "bch\ngalois_polynomial\nmajorana_stab\npolynomial\nquantum_cyclic\nreed_solomon\ngroup", "cousin_of_detail": "\n\nCyclic codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also weakly self-dual [1703.00459].\n\n\nReed-Solomon codes are cyclic whenever the length divides \\(q-1\\).\nA length-\\(n\\) cyclic code is an abelian group code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\).", "_type": "ecc", "_page_id": "c_cyclic", "_href": "c/cyclic"}, "c_quad_residue": {"notes": "", "realizations": "", "physical": "q-ary_digits", "description": "Stub.", "code_id": "quad_residue", "logical": "q-ary_digits", "introduced": "", "name": "Quadratic-residue code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "cyclic", "parents_detail": "", "cousin_of_code_id": "hamming", "cousin_of_detail": "\\([7,4,3]\\) Hamming code is a quadratic-residue code [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977].", "_type": "ecc", "_page_id": "c_quad_residue", "_href": "c/quad_residue"}, "c_skew_cyclic": {"notes": "Computer algebra software is used to find most codes of this type. Ref. [math/0604603] gives several examples of codes, which have slightly improved minimum distance for some \\((n,k)\\) codes.", "realizations": "Not directly implemented, but BCH codes form a subclass, and are used in DVD, solid state drive storage, etc.", "physical": "q-ary_digits", "description": "A classical code \\(C\\) of length \\(n\\) over an alphabet \\(R\\) is skew-cyclic if there exists an automorphism, \\(\\theta\\), of \\(R\\), such that for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the skew-cyclically shifted string \\(\\theta(c_n) \\theta(c_1) \\cdots \\theta(c_{n-1})\\in C\\). We say that \\(C\\) is a \\(\\theta\\)-cyclic code over \\(R\\).", "code_id": "skew_cyclic", "logical": "q-ary_digits", "introduced": "[math/0604603]", "name": "Skew-cyclic code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Only given for skew-BCH codes, adapted froom standard BCH codes.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "quasi_cyclic", "parents_detail": "Under certain conditions, there is an equivalent quasi-cyclic code for every skew-cyclic code [10.1504/IJICOT.2011.044674].", "cousins_code_id": "bch", "cousins_detail": "", "cousin_of_code_id": "skew-cyclic_galois_css", "cousin_of_detail": "Skew-cyclic CSS codes are constructed from classical skew-cylic codes.", "_type": "ecc", "_page_id": "c_skew_cyclic", "_href": "c/skew_cyclic"}, "c_quasi_cyclic": {"notes": "", "realizations": "", "physical": "q-ary_digits", "description": "Stub.", "code_id": "quasi_cyclic", "logical": "q-ary_digits", "introduced": "[10.1109/TIT.1967.1053974]", "name": "Quasi-cyclic code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "cyclic\nskew_cyclic", "parent_of_detail": "\nUnder certain conditions, there is an equivalent quasi-cyclic code for every skew-cyclic code [10.1504/IJICOT.2011.044674].", "_type": "ecc", "_page_id": "c_quasi_cyclic", "_href": "c/quasi_cyclic"}, "c_parallel_concatenated": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Parallel concatenated code", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "parallel_concatenated", "logical": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "tanner", "parent_of_detail": "", "cousins_code_id": "concatenated", "cousins_detail": "", "_type": "ecc", "_page_id": "c_parallel_concatenated", "_href": "c/parallel_concatenated"}, "c_generalized_concatenated": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Generalized concatenated code", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "generalized_concatenated", "logical": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "concatenated", "parent_of_detail": "", "cousin_of_code_id": "polar", "cousin_of_detail": "Polar codes can be represented as generalized concatenations of their kernels.", "_type": "ecc", "_page_id": "c_generalized_concatenated", "_href": "c/generalized_concatenated"}, "c_concatenated": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "[G. D. Forney, Jr (1966). Concatenated Codes. MIT Press, Cambridge, MA.]", "notes": "", "realizations": "", "name": "Concatenated code", "physical": "", "short_name": "", "protection": "", "description": "Also called a serially concatenated code [10.1109/TIT.2005.846392]. Stub.", "code_id": "concatenated", "logical": "", "parents_code_id": "generalized_concatenated", "parents_detail": "", "cousin_of_code_id": "parallel_concatenated", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_concatenated", "_href": "c/concatenated"}, "c_codes_with_availability": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Availability code", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "codes_with_availability", "logical": "", "parents_code_id": "parallel_recovery", "parents_detail": "", "_type": "ecc", "_page_id": "c_codes_with_availability", "_href": "c/codes_with_availability"}, "c_parallel_recovery": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Parallel-recovery code", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "parallel_recovery", "logical": "", "parents_code_id": "sequential_recovery", "parents_detail": "", "parent_of_code_id": "codes_with_availability", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_parallel_recovery", "_href": "c/parallel_recovery"}, "c_distributed_storage": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Distributed-storage code", "physical": "", "short_name": "", "protection": "", "description": "Designed to encode information into spatial nodes such that it is possible to recover said information after failure of some nodes by accessing the remaining nodes with minimal bandwidth. Stub.", "code_id": "distributed_storage", "logical": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "locally_recoverable\nmds\nreed_solomon\nregenerating", "parent_of_detail": "\nMDS codes are most efficient in terms of minimizing storage overhead for handling erasures.\n\n", "_type": "ecc", "_page_id": "c_distributed_storage", "_href": "c/distributed_storage"}, "c_sequential_recovery": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Sequential-recovery code", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "sequential_recovery", "logical": "", "parents_code_id": "locally_recoverable", "parents_detail": "", "parent_of_code_id": "parallel_recovery", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_sequential_recovery", "_href": "c/sequential_recovery"}, "c_locally_recoverable": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Locally recoverable code (LRC)", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "locally_recoverable", "logical": "", "parents_code_id": "distributed_storage", "parents_detail": "", "parent_of_code_id": "sequential_recovery", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_locally_recoverable", "_href": "c/locally_recoverable"}, "c_rings_into_rings": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Ring code", "physical": "rings", "short_name": "", "protection": "", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates over a ring \\(R\\).", "code_id": "rings_into_rings", "logical": "rings", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "rings_linear", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_rings_into_rings", "_href": "c/rings_into_rings"}, "c_quaternary_over_z4": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Quaternary code over \\(\\mathbb{Z}_4\\)", "physical": "rings", "short_name": "", "protection": "", "description": "A linear code encoding \\(K\\) states (codewords) in \\(n\\) coordinates over the ring \\(\\mathbb{Z}_4\\) of integers modulo 4.", "code_id": "quaternary_over_z4", "logical": "rings", "parents_code_id": "rings_linear", "parents_detail": "", "_type": "ecc", "_page_id": "c_quaternary_over_z4", "_href": "c/quaternary_over_z4"}, "c_rings_linear": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "\\(R\\)-linear code", "physical": "rings", "short_name": "", "protection": "", "description": "A code of length \\(n\\) over a ring \\(R\\) is \\(R\\)-linear if it is a submodule of \\(R^n\\).", "code_id": "rings_linear", "logical": "rings", "parents_code_id": "rings_into_rings", "parents_detail": "", "parent_of_code_id": "quaternary_over_z4", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_rings_linear", "_href": "c/rings_linear"}, "c_points_into_lattices": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Lattice-based code", "physical": "points", "short_name": "", "protection": "", "description": "Encodes states (codewords) in coordinates of a lattice in the \\(n\\)-dimensional real coordinate space \\(\\mathbb{R}^n\\). The number of codewords may be infinite because the coordinate space is infinite-dimensional, so various restricted versions have to be constructed in practice. Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.", "code_id": "points_into_lattices", "logical": "lattices", "parents_code_id": "ecc", "parents_detail": "Error-correcting codes are defined for a finite alphabet, so only finite lattice-based codes are children.", "cousins_code_id": "binary_linear", "cousins_detail": "Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.", "cousin_of_code_id": "group_classical\nmultimodegkp", "cousin_of_detail": "Group-based codes whose alphabet is based on the group \\(\\mathbb{R}\\) are lattice-based codes.\nMultimode GKP codes are quantum analogues of lattice-based codes.", "_type": "ecc", "_page_id": "c_points_into_lattices", "_href": "c/points_into_lattices"}, "c_convolutional": {"notes": "", "realizations": "A type of convolutional code used in Real-time Application networks [10.5815/ijcnis.2014.07.03].\nMobile and radio communications (3G networks) use convolutional codes concatenated with Reed-Solomon codes to obtain suitable performance [10.1002/0470866969].\nA convolutional code with rate 1/2 was used for deep-space and satellite communication [Butman, Deutsch, and Miller. Performance of concatenated codes for deep space missions. 1981.]", "physical": "bits", "description": "Classical codes that are formed using generator polynomials over the finite field with two elements. The encoder slides across contiguous subsets of the input bit-string (like a convolutional neural network) evaluating the polynomials on that window to obtain a number of parity bits. These parity bits are the encoded information. There are many ways to formulate these codes", "code_id": "convolutional", "logical": "bits", "introduced": "[Peter Elias. Coding for noisy channels. IRE Convention Records, 3(4):37\u201346, 1955.]", "name": "Convolutional code", "short_name": "", "protection": "", "features_rate": "Depends on the polynomials used. Using puncturing removal [10.12928/telkomnika.v10i4.171] the rate for the code can be increased from \\(\\frac{1}{t}\\) to \\(\\frac{s}{t}\\), where \\(t\\) is the number of output bits, and \\(s\\) depends on the puncturing done. This is done by deleting some pieces of the encoder output such that the most-likely decoders remain effective", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Decoders based on the Viterbi algorithm (trellis decoding) were developed first, which result in the most-likely codeword for the encoded bits [10.1109/TIT.1967.1054010]. Following, other trellis decoders such as the BCJR decoding algorithm [10.1109/TIT.1974.1055186] were developed later.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Evaluation on the generator polynomials. Can be implemented with a small number of XOR gates", "parents_code_id": "bits_into_bits", "parents_detail": "", "cousins_code_id": "quantum_convolutional\nreed_solomon", "cousins_detail": "Quantum analogue of convolutional codes\nConvolutional codes are often used in concatenation with Reed-Solomon codes for communication [10.1002/0470866969].", "_type": "ecc", "_page_id": "c_convolutional", "_href": "c/convolutional"}, "c_hadamard": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Hadamard code", "physical": "bits", "short_name": "", "protection": "", "description": "The Hadamard code is dual to the extended Hamming Code.", "code_id": "hadamard", "logical": "bits", "parents_code_id": "binary_linear", "parents_detail": "", "cousins_code_id": "dual\nhamming\nreed_muller", "cousins_detail": "The Hadamard code is the dual of the extended Hamming Code.\nThe Hadamard code is the dual of the extended Hamming Code. Conversely, the shortened Hadamard code is the dual of the Hamming Code.\nFor any Hamming code \\([2^m,2^m-m-1,3]\\), the dual Hadamard code, when augmented with a bit that is always 0, gives the \\(R(1,m)\\) 1st order Reed-Muller code. In general, \\(R(1,m)\\) is related to the duals of the Hamming code, and when \\(R(1,m)\\) is self dual, it is directly related to the Hamming code.", "_type": "ecc", "_page_id": "c_hadamard", "_href": "c/hadamard"}, "c_single_parity_check": {"notes": "", "realizations": "Can be realized on almost every communication device.", "physical": "bits", "description": "An \\([n,n-1,2]\\) binary linear error-detecting code encoding an \\(n\\)-bit codeword into an \\((n+1)\\)-bit string. In this code, parity information of a codeword is sotred in an extra parity bit. If the Hamming weight of a codeword is odd, then its parity is 1. If the Hamming weight of a codeword is even, then its parity is 0. This code is inexpensive since it only requires an extra parity bit and a single parity check. ", "code_id": "single_parity_check", "logical": "bits", "introduced": "", "name": "Single parity-check code", "short_name": "", "protection": "This code cannot protect information, it can only detect 1-bit error.", "features_rate": "The code rate is \\(\\frac{n}{n+1}\\to 1\\) as \\(n\\to\\infty\\). The code distance is 2.", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "If the receiver finds that the parity information of a codeword disagrees with the parity bit, then the receiver will discard the information and request a resend.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Concatenate the codeword with a parity bit which encodes the parity information of codeword.", "parents_code_id": "parity_check", "parents_detail": "", "cousins_code_id": "repetition", "cousins_detail": "Repetition code is dual to the single-parity check code.", "_type": "ecc", "_page_id": "c_single_parity_check", "_href": "c/single_parity_check"}, "c_tanner": {"notes": "", "realizations": "", "physical": "bits", "description": "Stub.", "code_id": "tanner", "logical": "bits", "introduced": "[10.1109/TIT.1981.1056404]", "name": "Tanner code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "binary_linear\nparallel_concatenated", "parents_detail": "\n", "parent_of_code_id": "expander", "parent_of_detail": "", "cousin_of_code_id": "expander_lifted_product", "cousin_of_detail": "Expander lifted-product codes are products of Tanner codes defined on expander graphs.", "_type": "ecc", "_page_id": "c_tanner", "_href": "c/tanner"}, "c_polar": {"notes": "There are multiple variants of the basic construction, in particular relying on other kernel matrices. The codes can be defined for nonbinary alphabets, and they can be adjusted to support tasks such as lossless and lossy compression, successive refinement, communication over the mulitple access channel, communication over the wiretap channel, and many others.\nDescribed in Ch. 32 of Ref. [10.1201/9781315147901].", "realizations": "Code control channels for the 5G NR (New Radio) interfaces.", "physical": "bits", "description": "In its basic version, a binary linear polar code encodes \\(K\\) message bits into \\(N=2^n\\) bits. The linear transformation that defines the code is given by the matrix \\(G^{(n)}=B_N G^{\\otimes n}\\), where \\(B_N\\) is a certain \\(N\\times N\\) permutation matrix, and \\(G^{\\otimes n}\\) is the \\(n\\)th Kronecker power of the \\(2\\times 2\\) kernel matrix \\(G=\\left[\\begin{smallmatrix}1 & 0\\\\ 1 & 1 \\end{smallmatrix}\\right]\\). To encode \\(K\\) message bits, one forms an \\(N\\)-vector \\(u\\) in which \\(K\\) coordinates represent the message bits. The remaining \\(N-K\\) coordinates are set to some fixed values and are said to be frozen. The codeword \\(x \\in \\{0,1\\}^N\\) is obtained as \\(x=u G^{\\otimes n}\\). The choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.", "code_id": "polar", "logical": "bits", "introduced": "[10.1109/TIT.2009.2021379]", "name": "Polar code", "short_name": "", "protection": "Protects against various types of noise in the communication channel, for instance, errors, erasures, or other types of noise. Distance plays no role in the analysis of its properties, and is much lower than the largest possible value given \\(K,N\\).", "features_rate": "Supports reliable transmission at rates \\(K/N\\) approaching the Shannon capacity of the channel.", "features_threshold": "Achieves Shannon capacity of the binary-input memoryless channel under successive cancellation decoder [10.1109/TIT.2009.2021379].", "features_magic_scaling_exponent": "", "features_decoders": "Successive cancellation decoder [10.1109/TIT.2009.2021379].\nSuccessive cancellation list decoder [10.1109/TIT.2015.2410251].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "binary_linear", "parents_detail": "", "cousins_code_id": "reed_muller\ngeneralized_concatenated", "cousins_detail": "Reed-Muller code relies on the same generator matrix, but places message bits in different coordinates.\nPolar codes can be represented as generalized concatenations of their kernels.", "cousin_of_code_id": "quantum_polar", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_polar", "_href": "c/polar"}, "c_repetition": {"notes": "", "realizations": "Repetition codes were used in magnetic disks.", "physical": "bits", "description": "\\([n,1,n]\\) binary linear code encoding one bit of information into an \\(n\\)-bit string. The length \\(n\\) needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a \\((n,1)\\)-Hamming code.", "code_id": "repetition", "logical": "bits", "introduced": "[10.1201/9781315147901]", "name": "Binary repetition code", "short_name": "", "protection": "Detects errors on up to \\(\\frac{n-1}{2}\\) coordinates, corrects erasure errors on up to \\(\\frac{n-1}{2}\\) coordinates. The generator matrix is \\(G=\\left[\\begin{smallmatrix}1 & 1&\\cdots& 1 & 1 \\end{smallmatrix}\\right]\\).", "features_rate": "Code rate is \\(\\frac{1}{n}\\), code distance is \\(n\\).", "features_threshold": "Suppose each bit has probability \\(p\\) of being received correctly, independent for each bit. The probability that a repetition code is received correctly is \\(\\sum_{k=0}^{(n-1)/2}\\frac{n!}{k!(n-k)!}p^{n-k}(1-p)^{k}\\). If \\(\\frac{1}{2}\\leq p\\), then people can always increase the probability of success by increasing the number of physical bit \\(n\\).", "features_magic_scaling_exponent": "", "features_decoders": "Calculate the Hamming weight \\(d_H\\) of the code. If \\(d_H\\leq \\frac{n-1}{2}\\), decode the code as 0. If \\(d_H\\geq \\frac{n+1}{2}\\), decode the code as 1.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "hamming", "parents_detail": "A \\([n,1,n]\\) repetition code is an \\((n,1)\\) Hamming code.", "cousins_code_id": "quantum_repetition", "cousins_detail": "", "cousin_of_code_id": "single_parity_check", "cousin_of_detail": "Repetition code is dual to the single-parity check code.", "_type": "ecc", "_page_id": "c_repetition", "_href": "c/repetition"}, "c_binary_linear": {"notes": "Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by A. E. Brouwer [Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.], are maintained by M. Grassl at this website <http://codetables.markus-grassl.de/>.", "realizations": "", "physical": "bits", "description": "An \\((n,2^k,d)\\) linear code is denoted as \\([n,k,d]\\). Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword. A code that is not linear is called nonlinear.\n\nLinear codes can be defined in terms of a generator matrix \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a codeword \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its standard or systematic form \\(G = [I_k A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) binary matrix.\n", "code_id": "binary_linear", "logical": "bits", "introduced": "", "name": "Linear binary code", "short_name": "", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set for which no two elements of the set add up to a codeword.\n\nLinear codes admit a parity check matrix \\(H\\), whose columns make up a set of parity checks, i.e., a maximal linearly independent set of vectors that are in the kernel of \\(G\\). It follows that\n\\begin{align}\n  G H^{\\text{T}} = 0 \\mod 2~.\n\\end{align}\n", "features_rate": "A family of linear codes \\(C_i = [n_i,k_i,d_i]\\) is asymptotically good if the asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "bits_into_bits", "parents_detail": "", "parent_of_code_id": "homological_classical\nhadamard\nhamming\nparity_check\npolar\nreed_muller\ntanner", "parent_of_detail": "\n\n\n\n\n\n", "cousin_of_code_id": "css\nfock_state\npoints_into_lattices\nqubit_stabilizer", "cousin_of_detail": "Construction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\).\nFock-state code distance is a natural extension of Hamming distance between binary strings.\nSince lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.\nQubit stabilizer codes are quantum analogues of binary linear codes.", "_type": "ecc", "_page_id": "c_binary_linear", "_href": "c/binary_linear"}, "c_parity_check": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Parity-check code", "physical": "bits", "short_name": "", "protection": "", "description": "Stub.", "code_id": "parity_check", "logical": "bits", "parents_code_id": "binary_linear", "parents_detail": "", "parent_of_code_id": "single_parity_check", "parent_of_detail": "", "cousin_of_code_id": "ldpc", "cousin_of_detail": "Binary LDPC codes are parity check codes.", "_type": "ecc", "_page_id": "c_parity_check", "_href": "c/parity_check"}, "c_hamming": {"notes": "Has the maximum rate among binary codes for that block length and with minimum distance 3. Therefore, it is a perfect code, i.e, it saturates the Hamming Bound.", "realizations": "Commonly used when error rates are very low, for example, computer RAM.", "physical": "bits", "description": "Hamming codes are an infinite family of linear codes with parameters \\((2^r-1,2^r-r-1, 3)\\) for \\(r \\geq 3\\). The \\(r \\times (2^r-1) \\) parity check matrix \\(H\\) has all possible non-zero \\(r\\)-bit strings as its columns. The codewords are \\(\\{x|Hx=0\\}\\).", "code_id": "hamming", "logical": "bits", "introduced": "[10.1002/j.1538-7305.1950.tb00463.x]", "name": "Hamming code", "short_name": "", "protection": "Can detect 1-bit and 2-bit errors, and can correct 1-bit errors.", "features_rate": "Asymptotic rate \\(k/n = 1-\\frac{\\log n}{n} \\to 1\\) and normalized distance \\(d/n \\to 0\\).", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "binary_linear", "parents_detail": "", "parent_of_code_id": "repetition", "parent_of_detail": "A \\([n,1,n]\\) repetition code is an \\((n,1)\\) Hamming code.", "cousins_code_id": "perfect\nquad_residue\nquantum_hamming", "cousins_detail": "\n\\([7,4,3]\\) Hamming code is a quadratic-residue code [F. J. MacWilliams and N. J. A. Sloane. The theory of error correcting codes. Elsevier, 1977].\n", "cousin_of_code_id": "hadamard\nreed_solomon\nsteane\nquantum_hamming_css", "cousin_of_detail": "The Hadamard code is the dual of the extended Hamming Code. Conversely, the shortened Hadamard code is the dual of the Hamming Code.\n\nThe Steane code is constructed from a classical Hamming code.\nQuantum Hamming codes result from applying the CSS construction to Hamming codes.", "_type": "ecc", "_page_id": "c_hamming", "_href": "c/hamming"}, "c_bch": {"notes": "", "realizations": "", "physical": "bits", "description": "Stub.", "code_id": "bch", "logical": "bits", "introduced": "[10.1016/s0019-9958(60)90287-4]", "name": "Bose\u2013Chaudhuri\u2013Hocquenghem (BCH) code", "short_name": "BCH", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "alternant", "parents_detail": "", "cousins_code_id": "reed_solomon\ncyclic\ngoppa", "cousins_detail": "\n\n", "cousin_of_code_id": "generalized_reed_solomon\nskew_cyclic", "cousin_of_detail": "\n", "_type": "ecc", "_page_id": "c_bch", "_href": "c/bch"}, "c_homological_classical": {"notes": "", "realizations": "", "physical": "bits", "description": "This code's properties are derived from the size two chain complex associated with a particular graph. Given a connected simplicial (no self loops or muliedges) graph \\(G = (V, E)\\), which is not a tree, with incidence matrix \\(\\Gamma\\) we can construct a code by choosing a parity check matrix which consists of all the linearly independent rows of \\(\\Gamma\\). This is a \\([n,k,d]\\) code with \\(n = |E|\\), \\(k = 1 - \\mathcal{X}(G) = 1-|V|+|E|\\), where \\( \\mathcal{X}(G)\\) is the euler characteristic of the graph. The code distance is equal to the shortest size of a cycle, guaranteed to exist since \\(G\\) is not a tree.\n", "code_id": "homological_classical", "logical": "bits", "introduced": "[quant-ph/0605094]", "name": "Graph homology code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "binary_linear", "parents_detail": "", "cousins_code_id": "perfect\ncss", "cousins_detail": "A family of homology codes saturate the asymptotic Hamming bound [quant-ph/0605094].\nCSS codes can also be constructed using homology techniques but for manifolds of dimension two or greater.", "_type": "ecc", "_page_id": "c_homological_classical", "_href": "c/homological_classical"}, "c_reed_muller": {"notes": "", "realizations": "", "physical": "bits", "description": "Stub.", "code_id": "reed_muller", "logical": "bits", "introduced": "[10.1109/irepgelc.1954.6499441,10.1109/tit.1954.1057465]", "name": "Reed-Muller code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "binary_linear", "parents_detail": "", "cousin_of_code_id": "hadamard\nmajorana_stab\npolar\nquantum_reed_muller\ngroup", "cousin_of_detail": "For any Hamming code \\([2^m,2^m-m-1,3]\\), the dual Hadamard code, when augmented with a bit that is always 0, gives the \\(R(1,m)\\) 1st order Reed-Muller code. In general, \\(R(1,m)\\) is related to the duals of the Hamming code, and when \\(R(1,m)\\) is self dual, it is directly related to the Hamming code.\nMajorana stabilizer codes can be constructed by weakly self-dual Reed-Muller codes [1703.00459]. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code.\nReed-Muller code relies on the same generator matrix, but places message bits in different coordinates.\nReed-Muller codes are the classical anologue of these codes.\nConsider a binary vector space of dimension \\( m \\). Under addition, this forms a finite group with \\( 2^m \\) elements known as an elementary abelian 2-group -- the direct product of \\( m \\) two-element cyclic groups \\( \\mathbb{Z}_2 \\times \\dots \\times \\mathbb{Z}_2 \\). Denote this group by \\( G_m \\). Let \\( J \\) be the Jacobson radical of the group algebra \\( \\mathbb{F}_2 G_m \\). Then, the binary Reed-Muller codes \\( \\text{RM}(r,m) \\) correspond to the ideal \\( J^{m-r} \\). The length of the code is \\( |G_m| = 2^m \\), the distance is \\( 2^{m-r} \\), and the dimension is \\( \\sum_{i=0}^r {m \\choose i} \\). A similar construction exists for choices of a prime \\( p\\neq 2 \\).", "_type": "ecc", "_page_id": "c_reed_muller", "_href": "c/reed_muller"}, "c_expander": {"notes": "", "realizations": "", "physical": "bits", "description": "Expander codes are binary linear codes whose parity check matrices are derived from the adjacency matrix of bipartite expander graphs. In particular, the rows of the parity check matrix correspond to the right nodes of the bipartite graph and the columns correspond to the left nodes. The codespace is equivalent to all subsets of the left nodes in the graph that have an even number of edges going into every right node of the graph. Since the expander graph is only left regular, these codes do not qualify as LDPC codes.\n\nExpander codes are important because they admit efficient encoding and decoding algorithms and are asymptotically good (i.e., their rate and normalized distance are constant). The rate and distance of the expander code depend on specific parameters of the corresponding graph. A (\\(n, m, D, \\gamma, \\alpha\\)) bipartite expander graph is defined as a \\(D\\)-left-regular graph with \\(n\\) left nodes, and \\(m\\) right nodes such that for any subset of left nodes \\(S\\) of size at most \\(\\gamma n\\) the neighborhood \\(N(S)\\) is at least of size \\(\\alpha|S|\\). Given a (\\(n, m, D, \\gamma, (1-\\epsilon)D\\)) expander graph, the corresponding expander code has rate of \\(1 - m/n\\) and a distance of at least \\(2(1-\\epsilon)\\gamma n\\) for any \\(\\epsilon < 1/2\\). Explicit constructions for expander graphs with any ratio \\(n/m\\) are known where \\(D = \\text{polylog}(n/m)\\), \\(\\gamma = \\Omega(1/D)\\) and arbitrary \\(\\epsilon\\) [10.1145/509907.510003].\n", "code_id": "expander", "logical": "bits", "introduced": "[10.1109/18.556667]", "name": "Expander code", "short_name": "", "protection": "Bit flip errors of weight at most \\((d-1)/2\\) where \\(d\\) is the distance of the code and is linear in \\(n\\), the number of physical bits.", "features_rate": "The rate is \\(1 - m/n\\) where \\(n\\) is the number of left nodes and \\(m\\) is the number of right nodes in the bipartite expander graph.", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Decoding can be done in \\(O(n)\\) runtime using a greedy algorithm. The algorithm consists of flipping a bit of the received word if it will result in a greater number of satisfied parity checks. This is repeated until a codeword is reached.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Multiplication by generator matrix with runtime \\(O(n^2)\\)", "parents_code_id": "tanner", "parents_detail": "", "cousin_of_code_id": "quantum_expander", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_expander", "_href": "c/expander"}, "c_bits_into_bits": {"notes": "", "realizations": "", "physical": "bits", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) binary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)\\). The distance is the minimum Hamming distance between a pair of distinct codewords.", "code_id": "bits_into_bits", "logical": "bits", "introduced": "", "name": "Binary code", "short_name": "", "protection": "A binary code \\(C\\) corrects \\(t\\) errors if\n\\begin{align}\n  \\forall x \\in C~,~D(x,x+y) < D(x' , x+y)\n\\end{align}\nfor all codewords \\(x' \\neq x\\) and all \\(y\\) such that \\(|y|=t\\), where \\(D\\) is the Hamming distance and \\(|y| = D(y,0) \\). A code corrects \\(t\\) errors if and only if \\(d \\geq 2t+1\\), i.e., a code corrects errors on \\(t \\leq \\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates. In addition, a code detects errors on up to \\(d-1\\) coordinates, and corrects erasure errors on up to \\(d-1\\) coordinates.\n", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "For few-bit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.\nGiven a received string \\(x\\) and an error bound \\(e\\), a list decoder returns a list of all codewords that are at most \\(e\\) from \\(x\\) in Hamming distance. The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\).", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "ecc", "parents_detail": "", "parent_of_code_id": "convolutional\nbinary_linear", "parent_of_detail": "\n", "cousin_of_code_id": "group_classical\nmovassagh_ouyang", "cousin_of_detail": "Group-based codes whose alphabet is based on the group \\(\\mathbb{Z}_2\\) are binary codes.\nMovassagh-Ouyang codes are constructed from classical binary codes.", "_type": "ecc", "_page_id": "c_bits_into_bits", "_href": "c/bits_into_bits"}, "c_oecc": {"notes": "", "realizations": "", "physical": "", "description": "A subsystem code, also known as an operator or gauge QECC, encodes information in a subsystem \\(\\mathsf{A}\\) of the code space \\(\\mathsf{C}\\), which is part of the system Hilbert space \\(\\mathsf{H}\\).\n\\begin{align}\n\\mathsf{H}=\\mathsf{C} \\oplus \\mathsf{C}^{\\perp} = \\mathsf{A} \\otimes \\mathsf{B} \\oplus \\mathsf{C}^{\\perp}\n\\end{align}\nFollowing an error, it is sufficient to revert back to the original state modulo a transformation on the auxiliary or gauge subsystem \\(\\mathsf{B}\\). The subsystem \\(\\mathsf{B}\\) therefore gives additional freedom to the error correction process, and is said to encode gauge qubits when its dimension is a power of two. While strictly speaking all operator QECCs are also ordinary QECCs, the attachment of a subsystem to a code can yield more efficient correction procedures and a wider variety of encoding procedures.\n", "code_id": "oecc", "logical": "", "introduced": "[quant-ph/0412076,quant-ph/0504189]", "name": "Subsystem quantum error-correcting code", "short_name": "Subsystem QECC", "protection": "Necessary and sufficient [quant-ph/0506069] error-correction conditions are, for all errors \\(E_a,E_b\\) in an error set \\(\\cal{E}\\),\n\\begin{align}\nP E^{\\dagger}_a E_b P = I_{\\mathsf{A}} \\otimes g_{ab}^{\\mathsf{B}}\n\\end{align}\nwhere \\(P\\) is a projector onto the codespace \\(\\mathsf{C}\\), and \\(g_{ab}^{\\mathsf{B}}\\) is an arbitrary operator on the gauge subsystem.\n", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "oaecc", "parents_detail": "", "parent_of_code_id": "subsystem_stabilizer", "parent_of_detail": "", "cousins_code_id": "qecc", "cousins_detail": "A subsystem code reduces to an ordinary error-correcting code when the gauge subsystem is trivial, \\(\\mathsf{B} = \\mathbb{C}\\). Conversely, any QECC with a tensor-product logical subspace can be turned into a subsystem code by treating a logical tensor factor as a gauge subsystem.", "_type": "ecc", "_page_id": "c_oecc", "_href": "c/oecc"}, "c_qecc_finite": {"notes": "", "realizations": "", "physical": "", "description": "Encodes quantum information in a \\(K\\)-dimensional (logical) subspace of an \\(N\\)-dimensional (physical) Hilbert space such that it is possible to recover said information from errors. The logical subspace is spanned by a basis comprised of code basis states or codewords.", "code_id": "qecc_finite", "logical": "", "introduced": "", "name": "Finite-dimensional quantum error-correcting code", "short_name": "Finite QECC", "protection": "Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a finite-dimensional quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{K}\\to\\mathsf{H}_{N}\\) with a set of correctable errors \\({\\cal{E}}:\\mathsf{H}_N\\to\\mathsf{H}_M\\) with the following property: there exists a quantum operation \\({\\cal{D}}:\\mathsf{H}_M\\to \\mathsf{H}_K\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{K}\\),\n\\begin{align}\n{\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\end{align}\nfor some constant \\(c\\). A code is said to protect against or correct the errors \\(\\mathcal{E}\\).\n\nEquivalently, correction capability is determined by the quantum error-correction conditions [quant-ph/9604034,quant-ph/9604024]: for all \\(|\\psi\\rangle,|\\phi\\rangle\\in\\mathsf{H}_{N}\\) and all errors \\(E_a,E_b\\in{\\mathcal{E}}\\),\n\\begin{align}\n  \\langle \\psi | E^{\\dagger}_a E_b |\\phi \\rangle = C_{ab} \\langle \\psi | \\phi \\rangle~,\n\\end{align}\nwhere the coefficients \\(C_{ab}\\) do not depend on \\(|\\psi\\rangle\\) or \\(|\\phi\\rangle\\). A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an approximate error-correcting code<code:approximate_qecc>.\n\nA code is degenerate with respect to a noise model if different errors map code states to the same error subspace. For a linearly independent error set \\(\\cal{E}\\), degeneracy is equivalent to \\(\\text{rank}(C_{ab}) < |\\cal{E}|\\).\n", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "The operation \\(\\cal{D}\\) in the definition of this code is called the decoder. However, the term decoder can sometimes be used for the inverse of an encoder, which does not correct errors.\nGiven an encoding, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [quant-ph/0109155,quant-ph/0307138] (see also Ref. [0706.3400]).\nQuantum machine-learning based decoders such as quantum convolutional neural networks [1810.03787] and quantum autoencoders [2202.00555].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Universal gate set cannot be transversal for any code that detects single-qubit errors due to Eastin-Knill theorem [0811.4262].", "features_fault_tolerance": "", "features_encoders": "Given a decoder, an encoding that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [quant-ph/0109155,quant-ph/0307138] (see also Ref. [0706.3400]).", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "category_quantum\nfermions\ngalois_into_galois\nqudits_into_qudits\nquantum_perfect\nquantum_mds\nqubits_into_qubits\nspins_into_spins", "parent_of_detail": "\n\n\n\n\n\n\n", "_type": "ecc", "_page_id": "c_qecc_finite", "_href": "c/qecc_finite"}, "c_qecc": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Quantum error-correcting code (QECC)", "physical": "", "short_name": "QECC", "protection": "Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{\\text{logical}}\\to\\mathsf{H}_{\\text{physical}}\\) with a set of correctable errors \\(\\cal{E}\\) with the following property: there exists a quantum operation \\(\\cal{D}\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{\\text{logical}}\\),\n\\begin{align}\n{\\cal D} (EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\n\\end{align}\nfor some constant \\(c\\).\n\nEquivalently, correction capability is determined by of the quantum error-correction conditions [quant-ph/9604034,quant-ph/9604024], which may admit infinite terms due to non-normalizability of ideal code states. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an approximate code<code:approximate_qecc>.\n", "description": "Encodes quantum information in a (logical) subspace of a (physical) Hilbert space such that it is possible to recover said information from errors that act as linear maps on the physical space. The logical subspace is spanned by a basis comprised of code basis states or codewords. Codewords may not be normalizable if the physical Hilbert space in infinite, so approximate versions have to be constructed in practice.", "code_id": "qecc", "logical": "", "parents_code_id": "oaecc", "parents_detail": "", "parent_of_code_id": "approximate_qecc\noscillators\nquantum_concatenated\ndynamic_gen\nqecc_finite\ngroup_quantum\nhamiltonian\nquantum_cyclic\nquantum_random\nstabilizer", "parent_of_detail": "\n\n\n\n\n\n\n\n\n", "cousin_of_code_id": "oecc", "cousin_of_detail": "A subsystem code reduces to an ordinary error-correcting code when the gauge subsystem is trivial, \\(\\mathsf{B} = \\mathbb{C}\\). Conversely, any QECC with a tensor-product logical subspace can be turned into a subsystem code by treating a logical tensor factor as a gauge subsystem.", "_type": "ecc", "_page_id": "c_qecc", "_href": "c/qecc"}, "c_quantum_convolutional": {"notes": "", "realizations": "", "physical": "qubits", "description": "Stub.", "code_id": "quantum_convolutional", "logical": "qubits", "introduced": "[quant-ph/0511016]", "name": "Quantum convolutional code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "cousin_of_code_id": "convolutional\nquantum_reed_muller", "cousin_of_detail": "Quantum analogue of convolutional codes\nQuantum convolutional codes can be derived from Quantum Reed-Muller codes [quant-ph/0701037].", "_type": "ecc", "_page_id": "c_quantum_convolutional", "_href": "c/quantum_convolutional"}, "c_color": {"notes": "", "realizations": "", "physical": "qubits", "description": "A family of abelian topological CSS stabilizer<code:css> codes defined on a \\(D\\)-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial \\(D\\)-complex obtained as a triangulation of the interior of a \\(D\\)-simplex and (2) is \\(D+1\\)-colorable. Qubits are placed on the \\(D\\)-simplices and generators are supported on suitable simplices [10.7907/059V-MG69]. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face [1311.0277].", "code_id": "color", "logical": "qubits", "introduced": "[quant-ph/0605138]", "name": "Color code", "short_name": "", "protection": "As with the surface code, the code distance depends on the specific kind of lattice used to define the code. More precisely, the distance depends on the homology of logical string operators [1311.0277].", "features_rate": "For general 2D manifolds, \\(kd^2 \\leq c(\\log k)^2 n\\) for some constant \\(c\\) [1301.6588], meaning that color codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\).", "features_threshold": "\\(\\geq 6.25\\%\\) threshold for 2d color codes with error-free syndrome extraction, and \\(0.1\\%\\) with faulty syndrome extraction [0907.1708].\n\\(0.46\\%\\) for 3d codes with clustering decoder [1708.07131].\n\\(1.9\\%\\) for 1D string-like logical operators and \\(27.6\\%\\) for 2D sheet-like operators for 3D codes with noise models using optimal decoding and perfect measurements [1708.07131].\n\\(0.31\\%\\) noise threshold error rate for gauge code using clustering decoder [1503.08217].\n\\(0.143\\%\\) with depolarising circuit-level noise using perfect-matching decoder [1407.5103].\n\\(>0\\%\\) threshold with sweep decoder [10.7907/059V-MG69].", "features_magic_scaling_exponent": "", "features_decoders": "Projection decoder [10.7907/059V-MG69].\nMatching decoder gives low logical failure rate [2108.11395].\nInteger-program-based decoder [1402.3037].\nRestriction decoder [10.1088/1367-2630/ab68fd].", "features_transversal_gates": "Transversal CNOT can be implemented via braiding [0806.4827]. Universal transversal gates can be achieved in 3D color code using gauge fixing [1311.0879], lattice surgery [1407.5103], or code deformation [10.1088/1367-2630/13/4/043005,0806.4827].", "features_code_capacity_threshold": "\\(\\geq 6\\%\\) threshold with rescaling-based decoder [2112.09584].", "features_general_gates": "Magic-state distillation protocols [10.7907/059V-MG69].\nNon-clifford gates can be implemented via code switching [10.7907/059V-MG69].\nLattice surgery scheme for 2D layout yields lower resource overhead when compared to analogous surface code scheme [2201.07806].", "features_fault_tolerance": "Clifford gates can be performed fault-tolerantly on a suitable 2D lattice [quant-ph/0605138].\nSyndrome measurement [1407.5103].\nSteane's ancilla-coupled measurement method [1407.5103]", "features_encoders": "", "parents_code_id": "css\ntopological_abelian", "parents_detail": "\nWhen treated as ground states of the code Hamiltonian, 2D color code states on realize \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) topological order [0906.4127], equivalent to the phase realized by two copies of the surface code [1503.02065].", "parent_of_code_id": "steane\nstab_15_1_3", "parent_of_detail": "Steane code is the smallest 2D color code.\nThe \\([[15,1,3]]\\) code is a 3D color code.", "cousins_code_id": "surface\nquantum_triorthogonal", "cousins_detail": "Color code is equivalent to surface code in several ways [1503.02065,1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.\nThe 3D color code is triorthogonal.", "cousin_of_code_id": "haah_cubic\nsubsystem_color", "cousin_of_detail": "The color and cubic code families both include 3D codes that do not admit string-like operators.\n", "_type": "ecc", "_page_id": "c_color", "_href": "c/color"}, "c_haar_random": {"notes": "", "realizations": "", "physical": "qubits", "description": "Haar-random codewords are generated in a process involving averaging over unitary operations distributed accoding to the Haar measure. Haar-random codes are used to prove statements about the capacity of a quantum channel to transmit quantum information [1106.1445], but encoding and decoding in such \\(n\\)-qubit codes quickly becomes impractical as \\(n\\to\\infty\\).\n\nThere are different approaches to create Haar-random codewords. In the construction of Ref. [quant-ph/0702005], codewords are produced by performing a unitarily covariant projective measurement on a typical subspace of a tensor-power state. Reference [quant-ph/0702005] showed that the capacity of a noisy quantum channel can be achieved by encoding in such Haar-random codes. In particular, Haar-random codes achieve perfect transmission in the \\(n\\to\\infty\\)) limit by proving that the encoded information becomes decoupled from the environment. This is a necessary and sufficient condition for successful decoding since measurements of the environment should never reveal the encoded information [quant-ph/9604022].\n\nIntuitively, coupling with the environment can be decreased by projecting the system onto a random codespace. The more qubits that are randomly discarded, the more the codespace is decoupled from the environment. One may ask what is the least amount of qubits that can be discarded, i.e. the largest remaining codespace, that still achieves decoupling. It can be shown through the decoupling inequality [quant-ph/0512247] that the largest possible dimension of the random codespace that achieves arbitrarily large decoupling is exponential in the coherent information of the channel. Therefore, there exist codes that can transmit information with rate equal to the coherent information. Furthermore, these codes can be constructed with high probability by performing a Haar-random isometry embedding a \\(k\\)-dimensional logical subspace into an \\(n\\)-dimensional physical space, where \\(k/n\\) is equal to the coherent information. Such an isometry can be produced by QR decomposition of a Gaussian random matrix [10.1137/0717034].\n", "code_id": "haar_random", "logical": "qubits", "introduced": "[Peter W. Shor, The quantum channel capacity and coherent information <https://github.com/errorcorrectionzoo/eczoo_data/files/7808154/shor.pdf>, 2002 (obtained from the MSRI Workshop on Quantum Computation website).,quant-ph/0702005,quant-ph/0304127,0712.2558]", "name": "Haar-random code", "short_name": "", "protection": "Random code achieve the capacity of any noisy quantum channel.", "features_rate": "The rate of the code is equal to the coherent information of the channel (i.e. the quantum channel capacity).", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "random_circuit", "parents_detail": "", "cousins_code_id": "t-designs", "cousins_detail": "Approximating the random projections through \\(t\\)-designs is necessary in order to make the protocol practical. Replacing with random Clifford gates is especially convenient since the Clifford group forms a unitary 2-design and produces stabilizer codes.", "_type": "ecc", "_page_id": "c_haar_random", "_href": "c/haar_random"}, "c_eth": {"notes": "", "realizations": "", "physical": "qubits", "description": "Also called a thermodynamic code [1902.07714]. An \\(n\\)-qubit approximate code whose codespace is formed by eigenstates of a translationally-invariant quantum many-body system which satisfies the Eigenstate Thermalization Hypothesis (ETH). ETH ensures that codewords cannot be locally distinguished in the thermodynamic limit. Relevant many-body systems include 1D non-interacting spin chains, Motzkin chains, or Heisenberg models.\n\nETH requires that for ordered energy eigenstates \\(|E_l\\rangle\\) and any local observable \\(O\\),\n\\begin{align}\n|\\langle E_l|O|E_l\\rangle-\\langle E_{l+1}|O|E_{l+1}\\rangle|\\leq\\exp(-cn)\n\\end{align}\nfor a constant \\(c\\). This implies that energy eigenstates around some energy \\(\\bar E\\) are approximately locally indistinguishable from one another, as their reduced density matrices on any subsystem are both approximately thermal at energy \\(\\bar E\\). In this way, global information is protected from local measurements by the environment as \\(n\\to\\infty\\).\n", "code_id": "eth", "logical": "qubits", "introduced": "[1710.04631]", "name": "Eigenstate thermalization hypothesis (ETH) code", "short_name": "ETH", "protection": "Approximately protects against erasure errors at known locations. Translation invariance alone is sufficient for good approximate error-correcting properties in a many-body spectrum, including in integrable models [1710.04631]. The ETH code generated from the spectrum of the translation-invariant 1D Heisenberg spin chain [1710.04631] has recovery infidelity (against the erasure of a constant number of sites) scale as \\(\\epsilon_\\text{worst}=O(1/n)\\) [1902.07714].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "An explicit universal recovery channel for the ETH code is given in [1906.03669].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "hamiltonian\napproximate_qecc", "parents_detail": "ETH codewords are eigenstates of a local Hamiltonian whose eigenstates satisfy ETH.\nETH codes approximately protect against erasures in the thermodynamic limit.", "cousins_code_id": "topological", "cousins_detail": "ETH codewords, like topological codewords, are locally indistinguishable.", "_type": "ecc", "_page_id": "c_eth", "_href": "c/eth"}, "c_haah_cubic": {"notes": "", "realizations": "Numerical simulations showed that \\(T_{\\rm{mem}}(\\beta) \\ge e^{c \\beta^2/12}\\), suggesting the possibility of macroscopically feasible memory times [1112.3252].", "physical": "qubits", "description": "Class of stabilizer codes on a length-\\(L\\) cubic lattice with one or two qubits per site. We also require that the stabilizer group \\(\\mathsf{S}\\) is translation invariant and generated by two types of operators with support on a cube. In the non-CSS case, these two are related by spatial inversion. For CSS codes, we require that the product of all corner operators is the identity. We lastly require that there are no non-trival ''string operators'', meaning that single-site operators are a phase, and any period one logical operator \\(l \\in \\mathsf{S}^{\\perp}\\) is just a phase. Haah showed in his original construction that there is exactly one non-CSS code of this form, and 17 CSS codes [1101.1962]. The non-CSS code is labeled code 0, and the rest are numbered from 1 - 17. Codes 1-4 do not have string logical operators, while codes 11-17 do.\n\nStraightforward generalizations of the above codes exist to modular qudits, oscillators, and rotors [J. Haah, Two generalizations of the cubic code model, KITP Conference: Frontiers of Quantum Information Physics, UCSB, Santa Barbara, CA. <https://online.kitp.ucsb.edu/online/qinfo_c17/haah/>,1709.04460].\n", "code_id": "haah_cubic", "logical": "qubits", "introduced": "[1101.1962]", "name": "Haah cubic code", "short_name": "", "protection": "Cubic codes protect against simultaneous independent Pauli errors on different sites (not qubits, since there can be 2 qubits per site). Codes 0-4 are known to have distance \\(d \\ge L\\), meaning they can achieve macroscopic code distance as \\(L\\to\\infty\\).", "features_rate": "", "features_threshold": "The encoding rate depends on the code implemented, but code 0 has been shown to have \\(k \\ge L\\) (on a periodic finite cubic lattice of side length \\(L\\). In general we expect the number of logical bits to scale as \\(k \\sim L\\).", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qubit_stabilizer\nfracton", "parents_detail": "\nHaah cubic codes are the first examples of Type-II fracton phases [2001.01722].", "cousins_code_id": "color\nsurface", "cousins_detail": "The color and cubic code families both include 3D codes that do not admit string-like operators.\nThe energy of any partial implementation of code 1 is proportional to the boundary length similar to the 4D toric code, which can potentially surpress the effects of thermal errors, but it is currently an open problem.", "cousin_of_code_id": "lifted_product", "cousin_of_detail": "A lifted product code for the ring \\(R=\\mathbb{F}_2[x,y,z]/(x^L-1,y^L-1,z^L-1)\\) is the cubic code.", "_type": "ecc", "_page_id": "c_haah_cubic", "_href": "c/haah_cubic"}, "c_t-designs": {"notes": "", "realizations": "", "physical": "qubits", "description": "An \\(n\\)-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal \\(n\\)-qubit states and acting with a random unitary circuit of depth polynomial in \\(n\\). Two states are locally indistinguishable if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about \\(n/2\\) two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries.\nThe above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (\\(D=1\\), while codes for higher-dimensional geometries require \\(O(n^{1/D})\\)-depth circuits [10.1007/s00220-016-2706-8]. Follow-up work [2010.09775] revealed that optimal code properties require only \\(O(\\sqrt{n})\\)-depth circuits for that case, and \\(O(\\sqrt{n})\\)-depth circuits for a two-dimensional square-lattice geometry.", "code_id": "t-designs", "logical": "qubits", "introduced": "[10.1007/s00220-016-2706-8]", "name": "Local Haar-random circuit code", "short_name": "", "protection": "In a 1D geometry, the code approximately detects any error with support on a segment of length \\(\\leq n/4\\), with deviations exponentially suppressed in \\(n\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Random local circuit of depth proportional to \\(n^{\\alpha}\\), with \\(\\alpha\\) depending on system geometry.", "parents_code_id": "random_circuit", "parents_detail": "", "cousins_code_id": "topological\napproximate_qecc", "cousins_detail": "Local Haar-random codewords, like topological codewords, are locally indistinguishable [10.1007/s00220-016-2706-8].\n", "cousin_of_code_id": "haar_random", "cousin_of_detail": "Approximating the random projections through \\(t\\)-designs is necessary in order to make the protocol practical. Replacing with random Clifford gates is especially convenient since the Clifford group forms a unitary 2-design and produces stabilizer codes.", "_type": "ecc", "_page_id": "c_t-designs", "_href": "c/t-designs"}, "c_qubits_into_qubits": {"notes": "", "realizations": "", "physical": "qubits", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2^n\\)-dimensional (i.e., \\(n\\)-qubit) Hilbert space. Usually denoted as \\(((n,K))\\) or \\(((n,K,d))\\), where \\(d\\) is the code's distance.", "code_id": "qubits_into_qubits", "logical": "qubits", "introduced": "", "name": "Qubit code", "short_name": "", "protection": "The minimum size of a Pauli error that has a non-zero expectation value for some code basis state is called the diagonal distance [2107.11286]. Codes whose distance is greater than the diagonal distance are degenerate.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "For few-qubit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "cws\nmovassagh_ouyang\npermutation_invariant", "parent_of_detail": "\n\n", "cousin_of_code_id": "fermions\nfock_state\ngroup_quantum\nspins_into_spins", "cousin_of_detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation [cond-mat/0010440], codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations.\nFock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators [Victor V. Albert, private communication, 2016]. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations [2111.08894].\nGroup quantum codes whose physical spaces are constructed using the group \\(\\mathbb{Z}_2\\) are qubit codes.\nSpin codes with spin \\(\\ell=1/2\\) correspond to qubit codes.", "_type": "ecc", "_page_id": "c_qubits_into_qubits", "_href": "c/qubits_into_qubits"}, "c_matching": {"notes": "", "realizations": "", "physical": "qubits", "description": "Stub.", "code_id": "matching", "logical": "qubits", "introduced": "[1501.07779]", "name": "Matching code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qubit_stabilizer\ntopological_abelian", "parents_detail": "\nMatching codes were inspired by the Kitaev honeycomb model [cond-mat/0506438], which realizes \\(\\mathbb{Z}_2\\) topological order.", "parent_of_code_id": "xyz_hexagonal", "parent_of_detail": "", "cousin_of_code_id": "honeycomb", "cousin_of_detail": "Matching and honeycomb codes are both inspired by the Kitaev honeycomb model [cond-mat/0506438].", "_type": "ecc", "_page_id": "c_matching", "_href": "c/matching"}, "c_qubit_stabilizer": {"notes": "Tables of bounds and examples of stabilizer codes for various \\(n\\) and \\(k\\), based on algorithms developed in Ref. [10.1007/978-3-540-37634-7_13], are maintained by M. Grassl at this website <http://codetables.markus-grassl.de/>.", "realizations": "", "physical": "qubits", "description": "An \\(((n,2^k,d))\\) qubit stabilizer code is denoted as \\([[n,k]]\\) or \\([[n,k,d]]\\), where \\(d\\) is the code's distance. Logical subspace is the joint eigenspace of commuting Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace of a set of \\(2^{n-k}\\) commuting Pauli operators which do not contain \\(-I\\).\n\nThe distance is the minimum weight of a Pauli string that implements a nontrivial logical operation in the code.\n\n(Pauli matrices go here.)\n\nEach stabilizer code can be represented by a \\((n-k) \\times 2n\\) stabilizer generator matrix \\(H=(A|B)\\), where each row \\((a|b)\\) is the binary symplectic representation of a stabilizer generator. (Standard form goes here.)\n\nQubit stabilizer codes can be extended to modular-qudit stabilizer codes by decorating appropriate generators with powers. For example, \\([[4,2,2]]\\) qubit code generators can be adjusted to \\(ZZZZ\\) and \\(XX^{-1} XX^{-1}\\). A systematic procedure extending a qubit code to prime-qudit codes involves putting its generator matrix into local-dimension-invariant (LDI) form  [1910.08122]. Various bounds exist on the distance of the resulting codes [2110.11510,2110.15274].\n", "code_id": "qubit_stabilizer", "logical": "qubits", "introduced": "[quant-ph/9605005,quant-ph/9705052]", "name": "Qubit stabilizer code", "short_name": "", "protection": "Detects errors on up to \\(d-1\\) qubits, and corrects erasure errors on up to \\(d-1\\) qubits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).\n\nA stabilizer code is geometrically local if the support of the stabilizer generators is bounded by a ball of size independent of \\(n\\). There is an upper bound of \\(d \\leq O(L^{D-1})\\) on the distance [0810.1983] of geometrically local stabilizer codes arranged in a \\(D\\)-dimensional lattice of length \\(L\\) with \\(n=L^D\\).\n", "features_rate": "", "features_threshold": "Computational thresholds against stochastic local noise can be achieved through repeated use of concatenatenation, and can rely on the same small code in every level [quant-ph/9702058,quant-ph/9906129,quant-ph/9705031,quant-ph/0504218]. The resulting code is highly degenerate, with all but an exponentially small fraction of generators having small weights. Circuit and measurement designs have to take case of the few stabilizer generators with large weights in order to be fault tolerant.", "features_magic_scaling_exponent": "", "features_decoders": "The structure of stabilizer codes allows for syndrome-based decoding, where errors are corrected based on the results of stabilizer measurements (syndromes). Finding an optimal decoder is \\(\\#P\\)-hard [1310.3235].\nTrellis decoder, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) [quant-ph/0512041].", "features_transversal_gates": "", "features_code_capacity_threshold": "For correlated Pauli noise, bounds on code capacity thresholds for any stabilizer codes can be obtained by mapping the effect of noise on the code to a statistical mechanical model [quant-ph/0110143,1208.2317,1311.7688,1809.10704].", "features_general_gates": "Logical gates implemented via constant-depth quantum circuits of \\(D\\)-dimensional geometrically local stabilizer codes lie in the \\(D\\)th level of the Clifford hierarchy [1206.1609].\nWith pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates [1603.03948].", "features_fault_tolerance": "With pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates [1603.03948].\nFault-tolerant error correction can be done using Shor error correction [quant-ph/9605011], which is based on repeated measurements, or Knill error correction, which is based on teleportation [quant-ph/0410199,quant-ph/0312190].", "features_encoders": "", "parents_code_id": "stabilizer\ncws", "parents_detail": "\nIf the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code.", "parent_of_code_id": "css\nclifford-deformed_surface\nfloquet\nfusion\nhaah_cubic\nmajorana_stab\nmatching\nhappy\nquantum_convolutional\nstabilizer_over_gf4\nxyz_product\nquantum_hamming", "parent_of_detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) weakly self-dual CSS code, with the mapping preserving geometric locality of a code up to a constant factor [1004.3791].\n\nParticular sequences of measurements on this code yield an instantaneous stabilizer group.\nThe resource states in FBQC are small stabilizer states, and after fusion measurements, the outputs are stabilizers (conditioned on measurement outcomes.\n\nThe Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code [cond-mat/0506438,1004.3791]. However, Pauli- and Majorana-based stabilizer codes have different notions of locality [cond-mat/0010440] and are thus useful for different physical platforms.\n\nThe HaPPY code is a stabilizer code because it is defined by a contracted network of stabilizer tensors; see Thm. 6 in Ref. [1503.06237].\n\n\n\n", "cousins_code_id": "binary_linear\nhamiltonian\nqudit_stabilizer", "cousins_detail": "Qubit stabilizer codes are quantum analogues of binary linear codes.\nCodespace is the ground-state space of the code Hamiltonian, which consists of an equal linear combination of stabilizer generators and which can be made into a commuting projector Hamiltonian.\nModular-qudit stabilizer codes for prime-dimensional qudits \\(q=p\\) inherit most of the features of qubit stabilizer codes, including encoding an integer number of qudits and a Pauli group with a unique number of generators. Conversely, qubit stabilizer codes can be extended to qudits by decorating the appropriate Pauli strings with powers, and the local-dimension-invariant (LDI) form [1910.08122] of the generator matrix yields systematic extensions to prime qudits.", "cousin_of_code_id": "movassagh_ouyang\nsubsystem_stabilizer", "cousin_of_detail": "Many, but not all, Movassagh-Ouyang codes are stabilizer codes.\nGauge stabilizer codes reduce to stabilizer codes when there are no gauge qubits.", "_type": "ecc", "_page_id": "c_qubit_stabilizer", "_href": "c/qubit_stabilizer"}, "c_quantum_reed_muller": {"notes": "", "realizations": "", "physical": "qubits", "description": "A CSS code formed from a classical Reed-Muller code in which polynomials over finite fields encode data. This is done by transforming these polynomials into the stabilizer generator matrices", "code_id": "quantum_reed_muller", "logical": "qubits", "introduced": "[quant-ph/9608026]", "name": "Quantum Reed-Muller code", "short_name": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "features_rate": "\\(\\frac{k}{n}\\), where \\(k = 2^r - {r \\choose t} + 2 \\sum_{i=0}^{t-1} {r \\choose i}\\). Additionally, CSS codes formed from binary Reed-Muller codes achieve channel capacity on erasure channels [1601.04689].", "features_threshold": "Between \\(10^{-3}\\) and \\(10^{-6}\\) for depolarizing noise (assuming ideal decoders), see [10.1088/2058-9565/abb027]", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Magic state distillation in all prime dimensions [10.1103/PhysRevX.2.041021]", "features_fault_tolerance": "Gate switching protocol for universal computation [1403.2734].", "features_encoders": "", "parents_code_id": "css", "parents_detail": "", "parent_of_code_id": "stab_15_1_3", "parent_of_detail": "The \\([[15,1,3]]\\) code is often noted as the 15-qubit quantum Reed-Muller code in the literature.", "cousins_code_id": "reed_muller\nquantum_convolutional", "cousins_detail": "Reed-Muller codes are the classical anologue of these codes.\nQuantum convolutional codes can be derived from Quantum Reed-Muller codes [quant-ph/0701037].", "cousin_of_code_id": "quantum_triorthogonal", "cousin_of_detail": "Classification of triorthongonal codes yields a connection to Reed-Muller polynomials [2107.09684].", "_type": "ecc", "_page_id": "c_quantum_reed_muller", "_href": "c/quantum_reed_muller"}, "c_double_semion": {"notes": "", "realizations": "", "physical": "qubits", "description": "Stub.", "code_id": "double_semion", "logical": "qudits", "introduced": "[cond-mat/0404617]", "name": "Double-semion code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qudit_stabilizer\ntopological_abelian", "parents_detail": "Double-semion code can be realized as a modular-qudit stabilizer code with \\(q=4\\) [2112.11394].\nWhen treated as ground states of the code Hamiltonian, the code states realize double-semion topological order, a topological phase of matter that also exists in twisted \\(\\mathbb{Z}_2\\) gauge theory [10.1007/BF02096988].", "cousins_code_id": "surface", "cousins_detail": "There is a logical basis for the toric and double-semion codes where each codeword is a superposition of states corresponding to all noncontractible loops of a particular homotopy type. The superposition is equal for the toric code, whereas some loops appear with a \\(-1\\) coefficient for the double semion.", "_type": "ecc", "_page_id": "c_double_semion", "_href": "c/double_semion"}, "c_movassagh_ouyang": {"notes": "", "realizations": "", "physical": "qubits", "description": "This is a family of codes derived via an algorithm that takes as input any binary classical code and outputs a quantum code (note that this framework can be extended to \\(q\\)-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.\n\nThis family strictly generalizes CSS codes (because CSS codes come only from linear or self orthogonal classical codes). These codes can be shown to be realized as a subspace of the ground space of a (geometrically) local Hamiltonian.\n", "code_id": "movassagh_ouyang", "logical": "qubits", "introduced": "[2012.01453]", "name": "Movassagh-Ouyang Hamiltonian code", "short_name": "", "protection": "Let \\(C \\subset \\{0,1,\\dots,q-1\\}^n\\) be a classical code with distance \\(d_x\\). Let \\(d_z\\) satisfy \\(q^n > 2 V_q(d_z-1) -1\\), where \\(V_q(r)\\) is the volume of the \\(q\\)-ary Hamming ball of radius \\(r\\). Then the algorithm produces a quantum code with distance \\(d = \\text{min}(d_x,d_z)\\). Asymptotically, the distance scales linearly with \\(n\\).", "features_rate": "The rate depends on the classical code, but distance can scale linearly with \\(n\\).", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qubits_into_qubits\nhamiltonian", "parents_detail": "\nMovassagh-Ouyang codes reside in the ground space of a Hamiltonian.", "parent_of_code_id": "css", "parent_of_detail": "Movassagh-Ouyang codes stem from a prescription that converts an arbitrary classical code into a quantum code.", "cousins_code_id": "qubit_stabilizer\nbits_into_bits", "cousins_detail": "Many, but not all, Movassagh-Ouyang codes are stabilizer codes.\nMovassagh-Ouyang codes are constructed from classical binary codes.", "cousin_of_code_id": "cws", "cousin_of_detail": "The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other.", "_type": "ecc", "_page_id": "c_movassagh_ouyang", "_href": "c/movassagh_ouyang"}, "c_floquet": {"notes": "", "realizations": "", "physical": "qubits", "description": "Dynamically-generated stabilizer-based code whose logical qubits are generated through a particular sequence of measurements such that the number of logical qubits is larger than when the code is viewed as a static subsystem stabilizer code. The code space is the \\(+1\\) eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured. As opposed to subsystem codes, only specific measurement sequences maintain the codespace.\n", "code_id": "floquet", "logical": "qubits", "introduced": "[2107.02194]", "name": "Floquet code", "short_name": "", "protection": "Protects against single-qubit Pauli noise and check operator measurement errors.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "dynamic_gen\nqubit_stabilizer", "parents_detail": "\nParticular sequences of measurements on this code yield an instantaneous stabilizer group.", "parent_of_code_id": "honeycomb", "parent_of_detail": "The honeycomb code is the first 2D Floquet code.", "cousins_code_id": "subsystem_stabilizer\nmonitored_random_circuits\nmajorana_stab", "cousins_detail": "This code can be viewed as a subsystem stabilizer code, albeit one with less logical qubits.\nBoth Floquet and monitored random circuit codes can have an instantaneous stabilizer group which evolves through unitary evolution and measurements. However, Floquet codewords are generated via a specific sequence of measurements, while random-circuit codes maintain a stabilizer group after any measurement. Floquet codes have the additional capability of detecting errors induced during the measurement process; see Appx. A of Ref. [2107.02194].\nFloquet codes are viable candidates for storage in Majorana-qubit devices [2202.11829].", "_type": "ecc", "_page_id": "c_floquet", "_href": "c/floquet"}, "c_quantum_hamming": {"notes": "", "realizations": "", "physical": "qubits", "description": "A family of stabilizer codes of distance \\(3\\) that asymptotically saturate quantum Hamming bound.", "code_id": "quantum_hamming", "logical": "qubits", "introduced": "[quant-ph/9604038]", "name": "\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming code", "short_name": "", "protection": "Protects against any single qubit error.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "cousins_code_id": "quantum_perfect", "cousins_detail": "Quantum Hamming codes saturate the asymptotic Hamming bound.", "cousin_of_code_id": "hamming", "cousin_of_detail": "", "_type": "ecc", "_page_id": "c_quantum_hamming", "_href": "c/quantum_hamming"}, "c_nonlocal_lowdepth": {"notes": "", "realizations": "", "physical": "qubits", "description": "An encoder for an \\([[n,k]]\\) quantum error correcting code, is an \\(n\\)-qubit unitary transformation that takes a \\(k\\)-qubit state as input (with \\(k\\leq n\\), and the remaining \\(n-k\\) qubits initialized to \\(|0\\rangle^{\\otimes n-k}\\) ) to give a corresponding state in the codespace as the output. An n-qubit quantum circuit with random 2-qubit Clifford gates can act as an encoder into a code with distance \\(d\\) with high probability, with a size (i.e. number of gates in the circuit) at most \\(O(n^2 log n)\\)). Noting that two gates acting on disjoint qubits could in fact be executed simultaneously, this is equivalent to the depth (number of time steps in the circuit) being at most \\(O(log^3 n)\\).", "code_id": "nonlocal_lowdepth", "logical": "qubits", "introduced": "[1312.7646]", "name": "Low-depth random Clifford-circuit code", "short_name": "", "protection": "Creates a random \\([[n,k,d]]\\) stabilizer code that detects errors on \\(d-1\\) qubits, and corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "random_circuit", "parents_detail": "", "_type": "ecc", "_page_id": "c_nonlocal_lowdepth", "_href": "c/nonlocal_lowdepth"}, "c_gnu_permutation_invariant": {"notes": "", "realizations": "", "physical": "qubits", "description": "Can be expressed in terms of Dicke states where the logical states are\n\\begin{align}\n|\\overline{\\pm}\\rangle = \\sum_{\\ell=0}^{n} \\frac{(\\pm 1)^\\ell}{\\sqrt{2^n}} \\sqrt{n \\choose \\ell} |D^m_{g \\ell}\\rangle~.\n\\end{align}\nHere, \\(m\\) is the number of particles used for encoding \\(1\\) qubit, and \\(g, n \\leq m\\) are arbitrary positive integers. The state \\(|D^m_w\\rangle\\) is a Dicke state -- a normalized permutation-invariant state on \\(m\\) qubits with \\(w\\) excitations, i.e., a normalized sum over all basis elements with \\(w\\) ones and \\(m - w\\) zeroes.\n\nA qudit extension of such codes, based on a correspondence with binomial codes, exists [1708.05010].\n", "code_id": "gnu_permutation_invariant", "logical": "qubits", "introduced": "[1302.3247]", "name": "GNU permutation-invariant code", "short_name": "", "protection": "Depends on the family. One family which is completely symmetrized versions of Bacon-Shor codes (parameterized by \\(t\\)) protects against arbitrary weight-\\(t\\) qubit errors. Additionally, codes with large enough length \\((t+1)(3t+1)+t\\) can approximately correct \\(t\\) spontaneous decay errors.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "permutation_invariant", "parents_detail": "", "cousins_code_id": "bacon_shor\nhamiltonian\napproximate_qecc\nbinomial", "cousins_detail": "Symmetrized versions of the Bacon-Shor codes are GNU codes\nGNU codes lie within the ground state of ferromagnetic Heisenberg models without an external magnetic field [1904.01458].\nSome GNU codes can protect approximately against amplitude damping errors.\nBinomial codes and GNU codes are both described by spin-coherent states [1708.05010].", "_type": "ecc", "_page_id": "c_gnu_permutation_invariant", "_href": "c/gnu_permutation_invariant"}, "c_quantum_hamming_css": {"notes": "", "realizations": "", "physical": "qubits", "description": "A Hamming-based CSS code is a CCS code constructed with a classical Hamming code \\([2^r-1,2^r-1-r,3]=C_X=C_Z\\).", "code_id": "quantum_hamming_css", "logical": "qubits", "introduced": "", "name": "\\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS code", "short_name": "", "protection": "Protects against any single qubit error.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "Syndrome measurement can be done with two ancillary flag qubits [1705.02329].", "features_encoders": "", "parents_code_id": "css", "parents_detail": "", "parent_of_code_id": "steane", "parent_of_detail": "Steane code is the smallest member of a family of Hamming-based CSS codes.", "cousins_code_id": "hamming", "cousins_detail": "Quantum Hamming codes result from applying the CSS construction to Hamming codes.", "cousin_of_code_id": "qudit_hamming_css", "cousin_of_detail": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) codes are prime-qudit extensions of \\([[2^r-1, 2^r-2r-1, 3]]\\) codes.", "_type": "ecc", "_page_id": "c_quantum_hamming_css", "_href": "c/quantum_hamming_css"}, "c_cws": {"notes": "", "realizations": "", "physical": "qubits", "description": "This family of codes strictly generalizes stabilizer codes. They are usually denoted by \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\) where \\(\\mathcal{G}\\) is a graph and \\(\\mathcal{C}\\) is a \\( (n,K,d) \\) binary classical code. From the graph we form the unique graph state (stabilizer state) \\( |G \\rangle \\). From the classical code we form Pauli \\(Z\\)-type operators \\( W_i = Z^{c_{i,1}} \\otimes \\cdots \\otimes Z^{c_{i,n}} \\), where \\(c_{i,j} \\) is the \\(j\\)-th bit of the \\(i\\)-th classical codeword. The CWS codewords are then \\( | i \\rangle =  W_i | G \\rangle \\).\n\nThere is an alternative description to the one above that is locally Clifford-equivalent. In particular, we can describe CWS codes as \\( \\mathcal{Q} = (S,\\mathcal{W})\\) where \\(S\\) is a stabilizer group and \\( \\mathcal{W} = \\{ w_\\ell \\}_{\\ell = 1}^K \\) is a family of \\(K\\) \\(n\\)-qubit Pauli strings. We then form CWS codeswords as \\( | i \\rangle = w_i | S \\rangle \\), where \\( | S \\rangle \\) is the (unique) stabilizer state of \\(S\\).\n", "code_id": "cws", "logical": "qubits", "introduced": "[0708.1021]", "name": "Codeword stabilized (CWS) code", "short_name": "CWS", "protection": "Code distance \\(\\mathcal{Q} = ( \\mathcal{G},\\mathcal{C}) \\) is upper bounded by the distance of the classical code \\(\\mathcal{C} \\). The diagonal distance<code:qubits_into_qubits> is upper bounded by \\(\\delta + 1\\), where \\(\\delta\\) is the minimum degree of \\(\\mathcal{G}\\). Computing the distance is generally NP-complete, and is NP-hard for non-degenerate codes [2203.04262].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "There is no known efficient algorithm to decode non-additive (non-stabilizer) CWS codes.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "If \\( \\mathcal{C} \\) has an efficient classical encoder, then so does the CWS code \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\).", "parents_code_id": "qubits_into_qubits", "parents_detail": "", "parent_of_code_id": "qubit_stabilizer", "parent_of_detail": "If the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code.", "cousins_code_id": "movassagh_ouyang", "cousins_detail": "The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other.", "_type": "ecc", "_page_id": "c_cws", "_href": "c/cws"}, "c_css": {"notes": "Introduction to CSS-to-homology dictionary by M. Hastings <https://www.youtube.com/watch?v=SeLpWg_8qlc>.\nOriginal requirement of \\(C_X^\\perp \\subset C_Z\\) [quant-ph/9512032] has been relaxed to absorb hypergraph product<code:hypergraph_product> codes.", "realizations": "", "physical": "qubits", "description": "An \\([[n,k,d]]\\) stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The stabilizer generator matrix is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parity}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:comm}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related binary linear codes<code:binary_linear>, an \\([n,k_X,d^\\prime_X]\\) code \\(C_X\\) and \\([n,k_Z,d^\\prime_Z]\\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d^\\prime_X,d^\\prime_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) eq:parity is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees eq:comm.\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n\nA CSS code has stabilizer weight \\(w\\) if the highest weight of any stabilizer generator is \\(w\\), i.e., any row of \\(H_X\\) and \\(H_Z\\) has weight at most \\(w\\). In the context of comparing weight as well as of determining distances for noise models biased toward \\(X\\)- or \\(Z\\)-type errors, an extended notation for CSS codes is \\([[n,k,(d_X,d_Z),w]]\\). The quantity \\(\\min\\{d_X,d_Z\\}\\) is often called the worst-case minimum distance.\n\nThere exists a many-to-one mapping from size three chain complexes to CSS codes [10.1070/RM1997v052n06ABEH002155,quant-ph/0605094,1311.0885,1802.01520] that allows one to extract code properties from topological features of the complexes. Codes constructed in this manner are sometimes called homological CSS codes, but they are equivalent to CSS codes. This mapping of codes to manifolds allows the application of structures from topology to error correction, yielding various QLDPC codes<code:generalized_homological_product> with favorable properties.\n\nA chain complex of size three is given by binary vector spaces \\(A_2\\), \\(A_1\\), \\(A_0\\) and binary matrices \\(\\partial_{i=1,2}\\) (called boundary operators) \\(A_i\\) to \\(A_{i-1}\\) that satisfy \\(\\partial_1 \\partial_2 = 0\\). Such a complex is typically denoted as\n\\begin{align}\nA_2 \\xrightarrow{\\partial_2} A_1 \\xrightarrow{\\partial_1} A_0~.\n\\label{eq:chain}\n\\end{align}\nOne constructs a CSS code by associating a physical qubit to every basis element of \\(A_1\\), and defining parity-check matrices \\(H_X=\\partial_1^T\\) and \\(H_Z=\\partial_2\\)). That way, the spaces \\(A_0\\) and \\(A_2\\) can be associated with \\(X\\)-type and \\(Z\\)-type Pauli operators, respectively, and boundary operators determine the Paulis making up the stabilizer generators. The requirement \\(\\partial_1 \\partial_2 = 0\\) guarantees that the \\(X\\)-stabilizer generators associated with \\(H_X\\) commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nUsually, the chain complex eq:chain used in the construction comes from the chain complex associated with a cellulation of a manifold. When the manifold is a two-dimensional surface, its entire chain is used. Higher-dimensional manifolds allow for longer chain complexes, and one can use the three largest non-trivial vector spaces in its chain.\n", "code_id": "css", "logical": "qubits", "introduced": "[quant-ph/9512032,10.1103/PhysRevLett.77.793,quant-ph/9601029]", "name": "Calderbank-Shor-Steane (CSS) stabilizer code", "short_name": "CSS", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.\n\nUsing the relation to chain complexes, the number of encoded logical qubits is equal to the dimension of the first \\(\\mathbb{Z}_2\\)-homology of the chain complex, \\(H_1(\\partial, \\mathbb{Z}_2) = \\frac{\\text{Ker}(\\partial_1)}{\\text{Im}(\\partial_2)}\\). The distance of the CSS code is equal to the minimum of the combinatorial (\\(d-1\\))-systole of the cellulated \\(d\\)-dimensional manifold and its dual.\n", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Coherent decoders allow for measurement-free error correction [2109.00086]. One method is table/multi-control decoding [1002.1536], which scales exponentially with the number of ancillas used in syndrome measurement. Another method, the Ising-based decoder, utilizes the mapping of the effect of the noise to a statistical mechanical model [quant-ph/0110143,2002.11733] such that the decoding problem maps to preparation of the ground state of an Ising model.", "features_transversal_gates": "", "features_code_capacity_threshold": "Bounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights [1208.2317,1412.6172].", "features_general_gates": "LDPC CSS code symmetries called \\(XZ\\)-dualities allow for fold-transversal gates, i.e., transversal gates followed by qubit permutations [2202.06647].", "features_fault_tolerance": "Steane error correction [quant-ph/9611027].", "features_encoders": "Stabilizer measurement [1404.2495].", "parents_code_id": "qubit_stabilizer\nmovassagh_ouyang", "parents_detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) weakly self-dual CSS code, with the mapping preserving geometric locality of a code up to a constant factor [1004.3791].\nMovassagh-Ouyang codes stem from a prescription that converts an arbitrary classical code into a quantum code.", "parent_of_code_id": "balanced_product\ncolor\ndistance_balanced\nsurface\nquantum_reed_muller\nquantum_parity\nquantum_polar\nquantum_repetition\nquantum_triorthogonal\nquantum_hamming_css", "parent_of_detail": "\n\n\n\n\n\n\n\n\n", "cousins_code_id": "binary_linear\ndual", "cousins_detail": "Construction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\).\nCSS codes for which \\(C_X=C_Z \\equiv C\\) are called weakly self-dual since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\).", "cousin_of_code_id": "galois_css\ngeneralized_homological_product\nhomological_classical\ngroup_gkp\nhomological_cv\nmajorana_stab\nqudit_css", "cousin_of_detail": "Extension of qubit CSS codes to Galois qudits.\nThe notion of homological products arose from interpreting CSS codes in terms of chain complexes over manifolds, but some generalized products no longer yield CSS codes.\nCSS codes can also be constructed using homology techniques but for manifolds of dimension two or greater.\nAn \\(n\\)-qubit CSS code corresponds to the \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{\\times n}\\) group construction.\nCSS and homological CV codes utilize chain complexes in code construction, with the latter complexes having trivial homology.\nWhen constructing a Majorana stabilizer code from a weakly self-dual classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space [1004.3791,1703.00459]. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different weakly self-dual classical codes with an odd number of bits, as is often done in the CSS construction.\nExtension of CSS codes to modular-integer qudits.", "_type": "ecc", "_page_id": "c_css", "_href": "c/css"}, "c_quantum_parity": {"notes": "", "realizations": "The \\([[m^2,1,m]]\\) codes for \\(m\\leq 7\\) have been realized in trapped-ion quantum devices [2104.01205].\nNon-determinisitic linear-optical encoding [quant-ph/0501184] whose success probability \\(P_{E}\\) is determined by the efficiency \\(\\eta\\) of the photonic encoding circuit. A threshold \\(\\eta > 0.82 \\) exists for the efficiency, above which \\(P_{E}\\to 1\\) as \\(m_1\\to\\infty\\) given particular \\(m_2\\).\nStudied in the context of error-corrected quantum repeaters [1310.5291].", "physical": "qubits", "description": "Also called a generalized Shor code [quant-ph/0610088]. A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) CSS code family obtained from concatenating an \\(m_1\\)-qubit phase-flip repetition code with an \\(m_2\\)-qubit bit-flip repetition code. Logical codewords are\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}+|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}-|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}~.\n\\end{split}\n\\end{align}\n", "code_id": "quantum_parity", "logical": "qubits", "introduced": "[quant-ph/0501184,quant-ph/0006088]", "name": "Quantum parity code (QPC)", "short_name": "", "protection": "Has distance \\(d=\\min(m_1,m_2)\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "css\nconstant_excitation\nquantum_concatenated", "parents_detail": "\nQPC codewords like in a common eigenspace of the total spin Hamiltonian.\nA QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code.", "parent_of_code_id": "shor_nine\nstab_4_2_2", "parent_of_detail": "Shor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes.\n\\([[4,1,2]]\\) subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "cousins_code_id": "quantum_repetition\nbacon_shor", "cousins_detail": "A QPC is a concatenation of a bit-flip and a phase-flip repetition codes.\nBacon-Shor codes reduce to QPCs for a particular gauge configuration.", "_type": "ecc", "_page_id": "c_quantum_parity", "_href": "c/quantum_parity"}, "c_quantum_repetition": {"notes": "Logical basis for the bit-flip code is spanned by GHz (a.k.a. cat) states \\(|0\\rangle^{\\otimes n}\\pm|1\\rangle^{\\otimes n}\\), which are used in Shor error correction.", "realizations": "Superconducting circuits: IBM 15-qubit [1709.00990], Google Quantum AI Sycamore [2102.06132].\n3-qubit semiconductor spin-qubit computer at RIKEN [2201.08581] and Delft [2202.11530].\n3-qubit codes can be used to benchmark device performance [2202.11045].\nSee Table S6 in Ref. [2102.06132] for a history of earlier implementations.", "physical": "qubits", "description": "Encodes \\(1\\) qubit into \\(n\\) qubits according to \\(|0\\rangle\\to|\\phi_0\\rangle^{\\otimes n}\\) and \\(|1\\rangle\\to|\\phi_1\\rangle^{\\otimes n}\\). Also known as a bit-flip code when \\(|\\phi_i\\rangle = |i\\rangle\\), and a phase-flip code when \\(|\\phi_0\\rangle = |+\\rangle\\) and \\(|\\phi_1\\rangle = |-\\rangle\\).", "code_id": "quantum_repetition", "logical": "qubits", "introduced": "", "name": "Quantum repetition code", "short_name": "", "protection": "Bit-flip code detects bit-flip errors \\(X\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any phase-flip errors \\(Z\\). Phase-flip code detects phase-flip errors \\(Z\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any bit-flip errors \\(X\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "css", "parents_detail": "", "cousins_code_id": "hamiltonian", "cousins_detail": "Bit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions.", "cousin_of_code_id": "repetition\nquantum_parity\nshor_nine\nvery-small-logical-qubit", "cousin_of_detail": "\nA QPC is a concatenation of a bit-flip and a phase-flip repetition codes.\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\nParts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss.", "_type": "ecc", "_page_id": "c_quantum_repetition", "_href": "c/quantum_repetition"}, "c_honeycomb": {"notes": "", "realizations": "", "physical": "qubits", "description": "Floquet code inspired by the Kitaev honeycomb model [cond-mat/0506438] whose logical qubits are generated through a particular sequence of measurements.\n\nThe code is defined on a hexagonal (honeycomb) lattice with a physical qubit located at each vertex. Edges are labeled \\(x\\), \\(y\\), and \\(z\\), such that one edge of each label meet at every vertex. Check operators are defined as \\(XX\\) acting on any two qubits joined by an \\(x\\) edge, and similarly for \\(y\\) and \\(z\\). The hexagonal lattice is 3-colorable, so the hexagons may be labeled 0, 1, 2 such that no two neighboring hexagons have the same label.\n\nThe code-generating measurement pattern consists of measuring the check operators located on all of the \\(r\\)-labeled edges in round \\(r\\) mod 3. The code space is the \\(+1\\) eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured.\n", "code_id": "honeycomb", "logical": "qubits", "introduced": "[2107.02194]", "name": "Honeycomb code", "short_name": "", "protection": "Protective features similar to the surface code: on a torus geometry, the code protects two logical qubits with a code distance proportional to the linear size of the torus. Properties of the code with open boundaries are discussed in Refs. [2110.09545,2110.05348].", "features_rate": "", "features_threshold": "\\(0.2\\%-0.3\\%\\) in a controlled-not circuit model with a correlated minimum-weight perfect-matching decoder [2108.10457].\n\\(1.5\\%<p<2.0\\%\\) in a circuit model with native two-body measurements and a correlated minimum-weight perfect-matching decoder [2108.10457]. Here, \\(p\\) is the collective error rate of the two-body measurement gate, including both measurement and correlated data depolarization error processes.\nAgainst circuit-level noise: within \\(0.2\\% \u2212 0.3\\%\\) for SD6 (standard depolarizing 6-step cycle), \\(0.1\\% \u2212 0.15\\%\\) for SI1000 (superconducting-inspired 1000 ns cycle), and \\(1.5\\% \u2212 2.0\\%\\) for EM3 (entangling-measurement 3-step cycle) [2202.11845].", "features_magic_scaling_exponent": "", "features_decoders": "The ISG has a static subgroup for all time steps \\(r\\geq 3\\) \u2013 that is, a subgroup which remains a subgroup of the ISG for all future times \u2013 given by so-called plaquette stabilizers. These are stabilizers consisting of products of check operators around homologically trivial paths. The syndrome bits correspond to the eigenvalues of the plaquette stabilizers. Because of the structure of the check operators, only one-third of all plaquettes are measured each round. The syndrome bits must therefore be represented by a lattice in spacetime, to reflect when and where the outcome was obtained.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "There are two types of logical operators, inner and outer. An inner logical operator is the product of check operators on a homologically nontrivial cycle. They belong to the stabilizer group as a subsystem code. Outer logical operators have an interpretation in terms of magnetic and electric operators of an embedded surface code, and they do not belong to the stabilizer group of the associated subsystem code.", "features_fault_tolerance": "One can run a fault-tolerant decoding algorithm by (1) bipartitioning the syndrome lattice into two graphs which are congruent to the Cayley graph of the free abelian group with three generators (up to boundary conditions) and (2) performing a matching algorithm to deduce errors.", "features_encoders": "Initialization can be performed by preparing each pair of qubits  on an edge in some particular state independently specified by the effective-one-qubit operators (two-qubit Pauli strings centered on an edge) and then beginning the check measurement sequence. This is analogous to projecting a state into the code space by measuring stabilizers.", "parents_code_id": "floquet", "parents_detail": "The honeycomb code is the first 2D Floquet code.", "cousins_code_id": "surface\nsubsystem_color\nmajorana_stab\nmatching\nqldpc", "cousins_detail": "Measurement of each check operator involves two qubits and projects the state of the two qubits to a two-dimensional subspace, which we regard as an effective qubit. These effective qubits form a surface code on a hexagonal superlattice. Electric and magnetic operators on the embedded surface code correspond to outer logical operators of the Floquet code. In fact, outer logical operators transition back and forth from magnetic to electric surface code operators under the measurement dynamics.\nBoth honeycomb and subsystem color codes are generated via periodic sequences of measurements. However, any measurement sequence can be performed on the color code without destroying the logical qubits, while honeycomb codes can be maintained only with specific sequences. Honeycomb codes require a shorter measurement cycle and use fewer qubits at the given code distance [2107.02194].\nThe Honeycomb code admits a representation in terms of Majorana fermions. This leads to a possible physical realization of the code in terms of tetrons [1610.05289], where each physical qubit is composed of four Majorana modes.\nMatching and honeycomb codes are both inspired by the Kitaev honeycomb model [cond-mat/0506438].\nThe Floquet check operators are weight-two, and each qubit participates in one check each round.", "_type": "ecc", "_page_id": "c_honeycomb", "_href": "c/honeycomb"}, "c_permutation_invariant": {"notes": "Can be constructed using real polynomials for high-dimensional qudit spaces [10.1016/j.laa.2017.06.031].", "realizations": "", "physical": "qubits", "description": "Codes which are stabilized by the symmetric group \\(S_n\\) on \\(n\\) elements, in a generalization of stabilizer codes to binary codes utilizing (non-abelian) group actions (in particular, \\(S_n\\) is non-abelian).", "code_id": "permutation_invariant", "logical": "qubits", "introduced": "[quant-ph/0304153]", "name": "Permutation-invariant code", "short_name": "", "protection": "Depends on the family. The GNU permutation-invariant family (parameterized by \\(t\\)) protects against arbitrary weight \\(t\\) qubit errors and approximately corrects spontaneous decay errors [1302.3247,10.1103/PhysRevA.93.042340]. Other related codes protect against amplitude damping [10.1109/TIT.2019.2956142] while admitting a constant number of excitations, and against deletion errors [2102.02494,2102.03015].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "For a family of codes, using projection, probability amplitude rebalancing, and gate teleportation can be done in \\(O(N^2)\\) [2102.02494].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "With quantum harmonic oscillators (superconducting charge qubits in a ultrastrong coupling regime) in \\(O(N)\\) as in [10.1103/PhysRevA.99.012335]. Can be done in \\(O(N^2)\\) steps using quantum circuits [1904.07358], or using geometric phase gates in \\(O(N)\\) [1908.01120].", "parents_code_id": "qubits_into_qubits", "parents_detail": "", "parent_of_code_id": "constant_excitation_permutation_invariant\ngnu_permutation_invariant", "parent_of_detail": "\n", "cousins_code_id": "quantum_cyclic", "cousins_detail": "The cyclic group of these codes is a subgroup of the \\(S_n\\) symmetric group used in permutation invariant codes.", "_type": "ecc", "_page_id": "c_permutation_invariant", "_href": "c/permutation_invariant"}, "c_monitored_random_circuits": {"notes": "Connections to information scrambling in black hole physics, as introduced in Section 11 of [1903.05124]. In particular, monitored random circuits can be viewed as the Hayden-Preskill recovery problem [10.1103/PhysRevD.100.086001] running backwards in time. In this setting, the volume-law entanglement phase of the monitored circuit describes the phase when information can be recovered from an old black hole (ie, a black hole that is maximally entangled with the early universe).\nMapping monitored random circuits to statistical mechanics models can help estimate thresholds and code distances for these systems [2007.03822].", "realizations": "Measurement induced quantum phases have been realized in a trapped-ion processor [2106.05881].", "physical": "groups", "description": "Error-correcting code arising from a monitored random circuit. Such a circuit is described by a series of intermittant random local projective Pauli measurements with random unitary time-evolution operators. An important sub-family consists of Clifford monitored random circuits, where unitaries are sampled from the Clifford group [1901.08092]. When the rate of projective measurements is independently controlled by a probability parameter \\(p\\), there can exist two stable phases, one described by volume-law entanglement entropy and the other by area-law entanglement entropy. The phases and their transition can be understood from the perspective of quantum error correction, information scrambling, and channel capacities [1903.05124,1905.05195].\n\nMonitored random circuits have a finite information capacity that decays exponentially with respect to system size [1905.05195]. When \\( p = 0 \\), the random circuit achieves channel capacity, meaning that it stores the most amount of information possible. This notion quantifies the recoverability of information and the reversability of the system under the monitored random dynamics. In the volume-law phase (\\( p < p_c \\) for some critical probability \\(p_c\\)), the channel capacity remains non-zero, and the monitored channel projects an initial state into a random error-correcting code [1905.05195]. With appropriately chosen evolution operators and measurements, the code is a stabilizer code whose parameters depend on time, \\( [[n,k(t),d(t)]] \\). A similar notion applies to Haar random circuits with measurements [1911.00008].\n", "code_id": "monitored_random_circuits", "logical": "qubits", "introduced": "[10.1103/PhysRevX.9.031009,10.1103/PhysRevB.98.205136,1808.05949]", "name": "Monitored random-circuit code", "short_name": "", "protection": "When in the volume-law phase, protects against random projective measurements at a rate \\( p < p_c \\). While the true code distance is not known, it is conjectured to be proportional to the contiguous distance. As first described in Ref. [1905.05195], the  contiguous distance for these circuits is defined with respect to all partitions of the system.", "features_rate": "Rate can be finite [1905.05195], depending on the family of random codes generated by the circuit.", "features_threshold": "Above the critical measurement rate \\( p_c\\), the natural error correction properties of the circuit can no longer protect the information. This can be interpreted as the code threshold.\nThese dynamically generated codes saturate the trade off between density of encoded information and the error rate threshold [1905.05195]", "features_magic_scaling_exponent": "", "features_decoders": "The recovery operation is the reverse unitary transformation with access to the measurement record (for dynamically generated codes with a strong purification transition) [1905.05195]", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "The dynamics of the monitored random circuit can be recast in the language of stabilizer codes [1905.05195]. The stabilizer group of the error-correcting code resulting from a monitored Clifford circuit either grows or shrinks with each time step, depending on which projective measurements were performed during the time step.\nOne can construct optimal single-copy encoding operations for strong purification transitions [1905.05195]", "parents_code_id": "random_circuit", "parents_detail": "Monitored random circuits are random circuits where projective measurements are interspersed throughout the circuit and measurement results are recorded.", "cousins_code_id": "topological", "cousins_detail": "Topological order can be generated in 2D monitored random circuits [2011.06595].", "cousin_of_code_id": "floquet", "cousin_of_detail": "Both Floquet and monitored random circuit codes can have an instantaneous stabilizer group which evolves through unitary evolution and measurements. However, Floquet codewords are generated via a specific sequence of measurements, while random-circuit codes maintain a stabilizer group after any measurement. Floquet codes have the additional capability of detecting errors induced during the measurement process; see Appx. A of Ref. [2107.02194].", "_type": "ecc", "_page_id": "c_monitored_random_circuits", "_href": "c/monitored_random_circuits"}, "c_quantum_polar": {"notes": "", "realizations": "", "physical": "qubits", "description": "Stub.", "code_id": "quantum_polar", "logical": "qubits", "introduced": "[1109.3195]", "name": "Quantum polar code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "css", "parents_detail": "", "cousins_code_id": "polar", "cousins_detail": "", "cousin_of_code_id": "stab_4_2_2", "cousin_of_detail": "\\([[4,2,2]]\\) code is a small quantum polar code [Kyungjoo Noh, Leung code as quantum polar code <https://github.com/errorcorrectionzoo/eczoo_data/files/7652763/Leung_code_as_quantum_polar_code.pdf>, 2017.].", "_type": "ecc", "_page_id": "c_quantum_polar", "_href": "c/quantum_polar"}, "c_stabilizer_over_gf4": {"notes": "", "realizations": "", "physical": "qubits", "description": "An \\([[n,k,d]]\\) stabilizer code whose encoding is based on a self-dual quaternary \\([n, n-k, d^*]_4\\) code over \\(GF(4)^n\\) with respect to the trace inner product where \\(d \\ge d^*\\).\nThe field \\(GF(4)=\\mathbf{F}_4\\) consists of \\(\\{0, 1, w, \\bar{w}\\}\\), with \\(\\bar{w} = w^2 = w + 1\\), \\(\\mathrm{Tr}(x) = x+\\bar{x}\\), and trace inner product \\(u * v = \\mathrm{Tr}(u \\cdot \\bar{v})\\).\nThere is a mapping \\(L\\) between Pauli matrices \\(I, Y, Z, X\\) and \\(0, 1, \\bar{w}, w\\), in turn \\([A, B] \\Leftrightarrow Tr\\langle L(A), L(A)\\rangle\\).\nThe classical self-dual code \\(C\\) over \\(GF(4)^n\\) corresponds to the stabilizer group \\(\\mathsf{S}\\) while \\(C^{\\perp}\\) corresponds to \\(\\mathsf{N(S)}\\).\n", "code_id": "stabilizer_over_gf4", "logical": "qubits", "introduced": "[quant-ph/9608006]", "name": "Stabilizer code over \\(GF(4)\\)", "short_name": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qubit_stabilizer", "parents_detail": "", "parent_of_code_id": "stab_5_1_3", "parent_of_detail": "The \\([[5,1,3]]\\) code is derived from the \\([5,3,3]_4\\) Hamming code.", "cousins_code_id": "q-ary_linear", "cousins_detail": "Quaternary \\(q=4\\) linear codes are used in this construction.", "cousin_of_code_id": "stabilizer_over_gfqsq", "cousin_of_detail": "Stabilizer codes over \\(GF(q^2)\\) are Galois-qudit extensions of those over \\(GF(4)\\).", "_type": "ecc", "_page_id": "c_stabilizer_over_gf4", "_href": "c/stabilizer_over_gf4"}, "c_xyz_hexagonal": {"notes": "Isolated \\(X\\), \\(Y\\), and \\(Z\\) errors lead to unidirectional pairs of plaquette defects along the three directions of the triangular lattice.", "realizations": "", "physical": "qubits", "description": "An instance of the matching code based on the Kitaev honeycomb model. It is described on a hexagonal lattice with \\(XYZXYZ\\) stabilizers on each hexagonal plaquette. Each vertical pair of qubits has an \\(XX\\), \\(YY\\), or \\(ZZ\\) link stabilizer depending on the orientation of the plaquette stabilizers.", "code_id": "xyz_hexagonal", "logical": "qubits", "introduced": "[2109.13308,2112.06036]", "name": "XYZ\\(^2\\) hexagonal stabilizer code", "short_name": "", "protection": "As a stabilizer code with boundaries, protects a single qubit with parameters \\([[2 d^2, 1, d]]\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Maximum-likelihood decoding using the EWD decoder [2112.01977].", "features_transversal_gates": "", "features_code_capacity_threshold": "\\(50\\%\\) for pure \\(Z\\), \\(Y\\), or \\(Z\\) noise under maximum-likelihood decoding.\nThreshold matches that of the \\(XZZX\\) code for various bias levels of \\(X\\), \\(Y\\), or \\(Z\\) biased noise  under maximum-likelihood decoding.\n\\(\\sim 18\\%\\) for depolarizing noise under maximum-likelihood decoding.", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "matching", "parents_detail": "", "_type": "ecc", "_page_id": "c_xyz_hexagonal", "_href": "c/xyz_hexagonal"}, "c_happy": {"notes": "", "realizations": "", "physical": "qubits", "description": "Holographic code constructed out of a network of perfect tensors that tesselates hyperbolic space. Physical qubits are associated with uncontracted tensor legs at the boundary of the tesselation, while logical qubits are associated with uncontracted legs in the bulk. The code serves as a minimal model for several aspects of the AdS/CFT holographic duality. The construction below is described for qubits, but straightforward generalizations exist to modular qudits, oscillators, and rotors [1902.07714].\n\nEncoding is accomplished using a tensor network of \\([[5,1,3]]\\) encoding isometries, which are six-legged perfect tensors (with five legs corresponding to the physical qubits and one for the encoded logical qubit). A \\(2n\\)-legged perfect tensor is proportional to an isometry for any bipartition of its indices into a set \\(A\\) and a complementary set \\(A^{\\perp}\\) such that \\(|A|\\leq|A^{\\perp}|\\).\n\nTo construct the encoding, one first uniformly tiles the hyperbolic AdS/CFT disc using pentagons and hexagons. Then, one places a 6-legged \\([[5,1,3]]\\) encoding tensor at each hexagon and pentagon, contracting legs between neighboring shapes and leaving one leg uncontracted at each pentagon. This construction forms an encoding isometry from the uncontracted legs in the bulk to the uncontracted legs at the boundary.\n", "code_id": "happy", "logical": "qubits", "introduced": "[1503.06237]", "name": "Pastawski-Yoshida-Harlow-Preskill (HaPPY) code", "short_name": "HaPPY", "protection": "Protects against erasure errors and Pauli errors on the boundary qubits.", "features_rate": "The pentagon HaPPY code has an asymptotic rate \\(\\frac{1}{\\sqrt{5}} \\approx 0.447\\). The pentagon/hexagon HaPPY code, with alternating layers of pentagons and hexagons in the tiling, has a rate of \\(0.299\\) if the last layer is a pentagon layer and a rate of \\(0.088\\) if the last layer is a hexagon layer.", "features_threshold": "\\(26\\%\\) for boundary erasure errors on the the pentagon/hexagon HaPPY code, which has alternating layers of pentagons and hexagons in the tiling.\n\\(\\sim 50\\%\\) for boundary erasure errors on the single-qubit HaPPY code, which has a central pentagon encoding one bulk operator and hexagons tiling all other layers\n\\(16.3\\%\\) for boundary Pauli errors on the single-qubit HaPPY code with 3 layers [2008.10206].\nThere is no threshold for the pentagon HaPPY code as a constant number of errors (two) can make bulk recovery impossible.", "features_magic_scaling_exponent": "", "features_decoders": "Greedy algorithm for decoding specified in Ref. [1503.06237].", "features_transversal_gates": "For locality-preserving physical gates on the boundary, the set of transversally implementable logical operations in the bulk is strictly contained in the Clifford group [2103.13404].", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Heisenberg-picture encoding is done through tensor pushing. Each bulk operator (logical) is pushed to an operator supported on a portion of the boundary region (physical). Pushing all the bulk operators through results in reconstruction of the boundary.", "parents_code_id": "holographic\nqubit_stabilizer", "parents_detail": "\nThe HaPPY code is a stabilizer code because it is defined by a contracted network of stabilizer tensors; see Thm. 6 in Ref. [1503.06237].", "cousins_code_id": "stab_5_1_3", "cousins_detail": "The \\([[5,1,3]]\\) encoding isometry tiles various holographic codes because its corresponding tensor is perfect [1503.06237].", "_type": "ecc", "_page_id": "c_happy", "_href": "c/happy"}, "c_quantum_triorthogonal": {"notes": "Reference [2107.09684] presents a classification of triorthogonal codes up to \\(n + k \\leq 38\\) by associating each triorthogonal code with a Reed-Muller polynomial.", "realizations": "", "physical": "qubits", "description": "A triorthogonal \\(m \\times n\\) binary matrix is triorthogonal if its rows \\(r_1, \\ldots, r_m\\) satisfy \\(|r_i \\cdot r_j| = 0\\) and \\(|r_i \\cdot r_j \\cdot r_k| = 0\\), where addition and multiplication are done on \\(\\mathbb{Z}_2\\). The triorthogonal code associated with the matrix is constructed by mapping non-zero entries in even-weight rows to \\(X\\) operators, and \\(Z\\) operators for each row in the orthogonal complement.", "code_id": "quantum_triorthogonal", "logical": "qubits", "introduced": "[1209.2426]", "name": "Triorthogonal code", "short_name": "", "protection": "Weight \\(t\\) Pauli errors, where \\(t\\) depends on the family. For example, Ref. [1209.2426] provides a family of distance \\(2\\) codes. It also presents a \\([[49, 1, 5]]\\) code.", "features_rate": "", "features_threshold": "Approximately \\(\\frac{1}{3k + 1}\\) [1209.2426].", "features_magic_scaling_exponent": "Depends on the matrix. Reference [1209.2426] gave a family of \\(\\frac{k}{3k+8}\\) codes with magic-state distillation scaling exponent \\(\\gamma = \\log_2 \\frac{3k+8}{k}\\).", "features_decoders": "", "features_transversal_gates": "Admits transversal \\(T\\) gates [1209.2426] and the controlled-controlled-\\(Z\\) gate.", "features_code_capacity_threshold": "", "features_general_gates": "Triorthogonal codes can be used for high-quality magic-state distillation [1209.2426].", "features_fault_tolerance": "", "features_encoders": "Encoder for magic states for the code constructed in [1209.2426].", "parents_code_id": "css", "parents_detail": "", "parent_of_code_id": "stab_15_1_3", "parent_of_detail": "The \\([[15, 1, 3]]\\) code is a triorthogonal code [2107.09684]", "cousins_code_id": "quantum_reed_muller", "cousins_detail": "Classification of triorthongonal codes yields a connection to Reed-Muller polynomials [2107.09684].", "cousin_of_code_id": "color", "cousin_of_detail": "The 3D color code is triorthogonal.", "_type": "ecc", "_page_id": "c_quantum_triorthogonal", "_href": "c/quantum_triorthogonal"}, "c_stab_4_2_2": {"notes": "Concatenating \\([[4,2,2]]\\) code with surface code can generate 2D topological code with a reasonable circuit-based threshold [10.26421/QIC16.15-16-1].", "realizations": "Trapped-ion device by IonQ [1611.06946].\nLogical state preparation and flag-qubit error correction realized in superconducting-circuit devices by IBM [1705.09259,2110.04285].", "physical": "qubits", "description": "Four-qubit CSS stabilizer code with generators \\(\\{XXXX, ZZZZ\\} \\) and codewords\n\\begin{align}\n  \\begin{split}\n    |\\overline{00}\\rangle = (|0000\\rangle + |1111\\rangle)/\\sqrt{2}\\\\\n    |\\overline{01}\\rangle = (|0011\\rangle + |1100\\rangle)/\\sqrt{2}\\\\\n    |\\overline{10}\\rangle = (|0101\\rangle + |1010\\rangle)/\\sqrt{2}\\\\\n    |\\overline{11}\\rangle = (|0110\\rangle + |1001\\rangle)/\\sqrt{2}~.\n  \\end{split}\n\\end{align}\n\nIts subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is a \\([[4,1,2]]\\) code [quant-ph/9704002], whose \\(\\pm\\)-basis codewords can be written as\n\\begin{align}\n  |\\overline{\\pm}\\rangle = \\frac{1}{2}(|00\\rangle \\pm |11\\rangle)^{\\otimes 2}~.\\\\\n\\end{align}\nThis code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code. The other subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\) [quant-ph/0103042] has also been studied against amplitude-damping noise.\n", "code_id": "stab_4_2_2", "logical": "qubits", "introduced": "[quant-ph/9603031]", "name": "\\([[4,2,2]]\\) CSS code", "short_name": "", "protection": "Detects a single-qubit error [quant-ph/9603031] or single erasure [quant-ph/9610042]. Not able to correct arbitrary single-qubit errors because \\( \\lfloor \\frac{d-1}{2} \\rfloor =0 \\). Approximately corrects a single amplitude damping error [quant-ph/9704002].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "Transversal Pauli, Hadamard, and two-qubit \\(R\\) gates [1610.03507].", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "Preparation of certain states along with transversal gates can be performed fault-tolerantly, but requires post-selection because the code cannot correct errors [1610.03507].", "features_encoders": "", "parents_code_id": "quantum_parity\nsurface", "parents_detail": "\\([[4,1,2]]\\) subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes.\n\\([[4,2,2]]\\) code is the smallest toric code.", "cousins_code_id": "stab_5_1_3\nquantum_polar\napproximate_qecc", "cousins_detail": "\\([[4,2,2]]\\) can be derived from \\([[5,1,3]]\\) code using a protocal that converts \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman [quant-ph/9705052].\n\\([[4,2,2]]\\) code is a small quantum polar code [Kyungjoo Noh, Leung code as quantum polar code <https://github.com/errorcorrectionzoo/eczoo_data/files/7652763/Leung_code_as_quantum_polar_code.pdf>, 2017.].\n\\([[4,1,2]]\\) subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [quant-ph/9704002] and \\(\\{|\\overline{01}\\rangle,|\\overline{11}\\rangle\\}\\) [quant-ph/0103042] approximately correct a single amplitude damping error.", "cousin_of_code_id": "heavy_hex", "cousin_of_detail": "The \\(d=2\\) heavy-hexagonal code is closely related to the \\([[4,1,2]]\\) code.", "_type": "ecc", "_page_id": "c_stab_4_2_2", "_href": "c/stab_4_2_2"}, "c_steane": {"notes": "", "realizations": "Trapped-ion qubits: seven-qubit device in Blatt group [1403.5426] and ten-qubit QCCD device by Quantinuum [2107.07505].", "physical": "qubits", "description": "A \\([[7,1,3]]\\) CSS code that uses the classical binary \\([7,4,3]\\) Hamming code for protecting against \\(X\\) errors and its dual \\([7,3,4]\\) for \\(Z\\) errors. The parity-check matrix for the \\([7,4,3]\\) Hamming code is\n\\begin{align}\n  H = \\left(\\begin{matrix}\n    1&0&0&1&0&1&1\\\\\n    0&1&0&1&1&0&1\\\\\n    0&0&1&0&1&1&1\n  \\end{matrix}\\right),\n\\end{align}\nand the check matrix for the Steane code is therefore\n\\begin{align}\n  \\left(\\begin{matrix}\n    0&H\\\\\n    H&0\n  \\end{matrix}\\right).\n\\end{align}\nThe stabilizer group for the Steane code has six generators.\n", "code_id": "steane", "logical": "qubits", "introduced": "[10.1098/rspa.1996.0136]", "name": "Steane \\([[7,1,3]]\\) code", "short_name": "", "protection": "The Steane code is a distance 3 code. It detects errors on 2 qubits, corrects errors on 1 qubit.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Pieceable fault-tolerant CCZ gate [1603.03948].", "features_fault_tolerance": "Pieceable fault-tolerant CCZ gate [1603.03948].\nSyndrome measurement can be done with ancillary flag qubits [1612.04795,1705.02329] or with no extra qubits [10.1088/2058-9565/abc6f4].", "features_encoders": "", "parents_code_id": "quantum_hamming_css\ncolor", "parents_detail": "Steane code is the smallest member of a family of Hamming-based CSS codes.\nSteane code is the smallest 2D color code.", "cousins_code_id": "hamming", "cousins_detail": "The Steane code is constructed from a classical Hamming code.", "_type": "ecc", "_page_id": "c_steane", "_href": "c/steane"}, "c_stab_5_1_3": {"notes": "", "realizations": "First realized in NMR [10.1103/PhysRevLett.86.5811].\nDemonstration with superconducting qubits [1907.04507].", "physical": "qubits", "description": "Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, \\begin{align} \\begin{split} S_1 &= IXZZX \\\\ S_2 &= XZZXI \\\\ S_3 &= ZZXIX \\\\ S_4 &= ZXIXZ. \\end{split} \\end{align}", "code_id": "stab_5_1_3", "logical": "qubits", "introduced": "[quant-ph/9602019]", "name": "\\([[5,1,3]]\\) perfect code", "short_name": "", "protection": "Smallest stabilizer code that protects against a single error on any one qubit. Detects two-qubit errors.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Combined dynamical decoupling and error correction protocol on individually-controlled qubits with always-on Ising couplings [1509.01239].\nSymmetric decoder correcting all weight-one Pauli errors. The resulting logical error channel after coherent noise has been explicitly derived [2203.01706].", "features_transversal_gates": "Pauli gates are transversal.", "features_code_capacity_threshold": "", "features_general_gates": "Pieceable fault-tolerant CZ and CCZ gates [1603.03948].", "features_fault_tolerance": "Pieceable fault-tolerant CZ and CCZ gates [1603.03948].\nSyndrome measurement can be done with two ancillary flag qubits [1705.02329].", "features_encoders": "Four CNOT and five CPHASE gates [1509.01239].", "parents_code_id": "stabilizer_over_gf4", "parents_detail": "The \\([[5,1,3]]\\) code is derived from the \\([5,3,3]_4\\) Hamming code.", "cousins_code_id": "quantum_perfect\nquantum_mds\nquantum_cyclic\nhamiltonian\nmajorana_stab", "cousins_detail": "The smallest perfect code.\nThe smallest quantum MDS code.\n\\([[5,1,3]]\\) code is the smallest known example of quantum cyclic code .\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].", "cousin_of_code_id": "happy\nstab_4_2_2", "cousin_of_detail": "The \\([[5,1,3]]\\) encoding isometry tiles various holographic codes because its corresponding tensor is perfect [1503.06237].\n\\([[4,2,2]]\\) can be derived from \\([[5,1,3]]\\) code using a protocal that converts \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman [quant-ph/9705052].", "_type": "ecc", "_page_id": "c_stab_5_1_3", "_href": "c/stab_5_1_3"}, "c_shor_nine": {"notes": "Shor's code is the first known quantum error correction code. ", "realizations": "Trapped-ion qubits: state preparation with 98.8(1)% and 98.5(1)% fidelity for state \\(|\\overline{0}\\rangle\\) and \\(|\\overline{1}\\rangle\\), respectively, by N. Linke group [2104.01205]. Variants of the code to handle coherent noise studied and realized by K. Brown and C. Monroe groups [2105.05068].\nAll-photonic quantum repeater architecture [2203.07979].", "physical": "qubits", "description": "Nine-qubit CSS code<code:css> that is the smallest such code to correct a single-qubit error. The logical state is encoded using\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right)^{\\otimes3}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle-|111\\rangle\\right)^{\\otimes3}~.\n\\end{split}\n\\end{align}\nThe code works by concatenating<code:quantum_concatenated> each qubit of a phase-flip with a bit-flip repetition code<code:quantum_repetition>. Therefore, the code can correct both type of errors simultaneously.\n\nSpecifically, a state is phase-flip error-corrected by a three-qubit phase-flip repetition code<code:quantum_repetition>, with stabilizer generators \\(X_0 X_1I_2\\) and \\(X_0I_1X_2\\) in \\(X\\) basis, where the subscript represents the qubit index. Each logical qubit is encoded using\n\\begin{align}\n\\label{eq:phase-flip}\n\\begin{split}\n  |\\overline{0}\\rangle &= |+_0+_1+_2\\rangle \\\\\n  |\\overline{1}\\rangle &= |-_0-_1-_2\\rangle .\n\\end{split}\n\\end{align}\nThen, each physical qubit used in eq:phase-flip is further encoded in the three-qubit bit-flip repetition code<code:quantum_repetition>,\n\\begin{align}\n  |\\pm _j \\rangle  = \\frac{1}{\\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\\rangle \\pm |1_{j0}1_{j1}1_{j2}\\rangle),\n\\end{align}\neach with bit-flip error stabilizer generators \\(Z_{j0}Z_{j1}I_{j2}\\) and  \\(Z_{j0}I_{j1}Z_{j2} \\) with \\(j=0,1,2\\).\nNotice now the phase-flip error stabilizer generator is extended as \\(X_j = X_{j0}X_{j1}X_{j2}\\).\nAs a result, the stabilizer generators with the qubit index flattened are\n\\begin{align}\n\\begin{split}\n  Z_{j0}Z_{j1}I_{j2} &\\rightarrow \\{Z_0Z_1, Z_3Z_4, Z_6Z_7\\} \\\\\n  Z_{j0}I_{j1}Z_{j2} &\\rightarrow \\{Z_0Z_2, Z_3Z_5, Z_6Z_8\\} \\\\\n  X_0 X_1I_2  &\\rightarrow  \\{X_0X_1X_2X_3X_4X_5\\}\\\\\n  X_0 I_1X_2  &\\rightarrow  \\{X_0X_1X_2X_6X_7X_8\\}.\n\\end{split}\n\\end{align}\n", "code_id": "shor_nine", "logical": "qubits", "introduced": "[10.1103/PhysRevA.52.R2493]", "name": "Shor \\([[9,1,3]]\\) code", "short_name": "", "protection": "The code detects two-qubit errors or corrects an arbitrary single-qubit error.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "quantum_parity", "parents_detail": "Shor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes.", "cousins_code_id": "quantum_repetition\nquantum_concatenated\nreal_projective_plane", "cousins_detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\nShor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.\nShor's code is the smallest surface code defined on the projective plane [quant-ph/9810055].", "_type": "ecc", "_page_id": "c_shor_nine", "_href": "c/shor_nine"}, "c_stab_15_1_3": {"notes": "The \\([[15,1,3]]\\) code can be converted into the smallest known stabilizer code with a fault-tolerant logical \\(T\\) gate (i.e., the \\([[10,1,2]]\\) code) through a \"morphing procedure\" [2112.01446].", "realizations": "", "physical": "qubits", "description": "\\([[15,1,3]]\\) CSS code that is most easily thought of as a tetrahedral 3D color code.\nThis code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center.\nThe tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers.\nEach colored cell corresponds to a weight-8 \\(X\\)-check, and each face corresponds to a weight-4 \\(Z\\)-check.\nA logical \\(Z\\) is any weight-3 \\(Z\\)-string along an edge of the entire tetrahedron.\nThe logical \\(X\\) is any weight-7 \\(X\\)-face of the entire tetrahedron.\n", "code_id": "stab_15_1_3", "logical": "qubits", "introduced": "", "name": "\\([[15,1,3]]\\) Reed-Muller code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "Magic-state distillation scaling exponent \\( \\gamma= \\log_d (n/k)\\approx 2.46\\) [1703.07847].", "features_decoders": "", "features_transversal_gates": "A transversal logical \\(T^\\dagger\\) is implemented by applying a \\(T\\) gate on every qubit [quant-ph/9610011,1403.2734,1612.07330].", "features_code_capacity_threshold": "", "features_general_gates": "Code is often used in magic-state distillation protocols because of its transversal \\(T\\) gate [quant-ph/0403025].", "features_fault_tolerance": "Combining the Steane code and the 15-qubit Reed-Muller code through a fault-tolerant conversion can result in a universal transversal gate set that does not need magic state distillation [1403.2734,1703.03860].", "features_encoders": "", "parents_code_id": "quantum_reed_muller\nquantum_triorthogonal\ncolor", "parents_detail": "The \\([[15,1,3]]\\) code is often noted as the 15-qubit quantum Reed-Muller code in the literature.\nThe \\([[15, 1, 3]]\\) code is a triorthogonal code [2107.09684]\nThe \\([[15,1,3]]\\) code is a 3D color code.", "_type": "ecc", "_page_id": "c_stab_15_1_3", "_href": "c/stab_15_1_3"}, "c_heavy_hex": {"notes": "", "realizations": "Logical state preparation and flag-qubit error correction realized in superconducting-circuit devices (specifically, fixed-frequency transmon qubit architectures) by IBM for \\(d=2\\) [1705.09259,2110.04285] and \\(d=3\\) [2203.07205].", "physical": "qubits", "description": "Subsystem stabilizer code on the heavy-hexagonal lattice that combines Bacon-Shor and surface-code stabilizers. Encodes one logical qubit into \\(n=(5d^2-2d-1)/2\\) physical qubits with distance \\(d\\). The heavy-hexagonal lattice allows for low degree (at most 3) connectivity between all the data and ancilla qubits, which is suitable for fixed-frequency transom qubits subject to frequency collision errors.\n\nData qubits and ancillas of the code are placed on a heavy-hexagonal lattice (vertices and edges of a tilling of hexagons). A subset of the ancilla qubits are flag qubits used for detecting high-weight errors arising from fewer faults. The code stabilizers for detecting \\(X\\)-type errors are measured by measuring weight-two \\(Z\\)-type gauge operators whose product produces stabilizers of the surface code. \\(X\\)-type stabilizers are column operators corresponding to stabilizers of the Bacon-Shor code, which are measured by taking products of weight-four and weight-two \\(X\\)-type gauge operators.\n", "code_id": "heavy_hex", "logical": "qubits", "introduced": "[1907.09528]", "name": "Heavy-hexagon code", "short_name": "", "protection": "Protects against Pauli noise. The code has no threshold for \\(Z\\)-type Pauli errors since they are detected by Bacon-Shor-type stabilizers.", "features_rate": "\\(1/n\\) for a distance-\\(d\\) heavy-hexagon code on \\(n = (5d^2-2d-1)/2\\) qubits.", "features_threshold": "\\(0.45\\%\\) for \\(X\\) errors under a full circuit-level depolarizing noise model (obtained from Monte Carlo simulations).\n\\(Z\\)-errors have no threshold given the \\(X\\)-type Bacon-Shor stabilizers.", "features_magic_scaling_exponent": "", "features_decoders": "Any graph-based decoder can be used, such as MWPM and Union Find. However, edge weights must be dynamically renormalized using flag-qubit measurement outcomes after each syndrome measurement round.", "features_transversal_gates": "CNOT gates are transveral for this code. However, for most architectures, all logical gates would be implemented using lattice surgery methods.", "features_code_capacity_threshold": "", "features_general_gates": "Universal gate set achieved with magic state injection and lattice surgery.", "features_fault_tolerance": "All logical gates can be fault-tolerantly implemented using lattice surgery and magic state injection.\nStabilizer measurements are measured fault-tolerantly using one-flag circuits since some single-fault events can result in weight-two data qubit errors which are parallel to the code's logical operators. Hence, using information from the flag-qubit measurements is crucial to fault-tolerantly measure the code stabilizers.", "features_encoders": "For a logical-zero state, prepare all data qubits in the physical-zero state and then measure the \\(X\\)-type Bacon-Shor stabilizers. For logical-plus state, prepare all data qubits in the physical-plus state and then measure \\(Z\\)-type surface code stabilizers.\nStabilizer measurement encoding circuits have a constant depth of 10 time steps (excluding ancilla state preparation and measurement).", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "cousins_code_id": "surface\nbacon_shor\nstab_4_2_2", "cousins_detail": "Surface code stabilizers are used to measure the Z-type stabilizers of the code.\nBacon-Shor stabilizers are used to measure the X-type stabilizers of the code.\nThe \\(d=2\\) heavy-hexagonal code is closely related to the \\([[4,1,2]]\\) code.", "_type": "ecc", "_page_id": "c_heavy_hex", "_href": "c/heavy_hex"}, "c_subsystem_stabilizer": {"notes": "When the gauge group \\( \\mathsf{G} \\) is abelian, the above is reduced to the standard stabilizer formalism.", "realizations": "", "physical": "qubits", "description": "Also called a gauge stabilizer code. A stabilizer code with some of its logical qubits denoted as gauge qubits and not used for storage of logical information. Note that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by \\([[n,k,r,d]]\\), similar to stabilizer codes, but with an extra parameter \\(r\\) denoting the number of gauge qubits.\n\nTo create these codes proceed as follows. Choose \\(2n\\) operators \\(\\{ \\tilde{X}_j,\\tilde{Z}_j\\}_{j=1}^n\\) from \\(\\mathsf{P}_n\\), the Pauli group on \\(n\\) qubits, such that they obey the same commutation relations as the regular \\(n\\)-qubit Pauli generators \\( \\{X_j,Z_j\\}_{j=1}^n \\) (the subscript on these latter operators indicates the single qubit the Pauli matrix acts on). The tilde operators might act on more than one physical (or bare) qubit but they behave as if they acted only on a single qubit. WLOG we can choose a stabilizer group as \\( \\mathsf{S} = \\langle Z_1,\\dots,Z_s \\rangle \\). It follows that the normalizer of \\(\\mathsf{S} \\) is \\( N(\\mathsf{S}) = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_n, \\tilde{X}_{s+1},\\dots, \\tilde{X}_n \\rangle \\). We now choose a gauge group as \\( \\mathsf{G} = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_s, \\tilde{X}_{s+1}, \\tilde{Z}_{s+1}, \\dots, \\tilde{X}_{s+r}, \\tilde{Z}_{s+r} \\rangle \\) with \\( s + r \\leq n \\). The logical group is choosen as \\( \\mathsf{L} = N(\\mathsf{S})/\\mathsf{G} \\simeq \\langle \\tilde{X}_{s+r+1},\\tilde{Z}_{s+r+1}, \\dots, \\tilde{X}_n,\\tilde{Z}_n \\rangle \\). Now the codespace \\( C \\) is as usual the \\(+1\\) eigenspace of the stabilizer \\( \\mathsf{S} \\). But the gauge and logical groups have further decomposed this space into \\( C = A \\otimes B \\simeq (\\mathbb{C}^2)^{\\otimes k} \\otimes (\\mathbb{C}^2)^{\\otimes r} \\). Thus the Hilbert space is partitioned into 3 sets; \\(k\\) logical qubits, \\(r\\) gauge qubits, and \\(s\\) stabilizer qubits, with \\(s+r+k=n\\).\n", "code_id": "subsystem_stabilizer", "logical": "qubits", "introduced": "[quant-ph/0508131]", "name": "Subsystem qubit stabilizer code", "short_name": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. More generally, a set of errors \\( \\{ E_a \\} \\) is correctable iff \\( E_aE_b \\not\\in N(\\mathsf{S}) \\setminus \\mathsf{G} \\) for all pairs \\(a,b\\). The distance of the code is the minimal weight of operators in \\( N(\\mathsf{S}) \\setminus \\mathsf{G}\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Syndrome measurements are obtained by first measuring gauge operators of the code and taking their products, which give the stabilizer measurement outcomes.", "features_transversal_gates": "", "features_code_capacity_threshold": "For correlated Pauli noise, bounds can be obtained by mapping the effect of noise on the code to a statistical mechanical model [1809.10704].", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "oecc", "parents_detail": "", "parent_of_code_id": "bravyi_bacon_shor\nheavy_hex\nsubsystem_color", "parent_of_detail": "\n\n", "cousins_code_id": "qubit_stabilizer", "cousins_detail": "Gauge stabilizer codes reduce to stabilizer codes when there are no gauge qubits.", "cousin_of_code_id": "balanced_product\ndistance_balanced\nfloquet", "cousin_of_detail": "Distance balancing is used to form balanced-product subsystem codes [2012.09271].\n\nThis code can be viewed as a subsystem stabilizer code, albeit one with less logical qubits.", "_type": "ecc", "_page_id": "c_subsystem_stabilizer", "_href": "c/subsystem_stabilizer"}, "c_bacon_shor": {"notes": "", "realizations": "Trapped-ion qubits: state preparation, logical measurement, and stabilizer measurement for nine-qubit Bacon-Shor code demonstrated on a 13-qubit device by M. Cetina and C. Monroe groups [2009.11482].", "physical": "qubits", "description": "CSS subsystem stabilizer code defined on an \\(m_1 \\times m_2\\) lattice of qubits. It is said to be symmetric when \\(m_1=m_2\\). The \\(X\\)-type and \\(Z\\)-type stabilizers defined as \\(X\\) and \\(Z\\) operators acting on all qubits on adjacent columns and rows, respectively. Let \\(O_{i,j}\\) denote an operator acting on the qubit at a position \\((i,j)\\) on the lattice, with \\(i\\in\\{0,1,\\ldots ,m_1-1\\}\\) and \\(j\\in\\{0,1,\\ldots,m_2-1\\}\\). The code's stabilizer group is\n\\begin{align}\n\\mathsf{S}=\\langle X_{i,*}X_{i+1,*},Z_{*,j}Z_{*,j+1}\\rangle~,\n\\end{align}\nwith generators expressed as products of nearest-neightbour 2-qubit gauge operators,\n\\begin{align}\n\\begin{split}\nX_{i,*}X_{i+1,*}= \\bigotimes_{k=0}^{m_2-1} X_{i,k}X_{i+1,k} \\\\\nZ_{*,j}Z_{*,j+1}=\\bigotimes_{k=0}^{m_1-1} Z_{k,j}Z_{k,j+1}~.\n\\end{split}\n\\end{align}\nSyndrome extraction can be done by measuring these gauge operators, which are on fewer qubits and local.\n\nThe shortest error-correcting Bacon-Shor code is \\([[9,1,3]]\\) and has 6 gauge operators, symmetric in both \\(X\\) and \\(Z\\), reducing to the Shor code<code:shor_nine> for a particular gauge configuration. The error-detecting \\([[4,1,2]]\\) Bacon-Shor code, which reduces to a subcode of the \\([[4,2,2]]\\) code<code:stab_4_2_2> for a particular gauge configuration, has gauge operators \\(\\{XIXI,IIXX,ZIZI,IZIZ\\}\\).\n", "code_id": "bacon_shor", "logical": "qubits", "introduced": "[10.1103/PhysRevA.52.R2493,quant-ph/0506023]", "name": "Bacon-Shor code", "short_name": "", "protection": "The \\([[m_1 m_2,1,min(m_1,m_2)]]\\) variant has distance \\(d=min(m_1,m_2)\\). In a symmetric 3-dimensional case (defined on a cubic lattice) with \\(L^3\\) qubits, the code has the parameters \\([[L^3,1,L]]\\).", "features_rate": "A non-LDPC family of Bacon-Shor codes achieves a distance of \\(\\Omega(n^{1-\\epsilon})\\) with sparse gauge operators.", "features_threshold": "A lower bound of \\(1.94 \\times 10^{-4}\\) for the accuracy threshold was proved for Bacon-Shor code with 5 levels of concatenation, using Steane method of FTEC [quant-ph/0610063].\nThe three dimensional version offers the possibility of being a self-correcting quantum memory [10.1103/PhysRevA.73.012340].", "features_magic_scaling_exponent": "", "features_decoders": "While check operators are few-body, stabilizer weights scale with the number of qubits, and stabilizer expectation values are obtained by taking products of gauge-operator expectation values. It is thus not clear how to extract stabilizer values in a fault-tolerant manner [2009.03921,2107.02194].", "features_transversal_gates": "Logical Hadamard is transversal in symmetric Bacon-Shor codes up to a qubit permutation [quant-ph/0610063] and can be implemented with teleportation [quant-ph/0002039]. Bacon-Shor codes on an \\(m \\times mk\\) lattice admit transversal \\(k\\)-qubit-controlled \\(Z\\) gates [1705.01686].", "features_code_capacity_threshold": "", "features_general_gates": "Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively [Yoder, Theodore., DSpace@MIT Practical Fault-Tolerant Quantum Computation (2018)].", "features_fault_tolerance": "Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively [Yoder, Theodore., DSpace@MIT Practical Fault-Tolerant Quantum Computation (2018)].", "features_encoders": "", "parents_code_id": "bravyi_bacon_shor", "parents_detail": "", "cousin_of_code_id": "gnu_permutation_invariant\nheavy_hex\nquantum_parity", "cousin_of_detail": "Symmetrized versions of the Bacon-Shor codes are GNU codes\nBacon-Shor stabilizers are used to measure the X-type stabilizers of the code.\nBacon-Shor codes reduce to QPCs for a particular gauge configuration.", "_type": "ecc", "_page_id": "c_bacon_shor", "_href": "c/bacon_shor"}, "c_bravyi_bacon_shor": {"notes": "", "realizations": "", "physical": "qubits", "description": "An \\([[n,k,d]]\\) CSS subsystem stabilizer code generalizing Bacon-Shor codes to a larger set of qubit geometries. Defined through a binary matrix \\(A\\) such that physical qubits live on sites \\((i,j)\\) whenever \\(A_{i,j}=1\\). The gauge group is generated by 2-qubit operators, including \\(XX\\) interations between any two qubits sharing a column in \\(A\\), and \\(ZZ\\) interations between two qubits sharing a row. The code parameters are: \\(n=\\sum_{i,j}A_{i,j}\\), \\(k=\\text{rank}(A)\\), and the distance is the minimum weight of any row or column.", "code_id": "bravyi_bacon_shor", "logical": "qubits", "introduced": "[1008.1029]", "name": "Bravyi-Bacon-Shor (BBS) code", "short_name": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits, where \\(d\\) is the minimum weight of a row or column in \\(A\\) [2002.06257].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "parent_of_code_id": "bacon_shor", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_bravyi_bacon_shor", "_href": "c/bravyi_bacon_shor"}, "c_subsystem_color": {"notes": "", "realizations": "", "physical": "qubits", "description": "Stub.\n", "code_id": "subsystem_color", "logical": "qubits", "introduced": "[0908.4246,1311.0879]", "name": "Subsystem color code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "subsystem_stabilizer", "parents_detail": "", "cousins_code_id": "color", "cousins_detail": "", "cousin_of_code_id": "honeycomb", "cousin_of_detail": "Both honeycomb and subsystem color codes are generated via periodic sequences of measurements. However, any measurement sequence can be performed on the color code without destroying the logical qubits, while honeycomb codes can be maintained only with specific sequences. Honeycomb codes require a shorter measurement cycle and use fewer qubits at the given code distance [2107.02194].", "_type": "ecc", "_page_id": "c_subsystem_color", "_href": "c/subsystem_color"}, "c_fractal_surface": {"notes": "", "realizations": "", "physical": "qubits", "description": "Kitaev surface code on a fractal geometry, which is obtained by removing qubits from the surface code on a cubic lattice. Stub.", "code_id": "fractal_surface", "logical": "qubits", "introduced": "[2108.00018,2201.03568]", "name": "Fractal surface code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "surface", "parents_detail": "", "cousins_code_id": "higher_dimensional_surface", "cousins_detail": "Fractal surface codes are obtained by removing qubits from the surface code on a cubic lattice.", "_type": "ecc", "_page_id": "c_fractal_surface", "_href": "c/fractal_surface"}, "c_xzzx": {"notes": "A single \\(X\\) or \\(Z\\) error gives rise to two nearby defects, which can be viewed as endpoints of a string. That way, multiple \\(Z\\) errors can be decomposed into a combination of diagonal strings.\nOriginally formulated as an example of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [quant-ph/0205004].", "realizations": "", "physical": "qubits", "description": "Non-CSS derivative of the surface code whose generators are \\(XZXZ\\) Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).", "code_id": "xzzx", "logical": "qubits", "introduced": "[2009.07851]", "name": "XZZX surface code", "short_name": "", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "features_rate": "", "features_threshold": "\\(\\sim 4.5\\%\\) using minimum-weight perfect matching decoder for depolarizing noise (bias \\(\\eta=0.5\\)); \\(\\sim 10\\%\\) for infinite \\(Z\\) bias.", "features_magic_scaling_exponent": "", "features_decoders": "Minimum-weight perfect matching decoder, which can be used for \\(X\\) and \\(Z\\) noise. For \\(Y\\) noise, a variant of the matching decoder could be used like it is used for the XY code in Ref. CITE arXiv:1907.02554.", "features_transversal_gates": "", "features_code_capacity_threshold": "\\(50\\%\\) threshold for noise infinitely biased towards \\(X\\) or \\(Y\\) or \\(Z\\) errors using a maximum-likelihood decoder.\nFor large but finite \\(X\\)- or \\(Z\\)-biased noise, the code's thresholds exceed the zero-rate hashing bound.  The difference of the threshold from the hashing bound exceeds \\(2.9\\%\\) at a \\(Z\\) or \\(X\\) bias of 300.\n\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder.\n\\(0.817\\%\\) and \\(0.940\\%\\) with minimum-weight perfect matching and belief-matching decoder, respectively, for biased circuit-level noise [2203.04948].", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "clifford-deformed_surface", "parents_detail": "XZZX code is obtained from the surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).", "cousins_code_id": "fracton\ntopological_abelian", "cousins_detail": "Subsystem symmetries play a role in finite-bias decoders for both codes [1901.08061].\nExample of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [quant-ph/0205004].", "_type": "ecc", "_page_id": "c_xzzx", "_href": "c/xzzx"}, "c_freedman_meyer_luo": {"notes": "See thesis by Fetaya for pedagogical exposition [1108.2886].", "realizations": "", "physical": "qubits", "description": "Hyperbolic surface code constructed using cellulation of a Riemann Manifold \\(M\\) exhibitng systolic freedom [10.2140/gtm.1999.2.113]. Codes derived from such manifolds can achieve distances scaling better than \\(\\sqrt{n}\\), something that is impossible using closed 2D surfaces or 2D surfaces with boundaries [10.1063/1.4726034]. Improved codes are obtained by studying a weak family of Riemann metrics on closed 4-dimensional manifolds \\(S^2\\otimes S^2\\) with the \\(Z_2\\)-homology.\n", "code_id": "freedman_meyer_luo", "logical": "qubits", "introduced": "[10.1201/9781420035377-13]", "name": "Freedman-Meyer-Luo code", "short_name": "", "protection": "Four-dimensional manifolds with weak systolic freedom yield \\([[n,2,\\Omega(\\sqrt{n \\sqrt{\\log n}})]]\\) surface codes.", "features_rate": "Codes held a 20-year record the best lower bound on asymptotic scaling of the minimum code distance, \\(d=\\Omega(\\sqrt{n \\sqrt{\\log n}})\\), broken by Ramanujan tensor-product codes.", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "hyperbolic_surface", "parents_detail": "", "cousin_of_code_id": "ramanujan_tensor_product", "cousin_of_detail": "Ramanujan codes broke 20-year record on minimum code distance set by Freedman-Meyer-Luo codes.", "_type": "ecc", "_page_id": "c_freedman_meyer_luo", "_href": "c/freedman_meyer_luo"}, "c_xysurface": {"notes": "", "realizations": "", "physical": "qubits", "description": "Non-CSS derivative of the surface code whose generators are \\(XXXX\\)  and \\(YYYY\\), obtained by mapping \\(Z \\to Y\\) in the surface code.", "code_id": "xysurface", "logical": "qubits", "introduced": "[1708.08474]", "name": "XY surface code", "short_name": "", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "features_rate": "", "features_threshold": "\\(6.32(3)\\%\\) for infinite \\(Z\\) bias, and thresholds of \\(\\sim 5\\%\\) for \\(Z\\) bias around \\(\\eta = 100\\) using a variant of the minimum-weight perfect matching decoder CITE arXiv:1907.02554.", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "\\(50\\%\\) at infinite \\(Z\\) bias with maximum-likelihood decoder [1812.08186].\n\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder [1812.08186].", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "clifford-deformed_surface", "parents_detail": "XY code is obtained from the surface code by applying \\(H\\sqrt{Z}H\\) to all qubits, thereby exchaning \\(Z\\leftrightarrow Y\\).", "_type": "ecc", "_page_id": "c_xysurface", "_href": "c/xysurface"}, "c_real_projective_plane": {"notes": "", "realizations": "", "physical": "qubits", "description": "A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold \\(\\mathbb{R}P^2\\) (in contrast to a genus-\\(g\\) surface). Whereas genus-\\(g\\) surface codes require \\(2g\\) logical qubits, qubit codes on \\(\\mathbb{R}P^2\\) are made from a single logical qubit.", "code_id": "real_projective_plane", "logical": "qubits", "introduced": "[quant-ph/9810055]", "name": "Projective-plane surface code", "short_name": "", "protection": "If \\(\\mathcal{C}\\) is a cellulation of \\(\\mathbb{R}P^2\\), then the bit-flip distance \\(d_X\\) is the shortest cycle in \\(\\mathcal{C}\\), and the phase-flip distance \\(d_Z\\) is the shortest cycle in the dual cellulation \\(\\mathcal{C}^*\\).", "features_rate": "The rate is \\(1/n\\), where \\(n\\) is the number of edges of the particular cellulation.", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "surface", "parents_detail": "", "cousin_of_code_id": "shor_nine", "cousin_of_detail": "Shor's code is the smallest surface code defined on the projective plane [quant-ph/9810055].", "_type": "ecc", "_page_id": "c_real_projective_plane", "_href": "c/real_projective_plane"}, "c_four_dimensional_hyperbolic": {"notes": "", "realizations": "", "physical": "qubits", "description": "Hyperbolic surface code based on cellulations of certain four-dimensional manifolds. The manifolds are shown to have good homology and systolic properties for the purposes of code construction, with corresponding codes exhibiting linear rate.\n\nGuth and Lubotzky [1310.5555] show that there exists \\(\\epsilon\\), a four-dimensional hyperbolic manifold \\(M\\), and a sequence of manifolds \\(M_i\\) such that\neach \\(M_i\\) is a finite sheeted covering <https://en.wikipedia.org/wiki/Covering_space> of \\(M\\), and the four-dimensional volumes of the manifolds \\(\\text{Vol}_4(M_i)\\) of the sequence tend to infinity.\nAlso, the dimension of the second homology and size of systoles are bounded by \\(H_2(M_i, Z_2) \\geq \\frac{\\text{Vol}_4(M_i)}{100}\\) and \\(\\text{Sys}_2(M_i) \\geq \\text{Vol}_4(M_i)^\\epsilon\\), respectively.\n\nThen given any cellulation of \\(M\\), it can naturally be extended to cellulations for each of the manifolds \\(M_i\\) and used to define CSS codes via the homological construction by choosing the size three chain complex consisting of the \\(3,2\\) and \\(1\\)-cells of the cellulations.\n\nFor dense cellulations (i.e. large \\(n\\)) the number of physical qubits for these codes will scale with the volume of the manifolds.\nTherefore, bounds on the dimension of the second homology and size of systoles are achieved in terms of \\(n\\) for large \\(n\\).\n", "code_id": "four_dimensional_hyperbolic", "logical": "qubits", "introduced": "[1310.5555]", "name": "Guth-Lubotzky code", "short_name": "", "protection": "Protection stems from the relationship between properties of manifolds and CSS codes derived from their cellulation. The number of physical \\(k\\) qubits and distance \\(d\\) of the code will scale as \\(\\Omega(n)\\) and \\(\\Omega(n^\\epsilon)\\), respectively.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "hyperbolic_surface", "parents_detail": "", "_type": "ecc", "_page_id": "c_four_dimensional_hyperbolic", "_href": "c/four_dimensional_hyperbolic"}, "c_hyperbolic_surface": {"notes": "", "realizations": "", "physical": "qubits", "description": "An extension of the Kitaev surface code construction to hyperbolic manifolds in dimension two or greater. Given a cellulation of a manifold, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers are associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\(i+1\\)-faces.\n", "code_id": "hyperbolic_surface", "logical": "qubits", "introduced": "", "name": "Hyperbolic surface code", "short_name": "", "protection": "Constructions (see code children below) have yielded distances scaling favorably with the number of qubits. The use of hyperbolic surfaces allows one to circumvent bounds on surface code parameters that are valid for surfaces with bounded geometry.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "surface", "parents_detail": "", "parent_of_code_id": "freedman_meyer_luo\nfour_dimensional_hyperbolic\ntwo_dimensional_hyperbolic_surface", "parent_of_detail": "\n\n", "cousins_code_id": "holographic", "cousins_detail": "Both holographic and hyperbolic surface codes utilize tesselations of hyperbolic surfaces. Encodings for the former are hyperbolically tiled tensor networks, while the latter is defined on hyperbolically tiled physical-qubit lattices.", "_type": "ecc", "_page_id": "c_hyperbolic_surface", "_href": "c/hyperbolic_surface"}, "c_two_dimensional_hyperbolic_surface": {"notes": "See Sec III A of Ref. [2103.06309] for a description of this code.\nConnection to percolation theory as shown in [1205.7036].", "realizations": "", "physical": "qubits", "description": "Hyperbolic surface codes based on a tessellation of a closed 2D manifold with a hyperbolic geometry (i.e., non-Euclidean geometry, e.g., saddle surfaces when defined on a 2D plane).\n\nFor a tessellation involving regular polygons with \\( r \\) sides and \\( s \\) polygons meeting at each edge, the number of logical qubits is given by \\( k = (1-2/r - 2/s) n + 2 \\). Some possible tilings are \\( {r,s}: {7,3}, {5,4} \\). The weight of the stabilizer generators are dependent on the tiling, with \\({5,4}\\) having lower weight than \\({7,3}\\).\n", "code_id": "two_dimensional_hyperbolic_surface", "logical": "qubits", "introduced": "[1506.04029]", "name": "Two-dimensional hyperbolic surface code", "short_name": "", "protection": "Protects against Pauli errors with distance \\( d \\propto \\log(n) \\). Code parameters are \\( [[n, (1-2/r - 2/s)  n + 2, \\log(n) ]] \\)", "features_rate": "Two-dimensional hyperbolic surface codes have an asymptotically constant encoding rate \\( k/n \\) with a distance scaling logarithmically with \\( n\\) when the surface is closed. The encoding rate depends on the tiling \\( {r,s} \\) and is given by \\( k/n = (1-2/r - 2/s) + 2/n \\), which approaches a constant value as the number of physical qubits grows. The weight of the stabilizers is \\( r \\) for \\( Z \\)-checks and \\( s \\) for \\( X \\)-checks. For open boundary conditions, the code reduces to constant distnace.", "features_threshold": "1\\(\\%\\) - 5\\(\\%\\) for a \\({5,4}\\) tiling under minimum-weight decoding [10.1103/PhysRevA.87.020304]. For larger tilings, the lower bound on the distance decreases, suggesting the threshold will also decrease.", "features_magic_scaling_exponent": "", "features_decoders": "Due to the symmetries of hyperbolic surface codes, optimal measurement schedules of the stabilizers can be found [2010.09626].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "hyperbolic_surface", "parents_detail": "", "_type": "ecc", "_page_id": "c_two_dimensional_hyperbolic_surface", "_href": "c/two_dimensional_hyperbolic_surface"}, "c_higher_dimensional_surface": {"notes": "", "realizations": "", "physical": "qubits", "description": "A family of Kitaev surface codes on planar or toric surfaces of dimension greater than two. Stub.", "code_id": "higher_dimensional_surface", "logical": "qubits", "introduced": "[quant-ph/0110143]", "name": "Higher-dimensional surface code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "surface", "parents_detail": "", "cousin_of_code_id": "fractal_surface", "cousin_of_detail": "Fractal surface codes are obtained by removing qubits from the surface code on a cubic lattice.", "_type": "ecc", "_page_id": "c_higher_dimensional_surface", "_href": "c/higher_dimensional_surface"}, "c_clifford-deformed_surface": {"notes": "", "realizations": "", "physical": "qubits", "description": "A generally non-CSS derivative of the surface code defined by applying a constant-depth Clifford circuit to the original (CSS) surface code. Unlike the surface code, CDSCs include codes whose thresholds and subthreshold performance are enhanced under noise biased towards dephasing. Examples of CDSCs include the XY code, XZZX code, and random CDSCs.", "code_id": "clifford-deformed_surface", "logical": "qubits", "introduced": "[2201.07802]", "name": "Clifford-deformed surface code (CDSC)", "short_name": "", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "A class of random CDSCs, parametrized by the probabilities \\(\\Pi_{XZ},~ \\Pi_{YZ}\\) of \\(X\\leftrightarrow Z\\) and \\(Y\\leftrightarrow Z\\) Pauli permutations, respectively, has \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.\nCertain translation-invariant CDSCs such as the XY code and the XZZX code also have \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.\nXZZX code and the \\((0.5,\\Pi_{YZ})\\) random CDSCs have a \\(50\\%\\) code capacity threshold for noise infinitely biased towards either Pauli-\\(X\\), \\(Y\\), or \\(Z\\) errors.", "features_general_gates": "", "features_fault_tolerance": "In order to leverage the benefits of CDSCs into practical universal computation, we have to implement syndrome measurement circuits and fault-tolerant logical gates in a bias-preserving way.", "features_encoders": "", "parents_code_id": "qubit_stabilizer\ntopological_abelian", "parents_detail": "\nLocal deformations of the surface code preserve its \\(\\mathbb{Z}_2\\) topological order.", "parent_of_code_id": "surface\nxysurface\nxzzx", "parent_of_detail": "CDSC is generally a non-CSS derivative of the surface code.\nXY code is obtained from the surface code by applying \\(H\\sqrt{Z}H\\) to all qubits, thereby exchaning \\(Z\\leftrightarrow Y\\).\nXZZX code is obtained from the surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\).", "cousins_code_id": "dynamic_gen\nquantum_random", "cousins_detail": "To create CDSCs, a dynamical process is applied on top of the surface code.\nMany useful CDSCs are constructed using random Clifford circuits.", "_type": "ecc", "_page_id": "c_clifford-deformed_surface", "_href": "c/clifford-deformed_surface"}, "c_surface": {"notes": "2D and 3D surface code visualization\ntool <http://gui.quantumcodes.io/>.\n\nTutorials from error-correction perspective by\nJ. Haah <https://boulderschool.yale.edu/2018/boulder-school-2018-lecture-notes>\nand condensed-matter perspective by\nM. Levin\nand C. Nayak <https://boulderschool.yale.edu/2016/boulder-school-2016-lecture-notes>.\n", "realizations": "Distance-two surface codes have been implemented by Andersen et\nal. [1912.09410], Erhard et al. [2006.03071], and\nGoogle Quantum AI [10.1038/s41586-021-03588-y].\n\nSignatures of corresponding topological phase of matter detected in\nsuperconducting circuits [2104.01180] and two-dimensional arrays\nof Rydberg atoms [2104.04119].\n\nDistance-three surface code implemented at ETH Zurich\n[2112.03708] and on the Zuchongzhi 2.1 superconducting quantum\nprocessor [2112.13505].\n", "physical": "qubits", "description": "A family of abelian topological CSS stabilizer<code:css> codes\nwhose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings\nassociated to the stars and plaquettes, respectively, of a cellulation of a\ntwo-dimensional surface (with a qubit located at each edge of the\ncellulation). Toric code often either refers to the construction on\nthe two-dimensional torus or is an alternative name for the general\nconstruction. The construction on surfaces with boundaries is often called the\nplanar code [quant-ph/9811052].\n\nThe original construction can be naturally extended to arbitrary dimensional\nmanifolds\n[10.1201/9781420035377-13,10.1007/978-3-642-01877-0_21]. Given a\ncellulation, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers\nare associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are\nassociated with \\(i+1\\)-faces.\n\nThe stabilizers of the surface code on the 2-dimensional torus are generated\nby star operators \\(A_v\\) and plaquette operators \\(B_p\\).  Each star operator\nis a product of four Pauli-\\(X\\) operators on the edges adjacent to a vertex\n\\(v\\) of the lattice; each plaquette operator is a product of four Pauli-\\(Z\\)\noperators applied to the edges adjacent to a face, or plaquette, \\(p\\) of the\nlattice (<figure:toric-code-operators>).\n\n<Figure>\n\nThe two-dimensional toric code encodes two logical qubits.  We denote by\n\\(\\overline{X}_i,\\overline{Z}_i\\) the logical Pauli-\\(X\\) and Pauli-\\(Z\\)\noperator of the \\(i\\)-th logical qubit.  They can are represented by strings\nof Pauli-\\(X\\) operators or Pauli-\\(Z\\) operators that wrap around the torus\nas shown in <figure:toric-code-operators>.\n", "code_id": "surface", "logical": "qubits", "introduced": "[10.1070/RM1997v052n06ABEH002155,10.1007/978-1-4615-5923-8_19,quant-ph/9707021]\n", "name": "Kitaev surface code", "short_name": "", "protection": "Toric code on an \\(L\\times L\\) torus is a \\([[2L^2,2,L]]\\) CSS code, and there\nexists a planar code with \\([[L^2,1,L]]\\) [1111.4022]. More\ngenerally, the code distance is related to the homology of the cellulation\n[quant-ph/0110143].\n", "features_rate": "Rate depends on the underlying cellulation and manifold. For general 2D\nmanifolds, \\(kd^2\\leq c(\\log k)^2 n\\) for some constant \\(c\\)\n[1301.6588], meaning that (1) 2D surface codes with bounded\ngeometry have distance scaling at most as \\(O(\\sqrt{n})\\)\n[0909.5200,10.1063/1.4726034], and (2) surface codes with\nfinite rate can only achieve an asymptotic minimum distance that is\nlogarithmic in \\(n\\). Higher-dimensional hyperbolic manifolds (see code\nchildren below) yield distances scaling more favorably. Loewner's theorem\nprovides an upper bound for any bounded-geometry surface code\n[10.1201/9781420035377-13].\n", "features_threshold": "\\(0.5-1.1\\%\\) for various error models [1311.5003,0811.0464].", "features_magic_scaling_exponent": "", "features_decoders": "Minimum weight perfect-matching\n[quant-ph/0110143,10.26421/QIC15.1-2-9], union-find\n[1709.06218], renormalization group\n[10.26421/QIC14.9-10-1,1411.3028], tensor network\n[1405.4883], Markov chain Monte Carlo [1302.2669],\ncellular automaton [1511.05579], machine learning\n[1610.04238,1802.06441,1810.07207].\n", "features_transversal_gates": "Transversal Pauli gates exist and are based on non-trivial loops on surface.\nTransversal Clifford gates can be done on folded surface codes [1603.02286].\n", "features_code_capacity_threshold": "For correlated Pauli noise, bounds on code capacity thresholds can be obtained by mapping the effect of noise on the code to a statistical mechanical model. The first such threshold, based on the planar code, is \\(0.017\\%\\) [quant-ph/0110143].\n\\(10.9\\%\\) (\\(10.31\\%\\)) with pure \\(Z\\)-dephasing noise for square tiling\nusing tensor-network [cond-mat/0106023,1405.4883]\n(minimum-weight perfect matching [quant-ph/0207088]) decoder.\n\n\\(18.9\\%\\) with depolarizing noise for square tiling [1202.1852].\n\\(50\\%\\) with loss errors for square tiling [0904.3556].\n\\(3.3\\%\\) with phenomenological noise for square tiling [quant-ph/0401101].", "features_general_gates": "Clifford gates can be implemented via lattice surgery\n[1111.4022,1709.02318,1808.02892,2109.02746],\ntwist-based lattice surgery [2201.05678], or braiding defects\n[quant-ph/0610082,quant-ph/0703143,1208.0928,1609.04673].\n\nNon-Clifford gates require magic state distillation\n[1905.06903], Dehn twists [1806.06078], or\njust-in-time decoding [1903.11634].\n", "features_fault_tolerance": "", "features_encoders": "Unitary [0712.0348,2002.00362,2110.02020].\nDissipative [1310.1036].\nStabilizer measurement-based [1404.2495].", "parents_code_id": "css\nclifford-deformed_surface\ntopological_abelian", "parents_detail": "\nCDSC is generally a non-CSS derivative of the surface code.\nWhen treated as ground states of the code Hamiltonian, the code states\nrealize \\(\\mathbb{Z}_2\\) topological order, a topological phase of\nmatter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory\n[10.1063/1.1665530].\n", "parent_of_code_id": "fractal_surface\nhigher_dimensional_surface\nhyperbolic_surface\nreal_projective_plane\nstab_4_2_2", "parent_of_detail": "\n\n\n\n\\([[4,2,2]]\\) code is the smallest toric code.", "cousins_code_id": "hypergraph_product", "cousins_detail": "Planar (toric) code obtained from hypergraph product of two repetition\n(cyclic) codes.\n", "cousin_of_code_id": "color\ndouble_semion\nhaah_cubic\nheavy_hex\nhoneycomb\nlifted_product\nqudit_surface\ntranslationally_invariant_stabilizer.yml", "cousin_of_detail": "Color code is equivalent to surface code in several ways [1503.02065,1804.00866]. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code.\nThere is a logical basis for the toric and double-semion codes where each codeword is a superposition of states corresponding to all noncontractible loops of a particular homotopy type. The superposition is equal for the toric code, whereas some loops appear with a \\(-1\\) coefficient for the double semion.\nThe energy of any partial implementation of code 1 is proportional to the boundary length similar to the 4D toric code, which can potentially surpress the effects of thermal errors, but it is currently an open problem.\nSurface code stabilizers are used to measure the Z-type stabilizers of the code.\nMeasurement of each check operator involves two qubits and projects the state of the two qubits to a two-dimensional subspace, which we regard as an effective qubit. These effective qubits form a surface code on a hexagonal superlattice. Electric and magnetic operators on the embedded surface code correspond to outer logical operators of the Floquet code. In fact, outer logical operators transition back and forth from magnetic to electric surface code operators under the measurement dynamics.\nA lifted product code for the ring \\(R=\\mathbb{F}_2[x,y]/(x^L-1,y^L-1)\\) is the toric code.\nThe qudit surface code with \\(q=2\\) is the surface code.\nTranslation-invariant 2D qubit topological stabilizer codes are equivalent to several copies of the Kitaev surface code via a local constant-depth Clifford circuit [1103.4606,1107.2707].", "_type": "ecc", "_page_id": "c_surface", "_href": "c/surface"}, "c_homological_cv": {"notes": "", "realizations": "No experimental realization. However, Ref. [1601.02544] describes a potential experimental optical procedure for the simplest non-trival code with 5 modes.", "physical": "oscillators", "description": "An \\([[n,1]]_{\\mathbb{R}}\\) oscillator-into-oscillator CSS stabilizer code<code:oscillator_stabilizer> defined using homological structres associated with an \\(n-1\\) simplex.\n\nStabilizer generators are defined by two orthogonal subspaces of the \\(C_1\\) in the chain complex. \\(C_X = \\partial_2 C_2\\) and \\(C_P = \\partial_1^T Q\\) for some \\(Q \\subset C_0\\). The standard approach would use \\(Q = C_0\\), which would mean the logical dimension would be the dimension of the 1st homology group \\(H^1\\). However, \\(H^1\\) is trivial for the \\(n-1\\) simplex, so one chooses \\(Q \\neq C_0\\) such that exactly one stabilizer is removed, yielding a stabilizer code instead of a single stabilized state.'\n", "code_id": "homological_cv", "logical": "oscillators", "introduced": "[1601.02544]", "name": "Homological bosonic code", "short_name": "", "protection": "Protects against certain types of erasure errors (depending on the specific dimension). Certain constructions also protect arbitrary sized errors on multiple photon states.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Decoding requires a different circuit for each possible erasure error, with no general circuit decoding any possible erasure error. Every circuit relies on a generalized conditional rotation, which Ref. [1601.02544] calls the QND Gate and which is defined as \\(QND_c | x , y \\rangle = |x + c y, y \\rangle\\).", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Encoding depends on the specific dimension, but can generally be done using generalized conditional-rotation and Fourier-transform gates.", "parents_code_id": "oscillators_into_oscillators\noscillator_stabilizer", "parents_detail": "\nHomological CV codes are bosonic CSS codes.", "cousins_code_id": "css\nniset_andersen_cerf", "cousins_detail": "CSS and homological CV codes utilize chain complexes in code construction, with the latter complexes having trivial homology.\nThe Niest-Andersen-Cerf code can be viewed as a scheme to replicate quantum information in multiple regions [1601.02544].", "_type": "ecc", "_page_id": "c_homological_cv", "_href": "c/homological_cv"}, "c_hybrid_qudit_oscillator": {"notes": "", "realizations": "", "physical": "qudits", "description": "Encodes a \\(K\\)-dimensional logical Hilbert space into \\(n_1\\) qudits of dimension \\(q\\) and \\(n_2 \\neq 0\\) oscillators, i.e., the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{Z}_q^{n_1} \\times \\mathbb{R}^{n_2}\\).", "code_id": "hybrid_qudit_oscillator", "logical": "groups", "introduced": "", "name": "Hybrid qudit-oscillator code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "oscillators", "parents_detail": "The physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator.", "parent_of_code_id": "very-small-logical-qubit", "parent_of_detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators.", "cousins_code_id": "qudits_into_oscillators", "cousins_detail": "Hybrid code with \\(n_1=0\\).", "_type": "ecc", "_page_id": "c_hybrid_qudit_oscillator", "_href": "c/hybrid_qudit_oscillator"}, "c_gkp": {"notes": "GKP codes were obtained after iterative numerical optimization of encoding and recovery against photon loss, starting with Haar-random states [1801.07271].", "realizations": "Microwave cavity coupled to superconducting circuits [10.1038/s41586-020-2603-3].\nMotional degree of freedom in a trapped ion [10.1038/s41586-019-0960-6].", "physical": "oscillators", "description": "Bosonic qudit-into-oscillator code whose stabilizers are oscillator displacement operators \\(\\hat{S}_q(2\\alpha)=e^{-2i\\alpha \\hat{p}}\\) and \\(\\hat{S}_p(2\\beta)=e^{2i\\beta \\hat{q}}\\). To ensure \\(\\hat{S}_q(2\\alpha)\\) and \\(\\hat{S}_p(2\\beta)\\) generate a stabilizer group that is Abelian, there is another constraint that \\(\\alpha\\beta=2k\\pi\\) where \\(k\\) is an integer. Codewords can be expressed as equal weight superpositions of coherent states on an infinite lattice, such as a square lattice in phase space with spatial period \\(2\\sqrt{\\pi}\\). The exact GKP state is non-normalizable, so approximate constructs have to be considered.", "code_id": "gkp", "logical": "qudits", "introduced": "[quant-ph/0008040]", "name": "Gottesman-Kitaev-Preskill (GKP) code", "short_name": "GKP", "protection": "For stabilizer \\(\\hat{S}_q(2\\alpha),\\hat{S}_p(2\\beta)\\), code can correct displacement errors up to \\(\\frac{\\alpha}{2}\\) in the \\(q\\)-direction and \\(\\frac{\\beta}{2}\\) at \\(p\\)-direction. Approximately protects against photon loss errors [10.1103/PhysRevA.93.012315], outperforming most other codes designed to explicitly protect against loss [1708.05010]. Very sensitive to dephasing errors [10.1103/PRXQuantum.2.020101]. A biased-noise GKP error correcting code can be prepared by choosing \\(\\alpha\\neq \\beta\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Syndrome measruement of displacement error can be done by applying a controlled-displacement controlled by an ancilla qubit. The syndrome information can be obtained by measuring the ancilla qubit after controlled-displacement opearation. See Section. 2D in [10.1103/PRXQuantum.2.020101].\nPauli \\(X\\),\\(Y\\) and \\(Z\\) measurements can be performed by measuring \\(-\\hat{p},\\hat{q}-\\hat{p}\\) and \\(\\hat{q}\\) repectively. If the measurement outcome is closed to an even multiple of \\(\\sqrt{\\pi}\\), then the outcome is +1. If the measurement outcome is closed to an odd multiple of \\(\\sqrt{\\pi}\\), then the outcome is -1. See Section. 2D in [10.1103/PRXQuantum.2.020101].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements [10.1103/PhysRevLett.123.200502].", "features_fault_tolerance": "Clifford gates can be realized by performing linear-optical operations, sympletic transformations and displacements, all of which are Gaussian operations. Pauli gates can be performed using displacement operators. Clifford gates are fault tolerant in the sense that they map bounded-size errors to bounded-size errors [quant-ph/0008040].\nError correction scheme is fault-tolerant to displacement noise as long as all input states have displacement errors less than \\(\\sqrt{\\pi}/6\\) [quant-ph/0510107].", "features_encoders": "Preparation of approximate GKP states is studied both theoretically and experimentally on circuit-QED platforms, by putting the GKP lattice inside a Gaussian envelope [10.1103/PhysRevA.93.012315,10.1103/PhysRevA.97.022341,10.1038/s41586-020-2603-3].", "parents_code_id": "multimodegkp", "parents_detail": "", "cousins_code_id": "approximate_qecc", "cousins_detail": "GKP codes approximately protect against photon loss [1506.05033,1708.05010,1801.07271].", "cousin_of_code_id": "bosonic_rotation\nrotor_gkp", "cousin_of_detail": "GKP codes utilize the translational symmetry in phase space, while rotation codes utilize rotational symmetry.\nGKP (rotor GKP) codes protect against shifts in linear (angular) degrees of freedom.", "_type": "ecc", "_page_id": "c_gkp", "_href": "c/gkp"}, "c_oscillators_into_oscillators": {"notes": "", "realizations": "", "physical": "oscillators", "description": "Encodes Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}^k\\) into that on \\(\\mathbb{R}^n\\). Usually denoted as \\(((n,k))_{\\mathbb{R}}\\).", "code_id": "oscillators_into_oscillators", "logical": "oscillators", "introduced": "[quant-ph/9711021,quant-ph/9711049]", "name": "Oscillator-into-oscillator code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "oscillators", "parents_detail": "Bosonic code with infinite-dimensional logical subspace.", "parent_of_code_id": "homological_cv\nniset_andersen_cerf", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_oscillators_into_oscillators", "_href": "c/oscillators_into_oscillators"}, "c_niset_andersen_cerf": {"notes": "", "realizations": "Realized in Ref. [10.1038/nphoton.2010.168] in an optical system with 3 beam-splitters. The fidelity peaked around \\(0.6\\) for deterministic approach, and around \\(0.77\\) for the probabilistic approach (with a 25% chance of error).", "physical": "oscillators", "description": "Encodes two-mode coherent states \\(\\{|\\alpha\\rangle, |\\beta\\rangle\\}\\) over two modes into four modes such that the values \\((\\alpha,\\beta)\\) are recoverable after a single-mode erasure. There are two variations of the storage procedure: a deterministic protocol that offers recovery against a single mode erasure, and a probabalistic that can protect against multiple errors with post selection. This code is effectively protecting classical information stored in \\((\\alpha,\\beta)\\) using quantum operations.", "code_id": "niset_andersen_cerf", "logical": "oscillators", "introduced": "[0710.4858]", "name": "Niset-Andersen-Cerf code", "short_name": "", "protection": "The deterministic protocol protects against a single erasure error on a known mode. This recovers one state perfectly and the other state with fidelity \\(F = \\frac{1}{1 + e^{-2 r}}\\) for an initial EPR pair squeezed with variance \\(e^{-2r}\\). The probabalistic protocol utilizes post-selection to protect against multiple erasures with state-dependent fidelity.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Optical decoder using three beam splitters, electronic gain detectors, and two phase-insensitive amplifiers as described in Ref. [0710.4858].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "After an EPR pair preparation, use 2 continuous CNOT and 2 continuous inverse CNOT gates to entangle a bosonic EPR pair with initial states \\(|\\alpha \\rangle\\) and \\(|\\beta \\rangle\\).\nAlternate optical encoder using a two-mode squeezed vacuum state and two balanced beam splitters to mix the input coherent states with the EPR pair.", "parents_code_id": "oscillators_into_oscillators", "parents_detail": "", "cousin_of_code_id": "homological_cv", "cousin_of_detail": "The Niest-Andersen-Cerf code can be viewed as a scheme to replicate quantum information in multiple regions [1601.02544].", "_type": "ecc", "_page_id": "c_niset_andersen_cerf", "_href": "c/niset_andersen_cerf"}, "c_oscillator_stabilizer": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Bosonic stabilizer code", "physical": "oscillators", "short_name": "", "protection": "Protective properties can be delineated in terms of the annihilators or displacements. If an error operator does not commute with a stabilizer group element, then that error is detectable. Oscillator-into-oscillator stabilizer codes protect against erasures of a subset of modes, while GKP codes protect against sufficiently small displacements in any number of modes.", "description": "Bosonic code whose codespace is defined as the common \\(+1\\) eigenspace of a group of mutually commuting displacement operators (exponentials of linear combinations of position and momentum operators). Such displacement-based codes closely resemble and inherit some features of qubit stabilizer codes. Displlacements, and therefore the stabilizers, have continuous eigenvalues, in contrast with the discrete set of eigenvalues of a qubit stabilizer code. Exact codewords are non-normalizable, so approximate constructions have to be considered.\n\nStabilizer codewords encoding a finite-dimensional codespace admit a discrete infinite stabilizer group. Qubit-into-oscillator stabilizer codes are equivalent to GKP codes<code:gkp>.\n\nStabilizer codewords encoding a logical oscillator admit either a discrete or a continuous stabilizer group. The former, called GKP-stabilizer codes, are obtained from multimode GKP codes by removing stabilizer generators for some of the modes. The latter are most easily defined in terms of the group's Lie algebra, i.e., as the common \\(0\\)-eigenvalue eigenspace of mutually commuting linear combinations of oscillator position and momentum operators called annihilators. An \\(((n,k,d))_{\\mathbb{R}}\\) oscillator-into-oscillator<code:oscillators_into_oscillators> stabilizer code is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.\n\nA bosonic stabilizer code admitting a set of mutually commuting operators (either annihilators or displacements) such that each operator consists of either position or momentum operators is called a bosonic CSS code.\n", "code_id": "oscillator_stabilizer", "logical": "", "parents_code_id": "stabilizer\noscillators", "parents_detail": "\n", "parent_of_code_id": "homological_cv\nmultimodegkp", "parent_of_detail": "Homological CV codes are bosonic CSS codes.\nGKP codes defined on rectangular lattice are bosonic CSS codes, which more general lattices yield bosonic stabilizer codes.", "cousin_of_code_id": "group_gkp", "cousin_of_detail": "The group-GKP construction encompasses all bosonic CSS codes. For example, a single-mode qubit GKP code corresponds to the \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\) group construction.", "_type": "ecc", "_page_id": "c_oscillator_stabilizer", "_href": "c/oscillator_stabilizer"}, "c_gkp-stabilizer": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "[1903.12615]", "notes": "", "realizations": "", "name": "GKP-stabilizer code", "physical": "oscillators", "short_name": "", "protection": "", "description": "Stub.", "code_id": "gkp-stabilizer", "logical": "", "parents_code_id": "multimodegkp", "parents_detail": "GKP-stabilizer codes correspond to multimode GKP codes constructed using a degenerate lattice; see Appx. A of Ref. [2109.14645].", "_type": "ecc", "_page_id": "c_gkp-stabilizer", "_href": "c/gkp-stabilizer"}, "c_oscillators": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Bosonic code", "physical": "oscillators", "short_name": "", "protection": "", "description": "Also called an oscillator or a continuous-variable (CV) code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one oscillator (a.k.a. bosonic mode or qumode). States of a single oscillator are elements of the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}\\)). Ideal codewords may not be normalizable because the space is infinite-dimensional, so approximate versions have to be constructed in practice.", "code_id": "oscillators", "logical": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "oscillator_stabilizer\nhybrid_qudit_oscillator\noscillators_into_oscillators\nqudits_into_oscillators", "parent_of_detail": "\nThe physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator.\nBosonic code with infinite-dimensional logical subspace.\nBosonic code with finite-dimensional logical subspace.", "cousin_of_code_id": "fermions\ngroup_quantum", "cousin_of_detail": "Bosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom.\nGroup quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes.", "_type": "ecc", "_page_id": "c_oscillators", "_href": "c/oscillators"}, "c_qudits_into_oscillators": {"notes": "", "realizations": "", "physical": "oscillators", "description": "Encodes \\(K\\)-dimensional Hilbert space into Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}^n\\).", "code_id": "qudits_into_oscillators", "logical": "qudits", "introduced": "", "name": "Qudit-into-oscillator code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Given an encoding of a finite-dimensional code, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program [quant-ph/0109155,quant-ph/0307138]. This technique can be adapted to bosonic codes as long as they are restricted to a finite-dimensional subspace of the oscillator Hilbert space [0706.3400].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "oscillators", "parents_detail": "Bosonic code with finite-dimensional logical subspace.", "parent_of_code_id": "fock_state\nmultimodegkp", "parent_of_detail": "\n", "cousin_of_code_id": "hybrid_qudit_oscillator", "cousin_of_detail": "Hybrid code with \\(n_1=0\\).", "_type": "ecc", "_page_id": "c_qudits_into_oscillators", "_href": "c/qudits_into_oscillators"}, "c_very-small-logical-qubit": {"notes": "", "realizations": "", "physical": "groups", "description": "The two logical codewords are \\(|\\pm\\rangle \\propto (|0\\rangle\\pm|2\\rangle)(|0\\rangle\\pm|2\\rangle)|0\\rangle|0\\rangle\\), where the total Hilbert space is the tensor product of two qudits (whose ground states \\(|0\\rangle\\) and second excited states \\(|2\\rangle\\) are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.", "code_id": "very-small-logical-qubit", "logical": "qubits", "introduced": "[10.1103/PhysRevLett.116.150501]", "name": "Very small logical qubit (VSLQ) code", "short_name": "", "protection": "Passively protects against single photon loss.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Logical qubit can be measured with physical qubit measurements along \\(X\\). Can be implemented by engineering a coupling of one of the qubits to a readout cavity via the interaction \\(\\sigma_x (a+a^\\dagger)\\) [10.1103/PhysRevLett.115.203601]. This results in an \\(X\\)-dependent shift of the readout cavity resonance which can be measured.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Single logical qubit operations implemented by resonant physical qubit driving and phase shifting the SQUID drives.\nA CZ gate between two logical qubits implemented by coupling devices through another driven SQUID and applying a pulse to the coupling squid simultaneously with a single qubit operation on one of the logical qubits.", "features_fault_tolerance": "", "features_encoders": "Engineering a circuit made of two transmons and two oscillators coupled through three driven superconducting quantum interference devices (SQUIDs) results in passive stabilization of the logical states.", "parents_code_id": "hybrid_qudit_oscillator", "parents_detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators.", "cousins_code_id": "quantum_repetition", "cousins_detail": "Parts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss.", "_type": "ecc", "_page_id": "c_very-small-logical-qubit", "_href": "c/very-small-logical-qubit"}, "c_multimodegkp": {"notes": "", "realizations": "", "physical": "oscillators", "description": "Generalization of the GKP code to \\(n\\) bosonic modes whose stabilizers are oscillator displacement operators\n\\begin{align}\nD(\\xi) = \\exp \\left\\{-i \\sqrt{2\\pi} {\\xi}^\\mathrm{T} J \\hat{x} \\right\\} , \\quad \\xi \\in \\mathbb{R}^{2n}\n\\end{align}\nand \\(\\hat{S}_p(2\\beta)=e^{2i\\beta \\hat{q}}\\), where the symplectic inner product between two vectors in \\(\\mathbb{R}^{2n}\\) is\n\\begin{align}\nJ = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} \\otimes I_n = \\begin{pmatrix}\n0 &  I_n \\\\\n-I_n  & 0 \\end{pmatrix}~.\n\\end{align}\nA group generated by a set of independent displacement operators is given by a lattice \\({\\mathcal{L}}\\)\n\\begin{align}\n\\langle D(\\xi_1) ,\\dots,  D(\\xi_{2n})  \\rangle = \\left{ e^{ i \\phi_M \\xi D(\\xi) \\vert \\xi \\in {\\mathcal{L}} } \\right}\n\\end{align}\nand becomes a valid stabilizer group when every symplectic inner product between lattice vectors yields an integer. In other words, the corresponding lattice is symplectically integral, corresponding to an integer-valued symplectic Gram matrix \\(A\\),\n\\begin{align}\nA_{ij}={\\xi}^T_i J \\xi_j \\in \\mathbb{Z}~.\n\\end{align}\n\nThe centralizer for this stabilizer group within the displacement operators can be identified with the symplectic dual lattice \\({\\mathcal{L}}^{\\perp}\\) (i.e. all points in \\(\\mathbb{R}^{2n}\\) that have integer symplectic inner product with all points in \\({\\mathcal{L}}\\) ), such that logical operations are identified with the dual quotients \\({\\mathcal{L}}^{\\perp}/{\\mathcal{L}}\\). The size of this dual quotient is the determinant of the Gram matrix, yielding the logical dimension \\(d=\\sqrt{\\| \\det{A}\\|}\\) [quant-ph/0008040].\n", "code_id": "multimodegkp", "logical": "qudits", "introduced": "[quant-ph/0008040,quant-ph/0105058]", "name": "Multi-mode GKP code", "short_name": "", "protection": "The level of protection against displacement errors is quantified by the Euclidean code distance \\(\\Delta=\\min_{x\\in {\\mathcal{L}}^{\\perp}\\setminus {\\mathcal{L}}} \\|x\\|_2\\) [2109.14645].", "features_rate": "Transmission schemes with multimode GKP codes achieve, up to a constant-factor offset, the capacity of displacement-noise and thermal-noise Gaussian loss channels [quant-ph/0105058,1708.07257,1801.04731,1801.07271].", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "The MLD decoder for Gaussian displacement errors is realized by evaluating a lattice theta function, and in general the decision can be approximated by either solving (approximating) the closest vector problem (CVP) or by using other effective iterative schemes when e.g. the lattice represents a concatenated GKP code [1810.00047,1908.03579,2109.14645,2111.07029].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements [1903.00012].", "features_fault_tolerance": "Logical Clifford operations are given by Gaussian unitaries, which map bounded-size errors to bounded-size errors [quant-ph/0008040].", "features_encoders": "Multi-mode GKP codes with fixed \\(n\\) and prime-dimensional logical Hilbert space are symplectically related to a disjoint product of single-mode GKP codes on \\(n\\) modes, such that encoding via Gaussian unitaries is possible.\nDissipative stabilization of finite-energy GKP states using stabilizers conjugated by the exponential of the total occupation number CITE 2201.12337.", "parents_code_id": "qudits_into_oscillators\noscillator_stabilizer", "parents_detail": "\nGKP codes defined on rectangular lattice are bosonic CSS codes, which more general lattices yield bosonic stabilizer codes.", "parent_of_code_id": "gkp-stabilizer\ngkp", "parent_of_detail": "GKP-stabilizer codes correspond to multimode GKP codes constructed using a degenerate lattice; see Appx. A of Ref. [2109.14645].\n", "cousins_code_id": "approximate_qecc\npoints_into_lattices", "cousins_detail": "Approximate error-correction offered by GKP codes yields achievable rates that are a constant away from the capacity of Guassian loss channels [quant-ph/0105058,1708.07257,1801.04731,1801.07271].\nMultimode GKP codes are quantum analogues of lattice-based codes.", "_type": "ecc", "_page_id": "c_multimodegkp", "_href": "c/multimodegkp"}, "c_chuang-leung-yamamoto": {"notes": "", "realizations": "", "physical": "oscillators", "description": "Bosonic Fock-state code that encodes \\(k\\) qubits into \\(n\\) oscillators, with each oscillator restricted to having at most \\(N\\) excitations. Codewords are superpositions of oscillator Fock states which have exactly \\(N\\) total excitations, and are either uniform (i.e., balanced) superpositions or unbalanced superpositions. Codes can be denoted as \\([[N,n,2^k,d]]\\), which conflicts with stabilizer code<code:stabilizer> notation.", "code_id": "chuang-leung-yamamoto", "logical": "qubits", "introduced": "[10.1103/PhysRevA.56.1114]", "name": "Chuang-Leung-Yamamoto code", "short_name": "", "protection": "Protects against amplitude damping for up to \\(t = d-1\\) excitation losses. Defining the spacing between two Fock states \\(|u_1\\cdots u_n\\rangle\\) and \\(|v_1\\cdots v_n\\rangle\\),\n\\begin{align}\n\\text{Spacing}(u,v) = \\frac{1}{2}\\sum_{i=1}^n |u_i - v_i|,\n\\end{align}\nthe code distance \\(d\\) can be defined as the minimial spacing between Fock states making up the codewords.\n", "features_rate": "Code rate is \\(\\frac{k}{n \\log_2(N+1)}\\). To correct the loss of up to \\(t\\) excitations with \\(K+1\\) codewords, a code exists with scaling \\(N \\sim t^3 K/2\\).", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Destructive decoding with a photon number measurement on each mode.\nState can be decoded with a network of beamsplitters, phase shifters, and Kerr media.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Photon Fock state input into a network of beamsplitters, phase shifters, and Kerr media. These operations all preserve total photon number. Beamsplitters and phase shifters take annihilation operators to linear combinations of annihilation operators, and the transformation matrix is unitary. The operations corresponding to Kerr nonlinear media are diagonal in the Fock basis, but they implement phases that in general depend nonlinearly on the number of photons in each mode. State preparation may require ancillary modes and be conditioned on photon-number measurement results.", "parents_code_id": "fock_state\nconstant_excitation", "parents_detail": "Chuang-Leung-Yamamoto code are multi-mode Fock-state codes.\nChuang-Leung-Yamamoto codewords are constructed out of Fock states with the same total excitation number.", "parent_of_code_id": "constant_excitation_permutation_invariant", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_chuang-leung-yamamoto", "_href": "c/chuang-leung-yamamoto"}, "c_binomial": {"notes": "The mean occupation number, or average Fock-state number in maximally-mixed state of the code, is \\((N+1)(S+1)(q-1)/2 \\), where \\(q\\) is the qudit dimension.", "realizations": "Realized in microwave cavities coupled to superconducting circuits [10.1038/s41567-018-0414-3].", "physical": "oscillators", "description": "Bosonic rotation codes designed to approximately protect against errors consisting of powers of raising and lowering operators up to some maximum power. Binomial codes can be thought of as spin-coherent states embedded into an oscillator [1708.05010]. The \\(q\\)-dimensional qudit \\((N, S)\\) binomial codeword states are \\(\\{|\\overline{i}\\rangle\\mid i\\in \\mathbb Z_q \\}\\), where\n  \\begin{align}\n    |\\overline{i}\\rangle = \\frac{1}{\\sqrt{q^N}} \\sum_{\\substack{p=0\\\\p\\equiv i \\pmod{q}}}^{(q-1)(N+1)} \\sqrt{\\binom{N+1}{p}_q} \\ket{p(S+1)}.\n  \\end{align}\n  Here, \\(\\binom{N+1}{p}_q\\) are extended binomial coefficients, or polynomial coeffiients, defined recursively as\n  \\begin{align}\n    \\binom{n}{m}_1 \\equiv 1,\\quad \\binom{n}{m}_q \\equiv \\sum_{k=0}^n \\binom{n}{k}\\binom{k}{m-k}_{q-1}.\n  \\end{align}\n", "code_id": "binomial", "logical": "qudits", "introduced": "[1602.00008]", "name": "Binomial code", "short_name": "", "protection": "An \\((N, S)\\) binomial code protects against \\(L\\) boson losses, \\(G\\) boson gains, and dephasing up to \\(\\hat{n}^{\\D}\\), where \\(S=L+G\\) and \\(N = \\mathrm{max}(L,G,2D)\\). Binomial codes approximately protect against continuous-time amplitude damping, boson loss and gain, and dephasing.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Photon loss and dephasing errors can be detected by measuring the phase-space rotation \\(\\exp\\left(2\\pi\\mathrm{i} hat n / (S+1)\\right)\\) and the check operator \\(J_x/J\\) in the spin-coherent state language, where \\(J\\) is the total angular momentum and \\(J_x\\) is the angular momentum in the \\(x\\) direction [1708.05010]. This type of error correction fails for errors that are products of photon loss/gain and dephasing errors. However, for certain \\((N,S)\\) instances of the binomial code, detection of these types of errors can be done.\nRecovery can be done via projective measurements and unitary operations [1602.00008,1708.05010].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "bosonic_rotation", "parents_detail": "One can verify by direct calculation that the logical states are eigenstates of the discrete rotation operator. One has freedom in the exact form of the primitive state to choose; see Appendix B.2 of Ref. [1901.08071].", "cousins_code_id": "cat\nnumber_phase", "cousins_detail": "For a fixed \\(S\\), binomial codes with \\(N \\to \\infty\\) coincide with cat codes as \\(\\alpha \\to \\infty\\) [1602.00008].\nIn the limit as \\(N,S \\to \\infty\\), phase measurement in the binomial code has vanishing variance, just like in a number-phase code [1901.08071].", "cousin_of_code_id": "gnu_permutation_invariant", "cousin_of_detail": "Binomial codes and GNU codes are both described by spin-coherent states [1708.05010].", "_type": "ecc", "_page_id": "c_binomial", "_href": "c/binomial"}, "c_wasilewski-banaszek": {"notes": "", "realizations": "", "physical": "oscillators", "description": "Three-oscillator Fock-state code encoding a single logical qubit using codewords \\begin{align} \\begin{split} |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{3}}(|003\\rangle+|030\\rangle+|300\\rangle)\\\\ |\\overline{1}\\rangle &= |111\\rangle \\end{split}. \\end{align}", "code_id": "wasilewski-banaszek", "logical": "qubits", "introduced": "[10.1103/PhysRevA.75.042316]", "name": "Wasilewski-Banaszek code", "short_name": "", "protection": "Protects against single photon loss in any one mode.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Destructive measurement with photon number measurements on each mode.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Single-qubit gates implemented using linear optical networks, sometimes with the addition of auxiliary modes with vacuum input and (conditional) output.", "features_fault_tolerance": "", "features_encoders": "A qubit in the dual-rail code can be transferred to this code via a linear optical network using four ancillary modes, each with one photon input. Successful encoding is conditioned on measuring the state \\(|110\\rangle\\) on the last three modes.", "parents_code_id": "constant_excitation_permutation_invariant", "parents_detail": "", "_type": "ecc", "_page_id": "c_wasilewski-banaszek", "_href": "c/wasilewski-banaszek"}, "c_dual_rail": {"notes": "For Deutsch's problem [10.1098/rspa.1992.0167] with optical qubits, error correction using photon number detection reduces the error probability from \\(\\frac{1}{4} (1+e^{-\\gamma}-2e^{-3\\gamma/2}) \\)   to \\(\\frac{1}{2} (1- \\text{sech} \\gamma/2)\\).", "realizations": "", "physical": "qubits", "description": "Two-mode code encoding a logical qubit in Fock states with one excitation. The logical-zero state is represented by \\(|01\\rangle\\), while the logical-one state is represented by \\(|10\\rangle\\).", "code_id": "dual_rail", "logical": "qubits", "introduced": "[10.1103/PhysRevA.52.3489]", "name": "Dual-rail code", "short_name": "", "protection": "This is an error-detecting code against one photon loss event; it is often used in photonic quantum devices because of its ease of realization. A single loss event can be detected because, after the loss occurs, the output state \\(|00\\rangle\\) is orthogonal to the codespace. Recovery is not possible, so a successful run of a quantum circuit is conditioned on not losing a photon during the circuit.\n\nFor Deutsch''s  problem specifically, this code protects against errors resulting in states that have the correct photon number, but in the wrong modes [10.1103/PhysRevA.52.3489].\n", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "General gates are performed using beamsplitters and Kerr non-linearities. Universal quantum computing can be achieved with photons in dual-rail encodings using the KLM protocol [10.1038/35051009] with only linear optical elements and photon detectors.", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "constant_excitation_permutation_invariant", "parents_detail": "", "_type": "ecc", "_page_id": "c_dual_rail", "_href": "c/dual_rail"}, "c_bosonic_rotation": {"notes": "", "realizations": "", "physical": "oscillators", "description": "A single-mode Fock-state bosonic code whose codespace is preserved by a phase-space rotation by a multiple of \\(2\\pi/N\\) for some \\(N\\). The rotation symmetry ensures that encoded states have support only on every \\(N^{\\textrm{th}}\\) Fock state. For example, single-mode Fock-state codes for \\(N=2\\) encoding a qubit admit basis states that are, respectively, supported on Fock state sets \\(\\{|0\\rangle,|4\\rangle,|8\\rangle,\\cdots\\}\\) and \\(\\{|2\\rangle,|6\\rangle,|10\\rangle,\\cdots\\}\\).\n\nEncoding of a \\(q\\)-dimensional logical qudit admit a basis whose elements are eigenstates of the rotation operator \\(\\exp\\left(\\mathrm{i} 2\\pi \\hat{n}/qN \\right)\\), where \\(\\hat{n}\\) is the number operator diagonal in the Fock basis. Basis elements are of the form \\(\\sum_{j=0}^\\infty c_j |(kq+j)N \\rangle\\) for some coefficients \\(c_j\\) and \\(k\\). This is because the rotation acting on a general Fock-state superposition \\(\\sum_n a_n |n\\rangle\\) yields \\(\\sum_n a_n \\exp\\left(\\mathrm{i} 2\\pi n / qN \\right) |n\\rangle\\). In order for a codeword to be an eigenvector of this operation, \\(a_n\\) must be zero whenever \\(n \\neq (kq+j)N\\) for some \\(k\\).\n\nCodewords can be uniquely specified by choosing a primitive state \\(|\\Theta\\rangle\\). To ensure valid (orthogonal and nonzero) codewords, \\(|\\Theta\\rangle\\) must satisfy the following requirement: for each \\(j \\in \\mathbb{Z}_q\\), \\(|\\Theta\\rangle\\) must have support on the Fock state \\(|(k_j q+j)N\\rangle\\) for at least one \\(k_j \\in \\mathbb{N}_0\\). From such a primitive, the codewords \\(\\{|\\overline{j}\\rangle \\mid j \\in \\mathbb{Z}_q\\}\\) are constructed as\n\\begin{align}\n|\\overline{j}\\rangle \\propto \\sum_{m=0}^{2N-1} \\mathrm{e}^{2\\pi \\mathrm{i} m (\\hat n  / N + j) / q} |\\Theta\\rangle~.\n\\end{align}\n", "code_id": "bosonic_rotation", "logical": "qudits", "introduced": "[1901.08071]", "name": "Bosonic rotation code", "short_name": "", "protection": "Losses or gains less than \\(N\\) are detectable. Dephasing rotations \\(\\exp(\\mathrm{i}\\theta \\hat{n})\\) can be detected whenever \\(\\theta\\) is roughly less than \\(\\pi/N\\). To get precise bounds on \\(\\theta\\), one needs to analyze the particular bosonic rotation code.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "One can distinguish (destructively) the codewords by performing a Fock-state number measurement. If a Fock state state \\(|n\\rangle\\) is measured, then one rounds to the nearest integer of the form \\((kq+j)/N\\), and deduces that the true state was \\(|\\overline{j}\\rangle\\).\nOne can distinguish states in the dual basis by performing phase estimation on \\(\\mathrm{e}^{\\mathrm{i} \\theta \\hat n}\\). One then rounds the resulting \\(\\theta\\) to the nearest number \\(2\\pi j / qN\\) in order to determine which dual basis state \\(j \\in \\mathbb Z_q\\) it came from.\nAutonomous quantum error correction schemes for \\(S=1\\) codes [2203.09234].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "The logical Pauli-\\(Z\\) gate can be the discrete rotation operator \\(\\mathrm{e}^{\\mathrm{i} \\pi \\hat n /N}\\), and the logical Pauli-\\(X\\) gate can be the (note: non-unitary) number-translation operator \\(\\sum_{n=0}^\\infty |n\\rangle\\bra{n+N}\\).\nFor qubit codes, a logical phase gate is \\(S = \\mathrm{e}^{\\pi \\mathrm{i} \\hat n^2 / 2N^2}\\).\nThe \\(T = \\mathrm{diag}(1,\\exp(\\mathrm{i}\\pi/4))\\) gate can be done via gate teleportation and a resource state \\(\\vert 0_N\\rangle + \\exp(\\mathrm{i}\\pi/4) \\vert 1_N \\rangle\\).\nA controlled-rotation gate between an order \\(N\\) rotation code and an order \\(M\\) rotation code is \\(\\mathrm{CROT}_{NM} = \\mathrm{e}^{(2\\pi\\mathrm{i} / qNM) \\hat n \\otimes \\hat n}\\).", "features_fault_tolerance": "", "features_encoders": "The optimal way to prepare codewords depends on the exact rotation code in question [1901.08071].", "parents_code_id": "fock_state", "parents_detail": "Single-mode Fock-state codes are typically rotationally invariant.", "parent_of_code_id": "binomial\ncat\nnumber_phase", "parent_of_detail": "One can verify by direct calculation that the logical states are eigenstates of the discrete rotation operator. One has freedom in the exact form of the primitive state to choose; see Appendix B.2 of Ref. [1901.08071].\nThe cat code is a bosonic rotation code whose primitive state is the coherent state \\(|\\alpha\\rangle\\) [1901.08071].\nNumber-phase codes are bosonic rotation codes with the primitive state is a Pegg-Barnett phase state [10.1088/0305-4470/19/18/030].", "cousins_code_id": "gkp", "cousins_detail": "GKP codes utilize the translational symmetry in phase space, while rotation codes utilize rotational symmetry.", "_type": "ecc", "_page_id": "c_bosonic_rotation", "_href": "c/bosonic_rotation"}, "c_cat": {"notes": "", "realizations": "Two-legged (\\(S=1\\)) cat code has been realized by two superconducting cavities coupled through a Josephson junction by Devoret group [1412.4633]. Exponential suppression of bit-flip errors achieved [1907.11729] up to a bit-flip time of 1 ms.\nFour-legged (\\(S=2\\)) cat code has been realized in superconducting circuit [10.1038/nature18949]. This paper is the first break-even point of quantum error-correction, where the lifetime of a logical qubit is on par with the lifetime of the noisiest constituent of the system.", "physical": "oscillators", "description": "Rotation-symmetric bosonic Fock-state code encoding a \\(q\\)-dimensional qudit into one oscillator. Codewords for a qubit code (\\(q=2\\)) consist of a coherent state \\(|\\alpha\\rangle\\) projected onto a subspace of Fock state number modulo \\(2(S+1)\\). The logical state \\(|\\overline{0}\\rangle\\) is in the \\(\\{|0\\rangle , |2(S+1)\\rangle , |4(S+1)\\rangle \\cdots \\}\\) Fock-state subspace, while \\(|\\overline{1}\\rangle\\) is in the \\(\\{|(S+1)\\rangle, |3(S+1)\\rangle , |5(S+1)\\rangle , |7(S+1)\\rangle \\cdots \\}\\) subspace. An alternative basis, valid for for general \\(q\\) and \\(\\alpha\\neq 0\\), consists of \\(q\\) coherent states distributed equidistanctly around a circle in phase space of radius \\(\\alpha\\).\n", "code_id": "cat", "logical": "qubits", "introduced": "[quant-ph/9809037,1207.0679]", "name": "Cat code", "short_name": "", "protection": "Due to the spacing between sets of Fock states, the distance between two distinct logical states is \\(d=S+1\\). Hence, this code is able to detect \\(S\\)-photon loss error. Two-legged cat codes (\\(S=1\\)) do not protect against loss events, but there exist modifications based on sign alternation [1901.05358] or squeezing [2201.02570] that add such protection.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Measurement in the Fock basis. For a \\(2(S+1)\\) cat code, a number measurement returns outcome \\(2(S+1)k\\), if \\(k\\) is even, then it corresponds to logical 0 state; if \\(k\\) is odd, then it corresponds to logical 1 state.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "For \\(S=1\\), universal gates can be performed using displacement operators and a rotation based on the Kerr nonlinearity [1312.2017]. For \\(S=2\\), squeezing replaces displacements.\nHolonomic gates utilizing the Berry phase of coherent states are universal [1503.00194].\nBias-preserving CNOT gate utilizing a topological Berry phase [1905.00450].", "features_fault_tolerance": "Bias-preserving CNOT gate [1905.00450] is part of a universal bias-preserving gate set that can be made fault tolerant using concatenation [1904.09474,1905.00450].", "features_encoders": "Lindbladian-based dissipative encoding utilizing multi-photon absorption [1312.2017].\nHamiltonian-based 'Kerr-cat' encoding utilizing the Kerr effect [1605.09408] (see also Ref. [1510.02566]).\nCombined dissipative and Hamiltonian-based encoding utilizing two-photon exchange for \\(S=1\\) codes [2112.05545].", "parents_code_id": "bosonic_rotation", "parents_detail": "The cat code is a bosonic rotation code whose primitive state is the coherent state \\(|\\alpha\\rangle\\) [1901.08071].", "cousins_code_id": "number_phase\nhamiltonian", "cousins_detail": "In the limit as \\(N,S \\to \\infty\\), phase measurement in the cat code has vanishing variance, just like in a number-phase code [1901.08071].\nTwo-legged cat codewords form ground-state subspace of a Kerr Hamiltonian [1605.09408].", "cousin_of_code_id": "binomial", "cousin_of_detail": "For a fixed \\(S\\), binomial codes with \\(N \\to \\infty\\) coincide with cat codes as \\(\\alpha \\to \\infty\\) [1602.00008].", "_type": "ecc", "_page_id": "c_cat", "_href": "c/cat"}, "c_constant_excitation_permutation_invariant": {"notes": "", "realizations": "", "physical": "qubits", "description": "Stub.\n", "code_id": "constant_excitation_permutation_invariant", "logical": "qubits", "introduced": "[1809.09801]", "name": "Constant-excitation permutation-invariant code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "permutation_invariant\nchuang-leung-yamamoto", "parents_detail": "\n", "parent_of_code_id": "dual_rail\nwasilewski-banaszek", "parent_of_detail": "\n", "_type": "ecc", "_page_id": "c_constant_excitation_permutation_invariant", "_href": "c/constant_excitation_permutation_invariant"}, "c_number_phase": {"notes": "", "realizations": "", "physical": "oscillators", "description": "Bosonic rotation code consisting of superpositions of Pegg-Barnett phase states [10.1088/0305-4470/19/18/030],\n\\begin{align}\n|\\phi\\rangle \\equiv \\frac{1}{\\sqrt{2\\pi}}\\sum_{n=0}^{\\infty} \\mathrm{e}^{\\mathrm{i} n \\phi} \\ket{n}.\n\\end{align}\nSince phase states and thus the ideal codewords are not normalizable, approximate versions need to be constructed. The codes' key feature is that, in the ideal case, phase measurement has zero uncertainty, making it a good canditate for a syndrome measurement.\n\nLogical states of an order-\\(N\\) number-phase qubit encoding are \\(|\\overline{0}\\rangle= \\sum_{m=0}^{2N-1} |\\phi = m\\pi/N\\rangle\\) and \\(|\\overline{1}\\rangle = \\sum_{m=0}^{2N-1} (-1)^m |\\phi=m\\pi/N\\rangle\\). By performing the summation over \\(m\\), one finds that \\(|\\overline{0}\\rangle\\) is supported on Fock states \\(|2kN\\rangle\\), while \\(|\\overline{1}\\rangle\\) is supported on states \\(|(2k+1)N\\rangle\\), for \\(k \\geq 0\\).\n", "code_id": "number_phase", "logical": "qubits", "introduced": "[1901.08071]", "name": "Number-phase code", "short_name": "", "protection": "Number-phase codes of order \\(N\\) detect up to \\(N\\) photon loss or gain errors, and dephasing up to \\(\\theta = \\pi/N\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Measurement done in the logical \\(X\\), or dual, basis has zero uncertainty in the case of ideal number phase codes. Approximate number-phase codes are characterized by vanishing phase uncertainty.\nNumber measurement can be done by using the CROT gate \\(\\mathrm{e}^{(2\\pi \\mathrm{i} / NM) \\hat n \\otimes \\hat n}\\). See Section 4.B.1 of Ref. [1901.08071].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "Fault-tolerant computation schemes with number-phase codes have been proposed based on concatenation with Bacon-Shor subsystem codes [1901.08071].", "features_encoders": "", "parents_code_id": "bosonic_rotation", "parents_detail": "Number-phase codes are bosonic rotation codes with the primitive state is a Pegg-Barnett phase state [10.1088/0305-4470/19/18/030].", "cousins_code_id": "rotor_gkp", "cousins_detail": "Number phase codes are a manifestation of planar-rotor GKP codes in an oscillator. Both codes protect against small shifts in angular degrees of freedom.", "cousin_of_code_id": "binomial\ncat", "cousin_of_detail": "In the limit as \\(N,S \\to \\infty\\), phase measurement in the binomial code has vanishing variance, just like in a number-phase code [1901.08071].\nIn the limit as \\(N,S \\to \\infty\\), phase measurement in the cat code has vanishing variance, just like in a number-phase code [1901.08071].", "_type": "ecc", "_page_id": "c_number_phase", "_href": "c/number_phase"}, "c_fock_state": {"notes": "", "realizations": "", "physical": "oscillators", "description": "Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. The simplest example is the dual-rail code, which has codewords consisting of single Fock states \\(|10\\rangle\\) and \\(|01\\rangle\\). This code can detect a single loss error since a loss operator in either mode maps one of the codewords to a different Fock state \\(|00\\rangle\\). More involved codewords consist of several well-separated Fock states such that multiple loss events can be detected and corrected.", "code_id": "fock_state", "logical": "qudits", "introduced": "", "name": "Fock-state bosonic code", "short_name": "", "protection": "Code distance \\(d\\) is the minimum distance (assuming some metric) between any two labels of Fock states corresponding to different code basis states. For a single mode, \\(d\\) is the minimum absolute value of the difference between any two Fock-state labels; such codes can detect up to \\(d-1\\) loss events. Multimode distances can be defined analogously; see, e.g., Chuang-Leung-Yamamoto codes<code:chuang-leung-yamamoto>.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qudits_into_oscillators", "parents_detail": "", "parent_of_code_id": "bosonic_rotation\nchuang-leung-yamamoto", "parent_of_detail": "Single-mode Fock-state codes are typically rotationally invariant.\nChuang-Leung-Yamamoto code are multi-mode Fock-state codes.", "cousins_code_id": "binary_linear\nqubits_into_qubits", "cousins_detail": "Fock-state code distance is a natural extension of Hamming distance between binary strings.\nFock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators [Victor V. Albert, private communication, 2016]. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations [2111.08894].", "cousin_of_code_id": "fusion", "cousin_of_detail": "While FBQC is a general framework, an intended application to linear-optical quantum computing will likely utilize small Fock-state bosonic codes such as the dual-rail code.", "_type": "ecc", "_page_id": "c_fock_state", "_href": "c/fock_state"}, "c_group_quantum": {"notes": "", "realizations": "", "physical": "groups", "description": "Encodes a logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space of \\(\\ell^2\\)-normalizable functions on a second-countable unimodular group. For \\(K\\)-dimensional logical subspace and for groups \\(G^{\\times n}\\), can be denoted as \\(((n,K))_G\\). When the logical subspace is the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(G^{\\times k}\\), can be denoted as \\([[n,k]]_G\\). Ideal codewords may not be normalizable, depending on whether \\(G\\) is continuous and/or noncompact, so approximate versions have to be constructed in practice.", "code_id": "group_quantum", "logical": "groups", "introduced": "", "name": "Group-based quantum code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "group_gkp", "parent_of_detail": "", "cousins_code_id": "qubits_into_qubits\nqudits_into_qudits\noscillators", "cousins_detail": "Group quantum codes whose physical spaces are constructed using the group \\(\\mathbb{Z}_2\\) are qubit codes.\nGroup quantum codes whose physical spaces are constructed using modular-integer groups \\(\\mathbb{Z}_q\\) are modular-qudit codes.\nGroup quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes.", "_type": "ecc", "_page_id": "c_group_quantum", "_href": "c/group_quantum"}, "c_rotor_gkp": {"notes": "", "realizations": "", "physical": "groups", "description": "GKP code protecting against small angular position and momentum shifts of a planar rotor.", "code_id": "rotor_gkp", "logical": "qudits", "introduced": "[quant-ph/0008040,1911.00099]", "name": "Rotor GKP code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "group_gkp", "parents_detail": "", "cousins_code_id": "gkp", "cousins_detail": "GKP (rotor GKP) codes protect against shifts in linear (angular) degrees of freedom.", "cousin_of_code_id": "number_phase", "cousin_of_detail": "Number phase codes are a manifestation of planar-rotor GKP codes in an oscillator. Both codes protect against small shifts in angular degrees of freedom.", "_type": "ecc", "_page_id": "c_rotor_gkp", "_href": "c/rotor_gkp"}, "c_molecular": {"notes": "Physical space characterizes orientations of a rigid body in 3D, which correspond to rotational states of an asymmetric molecule.", "realizations": "", "physical": "groups", "description": "Encodes finite-dimensional Hilbert space into the Hilbert space of \\(\\ell^2\\)-normalizable functions on the group \\(SO_3\\). Construction is based on nested subgroups \\(H\\subset K \\subset SO_3\\), where \\(H,K\\) are finite. The \\(|K|/|H|\\)-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\).", "code_id": "molecular", "logical": "rigid_bodies", "introduced": "[1911.00099]", "name": "Molecular code", "short_name": "", "protection": "Protects against generalized bit-flip errors \\(g\\in SO_3\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "group_gkp", "parents_detail": "", "_type": "ecc", "_page_id": "c_molecular", "_href": "c/molecular"}, "c_quantum_double": {"notes": "The \\( \\Phi, \\Lambda \\)  Decodoku game <https://citizensciencegames.com/games/decodoku/> is based on the quantum double model for the group \\(S_3\\) of permutations on three letters.", "realizations": "", "physical": "groups", "description": "A family of topological codes, defined by a finite group \\( G \\),  whose generators are few-body operators associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit of dimension \\( |G| \\) located at each edge of the tesselation).\n\nThe physical Hilbert space has dimension \\( |G|^E  \\), where \\( E \\) is the number of  edges in the tessellation. The dimension of the code space is the number of orbits of the conjugation action of \\( G \\) on \\( \\text{Hom}(\\pi_1(\\Sigma),G) \\),  the set of group homomorphisms from the fundamental group of the surface \\( \\Sigma \\) into the finite group \\( G \\) [1908.02829]. When \\( G \\) is abelian, the formula for the dimension simplifies to \\( |G|^{2g} \\), where \\( g \\) is the genus of the surface \\( \\Sigma \\).\n\nThe codespace is the ground-state subspace of the quantum double model Hamiltonian. For nonabelian groups, alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model [10.1007/3-540-49208-9_31,quant-ph/0306063,10.1017/CBO9780511792908]. The fusion space of such nonabelian anyons has dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.\n", "code_id": "quantum_double", "logical": "groups", "introduced": "[quant-ph/9707021]", "name": "Quantum-double code", "short_name": "", "protection": "Error-correcting properties established in Ref. [1908.02829]. The code distance is the number of edges in the shortest non contractible cycle in the tesselation or dual tesselation  [quant-ph/0110143].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "group_gkp\ntopological", "parents_detail": "Quantum-double models admit stabilizer-like \\(X\\)- and \\(Z\\)-type operators [2111.12096], and the codes can be formulated as group GKP codes.\nQuantum-double code Hamiltonians admit topological phases associated with finite groups \\(G\\).", "cousins_code_id": "qudit_surface\nstring_net", "cousins_detail": "A quantum-double model with \\(G=\\mathbb{Z}_q\\) is the qudit surface code.\nString-net model reduces to the quantum-double model for group categories.", "_type": "ecc", "_page_id": "c_quantum_double", "_href": "c/quantum_double"}, "c_group_gkp": {"notes": "", "realizations": "", "physical": "groups", "description": "Group code whose construction is based on nested subgroups \\(H\\subset K \\subset G\\). Logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\), and can be finite- or infinite-dimensional. Extension of the GKP code<code:gkp> construction.", "code_id": "group_gkp", "logical": "groups", "introduced": "[1911.00099]", "name": "Group GKP code", "short_name": "", "protection": "Protects against generalized bit-flip errors \\(g\\in G\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "group_quantum", "parents_detail": "", "parent_of_code_id": "molecular\nquantum_double\nrotor_gkp", "parent_of_detail": "\nQuantum-double models admit stabilizer-like \\(X\\)- and \\(Z\\)-type operators [2111.12096], and the codes can be formulated as group GKP codes.\n", "cousins_code_id": "oscillator_stabilizer\ncss", "cousins_detail": "The group-GKP construction encompasses all bosonic CSS codes. For example, a single-mode qubit GKP code corresponds to the \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\) group construction.\nAn \\(n\\)-qubit CSS code corresponds to the \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{\\times n}\\) group construction.", "_type": "ecc", "_page_id": "c_group_gkp", "_href": "c/group_gkp"}, "c_stab_3_1_2": {"notes": "Connections to Ads/CFT from the perspetive of how arbitrary operators are encoded into the logical space. This encoding is analagous and helps explain why operators acting on the bulk are protected against localized boundary errors [1411.7041].", "realizations": "", "physical": "qudits", "description": "A \\([[3,1,2]]_3\\) prime-qudit CSS code with stabilizer generators \\(ZZZ\\) and \\(XXX\\). The code defines a quantum secret-sharing scheme and serves as a minimal model for the AdS/CFT holographic duality. The codewords are\n\\begin{align}\n  \\begin{split}\n    | \\overline{0} \\rangle &= \\frac{1}{\\sqrt{3}} (| 000 \\rangle + | 111 \\rangle + | 222 \\rangle) \\\\\n    | \\overline{1} \\rangle &= \\frac{1}{\\sqrt{3}} (| 012 \\rangle + | 120 \\rangle + | 201 \\rangle) \\\\\n    | \\overline{2} \\rangle &= \\frac{1}{\\sqrt{3}} (| 021 \\rangle + | 102 \\rangle + | 210 \\rangle)~.\n  \\end{split}\n\\end{align}\nThe elements in the superposition of each logical codeword are related to each other via cyclic permutations.\n", "code_id": "stab_3_1_2", "logical": "qudits", "introduced": "[quant-ph/9901025]", "name": "Three qutrit code", "short_name": "", "protection": "Detects single qutrit errors and protects against a single-qutrit erasure. There does not exist a three-qubit code with analogous properties.\n\nThe code is an example of a \\( ((n = 3, k = 2)) \\) threshold scheme where a secret (the quantum information) is split into \\( n \\) shares and can be reconstructed by \\( k \\) pieces.\n\nThey key property of this code is that the reduced density matrix of any single qutrit is maximally mixed, meaning no information can be extracted from that qutrit. Therefore, a single qutrit tells you nothing about the encoded message, but access to any two pairs of qutrits will reveal the secret.\n", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "The quantum information (the secret) can be recovered from a unitary transformation acting on only two qutrits, \\( U_{ij} \\otimes I \\), where \\(U_{ij}\\) acts on qutrits \\(i,j\\) and \\(I\\) is the identity on the remaining qutrit. By the cyclic structure of the codewords, this unitary transformation performs a permutation that recovers the information and stores it in one of the two qutrits involved in recovery.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "In addition to thinking about the encoding of states, it is also interesting to look at the trasformation of operators from the physical space into the logical space. Due to the unique structure and recovery protocol of the three qutrit code, the representation of a logical operator \\( \\overline{O} \\) is not unique. Instead, \\( \\overline{O} \\) can be constructed from unitary matricies with support on only two out of the three qutrits. Therefore, the logical operator has valid representations constructed from support on different sets of two qutrits. This operator construction is directly analogous to the construction of operators in the bulk (at the center) of the AdS\\(_3\\)-Rindler reconstruction. The three-qutrit code can then be used to describe how these local bulk operators are protected against localized boundary errors [1411.7041].\nThis construction is related to the cleaning lemma [0810.1983], which was introduced in the context of constructing self-correcting quantum memories from stabilizer codes with geometrically-local generators. In this lemma, subspaces can be cleaned out by removing operators with support on a subset of qutrits.", "parents_code_id": "qudit_css\nholographic", "parents_detail": "Smallest single-erasure correcting qudit code for \\(q>2\\).\nThree-qutrit code is a minimal model for holography [1411.7041,1607.03901].", "cousins_code_id": "quantum_secret_sharing", "cousins_detail": "Three-qutrit code defines a minimal secret-sharing scheme [quant-ph/9901025] that is substantially generalized by approximate secret-sharing codes.", "_type": "ecc", "_page_id": "c_stab_3_1_2", "_href": "c/stab_3_1_2"}, "c_qudit_hamming_css": {"notes": "", "realizations": "", "physical": "qudits", "description": "A family of CSS codes extending Hamming-based CSS codes<code:quantum_hamming_css> to prime qudits of dimension \\(p\\) by expressing the qubit code stabilizers in local-dimension-invariant (LDI) form [2110.11510].", "code_id": "qudit_hamming_css", "logical": "qudits", "introduced": "[2110.11510]", "name": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) prime-qudit CSS code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qudit_css", "parents_detail": "", "cousins_code_id": "quantum_hamming_css", "cousins_detail": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) codes are prime-qudit extensions of \\([[2^r-1, 2^r-2r-1, 3]]\\) codes.", "_type": "ecc", "_page_id": "c_qudit_hamming_css", "_href": "c/qudit_hamming_css"}, "c_frobenius": {"notes": "Frobenius codes that are also stabilizer codes have been completely classified. No such codes exist when \\(t\\) is odd. All such codes with even \\(t\\) can be directly constructed.", "realizations": "", "physical": "qudits", "description": "Let \\(C\\) be a quantum cyclic code on \\(n\\) prime-dimensional qudits. \\(C\\) is a Frobenius code if there exists a positive integer \\(t\\) such that \\(n\\) divides \\(p^t +1\\).", "code_id": "frobenius", "logical": "qudits", "introduced": "[1011.5814]", "name": "Frobenius code", "short_name": "", "protection": "Protects against Pauli noise.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Adapted from the Berlekamp decoding algorithm for classical BCH codes. There exists a polynomial time quantum algorithm to correct errors of weight at most \\(\\tau\\), where \\(\\delta=2\\tau+1\\) is the BCH distance of the code [1011.5814]. ", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qudit_stabilizer\nquantum_cyclic", "parents_detail": "\n", "_type": "ecc", "_page_id": "c_frobenius", "_href": "c/frobenius"}, "c_qudit_stabilizer": {"notes": "A standardized definition of the qudit stabilizer group is developed in [1101.1519].", "realizations": "", "physical": "qudits", "description": "An \\(((n,K,d))_q\\) modular-qudit code whose logical subspace is the joint eigenspace of commuting qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code.\n\n(Pauli matrices go here.)\n\nA modular-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{q}\\) or \\([[n,k,d]]_{q}\\). For composite \\(q\\), such codes need not encode an integer number of qudits, with \\(K=q^n/|\\mathsf{S}|\\) [1101.1519]. This is because \\(|{\\mathsf{S}}|\\) need not be a power of \\(q\\), as group generators may have different orders. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\). Prime-qudit stabilizer codes, where \\(q=p\\) for some prime \\(p\\), do not suffer from this issue and encode \\(n-k\\) logical qudits, with \\(K=p^{n-k}\\).\n\nEach code can be represented by a stabilizer generator matrix \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(q\\)-ary symplectic representation of a stabilizer generator. (Standard form goes here.)\n", "code_id": "qudit_stabilizer", "logical": "qudits", "introduced": "[quant-ph/9705052]", "name": "Modular-qudit stabilizer code", "short_name": "", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "The structure of stabilizer codes allows for syndrome-based decoding, where errors are corrected based on the results of stabilizer measurements (syndromes).\nTrellis decoder for prime-dimensional qudits, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) [2106.08251].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "stabilizer\nqudits_into_qudits", "parents_detail": "\n", "parent_of_code_id": "double_semion\nfrobenius\nqudit_css", "parent_of_detail": "Double-semion code can be realized as a modular-qudit stabilizer code with \\(q=4\\) [2112.11394].\n\n", "cousin_of_code_id": "topological_abelian\ngalois_stabilizer\nqubit_stabilizer", "cousin_of_detail": "All abelian topological orders can be realized as modular-qudit stabilizer codes [2112.11394].\nRecalling that \\(q=p^m\\), Galois-qudit stabilizer codes can also be treated as prime-qudit stabilizer codes on \\(mn\\) qudits, giving \\(k=nm-r\\) [quant-ph/0005008]. The case \\(m=1\\) reduces to conventional prime-qudit stabilizer codes on \\(n\\) qudits.\nModular-qudit stabilizer codes for prime-dimensional qudits \\(q=p\\) inherit most of the features of qubit stabilizer codes, including encoding an integer number of qudits and a Pauli group with a unique number of generators. Conversely, qubit stabilizer codes can be extended to qudits by decorating the appropriate Pauli strings with powers, and the local-dimension-invariant (LDI) form [1910.08122] of the generator matrix yields systematic extensions to prime qudits.", "_type": "ecc", "_page_id": "c_qudit_stabilizer", "_href": "c/qudit_stabilizer"}, "c_polynomial": {"notes": "", "realizations": "", "physical": "qudits", "description": "Also called quantum Reed-Solomon code. An \\([[n,k,n-k+1]]_p\\) (with prime \\(p>n\\)) prime-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(p)=\\mathbb{Z}_p\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(\\mathbb{Z}_p\\), and let \\(g\\) be a number satisfying \\(0\\leq k \\leq g < n\\). Then, define degree-\\(g\\) polynomials\n\\begin{align}\n  f_{\\mu\\cup c}\\left(x\\right)=\\mu_{0}+\\mu_{1}x+\\cdots+\\mu_{k-1}x^{k-1}+c_{k}x^{k}+\\cdots+c_{g}x^{g}\\,,\n\\end{align}\nwhere the first \\(k\\) coefficients are indexed by the coefficient vector \\(\\mu\\in\\mathbb{Z}_p^{\\times k}\\), and the remaining coefficients are indexed by the vector \\(c\\in\\mathbb{Z}_p^{\\times (g+1-k)}\\). Logical states, labeled by \\(\\mu\\), are superpositions of canonical basis states whose \\(i\\)th bit is \\(f_{\\mu\\cup c}\\), evaluated at \\(\\alpha_i\\) and summed over all possible vectors \\(c\\),\n\\begin{align}\n  |\\overline{\\mu}\\rangle=\\sum_{c\\in\\mathbb{Z}_{p}^{\\times(g+1-k)}}|f_{\\mu\\cup c}(\\alpha_{1}),|f_{\\mu\\cup c}(\\alpha_{2}),\\cdots,|f_{\\mu\\cup c}(\\alpha_{n})\\rangle.\n\\end{align}\n", "code_id": "polynomial", "logical": "qudits", "introduced": "[quant-ph/9910059]", "name": "Prime-qudit polynomial code (QPyC)", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qudit_css", "parents_detail": "", "cousins_code_id": "reed_solomon\ncyclic\nquantum_mds", "cousins_detail": "Polynomial codes are CSS codes constructed from Reed-Solomon codes.\n\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).", "cousin_of_code_id": "galois_polynomial", "cousin_of_detail": "Polynomial codes can be defined for modular qudits of prime dimension or, more generally, for Galois qudits.", "_type": "ecc", "_page_id": "c_polynomial", "_href": "c/polynomial"}, "c_qudit_surface": {"notes": "The simplest Decodoku game <https://citizensciencegames.com/games/decodoku/> is based on the qudit surface code with \\( q=10\\).", "realizations": "", "physical": "qudits", "description": "A family of stabilizer codes whose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit located at each edge of the tesselation). The code has \\( n=E \\) many physical qudits, where \\( E \\) is the number of edges of the tesselation, and \\( k=2g \\) many logical qudits, where \\( g \\) is the genus of the surface.", "code_id": "qudit_surface", "logical": "qudits", "introduced": "[quant-ph/9707021]", "name": "Modular-qudit surface code", "short_name": "", "protection": "When defined on an \\(L\\times L\\) square tiling of the torus, protects against \\(L\\) errors. More generally, the code distance is the number of edges in the shortest non contractible cycle in the tesselation or dual tesselation  [quant-ph/0110143].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qudit_css\ntopological_abelian", "parents_detail": "Plaquette and star operators are stabilizer generators.\nQudit surface code Hamiltonians admit topological phases associated with \\(\\mathbb{Z}_q\\) [quant-ph/0609070].", "cousins_code_id": "surface", "cousins_detail": "The qudit surface code with \\(q=2\\) is the surface code.", "cousin_of_code_id": "quantum_double\ntranslationally_invariant_stabilizer.yml", "cousin_of_detail": "A quantum-double model with \\(G=\\mathbb{Z}_q\\) is the qudit surface code.\nTranslation-invariant 2D prime-qudit topological stabilizer codes are equivalent to several copies of the qudit surface code via a local constant-depth Clifford circuit [1812.11193].", "_type": "ecc", "_page_id": "c_qudit_surface", "_href": "c/qudit_surface"}, "c_qudits_into_qudits": {"notes": "", "realizations": "", "physical": "qudits", "description": "Also called a \\(\\mathbb{Z}_q\\)-qudit code. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the group \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\). Usually denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined, and with \\(q=p\\) when the dimension is prime.\n", "code_id": "qudits_into_qudits", "logical": "qudits", "introduced": "", "name": "Modular-qudit code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "qudit_stabilizer", "parent_of_detail": "", "cousin_of_code_id": "galois_into_galois\ngroup_quantum", "cousin_of_detail": "A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits [quant-ph/0005008]; see Sec. 5.3 of Ref. [quant-ph/0501074]. The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently.\nGroup quantum codes whose physical spaces are constructed using modular-integer groups \\(\\mathbb{Z}_q\\) are modular-qudit codes.", "_type": "ecc", "_page_id": "c_qudits_into_qudits", "_href": "c/qudits_into_qudits"}, "c_stabilizer_over_gfqsq": {"notes": "", "realizations": "", "physical": "galois", "description": "Stub.", "code_id": "stabilizer_over_gfqsq", "logical": "galois", "introduced": "[quant-ph/0508070]", "name": "Stabilizer code over \\(GF(q^2)\\)", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "galois_stabilizer", "parents_detail": "", "cousins_code_id": "q-ary_linear\nstabilizer_over_gf4", "cousins_detail": "\\(q\\)-ary linear codes are used in this construction.\nStabilizer codes over \\(GF(q^2)\\) are Galois-qudit extensions of those over \\(GF(4)\\).", "_type": "ecc", "_page_id": "c_stabilizer_over_gfqsq", "_href": "c/stabilizer_over_gfqsq"}, "c_qudit_css": {"notes": "", "realizations": "", "physical": "qudits", "description": "An \\(((n,K,d))_q\\) modular-qudit stabilizer code admitting a set of stabilizer generators that\nare either \\(Z\\)-type or \\(X\\)-type Pauli strings.\nThe stabilizer generator matrix, taking values from \\(\\mathbb{Z}_q\\), is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityq}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commQ}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nFor composite \\(q\\), such codes need not encode an integer number of qudits. For prime \\(q=p\\), properties reminiscent of qubit CSS codes are restored: encoding is based on two related \\(p\\)-ary linear codes<code:q-ary_linear>, an \\([n,k_X,d_X]_p \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_p \\) code \\(C_Z\\),\nsatisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\).\nThe \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) eq:parityq is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees eq:commQ.\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n", "code_id": "qudit_css", "logical": "qudits", "introduced": "[quant-ph/0005008,quant-ph/0508070]", "name": "Modular-qudit CSS code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qudit_stabilizer", "parents_detail": "", "parent_of_code_id": "qudit_surface\npolynomial\nstab_3_1_2\nqudit_hamming_css", "parent_of_detail": "Plaquette and star operators are stabilizer generators.\n\nSmallest single-erasure correcting qudit code for \\(q>2\\).\n", "cousins_code_id": "css\nq-ary_linear", "cousins_detail": "Extension of CSS codes to modular-integer qudits.\nConstruction for prime \\(q=p\\) uses two related \\(p\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).", "_type": "ecc", "_page_id": "c_qudit_css", "_href": "c/qudit_css"}, "c_skew-cyclic_galois_css": {"notes": "", "realizations": "", "physical": "qudits", "description": "Stub.", "code_id": "skew-cyclic_galois_css", "logical": "qudits", "introduced": "[10.1016/j.disc.2020.112189]", "name": "Skew-cyclic CSS code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "galois_css", "parents_detail": "", "cousins_code_id": "skew_cyclic", "cousins_detail": "Skew-cyclic CSS codes are constructed from classical skew-cylic codes.", "_type": "ecc", "_page_id": "c_skew-cyclic_galois_css", "_href": "c/skew-cyclic_galois_css"}, "c_galois_stabilizer": {"notes": "", "realizations": "", "physical": "galois", "description": "An \\(((n,K,d))_{GF(q)}\\) Galois-qudit code whose logical subspace is the joint eigenspace of commuting Galois-qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a Galois-qudit Pauli string that implements a nontrivial logical operation in the code.\n\n(Pauli matrices go here.)\n\nA Galois-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{GF(q)}\\) or \\([[n,k,d]]_{GF(q)}\\). This notation differentiates between Galois-qudit and modular-qudit stabilizer codes, although the same notation, \\([[n,k,d]]_q\\), is usually used for both. Galois-qudit stabilizer codes need not encode an integer number of qudits, with \\(K=q^{n-\\frac{r}{m}}\\), where \\(r\\) is the number of generators of the stabilizer group, and \\(q=p^m\\) given prime \\(p\\) for all Galois qudits. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\).\n", "code_id": "galois_stabilizer", "logical": "galois", "introduced": "[quant-ph/0005008,quant-ph/0508070]", "name": "Galois-qudit stabilizer code", "short_name": "", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. Corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qudits.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "As opposed to modular qudits for composite \\(q\\), Galois qudits inherit most of the properties of the prime-qudit Clifford group due to the correspondence between a \\(q=p^m\\) Galois qudit and \\(m\\) prime qudits of dimension \\(p\\) [quant-ph/0005008].", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "stabilizer\ngalois_into_galois", "parents_detail": "\n", "parent_of_code_id": "stabilizer_over_gfqsq\ngalois_true_stabilizer", "parent_of_detail": "\n", "cousins_code_id": "qudit_stabilizer", "cousins_detail": "Recalling that \\(q=p^m\\), Galois-qudit stabilizer codes can also be treated as prime-qudit stabilizer codes on \\(mn\\) qudits, giving \\(k=nm-r\\) [quant-ph/0005008]. The case \\(m=1\\) reduces to conventional prime-qudit stabilizer codes on \\(n\\) qudits.", "_type": "ecc", "_page_id": "c_galois_stabilizer", "_href": "c/galois_stabilizer"}, "c_galois_true_stabilizer": {"notes": "", "realizations": "", "physical": "galois", "description": "Also called a linear stabilizer code. A \\([[n,k,d]]_{GF(q)}\\) stabilizer code whose stabilizer's symplectic representation forms a linear subspace. In other words, the set of \\(q\\)-ary vectors representing the stabilizer group is closed under both addition and multiplication by elements of \\(GF(q)\\). In contrast, Galois-qudit stabilizer codes admit sets of vectors that are closed under addition only.\n\nThe number of generators \\(r\\) for a true stabilizer code is a multiple of \\(m\\) (recall that \\(q=p^m\\) for Galois qudits). As a result, the number \\(k=n-r/m\\) of logical qudits is an integer.\n\nEach code can be represented by a stabilizer generator matrix \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(GF(q)\\)-valued symplectic representation of a stabilizer generator.\n", "code_id": "galois_true_stabilizer", "logical": "galois", "introduced": "", "name": "True Galois-qudit stabilizer code", "short_name": "", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "galois_stabilizer", "parents_detail": "", "parent_of_code_id": "galois_css", "parent_of_detail": "", "cousins_code_id": "q-ary_linear", "cousins_detail": "A true Galois-qudit stabilizer code is the closest quantum analogue of a linear code over \\(GF(q)\\) because the \\(q\\)-ary vectors defining each code form a linear subspace.", "_type": "ecc", "_page_id": "c_galois_true_stabilizer", "_href": "c/galois_true_stabilizer"}, "c_binary_quantum_goppa": {"notes": "", "realizations": "", "physical": "galois", "description": "Also known as a quantum AG code. Binary quantum Goppa codes are a family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes for \\( q=2^m \\), generated using classical Goppa codes.\n\nLet \\( F/GF(q) \\) be an algebraic function field of one variable, \\(\\sigma \\) be an automorphism of order 2\nof \\(F\\) which leaves \\(GF(q)\\) invariant, and \\(P_1, \\cdots, P_n \\) be pairwise distinct places of degree one such that \\( \\sigma P_i = P_j\\) for all\n\\(i,j = 1, \\cdots, n\\). A place \\( P_i \\) of \\( F/ GF(q) \\) is the unique maximal ideal of a discrete valuation ring of the function field. Let \\( \\nu \\) be a  differential\nthat satisfies the properties guaranteed by  the strong approximation theorem of discrete evaluations. Let \\(G\\) be a divisor such that \\( \\sigma G = G \\) and the\ndiscrete valuation corresponding to place \\(P_i \\) of \\(G\\) and the discrete valuation corresponding to place \\(\\sigma P_i \\) of \\(G\\) are both 0 for all \\(i\\). Then we can define\na code \\( C(G)  = \\{ f(P_1), \\cdots, f(P_n), f(\\sigma P_1), \\cdots , f(\\sigma P_n) | f \\in \\mathcal{L}(G)\\} \\subset GF(q^{2n})\\) and\na code \\(C(H)\\) where \\(H = (P_1 + \\cdots + P_n + \\sigma P_1 + \\cdots + \\sigma P_n) - G + \\nu \\). Then the dual of \\(C(G)\\) with respect to the weighted symplectic inner\nproduct with weights \\(s_i\\) on \\( GF(q^n) \\) is equivalent to \\(C(H)\\). Therefore, the orthogonal code of \\(C(G)\\) is generated by \\(H\\). Using these properties and the assumption\nthat \\(H\\) is a subgroup of \\(G\\), we can construct a classical Goppa code \\(C(D,G)\\), where \\(D\\) is the sum of all \\(P_i\\). Using \\(C(D,G)\\), we can construct a \\([[n,k,d]]_{GF(q)}\\) quantum stabilizer code such that\n\\(k  = \\text{dim} G - \\text{dim}(G-P_1 - \\cdots - P_n - \\sigma P_1 - \\cdots  - \\sigma P_n) - n~.\\)\n", "code_id": "binary_quantum_goppa", "logical": "galois", "introduced": "[quant-ph/0501074,10.1007/s11128-006-0047-9]", "name": "Binary quantum Goppa code", "short_name": "", "protection": "Protects against weight t errors where \\( 0 < t \\leq  \\lfloor \\frac{d^*-g-1}{2} \\rfloor \\) where \\( d^* = \\text{deg} G + 2 -2g \\) and \\(g\\) is the genus of the function field and \\(d \\geq n - \\lfloor \\frac{deg G}{2} \\rfloor\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Farran algorithm [math/9910151].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Encoding defined in Matsumoto [quant-ph/0107129] uses a technique from Ashikhmin and Knill [quant-ph/0005008] to encode quantum stabilizer codes.", "parents_code_id": "galois_css", "parents_detail": "Goppa codes can be realized in the CSS code construction [10.1007/s11128-006-0047-9].", "cousins_code_id": "goppa", "cousins_detail": "Classical Goppa codes are used to construct their quantum versions.", "_type": "ecc", "_page_id": "c_binary_quantum_goppa", "_href": "c/binary_quantum_goppa"}, "c_galois_into_galois": {"notes": "Introduction to Galois qudits by Gottesman <https://ethz.ch/content/vp/en/conferences/2014/qec/05_thursday/dab6ca18-7453-4197-aaaa-8b1964ece714.html>.", "realizations": "", "physical": "galois", "description": "Also called a \\(GF(q)\\)- or \\(\\mathbb{F}_q\\)-qudit code. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the Galois field \\(GF(q)\\) and with \\(q\\) being a power of a prime \\(p\\). A Galois field can be thought of as a vector space whose basis vectors are the \\(m\\) roots of some polynomial and whose coefficients (i.e., field) are \\(p\\)th roots of unity. Codes can be denoted as \\(((n,K))_{GF(q)}\\) or \\(((n,K,d))_{GF(q)}\\), whenever the code's distance \\(d\\) is defined. This notation differentiates between Galois-qudit and modular-qudit codes, although the same notation, \\(((n,K,d))_q\\), is usually used for both.", "code_id": "galois_into_galois", "logical": "galois", "introduced": "[10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T,quant-ph/0508070]", "name": "Galois-qudit code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the maximum-likelihood decoder.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "galois_stabilizer", "parent_of_detail": "", "cousins_code_id": "qudits_into_qudits", "cousins_detail": "A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits [quant-ph/0005008]; see Sec. 5.3 of Ref. [quant-ph/0501074]. The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently.", "_type": "ecc", "_page_id": "c_galois_into_galois", "_href": "c/galois_into_galois"}, "c_quantum_secret_sharing": {"notes": "", "realizations": "", "physical": "galois", "description": "A family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes approximately correcting errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) qubits, i.e., with approximate distance approaching the no-cloning bound \\(n/2\\). Constructed using a non-degenerate CSS code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an \\(t\\)-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.", "code_id": "quantum_secret_sharing", "logical": "galois", "introduced": "[quant-ph/0503139]", "name": "Approximate secret-sharing code", "short_name": "", "protection": "Corrects up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors with fidelity exponentially lose to 1.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Decoding is analagous to reconstruction in a secret sharing scheme and is done in polynomial time. The only required operations are verification of quantum authentication, which is a pair of polynomial-time quantum algorithms that check if the fidelity of the received state is close to 1, and erasure correction for a stabilizer code, which involves solving a system of linear equations.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Uses a quantum authentication scheme, which is a keyed system in which a valid state has high fidelity, and a classical secret-sharing scheme.", "parents_code_id": "galois_css", "parents_detail": "The code required to construct this code must be a non-degenerate Galois-qubit CSS code.", "cousins_code_id": "approximate_qecc\ngalois_polynomial\nreed_solomon", "cousins_detail": "Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors.\nPolynomial codes can be used for a specific construction of this code.\nThe classical information in this code is encoded using a Reed-Solomon code.", "cousin_of_code_id": "stab_3_1_2", "cousin_of_detail": "Three-qutrit code defines a minimal secret-sharing scheme [quant-ph/9901025] that is substantially generalized by approximate secret-sharing codes.", "_type": "ecc", "_page_id": "c_quantum_secret_sharing", "_href": "c/quantum_secret_sharing"}, "c_galois_css": {"notes": "", "realizations": "", "physical": "galois", "description": "An \\([[n,k,d]]_{GF(q)} \\) Galois-qudit true stabilizer code admitting a set of stabilizer generators that\nare either \\(Z\\)-type or \\(X\\)-type Galois-qudit Pauli strings.\nThe stabilizer generator matrix, taking values from \\(GF(q)\\), is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityg}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commG}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related \\(q\\)-ary linear codes<code:q-ary_linear>,\nan \\([n,k_X,d_X]_q \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_q \\) code \\(C_Z\\),\nsatisfying \\(C_X^\\perp \\subseteq C_Z\\).\nThe resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\).\nThe \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) eq:parityg is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees eq:commG.\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n", "code_id": "galois_css", "logical": "galois", "introduced": "[quant-ph/0005008,quant-ph/0508070]", "name": "Galois-qudit CSS code", "short_name": "", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "galois_true_stabilizer", "parents_detail": "", "parent_of_code_id": "quantum_secret_sharing\nbinary_quantum_goppa\ngalois_polynomial\nlifted_product\nskew-cyclic_galois_css", "parent_of_detail": "The code required to construct this code must be a non-degenerate Galois-qubit CSS code.\nGoppa codes can be realized in the CSS code construction [10.1007/s11128-006-0047-9].\n\n\n", "cousins_code_id": "css\nq-ary_linear", "cousins_detail": "Extension of qubit CSS codes to Galois qudits.\nConstruction uses two related \\(q\\)-ary linear codes \\(C_X\\) and \\(C_Z\\).", "_type": "ecc", "_page_id": "c_galois_css", "_href": "c/galois_css"}, "c_galois_polynomial": {"notes": "", "realizations": "", "physical": "galois", "description": "Also called quantum Reed-Solomon code. An \\([[n,k,n-k+1]]_{GF(q)}\\) (with \\(q>n\\)) Galois-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(q)\\). Let \\(C_1\\) be a \\([n,k_1,d_1]_q\\) Reed-Solomon code and \\(C_2^\\perp\\) be a \\([n,k_2,d_2]_q\\) Reed-Solomon code, modified such that \\(C_2^\\perp \\subseteq C_1\\) and \\(0\\le k_2 \\le k_1 \\le n\\). Then, a polynomial code is a non-degenerate \\([[n,k_2,d]]_{GF(q)}\\) Galois-qudit CSS code with \\(d=\\min(n-k_1+1,k_1-k_2+1)\\). The polynomial code is the span of the basis codewords over GF(\\(q\\)) \\begin{align} |\\overline{\\beta_0,\\cdots,\\beta_{k_2-1}}\\rangle = \\sum_{(\\beta_{k_2},\\cdots,\\beta_{k_1-1})\\in GF(q) } \\bigotimes_{i=1}^{n} \\left|\\sum_{j=0}^{k_1-1} \\beta_j \\alpha_i^j \\right\\rangle, \\end{align} where \\((\\alpha_1, \\cdots, \\alpha_n)\\) are \\(n\\) distinct points chosen for code \\(C_1\\) from \\(GF(q)\\setminus \\{0\\}\\).", "code_id": "galois_polynomial", "logical": "galois", "introduced": "[quant-ph/9906129]", "name": "Galois-qudit polynomial code (QPyC)", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "galois_css", "parents_detail": "", "cousins_code_id": "polynomial\nreed_solomon\ncyclic\nquantum_mds", "cousins_detail": "Polynomial codes can be defined for modular qudits of prime dimension or, more generally, for Galois qudits.\nPolynomial codes are CSS codes constructed from Reed-Solomon codes.\n\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).", "cousin_of_code_id": "quantum_secret_sharing", "cousin_of_detail": "Polynomial codes can be used for a specific construction of this code.", "_type": "ecc", "_page_id": "c_galois_polynomial", "_href": "c/galois_polynomial"}, "c_dynamic_gen": {"notes": "", "realizations": "", "physical": "", "description": "Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process. Such processes, which are often non-deterministic, update the code structure and can include random unitary evolution or non-commuting projective measurements.", "code_id": "dynamic_gen", "logical": "", "introduced": "[0708.4025]", "name": "Dynamically-generated quantum error-correcting code", "short_name": "Dynamically-generated QECC", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "floquet\nrandom_circuit", "parent_of_detail": "\n", "cousin_of_code_id": "clifford-deformed_surface\nqldpc", "cousin_of_detail": "To create CDSCs, a dynamical process is applied on top of the surface code.\nQLDPC codes can arise form a dynamical process [2004.09560].", "_type": "ecc", "_page_id": "c_dynamic_gen", "_href": "c/dynamic_gen"}, "c_quantum_concatenated": {"features_rate": "", "features_threshold": "The first method to achieve a fault-tolerant computational threshold uses concatenated stabilizer codes [quant-ph/9702058,quant-ph/9906129,quant-ph/9705031,quant-ph/0504218].", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Concatenated quantum code", "physical": "", "short_name": "", "protection": "", "description": "A combination of two codes, an inner code \\(C\\) and an outer code \\(C^\\prime\\), where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code \\(C^\\prime\\), and then one encodes each of the physical registers of \\(C^\\prime\\) in an inner code \\(C\\).", "code_id": "quantum_concatenated", "logical": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "quantum_parity", "parent_of_detail": "A QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code.", "cousin_of_code_id": "shor_nine", "cousin_of_detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code.", "_type": "ecc", "_page_id": "c_quantum_concatenated", "_href": "c/quantum_concatenated"}, "c_stabilizer": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Stabilizer code", "physical": "", "short_name": "", "protection": "", "description": "A stabilizer code is a code whose logical subspace is the joint eigenspace (usually with eigenvalue \\(+1\\)) of a set of commuting unitary operators forming the code's stabilizer group. Stabilizer codes have been defined for qubits, modular qudits, Galois qudits, and oscillators using their respective Pauli-type groups.\n\nThe coding theory motivation for stabilizer codes came from linear binary codes, whose codewords form a closed subspace in the space of binary strings. Stabilizer codes extend this property, in various ways, to quantum error correction. The stabilizer formalism is applicable to the qubit, modular-qudit, Galois-qudit, bosonic, and fermionic kingdoms; see list of stabilizer codes <https://errorcorrectionzoo.org/list/stabilizer> for a list of all stabilizer codes in the zoo.\n\nStabilizer codes were originally defined for qubits, where the relevant commuting operators are tensor products of Pauli matrices. The Pauli stabilizer structure is immensely useful in providing standardized encoding, gates, decoding, and performance bounds. Elements of this structure remain in qudit extensions, in particular for prime-dimensional modular qudits and Galois qudits.\n\nAn important property of qubit and qudit stabilizer codes is the QLDPC property, which means (roughly) that working with them remains not too hard as number of qudits grows; these are the primary candidates for a future quantum memory.\n", "code_id": "stabilizer", "logical": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "oscillator_stabilizer\ngalois_stabilizer\nqudit_stabilizer\nqldpc\nqubit_stabilizer", "parent_of_detail": "\n\n\n\n", "cousin_of_code_id": "majorana_stab", "cousin_of_detail": "Majorana stabilizer codes are useful for Majorana-based architectures, where the degrees of freedom are electrons, and the notion of locality is different than all other code kingdoms.", "_type": "ecc", "_page_id": "c_stabilizer", "_href": "c/stabilizer"}, "c_quantum_cyclic": {"notes": "Many examples have been found by computer algebra programs. Ref. [1007.1697] give examples of \\([[17,1,7]]\\) and \\([[17,9,3]]\\) quantum cyclic codes.", "realizations": "", "physical": "", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits) is cyclic if a cyclic permutation of the subsystems leaves the code subspace invariant.", "code_id": "quantum_cyclic", "logical": "", "introduced": "[1007.1697]", "name": "Quantum cyclic code", "short_name": "", "protection": "Cyclic symmetry guarantees that if a single subsystem is protected against some noise, then all other subsystems are also.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Adapted from the Berlekamp decoding algorithm for classical BCH codes [1007.1697].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "frobenius", "parent_of_detail": "", "cousins_code_id": "cyclic", "cousins_detail": "", "cousin_of_code_id": "permutation_invariant\nstab_5_1_3", "cousin_of_detail": "The cyclic group of these codes is a subgroup of the \\(S_n\\) symmetric group used in permutation invariant codes.\n\\([[5,1,3]]\\) code is the smallest known example of quantum cyclic code .", "_type": "ecc", "_page_id": "c_quantum_cyclic", "_href": "c/quantum_cyclic"}, "c_topological": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Topological code", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "topological", "logical": "", "parents_code_id": "hamiltonian", "parents_detail": "Codespace is either the ground-state or low-energy subspace of a geometrically local commuting-projector Hamiltonian admitting a topological phase.", "parent_of_code_id": "topological_abelian\nquantum_double\nstring_net", "parent_of_detail": "\nQuantum-double code Hamiltonians admit topological phases associated with finite groups \\(G\\).\nString-net codes can be realized using Levin-Wen model Hamiltonians, which realize various topological phases [cond-mat/0404617,1002.2816,1106.6033].", "cousin_of_code_id": "eth\nfracton\nfusion\nt-designs\nmonitored_random_circuits\nqldpc", "cousin_of_detail": "ETH codewords, like topological codewords, are locally indistinguishable.\nFracton phases can be understood as topological defect networks, meaning that they can be described in the language of topological quantum field theory [2002.05166].\nArbitrary topological codes can be created using FBQC, as can topological features such as defects and boundaries, by modifying fusion measurements or adding single qubit measurements.\nLocal Haar-random codewords, like topological codewords, are locally indistinguishable [10.1007/s00220-016-2706-8].\nTopological order can be generated in 2D monitored random circuits [2011.06595].\nTopological codes are not generally defined using Pauli strings. However, for appropriate tesselations, the codespace forms a ground-state subspace of a geometrically local Hamiltonain. In this sense, topological codes are QLDPC codes. On the other hand, chain complexes describing some QLDPC codes can be 'lifted' into higher-dimensional manifolds admitting some notion of geometric locality [2012.02249]. This opens up the possibility that some QLDPC codes, despite not being geometrically local, can in fact be associated with a geometrically local theory described by a category.", "_type": "ecc", "_page_id": "c_topological", "_href": "c/topological"}, "c_random_circuit": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Random-circuit code", "physical": "", "short_name": "", "protection": "", "description": "Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.", "code_id": "random_circuit", "logical": "", "parents_code_id": "dynamic_gen\nquantum_random", "parents_detail": "\n", "parent_of_code_id": "haar_random\nt-designs\nnonlocal_lowdepth\nmonitored_random_circuits", "parent_of_detail": "\n\n\nMonitored random circuits are random circuits where projective measurements are interspersed throughout the circuit and measurement results are recorded.", "_type": "ecc", "_page_id": "c_random_circuit", "_href": "c/random_circuit"}, "c_approximate_qecc": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "[quant-ph/9704002,10.1070/RM1997v052n06ABEH002155,quant-ph/0307138,quant-ph/0503139,0907.4207,0907.5391]", "notes": "", "realizations": "", "name": "Approximate quantum code", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "approximate_qecc", "logical": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "eth", "parent_of_detail": "ETH codes approximately protect against erasures in the thermodynamic limit.", "cousin_of_code_id": "quantum_secret_sharing\ngnu_permutation_invariant\ngkp\nt-designs\nmultimodegkp\nstab_4_2_2", "cousin_of_detail": "Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors.\nSome GNU codes can protect approximately against amplitude damping errors.\nGKP codes approximately protect against photon loss [1506.05033,1708.05010,1801.07271].\n\nApproximate error-correction offered by GKP codes yields achievable rates that are a constant away from the capacity of Guassian loss channels [quant-ph/0105058,1708.07257,1801.04731,1801.07271].\n\\([[4,1,2]]\\) subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) [quant-ph/9704002] and \\(\\{|\\overline{01}\\rangle,|\\overline{11}\\rangle\\}\\) [quant-ph/0103042] approximately correct a single amplitude damping error.", "_type": "ecc", "_page_id": "c_approximate_qecc", "_href": "c/approximate_qecc"}, "c_holographic": {"notes": "All Boundary global symmetries must be dual to bulk gauge symmetries, and vice versa [1810.05338].", "realizations": "", "physical": "", "description": "A code whose encoding isometry serves to model aspects of the AdS/CFT holographic duality. Encodes operators in the bulk of the Anti de Sitter (AdS) space, represented by logical qudits, into operators on the boundary of the corresponding Conformal Field Theory (CFT), represented by physical qudits. Encoding can often be represented by a tensor network associated with a tiling of hyperbolic space. See Defn 4.3 of Ref. [2108.11402] for a technical formulation.\n\nTypically, the encoding isometry \\(U\\) obeys the entanglement-wedge reconstruction condition, which states that for any boundary region \\(R\\), any bulk operator \\(O\\) localized to the entanglement wedge of \\(R\\) must be implementable by some boundary operator \\(\\tilde{O}\\) localized to \\(R\\). Formally, \\(UO = \\tilde{O}U\\) and \\([\\tilde{O},UU^\\dagger] = 0\\). The entanglement wedge is the space enclosed within the Ryu\u2013Takayanagi surface in the bulk (minimal surface) with boundary \\(R\\).\n", "code_id": "holographic", "logical": "", "introduced": "[1503.06237]", "name": "Holographic code", "short_name": "", "protection": "Protects against erasure errors on the boundary. Error-correction properties are often stated in the Heisenberg picture, i.e., in terms of which logical operators can be reconstructed after erasures. Specifically, bulk operators outside the entanglement wedges of the erased boundary operators can be reconstructed using the remaining boundary operators. However, the protection can be nontrivial, and may only apply to a subalgebra of bulk operators [1411.7041,1612.00017].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "There exist holographic approximate codes with arbitrary transversal gate sets for any compact Lie group [2108.11402]. However, for sufficiently localized logical subsystems of holographic stabilizer codes, the set of transversally implementable logical operations is contained in the Clifford group [2103.13404].", "features_code_capacity_threshold": "The ideal holographic code (perfect representation of AdS/CFT) should be able to protect a central bulk operator against erasures of half of the physical qubits on the boundary, in line with AdS-Rindler reconstruction [1503.06237].\nHolographic codes are argued to have a algebraic threshold, for which the error rate scales polynomially (as opposed to exponentially) in the thermodynamic limit [2202.04710]. Such a threshold is governed by the underlying conformal field theory describing the boundary.", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "oaecc", "parents_detail": "Properties of holographic codes are often quantified in the Heisenberg picture, i.e., in terms of operator algebras [1411.7041,1612.00017].", "parent_of_code_id": "happy\nstab_3_1_2", "parent_of_detail": "\nThree-qutrit code is a minimal model for holography [1411.7041,1607.03901].", "cousin_of_code_id": "hyperbolic_surface", "cousin_of_detail": "Both holographic and hyperbolic surface codes utilize tesselations of hyperbolic surfaces. Encodings for the former are hyperbolically tiled tensor networks, while the latter is defined on hyperbolically tiled physical-qubit lattices.", "_type": "ecc", "_page_id": "c_holographic", "_href": "c/holographic"}, "c_fracton": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Fracton code", "physical": "", "short_name": "", "protection": "", "description": "A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.", "code_id": "fracton", "logical": "", "parents_code_id": "hamiltonian\nqldpc", "parents_detail": "Codespace is the ground-state subspace of a geometrically local commuting-projector Hamiltonian admitting a fracton phase.\nFracton codes admit geometrically local stabilizer generators on a cubic lattice.", "parent_of_code_id": "haah_cubic", "parent_of_detail": "Haah cubic codes are the first examples of Type-II fracton phases [2001.01722].", "cousins_code_id": "topological", "cousins_detail": "Fracton phases can be understood as topological defect networks, meaning that they can be described in the language of topological quantum field theory [2002.05166].", "cousin_of_code_id": "translationally_invariant_stabilizer.yml\nxzzx", "cousin_of_detail": "Translationally-invariant stabilizer codes can realize fracton orders. Conversely, fracton codes need not be translationally invariant, and can realize multiple phases on one lattice.\nSubsystem symmetries play a role in finite-bias decoders for both codes [1901.08061].", "_type": "ecc", "_page_id": "c_fracton", "_href": "c/fracton"}, "c_hamiltonian": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "Lindbladian-based dissipative encoding can be constructed for a codespace that is the ground-state subspace of a frustration-free Hamiltonian [0809.0613,1112.4860,0803.1447,1802.00010].", "introduced": "", "notes": "", "realizations": "", "name": "Hamiltonian-based code", "physical": "", "short_name": "", "protection": "Typically determined from the underlying physical properties of the Hamiltonian.", "description": "Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy.\n\nWhen the physical space is a tensor product of subsystems, the Hamiltonian is typically local, consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., QLDPC codes<code:qldpc>). When the physical space is endowed with a geometry, the Hamiltonian is typically geometrically local, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., topological codes<code:topological>). When the terms in a geometrically local Hamiltonian commute and can be expressed as projectors (i.e., having eigenvalues 0 or 1), the Hamiltonian is called  commuting-projector.\n", "code_id": "hamiltonian", "logical": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "constant_excitation\neth\nfracton\nmovassagh_ouyang\ntopological", "parent_of_detail": "Constant-excitation codes are associated with a Hamiltonian governing the total excitations of the system.\nETH codewords are eigenstates of a local Hamiltonian whose eigenstates satisfy ETH.\nCodespace is the ground-state subspace of a geometrically local commuting-projector Hamiltonian admitting a fracton phase.\nMovassagh-Ouyang codes reside in the ground space of a Hamiltonian.\nCodespace is either the ground-state or low-energy subspace of a geometrically local commuting-projector Hamiltonian admitting a topological phase.", "cousins_code_id": "qldpc", "cousins_detail": "Hamiltonian-based codes are not generally defined using Pauli strings. However, codes forming the ground-state subspace of a local Hamiltonain consisting of commuting terms are QLDPC codes in the sense that they satisfy the QLDPC locality requirements.", "cousin_of_code_id": "cat\ngnu_permutation_invariant\nquantum_repetition\nqubit_stabilizer\nstab_5_1_3", "cousin_of_detail": "Two-legged cat codewords form ground-state subspace of a Kerr Hamiltonian [1605.09408].\nGNU codes lie within the ground state of ferromagnetic Heisenberg models without an external magnetic field [1904.01458].\nBit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions.\nCodespace is the ground-state space of the code Hamiltonian, which consists of an equal linear combination of stabilizer generators and which can be made into a commuting projector Hamiltonian.\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].", "_type": "ecc", "_page_id": "c_hamiltonian", "_href": "c/hamiltonian"}, "c_quantum_random": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Random quantum code", "physical": "", "short_name": "", "protection": "", "description": "Quantum code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes (e.g., random-circuit codes), to codes whose multi-step construction is deterministic with the exception of a single step (e.g., expander lifter-product codes).", "code_id": "quantum_random", "logical": "", "parents_code_id": "qecc", "parents_detail": "", "parent_of_code_id": "random_circuit", "parent_of_detail": "", "cousins_code_id": "random", "cousins_detail": "", "cousin_of_code_id": "clifford-deformed_surface\nexpander_lifted_product\nfiber_bundle\nhomological_product", "cousin_of_detail": "Many useful CDSCs are constructed using random Clifford circuits.\nExpander lifted-product codes utilize small random classical codes in their construction.\n\n", "_type": "ecc", "_page_id": "c_quantum_random", "_href": "c/quantum_random"}, "c_topological_abelian": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Abelian topological code", "physical": "", "short_name": "", "protection": "", "description": "Code whose codewords realize topological order associated with an abelian group. Stub.\n\nAny local quantum circuit connecting ground states of topological orders with non-isomorphic abelian groups must have depth that is at least linear in the system\u2019s diameter [1407.2926].\n", "code_id": "topological_abelian", "logical": "", "parents_code_id": "topological\nqldpc", "parents_detail": "\nAll abelian topological orders can be realized as geometrically local modular-qudit stabilizer codes [2112.11394], and topological-code Hamiltonians are geometrically local for appropriate tesselations.", "parent_of_code_id": "clifford-deformed_surface\ncolor\ndouble_semion\nsurface\nmatching\nqudit_surface", "parent_of_detail": "Local deformations of the surface code preserve its \\(\\mathbb{Z}_2\\) topological order.\nWhen treated as ground states of the code Hamiltonian, 2D color code states on realize \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) topological order [0906.4127], equivalent to the phase realized by two copies of the surface code [1503.02065].\nWhen treated as ground states of the code Hamiltonian, the code states realize double-semion topological order, a topological phase of matter that also exists in twisted \\(\\mathbb{Z}_2\\) gauge theory [10.1007/BF02096988].\nWhen treated as ground states of the code Hamiltonian, the code states\nrealize \\(\\mathbb{Z}_2\\) topological order, a topological phase of\nmatter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory\n[10.1063/1.1665530].\n\nMatching codes were inspired by the Kitaev honeycomb model [cond-mat/0506438], which realizes \\(\\mathbb{Z}_2\\) topological order.\nQudit surface code Hamiltonians admit topological phases associated with \\(\\mathbb{Z}_q\\) [quant-ph/0609070].", "cousins_code_id": "qudit_stabilizer", "cousins_detail": "All abelian topological orders can be realized as modular-qudit stabilizer codes [2112.11394].", "cousin_of_code_id": "translationally_invariant_stabilizer.yml\nxzzx", "cousin_of_detail": "Translationally-invariant stabilizer codes can realize abelian topological orders. Conversely, abelian topological codes need not be translationally invariant, and can realize multiple topological phases on one lattice.\nExample of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model [quant-ph/0205004].", "_type": "ecc", "_page_id": "c_topological_abelian", "_href": "c/topological_abelian"}, "c_fusion": {"notes": "", "realizations": "", "physical": "qubits", "description": "Fusion Based Quantum Computing, or FBQC, describes a fault tolerant way to produce fusion networks, or large entangled states starting from small constant-sized entangled resource states along with destructive measurements called fusions. These large states can be produced asychronously in the fusion framework and can be used as resources, as in measurement-based quantum computation (MBQC), or as logical states of topological codes. The difference from ordinary MBQC is that error-correction is baked into the state-generation protocol.", "code_id": "fusion", "logical": "qubits", "introduced": "[2101.09310]", "name": "Fusion-based quantum computing (FBQC) code", "short_name": "FBQC", "protection": "Protects against erasure, Pauli errors, photon loss, fusion failure from non-determinism, and faulty resource states. Redundancy in fusion outcomes is captured by the check operator group. Fusion measurement outcomes form a syndrome that allows to correct for Pauli errors. There is no physical error correction, and decoding output is simply used to update the Pauli frame.", "features_rate": "", "features_threshold": "\\(11.98\\%\\) against erasure in fusion measurements.\n\\(1.07\\%\\) against Pauli error.\nIn linear optical systems, can tolerate \\(10.4\\%\\) probability of photon loss in each fusion.\n\\(43.2\\%\\) against fusion failure.", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Clifford gates by creating topological features such as boundaries, defects, or twists, which can be done by single qubit measurements.\nLogical gates can be performed by code deformation.\nNon Clifford gates by Magic-state injection\nLogical Clifford operations can be kept track of using the classical Pauli-frame register and need not be explicitly applied at the quantum level.", "features_fault_tolerance": "Fusion networks are constructed in a fault tolerant way (as a stabilizer code), and they can be created in a way that naturally encodes topological fault tolerance.", "features_encoders": "Resource state generators, which produce small constant size cluster states, and Fusion measurements (Bell fusions).", "parents_code_id": "qubit_stabilizer", "parents_detail": "The resource states in FBQC are small stabilizer states, and after fusion measurements, the outputs are stabilizers (conditioned on measurement outcomes.", "cousins_code_id": "topological\nfock_state", "cousins_detail": "Arbitrary topological codes can be created using FBQC, as can topological features such as defects and boundaries, by modifying fusion measurements or adding single qubit measurements.\nWhile FBQC is a general framework, an intended application to linear-optical quantum computing will likely utilize small Fock-state bosonic codes such as the dual-rail code.", "_type": "ecc", "_page_id": "c_fusion", "_href": "c/fusion"}, "c_quantum_perfect": {"features_rate": "\\(k/n\\to 1\\) asymptotically with \\(n\\).", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Perfect quantum code", "physical": "", "short_name": "", "protection": "Perfect codes have been classified. For qubits (\\(q=2\\)), the only codes are the stabilizer code family \\([[(4^r-1)/3, (4^r-1)/3 - 2r, 3]]\\) for \\(r \\geq 2\\) [quant-ph/9607027,quant-ph/9608006]. For qudits, the family is parameterized by \\(K=q^{n-2r}\\) for \\(n=\\frac{q^{2r}-1}{q^{2}-1}\\) and \\(r \\geq 2\\); all codes correct a single error (\\(t=1\\)) [0907.0049,10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T]. The trivial code (\\(k=n\\)) is also perfect.", "description": "A non-degenerate code constructed out of \\(q\\)-dimensional qudits and having parameters \\(((n,K,2t+1))\\) is perfect if \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the quantum Hamming bound\n\\begin{align}\n\\sum_{j=0}^{t}(q^2-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a qubit \\(q=2\\) code with one logical qubit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(3n+1 \\leq 2^{n-1}\\). The bound can be saturated only at certain \\(n\\).\n\nFor qubit codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-\\frac{t}{n}\\log_{2}3-H(t/n),\n\\end{align}\nwhere \\(H\\) is the binary entropy function.\n", "code_id": "quantum_perfect", "logical": "", "parents_code_id": "qecc_finite", "parents_detail": "", "cousins_code_id": "perfect", "cousins_detail": "A classical (quantum) perfect code saturates the classical (quantum) Hamming bound.", "cousin_of_code_id": "quantum_hamming\nstab_5_1_3", "cousin_of_detail": "Quantum Hamming codes saturate the asymptotic Hamming bound.\nThe smallest perfect code.", "_type": "ecc", "_page_id": "c_quantum_perfect", "_href": "c/quantum_perfect"}, "c_quantum_mds": {"notes": "The \\([[5,1,3]]\\) code and \\([[n,n-2,2]]\\) codes, where \\(n\\) is even, are the only examples of MDS qubit codes.", "realizations": "", "physical": "", "description": "An \\(((n,q^k,d))\\) code constructed out of \\(q\\)-dimensional qudits is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the quantum Singleton bound\n\\begin{align}\n2(d-1) \\leq n-k\n\\end{align}\nbecomes an equality.\n", "code_id": "quantum_mds", "logical": "", "introduced": "", "name": "Quantum maximum-distance-separable (MDS) code", "short_name": "Quantum MDS code", "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error correction properties.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qecc_finite", "parents_detail": "", "cousins_code_id": "mds\ngeneralized_reed_solomon", "cousins_detail": "\nQuantum MDS codes can be constructed through classical generalized Reed-Solomon codes [2002.06040].", "cousin_of_code_id": "galois_polynomial\npolynomial\nstab_5_1_3", "cousin_of_detail": "A polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).\nA polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\).\nThe smallest quantum MDS code.", "_type": "ecc", "_page_id": "c_quantum_mds", "_href": "c/quantum_mds"}, "c_constant_excitation": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "[quant-ph/9603022,quant-ph/9705044,quant-ph/9809081]", "notes": "", "realizations": "", "name": "Constant-excitation (CE) code", "physical": "", "short_name": "", "protection": "", "description": "Code whose codewords lie in an excited-state eigenspace of a Hamiltonian governing the total energy or total number of excitations of the underlying quantum system. For qubit codes, such a Hamiltonian is the total spin Hamiltonian, \\(H=\\sum_i Z_i\\). For bosonic codes, such as Fock-state codes, codewords are in an eigenspace with eigenvalue \\(N>0\\) of the total excitation or energy Hamiltonian, \\(H=\\sum_i \\hat{n}_i\\).\n\nOne of the first such codes [quant-ph/9603022] is a \\(((8,1,3))\\) qubit code, with codewords\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&= |00001111\\rangle + |11101000\\rangle \u2212 |10010110\\rangle \u2212 |01110001\\rangle\\\\\n                    & +|11010100\\rangle + |00110011\\rangle + |01001101\\rangle + |10101010\\rangle\\\\\n|\\overline{1}\\rangle&= X^{\\otimes 8} |\\overline{0}\\rangle~.\n\\end{split}\n\\end{align}\nEach logical state is a superposition of computational basis states with four excitations.\n", "code_id": "constant_excitation", "logical": "", "parents_code_id": "hamiltonian", "parents_detail": "Constant-excitation codes are associated with a Hamiltonian governing the total excitations of the system.", "parent_of_code_id": "chuang-leung-yamamoto\nquantum_parity", "parent_of_detail": "Chuang-Leung-Yamamoto codewords are constructed out of Fock states with the same total excitation number.\nQPC codewords like in a common eigenspace of the total spin Hamiltonian.", "_type": "ecc", "_page_id": "c_constant_excitation", "_href": "c/constant_excitation"}, "c_distance_balanced": {"notes": "", "realizations": "", "physical": "qubits", "description": "CSS stabilizer code constructed from a CSS code and a classical code using a distance-balancing procedure based on a generalized homological product. The initial code is said to be unbalanced, i.e., tailored to noise biased toward either bit- or phase-flip errors, and the procedure can result in a code that is treats both types of errors on a more equal footing. The original distance-balancing procedure [1611.03790], later generalized in Ref. [2004.07935], can yield QLDPC codes; see Thm. 1 in Ref. [1611.03790].", "code_id": "distance_balanced", "logical": "qubits", "introduced": "[1611.03790,2004.07935]", "name": "Distance-balanced code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "css\nhomological_product", "parents_detail": "\nDistance balancing relies on taking homological product of chain complexes corresponding to a classical and a quantum code.", "cousins_code_id": "subsystem_stabilizer", "cousins_detail": "", "cousin_of_code_id": "balanced_product\nfiber_bundle\nramanujan_tensor_product", "cousin_of_detail": "Distance balancing is used to form balanced-product subsystem codes [2012.09271].\nFiber-bundle code constructions use distance balancing to increase distance.\nRamanujan tensor-product constructions use distance balancing to increase distance.", "_type": "ecc", "_page_id": "c_distance_balanced", "_href": "c/distance_balanced"}, "c_ramanujan_tensor_product": {"notes": "Codes were first to break a 20-year record set by the Freedman-Meyer-Luo code<code:freedman_meyer_luo> for the lower bound on scaling of the minimum distance [2103.06309].", "realizations": "", "physical": "qubits", "description": "CSS code constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.", "code_id": "ramanujan_tensor_product", "logical": "qubits", "introduced": "[2004.07935]", "name": "Ramanujan-complex product code", "short_name": "", "protection": "Without distance balancing, a Ramanujan code can have \\(d_X =\\Omega(\\log n)\\) and \\(d_Z = \\Omega (n)\\). For 2D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}\\). For 3D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d= \\Omega(n^{1/2}\\log n )\\).", "features_rate": "For 2D Ramanujan complexes, the rate is \\(\\Omega(\\sqrt{ \\frac{1}{n \\log n} })\\), with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}) \\). For 3D, the rate is \\( \\Omega(\\frac{1}{\\sqrt{n}\\log n}) \\) with minimum distance \\(d \\geq \\sqrt{n} \\log n \\).", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "For 2D simplicial complexes, cycle code decoder admitting a polynomial-time decoding algorithm can be used [2004.07935].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "generalized_homological_product", "parents_detail": "Ramanujan codes result from a tensor product of a classical-code and a quantum-code chain complex.", "cousins_code_id": "distance_balanced\nfreedman_meyer_luo", "cousins_detail": "Ramanujan tensor-product constructions use distance balancing to increase distance.\nRamanujan codes broke 20-year record on minimum code distance set by Freedman-Meyer-Luo codes.", "_type": "ecc", "_page_id": "c_ramanujan_tensor_product", "_href": "c/ramanujan_tensor_product"}, "c_fiber_bundle": {"notes": "", "realizations": "", "physical": "qubits", "description": "CSS code constructed by combining a random LDPC code as the base and a cyclic repetition code as the fiber of a fiber bundle. After applying distance balancing, a QLDPC code with distance \\(\\Omega(n^{3/5}\\text{polylog}(n))\\) and rate \\(\\Omega(n^{-2/5}\\text{polylog}(n))\\) is obtained.", "code_id": "fiber_bundle", "logical": "qubits", "introduced": "[2009.03921]", "name": "Fiber-bundle code", "short_name": "", "protection": "", "features_rate": "Rate \\(k/n = \\Omega(n^{-2/5}/\\text{polylog}(n))\\), distance \\(d=\\Omega(n^{3/5}/\\text{polylog}(n))\\). This is the first QLDPC code to achieve a distance scaling better than \\(\\sqrt{n}~\\text{polylog}(n)\\).", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Greedy algorithm can be used to efficiently decode \\(X\\) errors, but no known efficient decoding of \\(Z\\) errors yet [2009.03921].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "balanced_product", "parents_detail": "Fiber-bundle codes can be formulated in terms of a balanced product [2012.09271].", "parent_of_code_id": "homological_product", "parent_of_detail": "Fiber-bundle code can be viewed as a homological product code with a twisted product.", "cousins_code_id": "distance_balanced\nquantum_random", "cousins_detail": "Fiber-bundle code constructions use distance balancing to increase distance.\n", "_type": "ecc", "_page_id": "c_fiber_bundle", "_href": "c/fiber_bundle"}, "c_translationally_invariant_stabilizer.yml": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Translationally-invariant stabilizer code", "physical": "", "short_name": "", "protection": "", "description": "Stub.", "code_id": "translationally_invariant_stabilizer.yml", "logical": "", "parents_code_id": "qldpc", "parents_detail": "Translationally-invariant stabilizer codes are geometrically local.", "cousins_code_id": "surface\nqudit_surface\ntopological_abelian\nfracton", "cousins_detail": "Translation-invariant 2D qubit topological stabilizer codes are equivalent to several copies of the Kitaev surface code via a local constant-depth Clifford circuit [1103.4606,1107.2707].\nTranslation-invariant 2D prime-qudit topological stabilizer codes are equivalent to several copies of the qudit surface code via a local constant-depth Clifford circuit [1812.11193].\nTranslationally-invariant stabilizer codes can realize abelian topological orders. Conversely, abelian topological codes need not be translationally invariant, and can realize multiple topological phases on one lattice.\nTranslationally-invariant stabilizer codes can realize fracton orders. Conversely, fracton codes need not be translationally invariant, and can realize multiple phases on one lattice.", "_type": "ecc", "_page_id": "c_translationally_invariant_stabilizer.yml", "_href": "c/translationally_invariant_stabilizer.yml"}, "c_qldpc": {"notes": "Links to code tables of notable QLDPC codes [2103.06309].\nReviews of QLDPC codes provided in Refs. [10.1109/ACCESS.2015.2503267,2103.06309].", "realizations": "", "physical": "", "description": "Family of \\([[n,k,d]]\\) stabilizer codes for which the number of sites (either qubit or qudit) participating in each stabilizer generator and the number of stabilizer generators that each site participates in are both bounded by a constant as \\(n\\to\\infty\\). A geometrically local stabilizer code is a QLDPC code where the sites involved in any syndrome bit are contained in a fixed volume that does not scale with \\(n\\).\n\nStrictly speaking, the term parity check describes only bitwise qubit error syndromes. Nevertheless, qudit stabilizer codes satisfying the above criteria are also called QLDPC codes.\n", "code_id": "qldpc", "logical": "", "introduced": "[quant-ph/0304161]", "name": "Quantum low-density parity-check (QLDPC) code", "short_name": "QLDPC", "protection": "Detects errors on \\(d-1\\) sites, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) sites. Asymptotic scaling of \\(k\\) and \\(d\\) with \\(n\\) is often of interest, and this depends heavily on the code construction.   Geometrically local qubit codes are limited by the BPT bound [0810.1983], which states that \\(d=O(n^{1-1/D})\\) for \\(D\\)-dimensional lattice geometries. For general graphs, distance is limited by graphs' connectivity, and a constant relative minimum distance can be achieved only for graphs that contain expanders [2106.00765]. Conversely, a code with parameters \\(k\\) and \\(d\\) requires a graph with \\(\\Omega(d)\\) edges of length \\(\\Omega(d/n^{1/D})\\) [2109.10982].\n\nCode distance may not be a reliable marker of code performance. QLDPC codes with generator weights bounded by some constant can correct many stochastic errors far beyond the distance, which may not scale as favorably. Together with more accurate, faster, and easier-to-parallelize measurements than those of general stabilizer codes, this property makes QLDPC codes interesting in practice.\n", "features_rate": "A family of QLDPC codes \\([[n_i,k_i,d_i]]\\) is asymptotically good if the asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive. The first examples of good qubit codes are a family of lifted-product codes<code:lifted_product>.", "features_threshold": "QLDPC codes with a constant encoding rate can reduce the overhead of fault-tolerant quantum computation to be constant [1310.2984].", "features_magic_scaling_exponent": "", "features_decoders": "Non-binary decoding algorithm for CSS-type QLDPC codes [10.1109/ACCESS.2015.2503267].", "features_transversal_gates": "", "features_code_capacity_threshold": "For correlated Pauli noise, bounds on code capacity thresholds for families of QLDPC codes can be obtained by mapping the effect of noise on the code to a statistical mechanical model [quant-ph/0110143,1208.2317,1311.7688].\nBounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights [1412.6172].", "features_general_gates": "", "features_fault_tolerance": "Lattice surgery techniques with ancilla qubits [2110.10794].\nFault-tolerance with constant overhead can be performed on certain QLDPC codes [1310.2984], e.g., quantum expander codes [1808.03821].", "features_encoders": "", "parents_code_id": "stabilizer", "parents_detail": "", "parent_of_code_id": "topological_abelian\nfracton\ngeneralized_homological_product\ntranslationally_invariant_stabilizer.yml", "parent_of_detail": "All abelian topological orders can be realized as geometrically local modular-qudit stabilizer codes [2112.11394], and topological-code Hamiltonians are geometrically local for appropriate tesselations.\nFracton codes admit geometrically local stabilizer generators on a cubic lattice.\nHomological products are a primary tool for generating QLDPC codes with favorable parameters. Typically, whenever the input codes are LDPC or QLDPC, the resulting code will be QLDPC with non geometrically local stabilizer generators.\nTranslationally-invariant stabilizer codes are geometrically local.", "cousins_code_id": "ldpc\ntopological\ndynamic_gen", "cousins_detail": "\nTopological codes are not generally defined using Pauli strings. However, for appropriate tesselations, the codespace forms a ground-state subspace of a geometrically local Hamiltonain. In this sense, topological codes are QLDPC codes. On the other hand, chain complexes describing some QLDPC codes can be 'lifted' into higher-dimensional manifolds admitting some notion of geometric locality [2012.02249]. This opens up the possibility that some QLDPC codes, despite not being geometrically local, can in fact be associated with a geometrically local theory described by a category.\nQLDPC codes can arise form a dynamical process [2004.09560].", "cousin_of_code_id": "hamiltonian\nhoneycomb", "cousin_of_detail": "Hamiltonian-based codes are not generally defined using Pauli strings. However, codes forming the ground-state subspace of a local Hamiltonain consisting of commuting terms are QLDPC codes in the sense that they satisfy the QLDPC locality requirements.\nThe Floquet check operators are weight-two, and each qubit participates in one check each round.", "_type": "ecc", "_page_id": "c_qldpc", "_href": "c/qldpc"}, "c_quantum_expander": {"notes": "", "realizations": "", "physical": "qubits", "description": "CSS codes constructed from a hypergraph product of bipartite expander graphs with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as \\(X\\) checks, and the parity check matrix of the other as \\(Z\\) checks.", "code_id": "quantum_expander", "logical": "qubits", "introduced": "[1504.00822]", "name": "Quantum expander code", "short_name": "", "protection": "Pauli errors of weight \\(\\leq t\\), distance scales as \\(\\Omega(n^{1/2})\\).", "features_rate": "\\([[n,k=\\Theta(n),d=O(\\sqrt{n})]]\\) code with asymptotically constant rate.", "features_threshold": "Current estimate of \\(2.7 \\cdot 10^{-16}\\) in locally stochastic noise model [1711.08351].", "features_magic_scaling_exponent": "", "features_decoders": "Ref. [10.1109/FOCS.2015.55] details a linear time decoder, which corrects \\(\\Omega(n^{1/2})\\) adversarial errors.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "Fault-tolerance with constant overhead can be achieved [1808.03821].", "features_encoders": "", "parents_code_id": "hypergraph_product", "parents_detail": "", "cousins_code_id": "expander", "cousins_detail": "", "_type": "ecc", "_page_id": "c_quantum_expander", "_href": "c/quantum_expander"}, "c_expander_lifted_product": {"notes": "Construction outlined in talk by R. O'Donnell <https://www.youtube.com/watch?v=k7LuOiOBYyQ>.\nPopular summary in Quanta Magazine <https://www.quantamagazine.org/qubits-can-be-as-safe-as-bits-researchers-show-20220106>.", "realizations": "", "physical": "galois", "description": "Family of \\(G\\)-lifted product codes constructed using two random classical Tanner codes<code:tanner> defined on expander graphs. For certain parameters, this construction yields the first asymptotically good QLDPC codes [2111.03654].\n\nAn expander lifted-product code family is constructed as follows. First, take the Cayley graph of a finite group \\(G\\). Second, take the double cover of the graph, resulting in a graph that satisfies the requirements of participating in a \\(G\\)-lifted product (i.e., the resulting graph is a free \\({\\mathbb{F}}_q G\\)-module). Third, create a Tanner code<code:tanner> out of the graph, in which parity-check supports are defined by the graph, and bitstrings satisfying a particular parity check are defined to be the codewords of a small classical code (chosen to be a random code in the construction). Fourth, take the \\(G\\)-lifted product of two copies of the Tanner code<code:tanner>.\n\nThe small classical codes used in the construction of good QLDPC codes are required to have a certain product-expansion property (Lemma 10 in Ref. [2111.03654]); it is proven that random codes satisfy said property in the thermodynamic limit.\n", "code_id": "expander_lifted_product", "logical": "galois", "introduced": "[2111.03654]", "name": "Expander lifted-product code", "short_name": "", "protection": "Code performance strongly depends on \\(G\\). Certain nonabelian groups yield asymptotically good QLDPC codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n)]]\\) [2111.03654]. Abelian groups like \\(\\mathbb{Z}_{\\ell}\\) for \\(\\ell=\\Theta(n / \\log n)\\) yield constant-rate codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n / \\log n)]]\\) [2012.04068]; this construction can be derandomized by being reformulated as a balanced product code [2012.09271].", "features_rate": "Expander lifted-product codes include the first examples [2111.03654] of (asymptotically) good QLDPC codes, i.e., codes with asymptotically constant rate and linear distance. The existence of such codes proves the QLDPC conjecture [2103.06309]. Another notable family encodes \\(k \\in \\Theta(n^\\alpha \\log n)\\) logical qubits with distance \\(d \\in \\Omega(n^{1 - \\alpha} / \\log n)\\) for any number of physical qubits \\(n\\) and any real parameter \\(0 \\leq \\alpha < 1\\) [2012.04068].", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "lifted_product", "parents_detail": "Lifted products of certain classical Tanner codes are the first asymptotically good QLDPC codes.", "cousins_code_id": "tanner\nquantum_random", "cousins_detail": "Expander lifted-product codes are products of Tanner codes defined on expander graphs.\nExpander lifted-product codes utilize small random classical codes in their construction.", "_type": "ecc", "_page_id": "c_expander_lifted_product", "_href": "c/expander_lifted_product"}, "c_homological_product": {"notes": "", "realizations": "", "physical": "qubits", "description": "CSS code formulated using the CSS chain-complex<code:css> construction in the homological product construction. Stub.\n", "code_id": "homological_product", "logical": "qubits", "introduced": "[1301.1363,1311.0885]", "name": "Homological product code", "short_name": "", "protection": "Given two codes \\([[n_a, k_a, d_a, w_a]]\\) for \\(a\\in\\{1,2\\}\\), where \\(w_a\\) denotes the maximum hamming weight of all rows and columns of \\(\\partial_a\\), the homological product code has parameter \\([[n=n_1 n_2, k=k_1 k_2, d\\leq d_1 d_2, w\\leq w_1+w_2]]\\). From this formula, and the fact that a randomly selected boundary operator \\(\\partial\\) yields a CSS code that is good with high probability, we see that the product code has \\(k=\\Theta(n)\\) and \\(w=O(\\sqrt{n})\\) with high probability. The main result in [1311.0885] is to show that the product code actually has linear distance with high probability as well. To sum up, it is shown that we have a family of \\([[n,k=c_1 n, d=c_2 n, w=c_3 \\sqrt{n}]]\\) codes given small enough \\(c_1,c_2,c_3\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Union-find [2009.14226].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state [1807.09783].", "features_fault_tolerance": "Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state [1807.09783].", "features_encoders": "", "parents_code_id": "fiber_bundle", "parents_detail": "Fiber-bundle code can be viewed as a homological product code with a twisted product.", "parent_of_code_id": "distance_balanced\nhypergraph_product", "parent_of_detail": "Distance balancing relies on taking homological product of chain complexes corresponding to a classical and a quantum code.\nA homological product of chain complexes corresponding to two classical codes is a hypergraph product code [2009.03921].", "cousins_code_id": "quantum_random", "cousins_detail": "", "_type": "ecc", "_page_id": "c_homological_product", "_href": "c/homological_product"}, "c_generalized_homological_product": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Generalized homological product code", "physical": "", "short_name": "", "protection": "", "description": "Stabilizer code formulated using the CSS chain-complex<code:css> construction, with chain complexes consisting of products of other chain complexes. The chain-complex construction of codes yields an interpretation of codes in terms of manifolds, thus allowing for the use of various products from topology in constructing codes. The codes participating in the product can be quantum, classical, or mixed. Products can be of more than two codes, in which case the output code need not be of CSS type (e.g., for XYZ-product codes<code:xyz_product>). The simplest product is a tensor product, with more general products imposing equivalence or symmetry relations on the outputs of the tensor product. A product of two codes can be interpreted as a fiber bundle, with one element of the product being the base and the other being the fiber.\n", "code_id": "generalized_homological_product", "logical": "", "parents_code_id": "qldpc", "parents_detail": "Homological products are a primary tool for generating QLDPC codes with favorable parameters. Typically, whenever the input codes are LDPC or QLDPC, the resulting code will be QLDPC with non geometrically local stabilizer generators.", "parent_of_code_id": "balanced_product\nramanujan_tensor_product\nxyz_product", "parent_of_detail": "Balanced product codes result from a tensor product of two classical-code chain complexes, followed by a factoring out of certain symmetries.\nRamanujan codes result from a tensor product of a classical-code and a quantum-code chain complex.\nXYZ product codes result from a tensor product of three classical-code chain complexes.", "cousins_code_id": "css", "cousins_detail": "The notion of homological products arose from interpreting CSS codes in terms of chain complexes over manifolds, but some generalized products no longer yield CSS codes.", "_type": "ecc", "_page_id": "c_generalized_homological_product", "_href": "c/generalized_homological_product"}, "c_balanced_product": {"notes": "", "realizations": "", "physical": "qubits", "description": "Family of CSS quantum codes based on products of two classical codes which share common symmetries. The balanced product can be understood as taking the usual tensor/hypergraph product and then factoring out the symmetries factored. This reduces the overall number of physical qubits \\(n\\), while, under certain circumstances, leaving the number of encoded qubits \\(k\\) and the code distance \\(d\\) invariant. This leads to a more favourable encoding rate \\(k/n\\) and normalized distance \\(d/n\\) compared to the tensor/hypergraph product.", "code_id": "balanced_product", "logical": "qubits", "introduced": "[2012.09271]", "name": "Balanced product code", "short_name": "", "protection": "Taking balanced products of two classical LDPC codes which have a symmetry group which grows linearly in their block lengths were known to give QLDPC codes with a linear rate and which were conjectured to have linear distance [2012.09271]. This conjecture was proved in Ref. [2111.03654].", "features_rate": "A notable family of balanced product codes encode \\(k \\in \\Theta(n^{4/5})\\) logical qubits with distance \\(d \\in \\Omega(n^{3/5})\\) for any number of physical qubits \\(n\\). Additionally, it is known that the code constructed from the balanced product of two good classical LDPC codes over groups of order \\(\\Theta(n)\\) has a constant encoding rate [2012.09271].", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "BP-OSD decoder [1904.02703].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "css\ngeneralized_homological_product", "parents_detail": "\nBalanced product codes result from a tensor product of two classical-code chain complexes, followed by a factoring out of certain symmetries.", "parent_of_code_id": "fiber_bundle\nlifted_product", "parent_of_detail": "Fiber-bundle codes can be formulated in terms of a balanced product [2012.09271].\n", "cousins_code_id": "subsystem_stabilizer\ndistance_balanced", "cousins_detail": "Distance balancing is used to form balanced-product subsystem codes [2012.09271].\nDistance balancing is used to form balanced-product subsystem codes [2012.09271].", "_type": "ecc", "_page_id": "c_balanced_product", "_href": "c/balanced_product"}, "c_xyz_product": {"notes": "", "realizations": "", "physical": "qubits", "description": "A non-CSS QLDPC code constructed from three classical codes. The construction of an XYZ product code is similar to that of a hypergraph product code and related codes. The idea is that rather than taking a product of only two classical codes to produce a CSS code, a third classical code is considered, acting with Pauli-\\(Y\\) operators.\n", "code_id": "xyz_product", "logical": "qubits", "introduced": "[2011.09746]", "name": "XYZ product code", "short_name": "", "protection": "", "features_rate": "Not much has been proven about the relationship between XYZ-product codes and other codes. The logical dimension depends on properties of the input classical codes, specifically similarity invariants from abstract algebra. It is conjectured that specific instances of XYZ-product codes have a constant encoding rate and a minimum distance of \\(d \\in \\Theta(n^{2/3})\\) [2011.09746].\n", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qubit_stabilizer\ngeneralized_homological_product", "parents_detail": "\nXYZ product codes result from a tensor product of three classical-code chain complexes.", "cousins_code_id": "hypergraph_product", "cousins_detail": "The XYZ product code is based on a hypergraph product of three classical codes.", "_type": "ecc", "_page_id": "c_xyz_product", "_href": "c/xyz_product"}, "c_hypergraph_product": {"notes": "", "realizations": "", "physical": "qubits", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two binary linear seed codes \\(C_1\\) and \\(C_2\\).", "code_id": "hypergraph_product", "logical": "qubits", "introduced": "[0903.0566,1202.0928]", "name": "Hypergraph product code", "short_name": "", "protection": "The hypergraph product has distance \\(d=O(\\sqrt{n})\\). The number of encoded logical qubits is \\(k=O(k_1k_2)\\) where \\(k_1\\) and \\(k_2\\) are the dimensions of the classical seed codes \\(C_1\\) and \\(C_2\\).", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Code deformation techniques yield Clifford gates [1909.07424].", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "lifted_product\nhomological_product", "parents_detail": "Lifted-product codes for trivial group \\(G\\) are hypergraph-product codes.\nA homological product of chain complexes corresponding to two classical codes is a hypergraph product code [2009.03921].", "parent_of_code_id": "quantum_expander", "parent_of_detail": "", "cousin_of_code_id": "surface\nxyz_product", "cousin_of_detail": "Planar (toric) code obtained from hypergraph product of two repetition\n(cyclic) codes.\n\nThe XYZ product code is based on a hypergraph product of three classical codes.", "_type": "ecc", "_page_id": "c_hypergraph_product", "_href": "c/hypergraph_product"}, "c_lifted_product": {"notes": "Formerly known as generalized hypergraph product codes [1904.02703], and later renamed to lifted-product codes [2012.04068,10.1103/PRXQuantum.2.040101].", "realizations": "", "physical": "galois", "description": "Code that utilizes the notion of a lifted product in its construction. Lifted products of certain classical Tanner codes are the first (asymptotically) good QLDPC codes.\n\nA lifted product over a ring \\(R\\) is a product of two chain complexes whose chains are free modules over \\(R\\). An interesting case is when \\(R={\\mathbb{F}}_q G\\), the group-\\(G\\) algebra over the finite field \\({\\mathbb{F}}_q = GF(q)\\); in this case, the product can be called a \\(G\\)-lifted product. Just like its further generalization the balanced product, a lifted product code generalizes a hypergraph product code in that a reduction of symmetry is exploited to decrease the number of physical qubits required.\n\nThe key operation behind the \\(G\\)-lifted product is the \\(G\\)-lift. A \\(G\\)-lift of a \\(\\mathbb{F}_q\\)-valued matrix \\(A\\) substitutes matrix elements of \\(A\\) with matrices forming the regular representation of the group algebra \\({\\mathbb{F}}_q G\\) according to some rule. A combination of the lift and the usual hypergraph product yields lifted-product codes. The two operations commute: one can first take the usual hypergraph product of two chain complexes, and then lift the resulting product complex; equivalently, one can take the hypergraph product of the two lifted complexes.\n", "code_id": "lifted_product", "logical": "galois", "introduced": "[1904.02703,2111.03654]", "name": "Lifted-product (LP) code", "short_name": "", "protection": "Code performance strongly depends on the group \\(G\\) used in the product [2012.04068].", "features_rate": "There is no known simple way to compute the logical dimension \\(k\\) in the general case [2012.04068].", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "BP-OSD decoder [1904.02703] adds OSD-like post-processing to the belief propogation (BP) decoder for improved performance.", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "balanced_product\ngalois_css", "parents_detail": "\n", "parent_of_code_id": "expander_lifted_product\nhypergraph_product", "parent_of_detail": "Lifted products of certain classical Tanner codes are the first asymptotically good QLDPC codes.\nLifted-product codes for trivial group \\(G\\) are hypergraph-product codes.", "cousins_code_id": "surface\nhaah_cubic", "cousins_detail": "A lifted product code for the ring \\(R=\\mathbb{F}_2[x,y]/(x^L-1,y^L-1)\\) is the toric code.\nA lifted product code for the ring \\(R=\\mathbb{F}_2[x,y,z]/(x^L-1,y^L-1,z^L-1)\\) is the cubic code.", "_type": "ecc", "_page_id": "c_lifted_product", "_href": "c/lifted_product"}, "c_spins_into_spins": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Spin code", "physical": "spins", "short_name": "", "protection": "", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, where the canonical qudit basis consists of states of a quantum mechanical spin. In other words, canonical single-qudit states \\(|^\\ell_m\\rangle\\) are labeled by total angular momentum \\(\\ell\\) (either integer or half-integer) and its \\(z\\)-axis projection \\(m\\), with \\(q=2\\ell+1\\).\n\nIn contrast to other qudit codes, spin codes are closely associated with the angular momentum Lie algebra and/or the Lie groups \\(SU(2)\\) or \\(SO(3)\\).\n", "code_id": "spins_into_spins", "logical": "spins", "parents_code_id": "qecc_finite", "parents_detail": "", "cousins_code_id": "qubits_into_qubits", "cousins_detail": "Spin codes with spin \\(\\ell=1/2\\) correspond to qubit codes.", "_type": "ecc", "_page_id": "c_spins_into_spins", "_href": "c/spins_into_spins"}, "c_fermions": {"notes": "", "realizations": "", "physical": "fermions", "description": "Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators [quant-ph/0003137].", "code_id": "fermions", "logical": "fermions", "introduced": "", "name": "Fermionic code", "short_name": "", "protection": "", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "majorana_stab", "parent_of_detail": "", "cousins_code_id": "qubits_into_qubits\noscillators", "cousins_detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation [cond-mat/0010440], codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations.\nBosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom.", "_type": "ecc", "_page_id": "c_fermions", "_href": "c/fermions"}, "c_majorana_stab": {"notes": "", "realizations": "", "physical": "fermions", "description": "Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as Majorana stabilizers. The codespace is the mutual \\(+1\\) eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as \\([[n,k,d]]_{f}\\) [1703.00459], where \\(n\\) is the number of fermionic modes.", "code_id": "majorana_stab", "logical": "fermions", "introduced": "[1004.3791]", "name": "Majorana stabilizer code", "short_name": "", "protection": "Detects products of Majorana operators with weight up to \\(d-1\\). Physically, protects against dephasing errors caused by coupling of fermion density to the environment and bit-flip errors caused by quasiparticle poisoning processes.", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "fermions\nqubit_stabilizer", "parents_detail": "\nThe Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code [cond-mat/0506438,1004.3791]. However, Pauli- and Majorana-based stabilizer codes have different notions of locality [cond-mat/0010440] and are thus useful for different physical platforms.", "cousins_code_id": "dual\ncss\ncyclic\nreed_muller\nstabilizer", "cousins_detail": "Classical weakly self-dual codes can be used to construct Majorana stabilizer codes [1703.00459]. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a weakly self-dual classical code. A weakly self-dual classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\).\nWhen constructing a Majorana stabilizer code from a weakly self-dual classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space [1004.3791,1703.00459]. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different weakly self-dual classical codes with an odd number of bits, as is often done in the CSS construction.\nCyclic codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also weakly self-dual [1703.00459].\nMajorana stabilizer codes can be constructed by weakly self-dual Reed-Muller codes [1703.00459]. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code.\nMajorana stabilizer codes are useful for Majorana-based architectures, where the degrees of freedom are electrons, and the notion of locality is different than all other code kingdoms.", "cousin_of_code_id": "floquet\nhoneycomb\nstab_5_1_3", "cousin_of_detail": "Floquet codes are viable candidates for storage in Majorana-qubit devices [2202.11829].\nThe Honeycomb code admits a representation in terms of Majorana fermions. This leads to a possible physical realization of the code in terms of tetrons [1610.05289], where each physical qubit is composed of four Majorana modes.\n\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators [Aleksander Kubica, private communication, 2019].", "_type": "ecc", "_page_id": "c_majorana_stab", "_href": "c/majorana_stab"}, "c_string_net": {"notes": "", "realizations": "", "physical": "categories", "description": "Also called a Turaev-Viro or Levin-Wen model code. A family of topological codes, defined by a finite unitary spherical category \\( \\mathcal{C} \\),  whose generators are few-body operators acting on a cell decomposition dual to a triangulation of a two-dimensional surface (with a qudit of dimension \\( |\\mathcal{C}| \\) located at each edge of the decomposition).\n\nThe codespace is the ground-state subspace of the Levin-Wen model Hamiltonian [cond-mat/0404617], a many-body Hamiltonian realizing the 3-manifold Turaev-Viro invariant [1002.2816,1106.6033]. Alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model [quant-ph/0001108,1002.2816]. The fusion space can have dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.\n", "code_id": "string_net", "logical": "categories", "introduced": "[cond-mat/0404617,1002.2816]", "name": "String-net code", "short_name": "", "protection": "Error-correcting properties established in Ref. [2004.11982].", "features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "Syndrome measurement circuits analyzed in Ref. [1206.6048].", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "Gates can be implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles for triangulations of toroidal [1806.02358,1806.06078] and hyperbolic [1901.11029] manifolds. Whether or not a gate set is universal depends on the choice of input category; in some cases such as the Ising category, gates can be complemented by topological charge measurements to obtain a universal gate set.\nAlternatively, one could encode the logical quantum information into the degenerate fusion space of a number of computational anyons. In this case, a universal logical gate set can be implemented through the braiding of the computational anyons [quant-ph/0001108,math/0103200,1002.2816], e.g., for the case of the Fibonacci<code:fibonacci> input category.", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "category_quantum\ntopological", "parents_detail": "\nString-net codes can be realized using Levin-Wen model Hamiltonians, which realize various topological phases [cond-mat/0404617,1002.2816,1106.6033].", "parent_of_code_id": "fibonacci", "parent_of_detail": "", "cousin_of_code_id": "quantum_double", "cousin_of_detail": "String-net model reduces to the quantum-double model for group categories.", "_type": "ecc", "_page_id": "c_string_net", "_href": "c/string_net"}, "c_fibonacci": {"notes": "", "realizations": "", "physical": "categories", "description": "Quantum error correcting code associated with the Levin-Wen string-net model with the Fibonacci input category, admitting two types of encodings.\n\nThe first type of encoding is into the ground-state subspace of the Levin-Wen model Hamiltonian, defined on a cell decomposition (dual to a triangulation) of a manifold with a qubit on each link. The code space is the simultaneous \\(+1\\) eigenspace of a set of vertex operators and plaquette operators, which are defined by the fusion rules and the numerical data of the Fibonacci category, respectively. The degeneracy of the code space is \\(4g\\),\nwere \\(g\\) is the genus of the surface on which the cell decomposition is defined.\n\nThe second type of encoding is into the degenerate fusion space of a number of anyonic quasiparticle excitations of the Levin-Wen model.\n", "code_id": "fibonacci", "logical": "categories", "introduced": "[cond-mat/0404617]", "name": "Fibonacci string-net code", "short_name": "", "protection": "When defined on a \\(L \\times L\\) tailed honeycomb lattice on a torus, the code distance for ground-state encoding is \\(L\\).", "features_rate": "", "features_threshold": "\\(4.7\\%\\) for depolarizing noise, \\(7.3\\%\\) for dephasing noise, and \\(3.8\\%\\) for bit-flip noise with clustering decoder, assuming perfect measurements and gates [2012.04610].\n\\(3.0\\%\\) for depolarizing noise, \\(6.0\\%\\) for dephasing noise, and \\(2.5\\%\\) for bit-flip noise with fusion-aware iterative MWPM decoder, assuming perfect measurements and gates [2012.04610].", "features_magic_scaling_exponent": "", "features_decoders": "Clustering decoder (provides best known threshold for this code) [2012.04610].\nFusion aware iterative minimum-weight perfect matching decoder. Note that ordinary MWPM decoders do not produce a threshold with this code [2012.04610].", "features_transversal_gates": "A universal transversal gate set could be implemented in a folded version of this code using the techniques introduced in Ref.[1711.05752].", "features_code_capacity_threshold": "", "features_general_gates": "Universal gate set for the ground-state encoding is implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles. These Dehn-twists can be implemented using constant-dept circuits when allowing long-range permutations of qubits [1806.02358,1806.06078].\nUniversal gate set for the fusion-space encoding is implemented through braiding of the computational anyons [quant-ph/0001108,1002.2816].", "features_fault_tolerance": "", "features_encoders": "", "parents_code_id": "string_net", "parents_detail": "", "_type": "ecc", "_page_id": "c_fibonacci", "_href": "c/fibonacci"}, "c_category_quantum": {"features_rate": "", "features_threshold": "", "features_magic_scaling_exponent": "", "features_decoders": "", "features_transversal_gates": "", "features_code_capacity_threshold": "", "features_general_gates": "", "features_fault_tolerance": "", "features_encoders": "", "introduced": "", "notes": "", "realizations": "", "name": "Category-based quantum code", "physical": "categories", "short_name": "", "protection": "", "description": "Encodes a finite-dimensional logical Hilbert space into a physical Hilbert space associated with a category. Often associated with a particular topological quantum field theory (TQFT), as the data of such theories is described by a category.", "code_id": "category_quantum", "logical": "categories", "parents_code_id": "qecc_finite", "parents_detail": "", "parent_of_code_id": "string_net", "parent_of_detail": "", "_type": "ecc", "_page_id": "c_category_quantum", "_href": "c/category_quantum"}}