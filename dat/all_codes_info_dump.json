{"oaecc": {"code_id": "oaecc", "name": "Operator-algebra error-correcting code", "introduced": "\\cite{arXiv:quant-ph/0203105,arXiv:0705.1574}", "description": "Stub.", "protection": ""}, "ecc": {"code_id": "ecc", "name": "Error-correcting code", "description": "Encodes \\(K\\) states (codewords) over an alphabet with \\(N\\) elements such that it is possible to recover the codewords from errors \\(E\\) from some error set \\(\\mathcal{E}\\). Formally, an error-correcting code \\((u,\\mathcal{E})\\) is an \\textit{encoder} function \\(u:[1\\cdots K]\\to[1\\cdots N]\\) with a set of correctable errors \\(E:[1\\cdots N]\\to [1\\cdots M]\\) with the following property: there exists a \\textit{decoder} function \\(d:[1\\cdots M]\\to [1\\cdots K]\\) such that for all \\(E\\in\\cal{E}\\) and states \\(x\\in[1\\cdots K]\\), \\(d(E(e(x)))=x\\).", "protection": "", "relations": {"parents": [{"code_id": "oaecc", "detail": ""}]}}, "q-ary_digits_into_q-ary_digits": {"code_id": "q-ary_digits_into_q-ary_digits", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "\\(q\\)-ary code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) \\(q\\)-ary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)_q\\). The distance is the minimum number of coordinates where two strings in the code differ.", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "relations": {"parents": [{"code_id": "ecc", "detail": ""}]}}, "weakly_self_dual": {"code_id": "weakly_self_dual", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Weakly self-dual linear code", "description": "Also called a \\textit{self-orthogonal} code. A \\(q\\)-ary linear code \\(C\\) whose dual code \\(C^\\perp = \\{ y\\in\\mathbb{Z}_q^{\\times n} ~|~ x\\cdot y=0 \\forall x\\in C\\}\\) is contained in \\(C\\).", "protection": "The generator matrix of \\(C^\\perp\\) is the parity check matrix of \\(C\\), and visa versa.", "notes": [""], "relations": {"parents": [{"code_id": "q-ary_digits_into_q-ary_digits", "detail": ""}]}}, "q-ary_linear": {"code_id": "q-ary_linear", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "\\(q\\)-ary linear code", "description": "An \\((n,K,d)_q\\) linear code is denoted as \\([n,k,d]_q\\), where \\(k=\\log_{q}K\\) need not be an integer. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any \\(q\\)-ary digits \\(\\alpha,\\beta\\). Often defined in terms of a generator matrix \\(G\\), whose rows form a basis for the subspace. Given a codeword \\(x\\), the corresponding encoded codeword is \\(G^T x\\).", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set such that the difference of any pair of distinct elements of the set is a codeword.", "notes": ["Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\)."], "relations": {"parents": [{"code_id": "q-ary_digits_into_q-ary_digits", "detail": ""}]}}, "self_dual": {"code_id": "self_dual", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Self-dual linear code", "description": "Also called \\textit{strictly self-dual}. A \\(q\\)-ary linear code \\(C\\) whose dual code \\(C^\\perp = \\{ y\\in\\mathbb{Z}_q^{\\times n} ~|~ x\\cdot y=0 \\forall x\\in C\\}\\) is equal to \\(C\\).", "protection": "The generator and parity-check matrices of \\(C\\) are equal.", "notes": [""], "relations": {"parents": [{"code_id": "weakly_self_dual", "detail": ""}]}}, "perfect": {"code_id": "perfect", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Perfect code", "description": "An \\((n,K,2t+1)_q\\) \\(q\\)-ary code is perfect if parameters \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the Hamming (a.k.a. sphere-packing) bound\n\\begin{align}\n\\sum_{j=0}^{t}(q-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a binary \\(q=2\\) code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\).\n\nFor binary codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-H(t/n),\n\\end{align}\nwhere \\(H\\) is the binary entropy function.\n", "notes": [""], "relations": {"parents": [{"code_id": "q-ary_digits_into_q-ary_digits", "detail": ""}]}}, "reed_solomon": {"code_id": "reed_solomon", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Reed-Solomon code", "introduced": "\\cite{doi:10.1137/0108018}", "description": "\\([n,k,n-k+1]_q\\) linear code. Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(GF(q)\\) for prime \\(q>n\\). Encodes \\(\\mu=\\{\\mu_0,\\cdots,\\mu_{k-1}\\}\\) into \\(\\{f_\\mu(\\alpha_1),\\cdots,f_\\mu(\\alpha_n)\\}\\) with polynomial \\(f_\\mu(x)=\\mu_0+\\mu_1 x + \\cdots + \\mu_{k-1}x^{k-1}\\).", "protection": "Corrects erasures on \\(n-k\\) coordinates.", "realizations": ["Numerous applications: computer hard-disks, DVDs, 3G telephone networks (IS-2000, Release D), NASA deep-space exploration, etc."], "relations": {"parents": [{"code_id": "q-ary_linear", "detail": ""}]}}, "classical_abelian_group": {"code_id": "classical_abelian_group", "name": "Classical Abelian group Code", "description": "Stub.", "protection": ""}, "cyclic": {"code_id": "cyclic", "name": "Cyclic code", "description": "A classical code \\(C\\) of length \\(n\\) over an alphabet is cyclic if, for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\in C\\).", "protection": "", "notes": [""], "relations": {"parents": [{"code_id": "ecc"}]}}, "generalized_concatenated": {"code_id": "generalized_concatenated", "name": "Generalized concatenated classical code", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "ecc", "detail": ""}]}}, "tanner": {"code_id": "tanner", "physical": "bits", "logical": "bits", "name": "Tanner code", "description": "Stub.", "protection": "", "notes": [""], "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}]}}, "polar": {"code_id": "polar", "physical": "bits", "logical": "bits", "name": "Polar code", "introduced": "\\cite{doi:10.1109/TIT.2009.2021379}", "description": "In its basic version, a binary linear polar code encodes \\(K\\) message bits into \\(N=2^n\\) bits. The linear transformation that defines the code is given by the matrix \\(G^{(n)}=B_N G^{\\otimes n}\\), where \\(B_N\\) is a certain \\(N\\times N\\) permutation matrix, and \\(G^{\\otimes n}\\) is the \\(n\\)th Kronecker power of the \\(2\\times 2\\) \\textit{kernel} matrix \\(G=\\left[\\begin{smallmatrix}1 & 0\\\\ 1 & 1 \\end{smallmatrix}\\right]\\). To encode \\(K\\) message bits, one forms an \\(N\\)-vector \\(u\\) in which \\(K\\) coordinates represent the message bits. The remaining \\(N-K\\) coordinates are set to some fixed values and are said to be \\textit{frozen}. The codeword \\(x \\in \\{0,1\\}^N\\) is obtained as \\(x=u G^{\\otimes n}\\). The choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.", "protection": "Protects against various types of noise in the communication channel, for instance, errors, erasures, or other types of noise. Distance plays no role in the analysis of its properties, and is much lower than the largest possible value given \\(K,N\\).", "features": {"rate": "Supports reliable transmission at rates \\(K/N\\) approaching the Shannon capacity of the channel.", "decoders": ["Successive cancellation decoder \\cite{doi:10.1109/TIT.2009.2021379}.", "Successive cancellation list decoder \\cite{doi:10.1109/TIT.2015.2410251}."], "threshold": ["Achieves Shannon capacity of the binary-input memoryless channel under successive cancellation decoder \\cite{doi:10.1109/TIT.2009.2021379}."]}, "realizations": ["Code control channels for the 5G NR (New Radio) interfaces."], "notes": ["There are multiple variants of the basic construction, in particular relying on other kernel matrices. The codes can be defined for nonbinary alphabets, and they can be adjusted to support tasks such as lossless and lossy compression, successive refinement, communication over the mulitple access channel, communication over the wiretap channel, and many others.", "Described in Ch. 32 of Ref. \\cite{doi:10.1201/9781315147901}."], "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}], "cousins": [{"code_id": "reed_muller", "detail": "Reed-Muller code relies on the same generator matrix, but places message bits in different coordinates."}, {"code_id": "generalized_concatenated", "detail": "Polar codes can be represented as generalized concatenations of their kernels."}]}}, "binary_linear": {"code_id": "binary_linear", "physical": "bits", "logical": "bits", "name": "Binary linear code", "description": "An \\((n,2^k,d)\\) linear code is denoted as \\([n,k,d]\\). Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword. Often defined in terms of a generator matrix \\(G\\), whose rows form a basis for the subspace. Given a codeword \\(x\\), the corresponding encoded codeword is \\(G^T x\\).", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set for which no two elements of the set add up to a codeword.", "notes": ["Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\)."], "relations": {"parents": [{"code_id": "bits_into_bits", "detail": ""}]}}, "ldpc": {"code_id": "ldpc", "physical": "bits", "logical": "bits", "name": "Low-density parity-check (LDPC) code", "description": "Stub.", "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}]}}, "reed_muller": {"code_id": "reed_muller", "physical": "bits", "logical": "bits", "name": "Reed-Muller code", "introduced": "\\cite{doi:10.1109/irepgelc.1954.6499441,doi:10.1109/tit.1954.1057465}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}]}}, "bits_into_bits": {"code_id": "bits_into_bits", "physical": "bits", "logical": "bits", "name": "Binary code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) binary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)\\). The distance is the minimum Hamming distance between a pair of distinct codewords.", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "relations": {"parents": [{"code_id": "ecc", "detail": ""}]}}, "oecc": {"code_id": "oecc", "name": "Operator quantum error-correcting code", "introduced": "\\cite{arXiv:quant-ph/0412076,arXiv:quant-ph/0504189}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "oaecc", "detail": ""}]}}, "qecc_finite": {"code_id": "qecc_finite", "name": "Finite-dimensional QECC", "description": "A quantum error-correcting code that encodes quantum information in a \\(K\\)-dimensional (\\textit{logical}) subspace \\(\\mathsf{H}_K\\) of an \\(N\\)-dimensional (\\textit{physical}) Hilbert space \\(\\mathsf{H}_N\\) such that it is possible to recover said information from errors. Formally, a finite-dimensional QECC \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{K}\\to\\mathsf{H}_{N}\\) with a set of correctable errors \\({\\cal{E}}:\\mathsf{H}_N\\to\\mathsf{H}_M\\) with the following property: there exists a quantum operation \\({\\cal{D}}:\\mathsf{H}_M\\to \\mathsf{H}_K\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{K}\\), \\({\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\) for some constant \\(c\\).", "protection": "Correction capability is determined by the Knill-Laflamme error correction criteria \\cite{arXiv:quant-ph/9604034,arXiv:quant-ph/9604024}. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an \\hyperref[code:approximate_qecc]{approximate code}.", "features": {"general_gates": ["Universal gate set cannot be transversal due to Eastin-Knill theorem \\cite{arXiv:0811.4262}."]}, "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "qecc": {"code_id": "qecc", "name": "Quantum error-correcting code (QECC)", "description": "Encodes quantum information in a (\\textit{logical}) subspace of a (\\textit{physical}) Hilbert space such that it is possible to recover said information from errors that act as linear maps on the physical space. The logical subspace is spanned by a basis comprised of \\textit{code basis states} or \\textit{codewords}. More formally, denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a QECC \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{\\text{logical}}\\to\\mathsf{H}_{\\text{physical}}\\) with a set of correctable errors \\(\\cal{E}\\) with the following property: there exists a quantum operation \\(\\cal{D}\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{\\text{logical}}\\), \\({\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\) for some constant \\(c\\). Ideal code states \\(|\\psi\\rangle\\) may not be normalizable if the physical Hilbert space in infinite, so approximate versions have to be constructed.", "protection": "Correction capability is determined by of the Knill-Laflamme error-correction criteria \\cite{arXiv:quant-ph/9604034,arXiv:quant-ph/9604024}, which may admit infinite terms due to non-normalizability of ideal code states. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an \\hyperref[code:approximate_qecc]{approximate code}.", "relations": {"parents": [{"code_id": "oecc", "detail": ""}]}}, "color": {"code_id": "color", "physical": "qubits", "logical": "qubits", "name": "Color code", "introduced": "\\cite{doi:10.1103/PhysRevLett.97.180501}", "description": "Color code is a topological stabilizer code defined on a \\(D\\)-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial \\(D\\)-complex obtained as a triangulation of the interior of a \\(D\\)-simplex and (2) is \\(D+1\\)-colorable. Qubits are placed on the \\(D\\)-simplices and generators are supported on suitable simplices \\cite{doi:10.7907/059V-MG69}. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face \\cite{arXiv:1311.0277}.", "protection": "As with the surface code, the code distance depends on the specific kind of lattice used to define the code. More precisely, the distance depends on the homology of logical string operators \\cite{arXiv:1311.0277}.", "features": {"transversal_gates": "Transversal CNOT can be implemented via braiding \\cite{arXiv:0806.4827}. Universal transversal gates can be achieved in 3D color code using gauge fixing \\cite{arxiv:1311.0879}, lattice surgery \\cite{arXiv:1407.5103}, or code deformation \\cite{doi:10.1088/1367-2630/13/4/043005,arXiv:0806.4827}.", "general_gates": ["Magic-state distillation protocols \\cite{doi:10.7907/059V-MG69}.", "Non-clifford gates can be implemented via code switching \\cite{doi:10.7907/059V-MG69}."], "decoders": ["Projection decoder \\cite{doi:10.7907/059V-MG69}.", "Matching decoder gives low logical failure rate \\cite{arXiv:2108.11395}.", "Integer-program-based decoder \\cite{arXiv:1402.3037}.", "Restriction decoder \\cite{doi:10.1088/1367-2630/ab68fd}."], "fault_tolerance": ["Syndrome measurement \\cite{arXiv:1407.5103}.", "Steane's ancilla-coupled measurement method \\cite{arXiv:1407.5103}"], "threshold": ["\\(\\geq 6.25\\%\\) threshold for 2d color codes with error-free syndrome extraction, and \\(0.1\\%\\) with faulty syndrome extraction \\cite{arXiv:0907.1708}.", "\\(0.46\\%\\) for 3d codes with clustering decoder \\cite{arXiv:1708.07131}.", "\\(1.9\\%\\) for 1D string-like logical operators and \\(27.6\\%\\) for 2D sheet-like operators for 3D codes with noise models using optimal decoding and perfect measurements \\cite{arXiv:1708.07131}.", "\\(0.31\\%\\) noise threshold error rate for gauge code using clustering decoder \\cite{arXiv:1503.08217}.", "\\(0.143\\%\\) with depolarising circuit-level noise using perfect-matching decoder \\cite{arXiv:1407.5103}.", "\\(>0\\%\\) threshold with sweep decoder \\cite{doi:10.7907/059V-MG69}."]}, "relations": {"parents": [{"code_id": "css", "detail": ""}, {"code_id": "topological", "detail": "Defined on a lattice with geometrically local stabilizer generators \\cite{doi:10.7907/059V-MG69}."}], "cousins": [{"code_id": "quantum_ldpc", "detail": "Stabilizer generator weights and qubit degrees are given by the properties of the tessellation, and most tesselations yield QLDPC codes."}, {"code_id": "surface", "detail": "Color code is equivalent to surface code in several ways \\cite{doi:10.1088/1367-2630/17/8/083026}. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D\\)-dimensional surface code."}]}}, "ramanujan_tensor_product": {"code_id": "ramanujan_tensor_product", "physical": "qubits", "logical": "qubits", "name": "Ramanujan tensor-product code", "introduced": "\\cite{arXiv:2004.07935}", "description": "Constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.", "protection": "Without distance balancing, a Ramanujan code can have \\(d_X =\\Omega(\\log n)\\) and \\(d_Z = \\Omega (n)\\). For 2D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}\\). For 3D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d= \\Omega(n^{1/2}\\log n )\\).", "features": {"rate": "For 2D Ramanujan complexes, the rate is \\(\\Omega(\\sqrt{ \\frac{1}{n \\log n} })\\), with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}) \\). For 3D, the rate is \\( \\Omega(\\frac{1}{\\sqrt{n}\\log n}) \\) with minimum distance \\(d \\geq \\sqrt{n} \\log n \\).", "decoders": ["For 2D simplicial complexes, cycle code decoder admitting a polynomial-time decoding algorithm can be used \\cite{arXiv:2004.07935}."]}, "notes": ["Codes were first to break a 20-year record set by the \\hyperref[code:freedman_meyer_lou]{Freedman-Meyer-Lou code} for the lower bound on scaling of the minimum distance \\cite{doi:10.1103/PRXQuantum.2.040101}."], "relations": {"parents": [{"code_id": "homological_product", "detail": "Code is constructed using product of complexes \\cite{arXiv:2004.07935}."}, {"code_id": "quantum_ldpc", "detail": "\\(Z\\)- and \\(X\\)- row and column weights are bounded from above by the weights of the two codes that are used in the construction of this code \\cite{arXiv:2004.07935}."}], "cousins": [{"code_id": "distance_balanced", "detail": "Ramanujan tensor-product constructions use distance balancing to increase distance."}]}}, "stab_4_2_2": {"code_id": "stab_4_2_2", "physical": "qubits", "logical": "qubits", "name": "\\([[4,2,2]]\\) CSS code", "introduced": "\\cite{arXiv:quant-ph/9603031}", "description": " Four-qubit CSS stabilizer code with generators \\(\\{XXXX, ZZZZ\\} \\) and codewords \\begin{align} \\begin{split} |\\overline{00}\\rangle = (|0000\\rangle + |1111\\rangle)/\\sqrt{2}\\\\ |\\overline{01}\\rangle = (|0011\\rangle + |1100\\rangle)/\\sqrt{2}\\\\ |\\overline{10}\\rangle = (|0101\\rangle + |1010\\rangle)/\\sqrt{2}\\\\ |\\overline{11}\\rangle = (|0110\\rangle + |1001\\rangle)/\\sqrt{2} \\end{split}. \\end{align} Its subcode is the \\([[4,1,2]]\\) code, whose \\(\\pm\\)-basis codewords can be written as \\begin{align} |\\overline{\\pm}\\rangle = \\frac{1}{2}(|00\\rangle \\pm |11\\rangle)^{\\otimes 2}\\\\ \\end{align} This code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code.", "protection": "Detects a single-qubit error \\cite{arXiv:quant-ph/9603031} or single erasure \\cite{arXiv:quant-ph/9610042}. Not able to correct arbitrary single-qubit errors because \\( \\lfloor \\frac{d-1}{2} \\rfloor =0 \\). Approximately corrects a single amplitude damping error \\cite{arXiv:quant-ph/9704002}.", "features": {"transversal_gates": "Transversal Pauli, Hadamard, and two-qubit \\(R\\) gates \\cite{arxiv:1610.03507}.", "fault_tolerance": ["Preparation of certain states along with transversal gates can be performed fault-tolerantly, but requires post-selection because the code cannot correct errors \\cite{arxiv:1610.03507}."]}, "realizations": ["Realized in trapped-ion quantum devices \\cite{arXiv:1611.06946}."], "notes": ["Concatenating \\([[4,2,2]]\\) code with surface code can generate 2D topological code with a reasonable circuit-based threshold \\cite{doi:10.26421/QIC16.15-16-1}."], "relations": {"parents": [{"code_id": "quantum_parity", "detail": "\\([[4,1,2]]\\) subcode is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes."}], "cousins": [{"code_id": "surface", "detail": "\\([[4,2,2]]\\) code is the smallest toric code."}, {"code_id": "stab_5_1_3", "detail": "\\([[4,2,2]]\\) can be derived from \\([[5,1,3]]\\) code using a protocal that converts \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman \\cite{arXiv:quant-ph/9705052}."}, {"code_id": "quantum_polar", "detail": "\\([[4,2,2]]\\) code is a small quantum polar code \\cite{manual:{Kyungjoo Noh, \\href{https://github.com/errorcorrectionzoo/eczoo_data/files/7652763/Leung_code_as_quantum_polar_code.pdf}{Leung code as quantum polar code}, 2017}}."}, {"code_id": "approximate_qecc", "detail": "\\([[4,2,2]]\\) code approximately corrects a single amplitude damping error \\cite{arXiv:quant-ph/9704002}."}]}}, "fiber_bundle": {"code_id": "fiber_bundle", "name": "Fiber-bundle code", "description": "Stub."}, "stabilizer": {"code_id": "stabilizer", "physical": "qubits", "logical": "qubits", "name": "Stabilizer code", "introduced": "\\cite{arXiv:quant-ph/9605005}\\cite{arXiv:quant-ph/9705052}", "description": "An \\(((n,2^k,d))\\) stabilizer code is denoted as \\([[n,k]]\\) or \\([[n,k,d]]\\), where \\(d\\) is the code's distance. Logical subspace is the joint \\(+1\\) eigenspace of a set of \\(2^{n-k}\\) commuting Pauli operators \\(S\\) forming the code's stabilizer group \\(\\mathsf{S}\\), which cannot contain \\(-I\\). The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation on the code.", "protection": "Detects errors on up to \\(d-1\\) qubits, and corrects erasure errors on up to \\(d-1\\) qubits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{\\hat{N}(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "features": {"encoders": ["Dissipative preparation, for which codespace is steady-state space of a Lindbladian \\cite{arXiv:1310.1036}."]}, "relations": {"parents": [{"code_id": "cws", "detail": ""}], "cousins": [{"code_id": "prime_qudit_stabilizer", "detail": ""}, {"code_id": "hamiltonian", "detail": "Codespace is the ground-state space of the \\textit{code Hamiltonian}, consisting of an equal linear combination of stabilizer generators."}]}}, "gauge_stabilizer": {"code_id": "gauge_stabilizer", "name": "Gauge stabilizer code", "description": "Stub."}, "t-designs": {"code_id": "t-designs", "physical": "qubits", "logical": "qubits", "name": "Local Haar-random circuit code", "introduced": "\\cite{doi:10.1007/s00220-016-2706-8}", "description": "An \\(n\\)-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal \\(n\\)-qubit states and acting with a random unitary circuit of depth linear in \\(n\\). Two states are \\textit{locally indistinguishable} if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about \\(n/2\\) two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries.\nThe above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (\\(D=1\\)), while general codes for higher-dimensional geometries required \\(O(N^{1/D}\\)-depth circuits \\cite{doi:10.1007/s00220-016-2706-8}. Follow-up work \\cite{arxiv:2010.09775} revealed that optimal code properties require only \\(O(\\sqrt{N})\\)-depth circuits for that case, and \\(O(\\sqrt{N}\\)-depth circuits for a two-dimensional square-lattice geometry.", "protection": "In a 1D geometry, the code approximately detects any error with support on a segment of length \\(\\leq n/4\\), with deviations exponentially suppressed in \\(n\\).", "features": {"encoders": ["Random local circuit of depth \\(\\leq 10^9 n\\)."]}, "notes": ["Described in Application III of Brandao et al. \\cite{doi:10.1007/s00220-016-2706-8}."], "relations": {"parents": [{"code_id": "random_circuit", "detail": ""}], "cousins": [{"code_id": "topological", "detail": "Local Haar-random codewords, like topological codewords, are locally indistinguishable \\cite{doi:10.1007/s00220-016-2706-8}."}, {"code_id": "approximate_qecc", "detail": ""}]}}, "qubits_into_qubits": {"code_id": "qubits_into_qubits", "physical": "qubits", "logical": "qubits", "name": "Qubit code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2^n\\)-dimensional (i.e., \\(n\\)-qubit) Hilbert space. Usually denoted as \\(((n,K))\\) or \\(((n,K,d))\\), where \\(d\\) is the code's distance.", "relations": {"parents": [{"code_id": "qecc_finite", "detail": ""}]}}, "quantum_reed_muller": {"code_id": "quantum_reed_muller", "physical": "qubits", "logical": "qubits", "name": "Quantum Reed-Muller code", "introduced": "\\cite{arXiv:quant-ph/9608026}", "description": "Stub.", "protection": "", "features": {"fault_tolerance": ["Gate switching protocol for universal computation \\cite{arxiv:1403.2734}."]}, "relations": {"parents": [{"code_id": "stabilizer", "detail": ""}]}}, "movassagh_ouyang": {"code_id": "movassagh_ouyang", "physical": "qubits", "logical": "qubits", "name": "Movassagh-Ouyang Hamiltonian Codes", "description": "Stub.", "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "bacon_shor": {"code_id": "bacon_shor", "physical": "qubits", "logical": "qubits", "name": "Bacon-Shor code", "description": "Stub.", "protection": ""}, "quantum_hamming": {"code_id": "quantum_hamming", "physical": "qubits", "logical": "qubits", "name": "Quantum Hamming code", "introduced": "\\cite{arXiv:quant-ph/9604038}", "description": "Stub.", "relations": {"parents": [{"code_id": "stabilizer", "detail": ""}]}}, "stab_5_1_3": {"code_id": "stab_5_1_3", "physical": "qubits", "logical": "qubits", "name": "\\([[5,1,3]]\\) code", "introduced": "\\cite{arXiv:quant-ph/9602019}", "description": "Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, \\begin{align} \\begin{split} S_1 &= IXZZX \\\\ S_2 &= XZZXI \\\\ S_3 &= ZZXIX \\\\ S_4 &= ZXIXZ. \\end{split} \\end{align}", "protection": "Smallest stabilizer code that protects against a single error on any one qubit. Detects two-qubit errors.", "features": {"transversal_gates": "Pauli gates are transversal."}, "realizations": ["First realized in NMR \\cite{doi:10.1103/PhysRevLett.86.5811}.", "Demonstration with superconducting qubits \\cite{arXiv:1907.04507}."], "relations": {"parents": [{"code_id": "stabilizer", "detail": "\\([[5,1,3]]\\) code is the smallest stabilizer code to correct a single qubit error."}], "cousins": [{"code_id": "quantum_perfect", "detail": "The smallest perfect code."}, {"code_id": "quantum_cyclic", "detail": "\\([[5,1,3]]\\) code is the smallest known example of quantum cyclic code ."}, {"code_id": "hamiltonian", "detail": "\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of Majorana operators \\cite{manual:{Aleksander Kubica, private communication, 2019}}."}, {"code_id": "majorana_stab", "detail": "\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of Majorana operators \\cite{manual:{Aleksander Kubica, private communication, 2019}}."}]}}, "freedman_meyer_lou": {"code_id": "freedman_meyer_lou", "physical": "qubits", "logical": "qubits", "name": "Freedman-Meyer-Lou code", "description": "Stub.", "protection": ""}, "surface": {"code_id": "surface", "physical": "qubits", "logical": "qubits", "name": "Kitaev surface code", "introduced": "\\cite{doi:10.1007/978-1-4615-5923-8_19,arXiv:quant-ph/9707021}", "description": "A family of \\hyperref[code:css]{CSS stabilizer} codes whose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qubit located at each edge of the tesselation). \\textit{Toric code} often either refers to the construction on the two-dimensional torus or is an alternative name for the general construction. The construction on surfaces with boundaries is often called the \\textit{planar code} \\cite{arXiv:quant-ph/9811052}.", "protection": "When defined on an \\(L\\times L\\) square tiling of the torus, protects against \\(L\\) errors. More generally, the code distance is related to the homology of the tessellation \\cite{arXiv:quant-ph/0110143}.", "features": {"transversal_gates": "Pauli gates on torus geometry.", "general_gates": ["Clifford gates can be implemented via lattice surgery \\cite{arXiv:1111.4022,arXiv:1709.02318} or braiding defects \\cite{arXiv:quant-ph/0610082,arXiv:quant-ph/0703143,arXiv:1208.0928,arXiv:1609.04673}.", "Non-Clifford gates require magic state distillation \\cite{arXiv:1905.06903} or just-in-time decoding \\cite{arXiv:1903.11634}."], "threshold": ["\\(10.9\\%\\) with independent \\(X/Z\\) errors for square tiling \\cite{arXiv:0811.0464}.", "\\(18.9\\%\\) with depolarizing noise for square tiling \\cite{arXiv:1202.1852}.", "\\(50\\%\\) with loss errors for square tiling \\cite{arXiv:0904.3556}.", "\\(3.3\\%\\) with phenomenological noise for square tiling \\cite{arXiv:quant-ph/0401101}.", "\\(0.5-1.1\\%\\) for various error models \\cite{arXiv:1311.5003}."], "encoders": ["Unitary \\cite{arXiv:0712.0348,arXiv:2002.00362,arXiv:2110.02020}.", "Dissipative \\cite{arXiv:1310.1036}.", "Stabilizer measurement-based \\cite{arXiv:1404.2495}."], "decoders": ["Minimum weight perfect-matching \\cite{arXiv:quant-ph/0110143,doi:10.26421/QIC15.1-2-9}, union-find \\cite{arXiv:1709.06218}, renormalization group \\cite{doi:10.26421/QIC14.9-10-1,arXiv:1411.3028}, tensor network \\cite{arXiv:1405.4883}, Markov chain Monte Carlo \\cite{arXiv:1302.2669}, cellular automaton \\cite{arXiv:1511.05579}, machine learning \\cite{arXiv:1610.04238,arXiv:1802.06441,arXiv:1810.07207}."]}, "notes": ["2D and 3D surface code \\href{http://gui.quantumcodes.io/}{visualization tool}.", "Toric code introductions from error-correction perspective by \\href{https://boulderschool.yale.edu/2018/boulder-school-2018-lecture-notes}{J. Haah} and condensed-matter perspective by \\href{https://boulderschool.yale.edu/2016/boulder-school-2016-lecture-notes}{M. Levin and C. Nayak}."], "realizations": ["Distance-two surface codes have been implemented by Andersen et al. \\cite{arXiv:1912.09410}, Erhard et al. \\cite{arXiv:2006.03071}, and Google Quantum AI \\cite{doi:10.1038/s41586-021-03588-y}.", "Signatures of corresponding topological phase of matter detected in superconducting circuits \\cite{arxiv:2104.01180} and two-dimensional arrays of Rydberg atoms \\cite{arXiv:2104.04119}.", "Distance-three surface code implemented at ETH Zurich \\cite{arxiv:2112.03708}."], "relations": {"parents": [{"code_id": "css", "detail": "Plaquette and star operators are stabilizer generators."}, {"code_id": "topological", "detail": "When treated as ground states of the code Hamiltonian, the code states realize \\(\\mathbb{Z}_2\\) topological order, a topological phase of matter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory \\cite{doi:10.1063/1.1665530}."}], "cousins": [{"code_id": "quantum_ldpc", "detail": "Stabilizer generator weights and qubit degrees are given by the properties of the tessellation, and most tesselations yield QLDPC codes."}, {"code_id": "hypergraph_product", "detail": "Planar (toric) code obtained from hypergraph product of two repetition (cyclic) codes."}]}}, "cws": {"code_id": "cws", "physical": "qubits", "logical": "qubits", "name": "Codeword stabilized (CWS) code", "description": "Stub.", "relations": {"parents": [{"code_id": "qubits_into_qubits", "detail": ""}]}}, "homological_product": {"code_id": "homological_product", "physical": "qubits", "logical": "qubits", "name": "Homological product code", "introduced": "\\cite{arXiv:1311.0885}", "description": "Stub.", "protection": "", "features": {"fault_tolerance": ["Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state \\cite{arXiv:1807.09783}."], "decoders": ["Union-find \\cite{arXiv:2009.14226}."]}, "relations": {"parents": [{"code_id": "css", "detail": ""}, {"code_id": "quantum_ldpc", "detail": ""}]}}, "css": {"code_id": "css", "physical": "qubits", "logical": "qubits", "name": "Calderbank-Shor-Steane (CSS) stabilizer code", "introduced": "\\cite{arXiv:quant-ph/9512032,doi:10.1103/PhysRevLett.77.793,arXiv:quant-ph/9601029}", "description": "An \\([[n,k,d]]\\) stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The parity check matrix is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}~.\n\\label{eq:parity}\n\\end{align}\n\nEncoding is based on two \\hyperref[code:binary_linear]{binary linear codes}, an \\([n,k_X,d_X]\\) code \\(C_X\\) and \\([n,k_Z,d_Z]\\) code \\(C_Z\\) with \\(C_X^\\perp \\subseteq C_Z\\), such that \\(k=k_X+k_Z-n\\) and \\(d\\geq\\min\\{d_X,d_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parity} is associated with the code \\(C_X\\) (\\(C_Z\\)), and the requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees that the \\(X\\)-stabilizers of \\(C_X\\) commute with the \\(Z\\)-stabilizers of \\(C_Z\\).\n\nA CSS code has \\textit{stabilizer weight} \\(w\\) if the highest weight of any stabilizer generator is \\(w\\), i.e., any row and column of \\(H_X\\) and \\(H_Z\\) has weight at most \\(w\\). In the context of comparing weight as well as of noise models biased toward \\(X\\)- or \\(Z\\)-type errors, an extended notation for CSS codes is \\([[n,k,(d_X,d_Z),w]]\\).\n", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "features": {"encoders": ["Stabilizer measurement \\cite{arxiv:1404.2495}."]}, "notes": ["Original requirement of \\(C_X^\\perp \\subset C_Z\\) \\cite{arXiv:quant-ph/9512032} has been relaxed to absorb \\hyperref[code:hypergraph_product]{hypergraph product} codes."], "relations": {"parents": [{"code_id": "stabilizer", "detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) weakly self-dual CSS code, with the mapping preserving geometric locality of a code up to a constant factor \\cite{arXiv:1004.3791}."}, {"code_id": "movassagh_ouyang", "detail": "Movassagh-Ouyang codes stem from a prescription that converts an \\textit{arbitrary} classical code into a quantum code."}], "cousins": [{"code_id": "binary_linear", "detail": "Construction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\)."}, {"code_id": "weakly_self_dual", "detail": "CSS codes for which \\(C_X=C_Z \\equiv C\\) are called \\textit{weakly self-dual} since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\)."}]}}, "shor_nine": {"code_id": "shor_nine", "physical": "qubits", "logical": "qubits", "name": "Shor \\([[9,1,3]]\\) code", "introduced": "\\cite{doi:10.1103/PhysRevA.52.R2493}", "description": "Nine-qubit CSS code that is the smallest such code to correct a single-qubit error. Shor's code works by concatenating each qubit of a phase-flip with a bit-flip repetition code. Therefore, the code can correct both type of errors simultaneously. To be specific, a state is phase-flip error-corrected by a three-qubit phase-flip correction code, with parity checks of \\(X_0 X_1I_2\\) and \\(X_0I_1X_2\\) in \\(X\\) basis, where the subscript represents the qubit index. Each logical qubit is encoded using \\begin{align} \\label{eq:phase-flip} \\begin{split} |0\\rangle_{L_P} &= |+_0+_1+_2\\rangle \\\\ |1\\rangle_{L_P} &= |-_0-_1-_2\\rangle . \\end{split} \\end{align} Then, each physical qubit used in \\eqref{eq:phase-flip} is further encoded in the three-qubit bit-flip correction code: \\begin{align} |\\pm _j \\rangle  = \\frac{1}{\\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\\rangle \\pm |1_{j0}1_{j1}1_{j2}\\rangle), \\end{align} each with bit-flip error parity check \\(Z_{j0}Z_{j1}I_{j2}\\) and  \\(Z_{j0}I_{j1}Z_{j2} \\), where \\(j=0,1,2\\). Notice now the phase-flip error parity check is extended as \\(X_j = X_{j0}X_{j1}X_{j2}\\). As a result, the overall parity checks with the flattened qubit index are \\begin{align} \\begin{split} Z_{j0}Z_{j1}I_{j2} &\\rightarrow \\{Z_0Z_1, Z_3Z_4, Z_6Z_7\\} \\\\ Z_{j0}I_{j1}Z_{j2} &\\rightarrow \\{Z_0Z_2, Z_3Z_5, Z_6Z_8\\} \\\\ X_0 X_1I_2  &\\rightarrow  \\{X_0X_1X_2X_3X_4X_5\\}\\\\ X_0 I_1X_2  &\\rightarrow  \\{X_0X_1X_2X_6X_7X_8\\}. \\end{split} \\end{align} The logical state is encoded using \\begin{align} \\begin{split} |\\overline{0}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right)^{\\otimes3}\\\\ |\\overline{1}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle-|111\\rangle\\right)^{\\otimes3} \\end{split} \\end{align}", "protection": "The code detects two-qubit errors or corrects an arbitrary single-qubit error.", "realizations": ["Realized in trapped-ion quantum devices, with 98.8(1)\\% and 98.5(1)\\% fidelity for state \\(|\\overline{0}\\rangle\\) and \\(|\\overline{1}\\rangle\\), respectively \\cite{arXiv:2104.01205}. "], "notes": ["Shor's code is the first known quantum error correction code. "], "relations": {"parents": [{"code_id": "quantum_parity", "detail": "Shor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes."}], "cousins": [{"code_id": "quantum_repetition", "detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code."}, {"code_id": "quantum_concatenated", "detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code."}, {"code_id": "surface", "detail": "Shor's code is the smallest surface code defined on the projective plane \\cite{arxiv:quant-ph/9810055}."}]}}, "quantum_parity": {"code_id": "quantum_parity", "physical": "qubits", "logical": "qubits", "name": "Quantum parity code (QPC)", "introduced": "\\cite{arxiv:quant-ph/0501184}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "css", "detail": ""}, {"code_id": "quantum_concatenated", "detail": "A QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code."}], "cousins": [{"code_id": "bacon_shor", "detail": ""}]}}, "quantum_repetition": {"code_id": "quantum_repetition", "physical": "qubits", "logical": "qubits", "name": "Qubit repetition code", "description": "Encodes \\(1\\) qubit into \\(n\\) qubits according to \\(|0\\rangle\\to|\\phi_0\\rangle^{\\otimes n}\\) and \\(|1\\rangle\\to|\\phi_1\\rangle^{\\otimes n}\\). Also known as a \\textit{bit-flip} code when \\(|\\phi_i\\rangle = |i\\rangle\\), and a \\textit{phase-flip} code when \\(|\\phi_0\\rangle = |+\\rangle\\) and \\(|\\phi_1\\rangle = |-\\rangle\\).", "protection": "Bit-flip code detects bit-flip errors \\(X\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any phase-flip errors \\(Z\\). Phase-flip code detects phase-flip errors \\(Z\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any bit-flip errors \\(X\\).", "notes": ["Logical basis for the bit-flip code is spanned by GHz (a.k.a. cat) states \\(|0\\rangle^{\\otimes n}\\pm|1\\rangle^{\\otimes n}\\), which are used in Shor error correction."], "realizations": ["Implemented on Sycamore processor by Google Quantum AI \\cite{arXiv:2102.06132} and earlier in other devices (see Table S6 in said paper)."], "relations": {"parents": [{"code_id": "css", "detail": ""}], "cousins": [{"code_id": "hamiltonian", "detail": "Bit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions."}]}}, "balanced_product": {"code_id": "balanced_product", "name": "Balanced-product code", "introduced": "\\cite{arxiv:2004.07935}", "description": "Stub.", "relations": {"cousins": [{"code_id": "fiber_bundle", "detail": "Some special cases of balanced product codes are fiber bundle codes \\cite{arXiv:2012.09271}."}]}}, "hypergraph_product": {"code_id": "hypergraph_product", "physical": "qubits", "logical": "qubits", "name": "Hypergraph product code", "introduced": "\\cite{arXiv:0903.0566,arxiv:1202.0928}", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two binary linear \\textit{seed} codes \\(C_1\\) and \\(C_2\\).", "protection": "The hypergraph product has distance \\(d=O(\\sqrt{n})\\). The number of encoded logical qubits is \\(k=O(k_1k_2)\\) where \\(k_1\\) and \\(k_2\\) are the dimensions of the classical seed codes \\(C_1\\) and \\(C_2\\).", "relations": {"parents": [{"code_id": "lifted_product", "detail": "Lifted-product codes for trivial group \\(G\\) are hypergraph-product codes."}, {"code_id": "homological_product", "detail": "Hypergraph product obtained from the homological product of two length-two chain complexes, i.e., classical binary codes."}]}}, "quantum_polar": {"code_id": "quantum_polar", "physical": "qubits", "logical": "qubits", "name": "Quantum polar code", "introduced": "\\cite{arxiv:1109.3195}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "css", "detail": ""}], "cousins": [{"code_id": "polar", "detail": ""}]}}, "quantum_ldpc": {"code_id": "quantum_ldpc", "physical": "qubits", "logical": "qubits", "name": "Quantum low-density parity-check (QLDPC) code", "description": "Family of \\([[n,k,d]]\\) stabilizer codes for which the number of qubits participating in each stabilizer generator and the number of stabilizer generators that each qubit participates in are both bounded by a constant as \\(n\\to\\infty\\).", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. Asymptotic scaling of \\(k\\) and \\(d\\) with \\(n\\) is often of interest, and this depends heavily on the code construction.\nA \\textit{good quantum LDPC code} family satisfies \\(k \\in \\theta(n) \\) and \\(d \\in \\theta(n)\\) \\cite{doi:10.1103/PRXQuantum.2.040101}, and the first examples of good codes are a family of \\hyperref[code:lifted_product]{lifted-product codes}.\nA \\textit{geometrically local LDPC code} is an LDPC code where the qubits involved in any syndrome bit are contained in a fixed volume that does not scale with \\(n\\); such codes are limited to having \\(d=O(n^{1-1/D})\\) for \\(D\\)-dimensional lattice geometries \\cite{arxiv:0810.1983}.", "features": {"threshold": ["Quantum LDPC codes with a constant encoding rate can reduce the overhead of fault-tolerant quantum computation to be constant \\cite{arXiv:1310.2984}."]}, "notes": ["Links to code tables \\cite{doi:10.1103/PRXQuantum.2.040101}."], "relations": {"parents": [{"code_id": "stabilizer", "detail": ""}], "cousins": [{"code_id": "ldpc", "detail": ""}, {"code_id": "hamiltonian", "detail": "Codespace is the ground-state space of a local \\textit{code Hamiltonian}, consisting of an equal linear combination of stabilizer generators."}, {"code_id": "dynamic_gen", "detail": "QLDPC codes can arise form a dynamical process \\cite{arxiv:2004.09560}."}]}}, "stab_15_1_3": {"code_id": "stab_15_1_3", "physical": "qubits", "logical": "qubits", "name": "\\([[15,1,3]]\\) Reed-Muller code", "description": " \\([[15,1,3]]\\) CSS code that is most easily thought of as a tetrahedral 3D color code. This code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center. The tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers. Each colored cell corresponds to a weight-8 \\(X\\)-check, and each face corresponds to a weight-4 \\(Z\\)-check. A logical \\(Z\\) is any weight-3 \\(Z\\)-string along an edge of the entire tetrahedron. The logical \\(X\\) is any weight-7 \\(X\\)-face of the entire tetrahedron. ", "features": {"rate": "Magic-state distillation scaling exponent \\( \\gamma= \\log_d (n/k)\\approx 2.46\\) \\cite{arXiv:1703.07847}.", "transversal_gates": "A transversal logical \\(T^\\dagger\\) is implemented by applying a \\(T\\) gate on every qubit \\cite{arXiv:quant-ph/9610011,arXiv:1403.2734,arXiv:1612.07330}.", "general_gates": ["Code is often used in magic-state distillation protocols because of its transversal \\(T\\) gate \\cite{arXiv:quant-ph/0403025}."], "fault_tolerance": ["Combining the Steane code and the 15-qubit Reed-Muller code through a fault-tolerant conversion can result in a universal transversal gate set that does not need magic state distillation \\cite{arXiv:1403.2734,arXiv:1703.03860}."]}, "notes": ["The \\([[15,1,3]]\\) code can be converted into the smallest known stabilizer code with a fault-tolerant logical \\(T\\) gate (i.e., the \\([[10,1,2]]\\) code) through a \"morphing procedure\" \\cite{arXiv:2112.01446}."], "relations": {"parents": [{"code_id": "quantum_reed_muller", "detail": "The \\([[15,1,3]]\\) code is often noted as the 15-qubit quantum Reed-Muller code in the literature."}]}}, "lifted_product": {"code_id": "lifted_product", "physical": "qubits", "logical": "qubits", "name": "Lifted product code", "introduced": "\\cite{arXiv:1904.02703}", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two linear \\textit{seed} codes \\(C_1\\) and \\(C_2\\) with a free action of a group \\(G\\). Lifted product codes can also be defined over arbitrary matrix rings.", "protection": "Code performance strongly depends on \\(G\\), but lifted product codes contain \\cite{arXiv:2111.03654} families of QLDPC codes with the parameters \\([[n, k = \\Theta(n), d = \\Theta(n)]]\\).", "features": {"rate": "Lifted product codes include the first examples \\cite{arXiv:2111.03654} of \\textit{good QLDPC codes}, i.e., codes with asymptotically constant rate and linear distance. The existence of such codes proves the QLDPC conjecture \\cite{arXiv:2103.06309}.", "decoders": ["BP-OSD decoder \\cite{arXiv:1904.02703}."]}, "relations": {"parents": [{"code_id": "homological_product", "detail": "Lifted product obtained from the homological product over a group algebra \\(\\mathbb{F}_2 G\\) of two length-two chain complexes over \\(\\mathbb{F}_2 G\\), i.e., classical binary codes with a free action of the group \\(G\\)."}]}}, "chuang-leung-yamamoto": {"code_id": "chuang-leung-yamamoto", "physical": "oscillators", "logical": "qubits", "name": "Chuang-Leung-Yamamoto code", "introduced": "\\cite{doi:10.1103/PhysRevA.56.1114}", "description": "Bosonic Fock-state code that encodes \\(k\\) qubits into \\(n\\) oscillators, with each oscillator restricted to having at most \\(N\\) excitations. Codewords are superpositions of oscillator Fock states, either balanced (i.e., uniform) or unbalanced. Codes can be denoted as \\([[N,n,2^k,d]]\\), which conflicts with \\hyperref[code:stabilizer]{stabilizer code} notation.", "protection": "Protects against amplitude damping for up to \\(t = d-1\\) excitation losses. Defining the \\textit{spacing} between two Fock states \\(|u_1\\cdots u_n\\rangle\\) and \\(|v_1\\cdots v_n\\rangle\\),\n\\begin{align}\n\\text{Spacing}(u,v) = \\frac{1}{2}\\sum_{i=1}^n |u_i - v_i|,\n\\end{align}\nthe code distance \\(d\\) can be defined as the minimial spacing between Fock states making up the codewords.\n", "features": {"rate": "Code rate is \\(\\frac{k}{n \\log_2(N+1)}\\). To correct the loss of up to \\(t\\) excitations with \\(K+1\\) codewords, a code exists with scaling \\(N \\sim t^3 K/2\\).", "encoders": ["Photon Fock state input into a network of beamsplitters, phase shifters, and Kerr media. These operations all preserve total photon number. Beamsplitters and phase shifters take annihilation operators to linear combinations of annihilation operators, and the transformation matrix is unitary. The operations corresponding to Kerr nonlinear media are diagonal in the Fock basis, but they implement phases that in general depend nonlinearly on the number of photons in each mode. State preparation may require ancillary modes and be conditioned on photon-number measurement results."], "decoders": ["Destructive decoding with a photon number measurement on each mode.", "State can be decoded with a network of beamsplitters, phase shifters, and Kerr media."]}, "relations": {"parents": [{"code_id": "fock_state", "detail": ""}]}}, "wasilewski-banaszek": {"code_id": "wasilewski-banaszek", "physical": "oscillators", "logical": "qubits", "name": "Wasilewski-Banaszek code", "introduced": "\\cite{doi:10.1103/PhysRevA.75.042316}", "description": "Three-oscillator Fock-state code encoding a single logical qubit using codewords \\begin{align} \\begin{split} |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{3}}(|003\\rangle+|030\\rangle+|300\\rangle)\\\\ |\\overline{1}\\rangle &= |111\\rangle \\end{split}. \\end{align}", "protection": "Protects against single photon loss in any one mode.", "features": {"encoders": ["A qubit in the dual-rail code can be transferred to this code via a linear optical network using four ancillary modes, each with one photon input. Successful encoding is conditioned on measuring the state \\(|110\\rangle\\) on the last three modes."], "general_gates": ["Single-qubit gates implemented using linear optical networks, sometimes with the addition of auxiliary modes with vacuum input and (conditional) output."], "decoders": ["Destructive measurement with photon number measurements on each mode."]}, "relations": {"parents": [{"code_id": "fock_state", "detail": ""}], "cousins": [{"code_id": "chuang-leung-yamamoto", "detail": ""}]}}, "hybrid_qudit_oscillator": {"code_id": "hybrid_qudit_oscillator", "physical": "qudits", "logical": "groups", "name": "Hybrid qudit-oscillator code", "description": "Encodes a \\(K\\)-dimensional logical Hilbert space into \\(n_1\\) qudits of dimension \\(q\\) and \\(n_2 \\neq 0\\) oscillators, i.e., the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{Z}_q^{n_1} \\times \\mathbb{R}^{n_2}\\).", "protection": "", "relations": {"parents": [{"code_id": "oscillators", "detail": "The physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator."}], "cousins": [{"code_id": "qudits_into_oscillators", "detail": "Hybrid code with \\(n_1=0\\)."}]}}, "cat": {"code_id": "cat", "physical": "oscillators", "logical": "qudits", "name": "Cat code", "introduced": "\\cite{arXiv:quant-ph/9809037,arXiv:1207.0679,arXiv:1312.2017}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "qudits_into_oscillators", "detail": ""}]}}, "gkp": {"code_id": "gkp", "physical": "oscillators", "logical": "qudits", "name": "Gottesman-Kitaev-Preskill (GKP) code", "introduced": "\\cite{arXiv:quant-ph/0008040}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "qudits_into_oscillators", "detail": ""}], "cousins": [{"code_id": "stabilizer", "detail": "Displacement operators can be thought of as analogues of Pauli operators for the oscillator."}]}}, "oscillators_into_oscillators": {"code_id": "oscillators_into_oscillators", "physical": "oscillators", "logical": "oscillators", "name": "Oscillator-into-oscillator code", "introduced": "\\cite{arXiv:quant-ph/9711021,arXiv:quant-ph/9711049}", "description": "Encodes Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}^k\\) into that on \\(\\mathbb{R}^n\\). Usually denoted as \\(((n,k))_{\\mathbb{R}}\\).", "protection": "", "relations": {"parents": [{"code_id": "oscillators", "detail": "Bosonic code with infinite-dimensional logical subspace."}]}}, "fock_state": {"code_id": "fock_state", "physical": "oscillators", "logical": "qudits", "name": "Fock-state bosonic code", "description": "Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. For example, single-mode Fock-state codes include any qubit codes whose basis states are, respectively, supported on Fock state sets \\(\\{|0\\rangle,|4\\rangle,|8\\rangle,\\cdots\\}\\) and \\(\\{|2\\rangle,|6\\rangle,|10\\rangle,\\cdots\\}\\).", "protection": "Code distance \\(d\\) is the minimum distance (assuming some metric) between any two labels of Fock states corresponding to different code basis states. For a single mode, \\(d\\) is the minimum absolute value of the difference between any two Fock-state labels; such codes can detect up to \\(d-1\\) loss events. Multimode distances can be defined analogously; see, e.g., \\hyperref[code:chuang-leung-yamamoto]{Chuang-Leung-Yamamoto codes}.", "relations": {"parents": [{"code_id": "qudits_into_oscillators", "detail": ""}], "cousins": [{"code_id": "binary_linear", "detail": "Fock-state code distance is a natural extension of Hamming distance between binary strings."}, {"code_id": "qubits_into_qubits", "detail": "Fock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli opeartors for the constituent qubits can be expressed in terms of bosonic raising and lowering operators \\cite{manual:{Victor V. Albert, private communication, 2016}}. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations \\cite{arxiv:2111.08894}."}]}}, "oscillators": {"code_id": "oscillators", "physical": "oscillators", "name": "Bosonic code", "description": "Also called an \\textit{oscillator} or a \\textit{continuous-variable (CV)} code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one \\textit{oscillator} or \\textit{mode} (i.e., one copy of the space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}\\)). Ideal codewords may not be normalizable, so approximate versions have to be constructed.", "protection": "", "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "qudits_into_oscillators": {"code_id": "qudits_into_oscillators", "physical": "oscillators", "logical": "qudits", "name": "Qudit-into-oscillator code", "description": "Encodes \\(K\\)-dimensional Hilbert space into Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}^n\\).", "protection": "", "relations": {"parents": [{"code_id": "oscillators", "detail": "Bosonic code with finite-dimensional logical subspace."}]}}, "very-small-logical-qubit": {"code_id": "very-small-logical-qubit", "physical": "groups", "logical": "qubits", "name": "Very small logical qubit (VSLQ) code", "introduced": "\\cite{doi:10.1103/PhysRevLett.116.150501}", "description": "The two logical codewords are \\(|\\pm\\rangle \\propto (|0\\rangle\\pm|2\\rangle)(|0\\rangle\\pm|2\\rangle)|0\\rangle|0\\rangle\\), where the total Hilbert space is the tensor product of two qudits (whose ground states \\(|0\\rangle\\) and second excited states \\(|2\\rangle\\) are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.", "protection": "Passively protects against single photon loss.", "features": {"encoders": ["Engineering a circuit made of two transmons and two oscillators coupled through three driven superconducting quantum interference devices (SQUIDs) results in passive stabilization of the logical states."], "general_gates": ["Single logical qubit operations implemented by resonant physical qubit driving and phase shifting the SQUID drives.", "A CZ gate between two logical qubits implemented by coupling devices through another driven SQUID and applying a pulse to the coupling squid simultaneously with a single qubit operation on one of the logical qubits."], "decoders": ["Logical qubit can be measured with physical qubit measurements along \\(X\\). Can be implemented by engineering a coupling of one of the qubits to a readout cavity via the interaction \\(\\sigma_x (a+a^\\dagger)\\) \\cite{doi:10.1103/PhysRevLett.115.203601}. This results in an \\(X\\)-dependent shift of the readout cavity resonance which can be measured."]}, "relations": {"parents": [{"code_id": "hybrid_qudit_oscillator", "detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators."}], "cousins": [{"code_id": "quantum_repetition", "detail": "Parts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss."}]}}, "group_quantum": {"code_id": "group_quantum", "physical": "groups", "logical": "groups", "name": "Group quantum code", "description": "Encodes a \\textit{logical} Hilbert space, finite- or infinite-dimensional, into a \\textit{physical} Hilbert space of \\(\\ell^2\\)-normalizable functions on a second-countable unimodular group. For \\(K\\)-dimensional logical subspace and for groups \\(G^{\\times n}\\), can be denoted as \\(((n,K))_G\\). When the logical subspace is the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(G^{\\times k}\\), can be denoted as \\([[n,k]]_G\\). Ideal codewords may not be normalizable, depending on whether \\(G\\) is continuous and/or noncompact, so approximate versions have to be constructed.", "protection": "", "relations": {"parents": [{"code_id": "qecc", "detail": ""}], "cousins": [{"code_id": "qecc_finite", "detail": "Group quantum codes whose physical spaces are constructed using finite groups are finite-dimensional."}, {"code_id": "qudits_into_qudits", "detail": "Group quantum codes whose physical spaces are constructed using modular-integer groups are \\(\\mathbb{Z}_q\\)-qudit codes."}, {"code_id": "oscillators", "detail": "Group quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes."}]}}, "molecular": {"code_id": "molecular", "physical": "groups", "logical": "rigid_bodies", "name": "Molecular code", "introduced": "\\cite{arXiv:1911.00099}", "description": "Encodes finite-dimensional Hilbert space into the Hilbert space of \\(\\ell^2\\)-normalizable functions on the group \\(SO_3\\). Construction is based on nested subgroups \\(H\\subset K \\subset SO_3\\), where \\(H,K\\) are finite. The \\(|K|/|H|\\)-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\).", "protection": "Protects against generalized bit-flip errors \\(g\\in SO_3\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "notes": ["Physical space characterizes orientations of a rigid body in 3D, which correspond to rotational states of an asymmetric molecule."], "relations": {"parents": [{"code_id": "group_gkp", "detail": ""}]}}, "group_gkp": {"code_id": "group_gkp", "physical": "groups", "logical": "groups", "name": "Group GKP code", "introduced": "\\cite{arXiv:1911.00099}", "description": "Group code whose construction is based on nested subgroups \\(H\\subset K \\subset G\\). Logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\), and can be finite- or infinite-dimensional. Extension of the \\hyperref[code:gkp]{GKP code} construction.", "protection": "Protects against generalized bit-flip errors \\(g\\in G\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "relations": {"parents": [{"code_id": "group_quantum", "detail": ""}], "cousins": [{"code_id": "oscillators_into_oscillators", "detail": "For logical and physical spaces based on the real line \\(\\mathbb{R}\\)."}, {"code_id": "css", "detail": "For an \\(n\\)-qubit CSS code, the nested group construction \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{\\times n}\\)."}, {"code_id": "gkp", "detail": "For a single-mode qubit GKP code, the nested group construction is \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\)."}]}}, "qudit_stabilizer": {"code_id": "qudit_stabilizer", "physical": "qudits", "logical": "qudits", "name": "\\(\\mathbb{Z}_q\\)-qudit stabilizer code", "description": "An \\(((n,p^k,d))_q\\) (with \\(q\\) not necessarily prime) stabilizer code is denoted as \\([[n,k]]_q\\) or \\([[n,k,d]]_q\\), where \\(d\\) is the code's distance. Stub.", "protection": "", "relations": {"parents": [{"code_id": "qudits_into_qudits", "detail": ""}]}}, "polynomial": {"code_id": "polynomial", "physical": "qudits", "logical": "qudits", "name": "\\(\\mathbb{Z}_p\\)-qudit polynomial code", "introduced": "\\cite{arxiv:quant-ph/9906129,arxiv:quant-ph/9910059}", "description": "Also called \\textit{quantum Reed-Solomon code}. Stub.", "protection": "", "relations": {"parents": [{"code_id": "qudit_css", "detail": ""}]}}, "prime_qudit_stabilizer": {"code_id": "prime_qudit_stabilizer", "physical": "qudits", "logical": "qudits", "name": "\\(\\mathbb{Z}_p\\)-qudit stabilizer code", "introduced": "\\cite{arXiv:quant-ph/9705052}", "description": "An \\(((n,p^k,d))_p\\) (with \\(p\\) prime) stabilizer code is denoted as \\([[n,k]]_p\\) or \\([[n,k,d]]_p\\), where \\(d\\) is the code's distance. Logical subspace is the joint \\(+1\\) eigenspace of a set of \\(p^{n-k}\\) commuting qudit Pauli operators forming the code's stabilizer group, which cannot contain \\(-I\\). The distance is the minimum weight of an error that implements a nontrivial logical operation on the code.", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.  More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a generalized Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{\\hat{N}(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "relations": {"parents": [{"code_id": "qudit_stabilizer", "detail": ""}, {"code_id": "galois_stabilizer", "detail": "A prime-qudit stabilizer code is a Galois-qudit stabilizer code with \\(m=1\\)."}]}}, "qudits_into_qudits": {"code_id": "qudits_into_qudits", "physical": "qudits", "logical": "qudits", "name": "\\(\\mathbb{Z}_q\\)-qudit code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the group \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\). Usually denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined, and with \\(q=p\\) when the dimension is prime.", "relations": {"parents": [{"code_id": "qecc_finite", "detail": ""}]}}, "qudit_css": {"code_id": "qudit_css", "physical": "qubits", "logical": "qubits", "name": "\\(\\mathbb{Z}_q\\)-qudit CSS code", "description": "Often, but not always, defined for prime qudits (\\(q=p\\)). Stub.", "relations": {"parents": [{"code_id": "qudit_stabilizer", "detail": ""}], "cousins": [{"code_id": "css", "detail": "Extension of CSS codes to modular-integer qudits."}]}}, "galois_stabilizer": {"code_id": "galois_stabilizer", "physical": "galois", "logical": "galois", "name": "Galois-qudit stabilizer code", "introduced": "\\cite{arXiv:quant-ph/0005008}", "description": "An \\(((n,p^k,d))_{GF(q)}\\) stabilizer code is denoted as \\([[n,k]]_{GF(q)}\\) or \\([[n,k,d]]_{GF(q)}\\), where \\(d\\) is the code's distance. Stub.", "relations": {"parents": [{"code_id": "galois_into_galois", "detail": ""}]}}, "galois_into_galois": {"code_id": "galois_into_galois", "physical": "galois", "logical": "galois", "name": "Galois-qudit code", "introduced": "\\cite{doi:10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T}", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the \\textit{Galois field} \\(GF(q)\\) and with \\(q\\) being a power of a prime \\(p\\). A Galois field can be thought of as a vector space whose basis vectors are the \\(m\\) roots of some polynomial and whose coefficients (i.e., field) are \\(p\\)th roots of unity. Codes can be denoted as \\(((n,K))_{GF(q)}\\) or \\(((n,K,d))_{GF(q)}\\), whenever the code's distance \\(d\\) is defined.", "notes": ["Introduction to Galois qudits by \\href{https://ethz.ch/content/vp/en/conferences/2014/qec/05_thursday/dab6ca18-7453-4197-aaaa-8b1964ece714.html}{Gottesman}."], "relations": {"parents": [{"code_id": "qecc_finite", "detail": ""}], "cousins": [{"code_id": "qudits_into_qudits", "detail": "A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) \\(\\mathbb{Z}_q\\)-qudits. The two coincide when \\(q\\) is prime. However, Pauli matrices for the two types of qudits are defined differently."}]}}, "galois_css": {"code_id": "galois_css", "physical": "galois", "logical": "galois", "name": "Galois-qudit CSS code", "description": "Stub.", "relations": {"parents": [{"code_id": "galois_stabilizer", "detail": ""}], "cousins": [{"code_id": "css", "detail": "Extension of qubit CSS codes to Galois qudits."}, {"code_id": "qudit_css", "detail": ""}]}}, "galois_polynomial": {"code_id": "galois_polynomial", "physical": "galois", "logical": "galois", "name": "Galois-qudit polynomial code", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "galois_css", "detail": ""}]}}, "distance_balanced": {"code_id": "distance_balanced", "name": "Distance-balanced code", "introduced": "\\cite{arxiv:1611.03790,arxiv:2004.07935}", "description": "CSS stabilizer code constructed from another CSS code using a distance-balancing procedure.", "relations": {"parents": [{"code_id": "css", "detail": ""}, {"code_id": "quantum_ldpc", "detail": "Distance-balancing procedure can yield QLDPC codes; see Thm. 1 in Ref. \\cite{arxiv:1611.03790}."}], "cousins": [{"code_id": "balanced_product", "detail": "According to \\cite{arXiv:2012.09271}, distance balancing is used to form balanced-product subsystem codes."}, {"code_id": "quantum_ldpc", "detail": "Distance-balancing procedure can yield QLDPC codes; see Thm. 1 in Ref. \\cite{arxiv:1611.03790}."}, {"code_id": "gauge_stabilizer", "detail": ""}]}}, "dynamic_gen": {"code_id": "dynamic_gen", "name": "Dynamically-generated quantum error-correcting code", "introduced": "\\cite{arXiv:0708.4025}", "description": "Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process.", "protection": "", "relations": {"parents": [{"code_id": "oecc", "detail": ""}]}}, "quantum_concatenated": {"code_id": "quantum_concatenated", "name": "Concatened code", "description": "A concatened code is a combination of two codes, an inner code \\(C\\) and an outer code \\(C^\\prime\\), where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code \\(C^\\prime\\), and then one encodes each of the physical registers of \\(C^\\prime\\) in an inner code \\(C\\).", "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "quantum_cyclic": {"code_id": "quantum_cyclic", "name": "Cyclic quantum code", "introduced": "\\cite{arxiv:1007.1697}", "description": "An code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits) is cyclic if a cyclic permutation of the subsystems leaves the code subspace invariant.", "protection": "", "notes": [""], "relations": {"parents": [{"code_id": "qecc"}], "cousins": [{"code_id": "cyclic"}]}}, "topological": {"code_id": "topological", "name": "Topological code", "description": "Stub.", "relations": {"parents": [{"code_id": "hamiltonian", "detail": "Codespace is either the ground-state or low-energy subspace of a geometrically local Hamiltonian admitting a topological phase."}], "cousins": [{"code_id": "quantum_ldpc", "detail": "Stabilizer-based topological codes (e.g., the surface code) on appropriate tesselations are QLDPC."}]}}, "random_circuit": {"code_id": "random_circuit", "name": "Random-circuit code", "description": "Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.", "protection": "", "relations": {"parents": [{"code_id": "dynamic_gen", "detail": ""}]}}, "approximate_qecc": {"code_id": "approximate_qecc", "name": "Approximate QECC", "introduced": "\\cite{arXiv:quant-ph/0503139,arXiv:quant-ph/0307138,arXiv:0907.5391}", "description": "Stub.", "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "fracton": {"code_id": "fracton", "name": "Fracton code", "description": "A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.", "protection": "", "relations": {"parents": [{"code_id": "hamiltonian", "detail": "Codespace is the ground-state subspace of a geometrically local Hamiltonian admitting a fracton phase."}], "cousins": [{"code_id": "topological", "detail": ""}]}}, "hamiltonian": {"code_id": "hamiltonian", "name": "Hamiltonian-based code", "description": "Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy. When the physical space is a tensor product of subsystems, the Hamiltonian is typically \\textit{local}, consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., \\hyperref[code:quantum_ldpc]{quantum LDPC codes}). When the physical space is endowed with a geometry, the Hamiltonian is typically \\textit{geometrically local}, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., \\hyperref[code:topological]{topological codes}).", "protection": "Typically determined from the underlying physical properties of the Hamiltonian.", "features": {"encoders": ["Lindbladian-based dissipative encoding can be constructed for a codespace that is the ground-state subspace of a frustration-free Hamiltonian \\cite{arXiv:0809.0613,arXiv:1112.4860,arxiv:0803.1447,arxiv:1802.00010}."]}, "relations": {"parents": [{"code_id": "oecc", "detail": ""}]}}, "quantum_perfect": {"code_id": "quantum_perfect", "name": "Perfect quantum code", "description": "A non-degenerate code constructed out of \\(q\\)-dimensional qudits and having parameters \\(((n,K,2t+1))\\) is perfect if \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the quantum Hamming bound\n\\begin{align}\n\\sum_{j=0}^{t}(q^2-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a qubit \\(q=2\\) code with one logical qubit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(3n+1 \\leq 2^{n-1}\\). The bound can be saturated only at certain \\(n\\).\n\nFor qubit codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-\\frac{t}{n}\\log_{2}3-H(t/n),\n\\end{align}\nwhere \\(H\\) is the binary entropy function.\n", "protection": "Perfect codes have been classified. For qubits (\\(q=2\\)), the only codes are the stabilizer code family \\([[(4^r-1)/3, (4^r-1)/3 - 2r, 3]]\\) for \\(r \\geq 2\\) \\cite{arxiv:quant-ph/9607027,arxiv:quant-ph/9608006}. For qudits, the family is parameterized by \\(K=q^{n-2r}\\) for \\(n=\\frac{q^{2r}-1}{q^{2}-1}\\) and \\(r \\geq 2\\); all codes correct a single error (\\(t=1\\)) \\cite{arxiv:0907.0049,doi:10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T}. The trivial code (\\(k=n\\)) is also perfect.", "features": {"rate": "\\(k/n\\to 1\\) asymptotically with \\(n\\)."}, "relations": {"parents": [{"code_id": "qudits_into_qudits", "detail": ""}], "cousins": [{"code_id": "perfect", "detail": "A classical (quantum) perfect code saturates the classical (quantum) Hamming bound."}]}}, "fermions": {"code_id": "fermions", "physical": "fermions", "logical": "fermions", "name": "Fermionic code", "description": "Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators \\cite{arXiv:quant-ph/0003137}.", "protection": "", "relations": {"parents": [{"code_id": "qecc_finite", "detail": ""}], "cousins": [{"code_id": "qubits_into_qubits", "detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation \\cite{arXiv:cond-mat/0010440}, codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations."}, {"code_id": "oscillators", "detail": "Bosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom."}]}}, "majorana_stab": {"code_id": "majorana_stab", "physical": "fermions", "logical": "fermions", "name": "Majorana stabilizer code", "introduced": "\\cite{arXiv:1004.3791}", "description": "Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as \\textit{Majorana stabilizers}. The codespace is the mutual \\(+1\\) eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as \\([[n,k,d]]_{f}\\) \\cite{arXiv:1703.00459}, where \\(n\\) is the number of fermionic modes.", "protection": "Detects products of Majorana operators with weight up to \\(d-1\\). Physically, protects against dephasing errors caused by coupling of fermion density to the environment and bit-flip errors caused by quasiparticle poisoning processes.", "relations": {"parents": [{"code_id": "fermions", "detail": ""}, {"code_id": "stabilizer", "detail": "The Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code \\cite{arXiv:cond-mat/0506438,arXiv:1004.3791}. However, Pauli- and Majorana-based stabilizer codes have different notions of locality \\cite{arXiv:cond-mat/0010440} and are thus useful for different physical platforms."}], "cousins": [{"code_id": "weakly_self_dual", "detail": "Classical weakly self-dual codes can be used to construct Majorana stabilizer codes \\cite{arXiv:1703.00459}. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a weakly self-dual classical code. A weakly self-dual classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\)."}, {"code_id": "css", "detail": "When constructing a Majorana stabilizer code from a weakly self-dual classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space \\cite{arXiv:1004.3791,arXiv:1703.00459}. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different weakly self-dual classical codes with an odd number of bits, as is often done in the CSS construction."}, {"code_id": "cyclic", "detail": "Cyclic codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also weakly self-dual \\cite{arXiv:1703.00459}."}, {"code_id": "reed_muller", "detail": "Majorana stabilizer codes can be constructed by weakly self-dual Reed-Muller codes \\cite{arXiv:1703.00459}. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code."}]}}}