{"oaecc": {"code_id": "oaecc", "name": "Operator-algebra error-correcting code", "introduced": "\\cite{arXiv:quant-ph/0203105,arXiv:0705.1574}", "description": "Stub.", "protection": ""}, "ecc": {"code_id": "ecc", "name": "Error-correcting code", "description": "Encodes \\(K\\) states (codewords) over an alphabet with \\(N\\) elements such that it is possible to recover the codewords from errors \\(E\\) from some error set \\(\\mathcal{E}\\). Formally, an error-correcting code \\((u,\\mathcal{E})\\) is an \\textit{encoder} function \\(u:[1\\cdots K]\\to[1\\cdots N]\\) with a set of correctable errors \\(E:[1\\cdots N]\\to [1\\cdots M]\\) with the following property: there exists a \\textit{decoder} function \\(d:[1\\cdots M]\\to [1\\cdots K]\\) such that for all \\(E\\in\\cal{E}\\) and states \\(x\\in[1\\cdots K]\\), \\(d(E(e(x)))=x\\).", "protection": "", "relations": {"parents": [{"code_id": "oaecc", "detail": ""}]}}, "cyclic": {"code_id": "cyclic", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Cyclic code", "description": "A classical code \\(C\\) of length \\(n\\) over an alphabet is cyclic if, for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\in C\\).", "protection": "", "notes": [""], "relations": {"parents": [{"code_id": "skew_cyclic"}]}}, "q-ary_digits_into_q-ary_digits": {"code_id": "q-ary_digits_into_q-ary_digits", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "\\(q\\)-ary code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) \\(q\\)-ary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)_q\\). The distance is the minimum number of coordinates where two strings in the code differ.", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "relations": {"parents": [{"code_id": "ecc", "detail": ""}]}}, "q-ary_linear": {"code_id": "q-ary_linear", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "\\(q\\)-ary linear code", "description": "An \\((n,K,d)_q\\) linear code is denoted as \\([n,k,d]_q\\), where \\(k=\\log_{q}K\\) need not be an integer. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any \\(q\\)-ary digits \\(\\alpha,\\beta\\). Often defined in terms of a generator matrix \\(G\\), whose rows form a basis for the subspace. Given a codeword \\(x\\), the corresponding encoded codeword is \\(G^T x\\).", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set such that the difference of any pair of distinct elements of the set is a codeword.", "notes": ["Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\)."], "relations": {"parents": [{"code_id": "q-ary_digits_into_q-ary_digits", "detail": ""}]}}, "dual": {"code_id": "dual", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Dual linear code", "introduced": "\\cite{doi:10.1201/9781315147901}", "description": "For any \\(q\\)-ary linear code \\(C\\), the dual code\n\\begin{align}\nC^\\perp = \\{ y\\in\\mathbb{Z}_q^{\\times n} ~|~ x\\cdot y=0 \\forall x\\in C\\}~.\n\\end{align}\n\nA code that contains its dual, \\(C^\\perp \\subseteq C\\), is called \\textit{weakly self-dual} or \\textit{self-orthogonal}. A code that is equal to its dual, \\(C^\\perp = C\\), is called \\textit{self-dual}. The dual of a dual code is the original code.\n", "protection": "The dual of an \\([n,k,d] \\) code is an \\([n,n-k,d']\\) code, where \\(d'\\) is not always related to \\(d\\). The generator matrix of \\(C^\\perp\\) is the parity check matrix of \\(C\\), and visa versa.", "relations": {"parents": [{"code_id": "q-ary_linear", "detail": ""}]}}, "perfect": {"code_id": "perfect", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Perfect code", "description": "An \\((n,K,2t+1)_q\\) \\(q\\)-ary code is perfect if parameters \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the Hamming (a.k.a. sphere-packing) bound\n\\begin{align}\n\\sum_{j=0}^{t}(q-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a binary \\(q=2\\) code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\).\n\nFor binary codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-H(t/n),\n\\end{align}\nwhere \\(H\\) is the binary entropy function.\n", "notes": [""], "relations": {"parents": [{"code_id": "q-ary_digits_into_q-ary_digits", "detail": ""}]}}, "skew_cyclic": {"code_id": "skew_cyclic", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Skew-cyclic code", "introduced": "\\cite{arXiv:math/0604603}", "description": "A classical code \\(C\\) of length \\(n\\) over \\(GF(q)\\) is skew-cyclic if there exists an automorphism, \\(\\theta\\), of \\(GF(q)\\), such that for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the skew-cyclically shifted string \\(\\theta(c_n) \\theta(c_1) \\cdots \\theta(c_{n-1})\\in C\\). We say that \\(C\\) is a \\(\\theta\\)-cyclic code over \\(GF(q)\\).", "features": {"decoders": ["Only given for skew-BCH codes, adapted froom standard BCH codes."]}, "realizations": ["Not directly implemented, but BCH codes form a subclass, and are used in DVD, solid state drive storage, etc."], "notes": ["Computer algebra software is used to find most codes of this type. Ref. \\cite{arXiv:math/0604603} gives several examples of codes, which have slightly improved minimum distance for some \\((n,k)\\) codes."], "relations": {"parents": [{"code_id": "quasi_cyclic", "detail": "For every skew-cyclic code there is an equivalent quasi-cyclic code \\cite{doi:10.1504/IJICOT.2011.044674}."}], "cousins": [{"code_id": "bch"}]}}, "gabidulin": {"code_id": "gabidulin", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Rank code", "introduced": "\\cite{manual:{E. M. Gabidulin, \"Theory of Codes with Maximum Rank Distance\", Problemy Peredachi Informacii, Volume 21, Issue 1, \\emph{3\u201316} (1985)},doi:10.1109/18.75248}", "description": "Also called \\textit{Gabidulin} or \\textit{(matrix) rank-metric code}. The code corrects errors over rank metric instead of the traditional Hamming distance. The rank of an \\(n\\)-dimensional vector over \\(GF(q^N)\\) is the maximum number of its linearly independent coordinates.\n\nGiven \\(X^n\\), an \\(n\\)-dimensional vector space over \\(GF(q^N)\\) where \\(q\\) is a power of a prime number, the \\textit{rank metric} \\(d(x, y)\\) is defined via the rank norm \\(r(x, q) = \\mathrm{rank}(A(x))\\), where\n\\begin{align}\nA(x) = \\begin{pmatrix} a_{11} & a_{12} & \\ldots & a_{1n} \\\\ a_{21} & a_{22} & \\ldots & a_{2n} \\\\  a_{N1} & a_{N2} & \\ldots & a_{Nn} \\end{pmatrix}\n\\end{align}\nand \\(x_i = a_{1i} u_1 + a_{2i} u_2 + \\ldots + a_{Ni}u_N \\) for some fixed basis \\(\\{u_i\\}_{i=1}^N\\).\n\nIf the vector set \\(\\{x_1, x_2, \\ldots, x_M\\}\\) defines a \\(k\\)-dimensional subspace, then the code is \\([n,k]\\)-linear.\n", "protection": "Set of vectors \\(\\{x_1, x_2, \\ldots, x_M\\}\\) determines a rank code with distance \\(d=\\min d(x_i, x_j)\\). The code with distance \\(d\\) corrects all errors with rank of the error not greater than \\(\\lfloor (d-1)/2\\rfloor\\).", "realizations": ["Useful for error and erasure correction in network coding"], "relations": {"parents": [{"code_id": "q-ary_digits_into_q-ary_digits", "detail": ""}]}}, "quasi_cyclic": {"code_id": "quasi_cyclic", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Quasi-cyclic code", "introduced": "\\cite{doi:10.1109/TIT.1967.1053974}", "description": "Stub.", "relations": {"parents": [{"code_id": "q-ary_linear"}]}}, "alternant": {"code_id": "alternant", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Alternant Codes", "introduced": "\\cite{doi:10.1016/S0019-9958(74)80005-7}", "description": "Stub.", "relations": {"parents": [{"code_id": "q-ary_linear", "detail": ""}], "cousins": [{"code_id": "reed_solomon", "detail": ""}]}}, "goppa": {"code_id": "goppa", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Goppa Code", "introduced": "\\cite{manual:{V. D. Goppa, \"A new class of linear error-correcting codes\", Probl. Peredach. Inform., vol. 6, no. 3, pp. 24-30, Sept. 1970.},manual:{V. D. Goppa, \"Rational representation of codes and (Lg) codes\", Probl. Peredach. Inform., vol. 7, no. 3, pp. 41-49, Sept. 1971.},doi:10.1109/TIT.1973.1055088}", "description": "Let \\( G(z) \\)  be a polynomial describing a projective plane curve with coefficients from \\( GF(q^m) \\) for some fixed integer \\(m\\). Let \\( L \\) be a finite subset of the extension field \\( GF(q^m) \\)  where \\(q\\) is prime, meaning \\( L  = \\{\\alpha_1, \\cdots, \\alpha_n\\} \\) is a subset of nonzero elements of \\( GF(q^m) \\). A Goppa code \\( \\Gamma(L,G) \\) is an \\([n,k,d]\\) linear code consisting of all vectors \\(a = a_1, \\cdots, a_n\\) such that \\( R_a(z) =0 \\) modulo \\(G(z)\\), where \\( R_a(z) = \\sum_{i=1}^n \\frac{a_i}{z - \\alpha_i} \\).", "protection": "The length \\( n = |L| \\) , dimension \\( k \\geq n-mr \\) where \\( r = \\text{deg} G(z) \\), and the minimum distance \\( d \\geq r +1 \\).", "features": {"rate": "There exist Goppa codes defined over larger alphabets that meet the Gilbert-Varshamov, or GV,  bound.", "decoders": ["Algebraic decoding algorithms \\cite{doi:10.1109/TIT.1975.1055350}.", "If \\( \\text{deg} G(z) = 2t \\) , then there exists a \\(t\\)-correcting algebraic decoding algorithm for \\( \\Gamma(L,G) \\)."]}, "realizations": ["The binary version \\( (q=2) \\) is commonly used in post-quantum cryptosystems such as the McElise cryptosystem \\cite{doi:10.1007/BF00173300}."], "notes": ["GAP function \\href{https://www.gap-system.org/Manuals/pkg/guava/doc/chap5.html#X7EE808BB7D1E487A}{GoppaCode(G,L)} takes in a polynomial \\(G\\) that satisfies the necessary conditions for a Goppa code and a list \\(L\\) that contains elements in \\(GF(q)\\) that are not roots of \\(G\\). It returns a Goppa code."], "relations": {"parents": [{"code_id": "alternant", "detail": ""}]}}, "maximum_rank_distance": {"code_id": "maximum_rank_distance", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Maximum-rank code", "introduced": "\\cite{manual:{E. M. Gabidulin, \"Theory of Codes with Maximum Rank Distance\", Problemy Peredachi Informacii, Volume 21, Issue 1, \\emph{3\u201316} (1985)},doi:10.1109/18.75248}", "description": "Linear rank-metric code with maximum rank \\([n,k,n-k+1]_q\\) over rank metric. For any vector \\(g=(g_1, \\ldots, g_n)\\) with linearly independent elements \\(g_i\\) over \\(GF(q)\\),\nthe generator matrix\n\\begin{align}\nG = \\begin{pmatrix} g_1^{[0]} & g_2^{[0]} & \\ldots & g_n^{[0]} \\\\ g_1^{[1]} & g_2^{[1]} & \\ldots & g_n^{[1]} \\\\ g_1^{[k-1]} & g_2^{[k-1]} & \\ldots & g_n^{[k-1]} \\end{pmatrix}~,\n\\end{align}\nwhere \\([i]:=q^i\\) and \\(k=n-d+1\\) defines a maximum rank distance code.\n", "protection": "\\(d\\)-distance codes protect agains all errors of rank not greater \\(\\lfloor (d-1)/2\\rfloor\\)", "relations": {"parents": [{"code_id": "gabidulin", "detail": "Linear rank codes with maximum rank."}], "cousins": [{"code_id": "reed_solomon", "detail": "The construction of the generators matrix of both codes uses a Vandermonde matrix."}]}}, "mds": {"code_id": "mds", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Maximum distance separable (MDS) code", "introduced": "\\cite{doi:10.1109/TIT.1964.1053661}", "description": "A \\([n,k,d]_q\\) \\(q\\)-ary linear code is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Singleton bound\n\\begin{align}\nd \\leq n-k+1\n\\end{align}\nbecomes an equality. A bound for general \\(q\\)-ary codes can also be formulated; see Thm. 1.9.10 in Ref. \\cite{doi:10.1201/9781315147901}.\n", "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error correction properties.", "notes": ["The dual of an MDS codes is always MDS.", "The codes \\( [[n,1,n]]_q, [[n,n-1,2]]_q, [[n,n,1]]_q \\) for any \\(q\\) are MDS codes. These are called the \\textit{trivial} MDS codes.", "The only binary MDS codes are the trivial ones."], "relations": {"parents": [{"code_id": "q-ary_linear", "detail": ""}], "cousins": [{"code_id": "reed_solomon", "detail": "Every Reed Solomon code is MDS. If \\(k \\leq p\\) then all MDS codes \\( [n,k,n-k+1]_{p^m} \\) are Reed-Solomon codes \\cite{doi:10.4171/JEMS/316}."}]}}, "reed_solomon": {"code_id": "reed_solomon", "physical": "q-ary_digits", "logical": "q-ary_digits", "name": "Reed-Solomon code", "introduced": "\\cite{doi:10.1137/0108018}", "description": "\\([n,k,n-k+1]_q\\) linear code based on polynomials over \\(GF(q)\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(GF(q)\\) for prime \\(q>n\\). Encodes \\(\\mu=\\{\\mu_0,\\cdots,\\mu_{k-1}\\}\\) into \\(\\{f_\\mu(\\alpha_1),\\cdots,f_\\mu(\\alpha_n)\\}\\) with polynomial \\(f_\\mu(x)=\\mu_0+\\mu_1 x + \\cdots + \\mu_{k-1}x^{k-1}\\).", "protection": "Corrects erasures on \\(n-k\\) coordinates.", "realizations": ["Numerous applications: computer hard-disks, DVDs, 3G telephone networks (IS-2000, Release D), NASA deep-space exploration, etc."], "relations": {"parents": [{"code_id": "q-ary_linear", "detail": ""}]}}, "classical_abelian_group": {"code_id": "classical_abelian_group", "name": "Classical Abelian group Code", "description": "Stub.", "protection": ""}, "generalized_concatenated": {"code_id": "generalized_concatenated", "name": "Generalized concatenated classical code", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "ecc", "detail": ""}]}}, "convolutional": {"code_id": "convolutional", "physical": "bits", "logical": "bits", "name": "Convolutional code", "introduced": "\\cite{manual:{Peter Elias. Coding for noisy channels. IRE Convention Records, 3(4):37\u201346, 1955.}}", "description": "Classical codes that are formed using generator polynomials over the finite field with two elements. The encoder slides across contiguous subsets of the input bit-string (like a convolutional neural network) evaluating the polynomials on that window to obtain a number of parity bits. These parity bits are the encoded information. There are many ways to formulate these codes", "features": {"rate": "Depends on the polynomials used. Using puncturing removal \\cite{doi:10.12928/telkomnika.v10i4.171} the rate for the code can be increased from \\(\\frac{1}{t}\\) to \\(\\frac{s}{t}\\), where \\(t\\) is the number of output bits, and \\(s\\) depends on the puncturing done. This is done by deleting some pieces of the encoder output such that the most-likely decoders remain effective", "encoders": ["Evaluation on the generator polynomials. Can be implemented with a small number of XOR gates"], "decoders": ["Decoders based on the Viterbi algorithm (trellis decoding) were developed first, which result in the most-likely codeword for the encoded bits \\cite{doi:10.1109/TIT.1967.1054010}. Following, other trellis decoders such as the BCJR decoding algorithm \\cite{doi:10.1109/TIT.1974.1055186} were developed later."]}, "realizations": ["A type of convolutional code used in Real-time Applcation networks \\cite{doi:10.5815/ijcnis.2014.07.03}.", "Mobile and radio communications (3G networks) use convolutional codes concatenated with Reed-Solomon codes to obtain suitable performance \\cite{doi:10.1002/0470866969}.", "A convolutional code with rate 1/2 was used for deep-space and satellite communication \\cite{manual:{Butman, Deutsch, and Miller. Performance of concatenated codes for deep space missions. 1981.}}"], "relations": {"parents": [{"code_id": "bits_into_bits", "detail": ""}], "cousins": [{"code_id": "quantum_convolutional", "detail": "Quantum analogue of convolutional codes"}, {"code_id": "reed_solomon", "detail": "Convolutional codes are often used in concatenation with Reed-Solomon codes for communication \\cite{doi:10.1002/0470866969}."}]}}, "hadamard": {"code_id": "hadamard", "physical": "bits", "logical": "bits", "name": "Hadamard code", "description": "The Hadamard code is dual to the extended Hamming Code.", "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}], "cousins": [{"code_id": "dual", "detail": "The Hadamard code is the dual of the extended Hamming Code."}, {"code_id": "hamming", "detail": "The Hadamard code is the dual of the extended Hamming Code. Conversely, the shortened Hadamard code is the dual of the Hamming Code."}, {"code_id": "reed_muller", "detail": "For any Hamming code \\([2^m,2^m-m-1,3]\\), the dual Hadamard code, when augmented with a bit that is always 0, gives the \\(R(1,m)\\) 1st order Reed-Muller code. In general, \\(R(1,m)\\) is related to the duals of the Hamming code, and when \\(R(1,m)\\) is self dual, it is directly related to the Hamming code."}]}}, "single_parity_check": {"code_id": "single_parity_check", "physical": "bits", "logical": "bits", "name": "Single parity-check code", "description": "An \\([n,n-1,2]\\) binary linear error-detecting code encoding an \\(n\\)-bit codeword into an \\((n+1)\\)-bit string. In this code, parity information of a codeword is sotred in an extra parity bit. If the Hamming weight of a codeword is odd, then its parity is 1. If the Hamming weight of a codeword is even, then its parity is 0. This code is inexpensive since it only requires an extra parity bit and a single parity check. ", "protection": "This code cannot protect information, it can only detect 1-bit error.", "features": {"rate": "The code rate is \\(\\frac{n}{n+1}\\to 1\\) as \\(n\\to\\infty\\). The code distance is 2.", "encoders": ["Concatenate the codeword with a parity bit which encodes the parity information of codeword."], "decoders": ["If the receiver finds that the parity information of a codeword disagrees with the parity bit, then the receiver will discard the information and request a resend."]}, "realizations": ["Can be realized on almost every communication device."], "relations": {"parents": [{"code_id": "parity_check", "detail": ""}], "cousins": [{"code_id": "repetition", "detail": "Repetition code is dual to the single-parity check code."}]}}, "tanner": {"code_id": "tanner", "physical": "bits", "logical": "bits", "name": "Tanner code", "description": "Stub.", "protection": "", "notes": [""], "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}]}}, "polar": {"code_id": "polar", "physical": "bits", "logical": "bits", "name": "Polar code", "introduced": "\\cite{doi:10.1109/TIT.2009.2021379}", "description": "In its basic version, a binary linear polar code encodes \\(K\\) message bits into \\(N=2^n\\) bits. The linear transformation that defines the code is given by the matrix \\(G^{(n)}=B_N G^{\\otimes n}\\), where \\(B_N\\) is a certain \\(N\\times N\\) permutation matrix, and \\(G^{\\otimes n}\\) is the \\(n\\)th Kronecker power of the \\(2\\times 2\\) \\textit{kernel} matrix \\(G=\\left[\\begin{smallmatrix}1 & 0\\\\ 1 & 1 \\end{smallmatrix}\\right]\\). To encode \\(K\\) message bits, one forms an \\(N\\)-vector \\(u\\) in which \\(K\\) coordinates represent the message bits. The remaining \\(N-K\\) coordinates are set to some fixed values and are said to be \\textit{frozen}. The codeword \\(x \\in \\{0,1\\}^N\\) is obtained as \\(x=u G^{\\otimes n}\\). The choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.", "protection": "Protects against various types of noise in the communication channel, for instance, errors, erasures, or other types of noise. Distance plays no role in the analysis of its properties, and is much lower than the largest possible value given \\(K,N\\).", "features": {"rate": "Supports reliable transmission at rates \\(K/N\\) approaching the Shannon capacity of the channel.", "decoders": ["Successive cancellation decoder \\cite{doi:10.1109/TIT.2009.2021379}.", "Successive cancellation list decoder \\cite{doi:10.1109/TIT.2015.2410251}."], "threshold": ["Achieves Shannon capacity of the binary-input memoryless channel under successive cancellation decoder \\cite{doi:10.1109/TIT.2009.2021379}."]}, "realizations": ["Code control channels for the 5G NR (New Radio) interfaces."], "notes": ["There are multiple variants of the basic construction, in particular relying on other kernel matrices. The codes can be defined for nonbinary alphabets, and they can be adjusted to support tasks such as lossless and lossy compression, successive refinement, communication over the mulitple access channel, communication over the wiretap channel, and many others.", "Described in Ch. 32 of Ref. \\cite{doi:10.1201/9781315147901}."], "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}], "cousins": [{"code_id": "reed_muller", "detail": "Reed-Muller code relies on the same generator matrix, but places message bits in different coordinates."}, {"code_id": "generalized_concatenated", "detail": "Polar codes can be represented as generalized concatenations of their kernels."}]}}, "repetition": {"code_id": "repetition", "physical": "bits", "logical": "bits", "name": "Binary repetition code", "introduced": "\\cite{doi:10.1201/9781315147901}", "description": "\\([n,1,n]\\) binary linear code encoding one bit of information into an \\(n\\)-bit string. The length \\(n\\) needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a \\((n,1)\\)-Hamming code.", "protection": "Detects errors on up to \\(\\frac{n-1}{2}\\) coordinates, corrects erasure errors on up to \\(\\frac{n-1}{2}\\) coordinates. The generator matrix is \\(G=\\left[\\begin{smallmatrix}1 & 1&\\cdots& 1 & 1 \\end{smallmatrix}\\right]\\).", "features": {"rate": "Code rate is \\(\\frac{1}{n}\\), code distance is \\(n\\).", "decoders": ["Calculate the Hamming weight \\(d_H\\) of the code. If \\(d_H\\leq \\frac{n-1}{2}\\), decode the code as 0. If \\(d_H\\geq \\frac{n+1}{2}\\), decode the code as 1."], "threshold": ["Suppose each bit has probability \\(p\\) of being received correctly, independent for each bit. The probability that a repetition code is received correctly is \\(\\sum_{k=0}^{(n-1)/2}\\frac{n!}{k!(n-k)!}p^{n-k}(1-p)^{k}\\). If \\(\\frac{1}{2}\\leq p\\), then people can always increase the probability of success by increasing the number of physical bit \\(n\\)."]}, "realizations": ["Repetition codes were used in magnetic disks.", "Although classical repetition code does not have many real-world applications, it still inspire the studies of quantum error correction. Quantum repetition code is widely studied in quantum computing community."], "relations": {"cousins": [{"code_id": "quantum_repetition"}]}}, "binary_linear": {"code_id": "binary_linear", "physical": "bits", "logical": "bits", "name": "Binary linear code", "description": "An \\((n,2^k,d)\\) linear code is denoted as \\([n,k,d]\\). Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword. Often defined in terms of a generator matrix \\(G\\), whose rows form a basis for the subspace. Given a codeword \\(x\\), the corresponding encoded codeword is \\(G^T x\\).", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set for which no two elements of the set add up to a codeword.", "notes": ["Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\)."], "relations": {"parents": [{"code_id": "bits_into_bits", "detail": ""}]}}, "parity_check": {"code_id": "parity_check", "physical": "bits", "logical": "bits", "name": "Parity-check code", "description": "Stub.", "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}]}}, "hamming": {"code_id": "hamming", "physical": "bits", "logical": "bits", "name": "Hamming code", "introduced": "\\cite{doi:10.1002/j.1538-7305.1950.tb00463.x}", "description": "Hamming codes are a family of linear codes with parameters \\((2^r-1,2^r-r-1, 3)\\) for any \\(r\\). The \\(r \\times (2^r-1) \\) parity check matrix, \\(H\\), has all possible non-zero r-bit strings as its columns. The codewords are \\({x|Hx=0}\\).", "protection": "Can detect 1-bit and 2-bit errors, and can correct 1-bit errors", "features": {"rate": "\\(1-\\frac{\\log n}{n}\\)"}, "realizations": ["Commonly used when error rates are very low, for example, computer RAM."], "notes": ["Has the maximum rate among binary codes for that block length and with minimum distance 3. Therefore, it is a perfect code, i.e, it saturates the Hamming Bound."], "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}], "cousins": [{"code_id": "perfect", "detail": ""}, {"code_id": "quantum_hamming", "detail": ""}]}}, "ldpc": {"code_id": "ldpc", "physical": "bits", "logical": "bits", "name": "Low-density parity-check (LDPC) code", "description": "Stub.", "relations": {"parents": [{"code_id": "parity_check", "detail": ""}]}}, "bch": {"code_id": "bch", "physical": "bits", "logical": "bits", "name": "Bose\u2013Chaudhuri\u2013Hocquenghem (BCH) code", "introduced": "\\cite{doi:10.1016/s0019-9958(60)90287-4}", "description": "Stub.", "relations": {"parents": [{"code_id": "alternant", "detail": ""}], "cousins": [{"code_id": "reed_solomon", "detail": ""}, {"code_id": "cyclic", "detail": ""}]}}, "homological_classical": {"code_id": "homological_classical", "physical": "bits", "logical": "bits", "name": "Graph homology code", "introduced": "\\cite{arXiv:quant-ph/0605094}", "description": "This code's properties are derived from the size two chain complex associated with a particular graph. Given a connected simplicial (no self loops or muliedges) graph \\(G = (V, E)\\), which is not a tree, with incidence matrix \\(\\Gamma\\) we can construct a code by choosing a parity check matrix which consists of all the linearly independent rows of \\(\\Gamma\\). This is a \\([n,k,d]\\) code with \\(n = |E|\\), \\(k = 1 - \\mathcal{X}(G) = 1-|V|+|E|\\), where \\( \\mathcal{X}(G)\\) is the euler characteristic of the graph. The code distance is equal to the shortest size of a cycle, guaranteed to exist since \\(G\\) is not a tree.\n", "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}], "cousins": [{"code_id": "perfect", "detail": "A family of homology codes saturate the asymptotic Hamming bound \\cite{arXiv:quant-ph/0605094}."}, {"code_id": "css", "detail": "CSS codes can also be constructed using homology techniques but for manifolds of dimension two or greater."}]}}, "reed_muller": {"code_id": "reed_muller", "physical": "bits", "logical": "bits", "name": "Reed-Muller code", "introduced": "\\cite{doi:10.1109/irepgelc.1954.6499441,doi:10.1109/tit.1954.1057465}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "binary_linear", "detail": ""}]}}, "expander": {"code_id": "expander", "physical": "bits", "logical": "bits", "name": "Expander code", "introduced": "\\cite{doi:10.1109/18.556667}", "description": "Expander codes are binary linear codes whose parity check matrices are derived from the adjacency matrix of bipartite expander graphs. In particular, the rows of the parity check matrix correspond to the right nodes of the bipartite graph and the columns correspond to the left nodes. The codespace is equivalent to all subsets of the left nodes in the graph that have an even number of edges going into every right node of the graph. Since the expander graph is only left regular, these codes do not qualify as LDPC codes.\n\nExpander codes are important because they admit efficient encoding and decoding algorithms and have the desirable property that their rate and relative distance are constant. The rate and distance of the expander code depend on specific parameters of the corresponding graph. A (\\(n, m, D, \\gamma, \\alpha\\)) bipartite expander graph is defined as a \\(D\\)-left-regular graph with \\(n\\) left nodes, and \\(m\\) right nodes such that for any subset of left nodes \\(S\\) of size at most \\(\\gamma n\\) the neighborhood \\(N(S)\\) is at least of size \\(\\alpha|S|\\). Given a (\\(n, m, D, \\gamma, (1-\\epsilon)D\\)) expander graph, the corresponding expander code has rate of \\(1 - m/n\\) and a distance of at least \\(2(1-\\epsilon)\\gamma n\\) for any \\(\\epsilon < 1/2\\). Explicit constructions for expander graphs with any ratio \\(n/m\\) are known where \\(D = \\text{polylog}(n/m)\\), \\(\\gamma = \\Omega(1/D)\\) and arbitrary \\(\\epsilon\\) \\cite{doi:10.1145/509907.510003}.\n", "protection": "Bit flip errors of weight at most \\((d-1)/2\\) where \\(d\\) is the distance of the code and is linear in \\(n\\), the number of physical bits.", "features": {"rate": "The rate is \\(1 - m/n\\) where \\(n\\) is the number of left nodes and \\(m\\) is the number of right nodes in the bipartite expander graph.", "encoders": ["Multiplication by generator matrix with runtime \\(O(n^2)\\)"], "decoders": ["Decoding can be done in \\(O(n)\\) runtime using a greedy algorithm. The algorithm consists of flipping a bit of the received word if it will result in a greater number of satisfied parity checks. This is repeated until a codeword is reached."]}, "relations": {"parents": [{"code_id": "tanner"}]}}, "bits_into_bits": {"code_id": "bits_into_bits", "physical": "bits", "logical": "bits", "name": "Binary code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) binary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)\\). The distance is the minimum Hamming distance between a pair of distinct codewords.", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "relations": {"parents": [{"code_id": "ecc", "detail": ""}]}}, "oecc": {"code_id": "oecc", "name": "Operator quantum error-correcting code", "introduced": "\\cite{arXiv:quant-ph/0412076,arXiv:quant-ph/0504189}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "oaecc", "detail": ""}]}}, "qecc_finite": {"code_id": "qecc_finite", "name": "Finite-dimensional quantum code", "description": "A quantum error-correcting code that encodes quantum information in a \\(K\\)-dimensional (\\textit{logical}) subspace \\(\\mathsf{H}_K\\) of an \\(N\\)-dimensional (\\textit{physical}) Hilbert space \\(\\mathsf{H}_N\\) such that it is possible to recover said information from errors. Formally, a finite-dimensional quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{K}\\to\\mathsf{H}_{N}\\) with a set of correctable errors \\({\\cal{E}}:\\mathsf{H}_N\\to\\mathsf{H}_M\\) with the following property: there exists a quantum operation \\({\\cal{D}}:\\mathsf{H}_M\\to \\mathsf{H}_K\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{K}\\), \\({\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\) for some constant \\(c\\).", "protection": "Correction capability is determined by the Knill-Laflamme error correction criteria \\cite{arXiv:quant-ph/9604034,arXiv:quant-ph/9604024}. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an \\hyperref[code:approximate_qecc]{approximate code}.", "features": {"general_gates": ["Universal gate set cannot be transversal due to Eastin-Knill theorem \\cite{arXiv:0811.4262}."]}, "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "qecc": {"code_id": "qecc", "name": "Quantum error-correcting code (QECC)", "description": "Encodes quantum information in a (\\textit{logical}) subspace of a (\\textit{physical}) Hilbert space such that it is possible to recover said information from errors that act as linear maps on the physical space. The logical subspace is spanned by a basis comprised of \\textit{code basis states} or \\textit{codewords}. More formally, denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{\\text{logical}}\\to\\mathsf{H}_{\\text{physical}}\\) with a set of correctable errors \\(\\cal{E}\\) with the following property: there exists a quantum operation \\(\\cal{D}\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{\\text{logical}}\\), \\({\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\) for some constant \\(c\\). Ideal code states \\(|\\psi\\rangle\\) may not be normalizable if the physical Hilbert space in infinite, so approximate versions have to be constructed.", "protection": "Correction capability is determined by of the Knill-Laflamme error-correction criteria \\cite{arXiv:quant-ph/9604034,arXiv:quant-ph/9604024}, which may admit infinite terms due to non-normalizability of ideal code states. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an \\hyperref[code:approximate_qecc]{approximate code}.", "relations": {"parents": [{"code_id": "oecc", "detail": ""}]}}, "quantum_convolutional": {"code_id": "quantum_convolutional", "physical": "qubits", "logical": "qubits", "name": "Quantum convolutional code", "introduced": "\\cite{arxiv:quant-ph/0511016}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "stabilizer", "detail": ""}]}}, "color": {"code_id": "color", "physical": "qubits", "logical": "qubits", "name": "Color code", "introduced": "\\cite{doi:10.1103/PhysRevLett.97.180501}", "description": "Color code is a topological stabilizer code defined on a \\(D\\)-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial \\(D\\)-complex obtained as a triangulation of the interior of a \\(D\\)-simplex and (2) is \\(D+1\\)-colorable. Qubits are placed on the \\(D\\)-simplices and generators are supported on suitable simplices \\cite{doi:10.7907/059V-MG69}. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face \\cite{arXiv:1311.0277}.", "protection": "As with the surface code, the code distance depends on the specific kind of lattice used to define the code. More precisely, the distance depends on the homology of logical string operators \\cite{arXiv:1311.0277}.", "features": {"rate": "For general 2D manifolds, \\(kd^2 \\leq c(\\log k)^2 n\\) for some constant \\(c\\) \\cite{arXiv:1301.6588}, meaning that color codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\).", "transversal_gates": "Transversal CNOT can be implemented via braiding \\cite{arXiv:0806.4827}. Universal transversal gates can be achieved in 3D color code using gauge fixing \\cite{arxiv:1311.0879}, lattice surgery \\cite{arXiv:1407.5103}, or code deformation \\cite{doi:10.1088/1367-2630/13/4/043005,arXiv:0806.4827}.", "general_gates": ["Magic-state distillation protocols \\cite{doi:10.7907/059V-MG69}.", "Non-clifford gates can be implemented via code switching \\cite{doi:10.7907/059V-MG69}."], "decoders": ["Projection decoder \\cite{doi:10.7907/059V-MG69}.", "Matching decoder gives low logical failure rate \\cite{arXiv:2108.11395}.", "Integer-program-based decoder \\cite{arXiv:1402.3037}.", "Restriction decoder \\cite{doi:10.1088/1367-2630/ab68fd}."], "fault_tolerance": ["Syndrome measurement \\cite{arXiv:1407.5103}.", "Steane's ancilla-coupled measurement method \\cite{arXiv:1407.5103}"], "code_capacity_threshold": ["\\(\\geq 6\\%\\) threshold with rescaling-based decoder \\cite{arXiv:2112.09584}."], "threshold": ["\\(\\geq 6.25\\%\\) threshold for 2d color codes with error-free syndrome extraction, and \\(0.1\\%\\) with faulty syndrome extraction \\cite{arXiv:0907.1708}.", "\\(0.46\\%\\) for 3d codes with clustering decoder \\cite{arXiv:1708.07131}.", "\\(1.9\\%\\) for 1D string-like logical operators and \\(27.6\\%\\) for 2D sheet-like operators for 3D codes with noise models using optimal decoding and perfect measurements \\cite{arXiv:1708.07131}.", "\\(0.31\\%\\) noise threshold error rate for gauge code using clustering decoder \\cite{arXiv:1503.08217}.", "\\(0.143\\%\\) with depolarising circuit-level noise using perfect-matching decoder \\cite{arXiv:1407.5103}.", "\\(>0\\%\\) threshold with sweep decoder \\cite{doi:10.7907/059V-MG69}."]}, "relations": {"parents": [{"code_id": "css", "detail": ""}, {"code_id": "topological", "detail": "Defined on a lattice with geometrically local stabilizer generators \\cite{doi:10.7907/059V-MG69}."}], "cousins": [{"code_id": "quantum_ldpc", "detail": "Stabilizer generator weights and qubit degrees are given by the properties of the tessellation, and most tesselations yield QLDPC codes."}, {"code_id": "surface", "detail": "Color code is equivalent to surface code in several ways \\cite{arxiv:1503.02065}. For example, the color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D\\)-dimensional surface code."}]}}, "ramanujan_tensor_product": {"code_id": "ramanujan_tensor_product", "physical": "qubits", "logical": "qubits", "name": "Ramanujan tensor-product code", "introduced": "\\cite{arXiv:2004.07935}", "description": "Constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.", "protection": "Without distance balancing, a Ramanujan code can have \\(d_X =\\Omega(\\log n)\\) and \\(d_Z = \\Omega (n)\\). For 2D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}\\). For 3D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d= \\Omega(n^{1/2}\\log n )\\).", "features": {"rate": "For 2D Ramanujan complexes, the rate is \\(\\Omega(\\sqrt{ \\frac{1}{n \\log n} })\\), with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}) \\). For 3D, the rate is \\( \\Omega(\\frac{1}{\\sqrt{n}\\log n}) \\) with minimum distance \\(d \\geq \\sqrt{n} \\log n \\).", "decoders": ["For 2D simplicial complexes, cycle code decoder admitting a polynomial-time decoding algorithm can be used \\cite{arXiv:2004.07935}."]}, "notes": ["Codes were first to break a 20-year record set by the \\hyperref[code:freedman_meyer_lou]{Freedman-Meyer-Lou code} for the lower bound on scaling of the minimum distance \\cite{doi:10.1103/PRXQuantum.2.040101}."], "relations": {"parents": [{"code_id": "homological_product", "detail": "Code is constructed using product of complexes \\cite{arXiv:2004.07935}."}, {"code_id": "quantum_ldpc", "detail": "\\(Z\\)- and \\(X\\)- row and column weights are bounded from above by the weights of the two codes that are used in the construction of this code \\cite{arXiv:2004.07935}."}], "cousins": [{"code_id": "distance_balanced", "detail": "Ramanujan tensor-product constructions use distance balancing to increase distance."}]}}, "stab_4_2_2": {"code_id": "stab_4_2_2", "physical": "qubits", "logical": "qubits", "name": "\\([[4,2,2]]\\) CSS code", "introduced": "\\cite{arXiv:quant-ph/9603031}", "description": " Four-qubit CSS stabilizer code with generators \\(\\{XXXX, ZZZZ\\} \\) and codewords \\begin{align} \\begin{split} |\\overline{00}\\rangle = (|0000\\rangle + |1111\\rangle)/\\sqrt{2}\\\\ |\\overline{01}\\rangle = (|0011\\rangle + |1100\\rangle)/\\sqrt{2}\\\\ |\\overline{10}\\rangle = (|0101\\rangle + |1010\\rangle)/\\sqrt{2}\\\\ |\\overline{11}\\rangle = (|0110\\rangle + |1001\\rangle)/\\sqrt{2} \\end{split}. \\end{align} Its subcode is the \\([[4,1,2]]\\) code, whose \\(\\pm\\)-basis codewords can be written as \\begin{align} |\\overline{\\pm}\\rangle = \\frac{1}{2}(|00\\rangle \\pm |11\\rangle)^{\\otimes 2}\\\\ \\end{align} This code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code.", "protection": "Detects a single-qubit error \\cite{arXiv:quant-ph/9603031} or single erasure \\cite{arXiv:quant-ph/9610042}. Not able to correct arbitrary single-qubit errors because \\( \\lfloor \\frac{d-1}{2} \\rfloor =0 \\). Approximately corrects a single amplitude damping error \\cite{arXiv:quant-ph/9704002}.", "features": {"transversal_gates": "Transversal Pauli, Hadamard, and two-qubit \\(R\\) gates \\cite{arxiv:1610.03507}.", "fault_tolerance": ["Preparation of certain states along with transversal gates can be performed fault-tolerantly, but requires post-selection because the code cannot correct errors \\cite{arxiv:1610.03507}."]}, "realizations": ["Realized in trapped-ion quantum devices \\cite{arXiv:1611.06946}."], "notes": ["Concatenating \\([[4,2,2]]\\) code with surface code can generate 2D topological code with a reasonable circuit-based threshold \\cite{doi:10.26421/QIC16.15-16-1}."], "relations": {"parents": [{"code_id": "quantum_parity", "detail": "\\([[4,1,2]]\\) subcode is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes."}], "cousins": [{"code_id": "surface", "detail": "\\([[4,2,2]]\\) code is the smallest toric code."}, {"code_id": "stab_5_1_3", "detail": "\\([[4,2,2]]\\) can be derived from \\([[5,1,3]]\\) code using a protocal that converts \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman \\cite{arXiv:quant-ph/9705052}."}, {"code_id": "quantum_polar", "detail": "\\([[4,2,2]]\\) code is a small quantum polar code \\cite{manual:{Kyungjoo Noh, \\href{https://github.com/errorcorrectionzoo/eczoo_data/files/7652763/Leung_code_as_quantum_polar_code.pdf}{Leung code as quantum polar code}, 2017}}."}, {"code_id": "approximate_qecc", "detail": "\\([[4,2,2]]\\) code approximately corrects a single amplitude damping error \\cite{arXiv:quant-ph/9704002}."}]}}, "fiber_bundle": {"code_id": "fiber_bundle", "name": "Fiber-bundle code", "description": "Stub."}, "stabilizer": {"code_id": "stabilizer", "physical": "qubits", "logical": "qubits", "name": "Stabilizer code", "introduced": "\\cite{arXiv:quant-ph/9605005}\\cite{arXiv:quant-ph/9705052}", "description": "An \\(((n,2^k,d))\\) stabilizer code is denoted as \\([[n,k]]\\) or \\([[n,k,d]]\\), where \\(d\\) is the code's distance. Logical subspace is the joint \\(+1\\) eigenspace of a set of \\(2^{n-k}\\) commuting Pauli operators \\(S\\) forming the code's stabilizer group \\(\\mathsf{S}\\), which cannot contain \\(-I\\). The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation on the code.", "protection": "Detects errors on up to \\(d-1\\) qubits, and corrects erasure errors on up to \\(d-1\\) qubits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{\\hat{N}(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "features": {"encoders": ["Dissipative preparation, for which codespace is steady-state space of a Lindbladian \\cite{arXiv:1310.1036}."]}, "relations": {"parents": [{"code_id": "cws", "detail": "If the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code."}], "cousins": [{"code_id": "binary_linear", "detail": "Qubit stabilizer codes are quantum analogues of binary linear codes."}, {"code_id": "hamiltonian", "detail": "Codespace is the ground-state space of the \\textit{code Hamiltonian}, consisting of an equal linear combination of stabilizer generators."}]}}, "gauge_stabilizer": {"code_id": "gauge_stabilizer", "physical": "qubits", "logical": "qubits", "name": "Gauge stabilizer code", "introduced": "\\cite{arXiv:quant-ph/0508131}", "description": "Also called a \\textit{subsystem stabilizer code}. A stabilizer code with some of its logical qubits denoted as \\textit{gauge} qubits and not used for storage of logical information. Note that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by \\([[n,k,r,d]]\\), similar to stabilizer codes, but with an extra parameter \\(r\\) denoting the number of gauge qubits.\n\nTo create these codes proceed as follows. Choose \\(2n\\) operators \\(\\{ \\tilde{X}_j,\\tilde{Z}_j\\}_{j=1}^n\\) from \\(\\mathsf{P}_n\\), the Pauli group on \\(n\\) qubits, such that they obey the same commutation relations as the regular \\(n\\)-qubit Pauli generators \\( \\{X_j,Z_j\\}_{j=1}^n \\) (the subscript on these latter operators indicates the single qubit the Pauli matrix acts on). The tilde operators might act on more than one physical (or \\textit{bare}) qubit but they behave as if they acted only on a single qubit. WLOG we can choose a stabilizer group as \\( \\mathsf{S} = \\langle Z_1,\\dots,Z_s \\rangle \\). It follows that the normalizer of \\(\\mathsf{S} \\) is \\( N(\\mathsf{S}) = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_n, \\tilde{X}_{s+1},\\dots, \\tilde{X}_n \\rangle \\). We now choose a gauge group as \\( \\mathsf{G} = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_s, \\tilde{X}_{s+1}, \\tilde{Z}_{s+1}, \\dots, \\tilde{X}_{s+r}, \\tilde{Z}_{s+r} \\rangle \\) with \\( s + r \\leq n \\). The logical group is choosen as \\( \\mathsf{L} = N(\\mathsf{S})/\\mathsf{G} \\simeq \\langle \\tilde{X}_{s+r+1},\\tilde{Z}_{s+r+1}, \\dots, \\tilde{X}_n,\\tilde{Z}_n \\rangle \\). Now the codespace \\( C \\) is as usual the \\(+1\\) eigenspace of the stabilizer \\( \\mathsf{S} \\). But the gauge and logical groups have further decomposed this space into \\( C = A \\otimes B \\simeq (\\mathbb{C}^2)^{\\otimes k} \\otimes (\\mathbb{C}^2)^{\\otimes r} \\). Thus the Hilbert space is partitioned into 3 sets; \\(k\\) logical qubits, \\(r\\) gauge qubits, and \\(s\\) stabilizer qubits, with \\(s+r+k=n\\).\n", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. More generally, a set of errors \\( \\{ E_a \\} \\) is correctable iff \\( E_aE_b \\not\\in N(\\mathsf{S}) \\setminus \\mathsf{G} \\) for all pairs \\(a,b\\). The distance of the code is the minimal weight of operators in \\( N(\\mathsf{S}) \\setminus \\mathsf{G}\\).", "notes": ["When the gauge group \\( \\mathsf{G} \\) is abelian, the above is reduced to the standard stabilizer formalism."], "relations": {"parents": [{"code_id": "oecc", "detail": ""}], "cousins": [{"code_id": "stabilizer", "detail": "Gauge stabilizer codes reduce to stabilizer codes when there are no gauge qubits."}]}}, "t-designs": {"code_id": "t-designs", "physical": "qubits", "logical": "qubits", "name": "Local Haar-random circuit code", "introduced": "\\cite{doi:10.1007/s00220-016-2706-8}", "description": "An \\(n\\)-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal \\(n\\)-qubit states and acting with a random unitary circuit of depth polynomial in \\(n\\). Two states are \\textit{locally indistinguishable} if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about \\(n/2\\) two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries.\nThe above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (\\(D=1\\), while codes for higher-dimensional geometries require \\(O(n^{1/D})\\)-depth circuits \\cite{doi:10.1007/s00220-016-2706-8}. Follow-up work \\cite{arxiv:2010.09775} revealed that optimal code properties require only \\(O(\\sqrt{n})\\)-depth circuits for that case, and \\(O(\\sqrt{n})\\)-depth circuits for a two-dimensional square-lattice geometry.", "protection": "In a 1D geometry, the code approximately detects any error with support on a segment of length \\(\\leq n/4\\), with deviations exponentially suppressed in \\(n\\).", "features": {"encoders": ["Random local circuit of depth proportional to \\(n^{\\alpha}\\), with \\(\\alpha\\) depending on system geometry."]}, "relations": {"parents": [{"code_id": "random_circuit", "detail": ""}], "cousins": [{"code_id": "topological", "detail": "Local Haar-random codewords, like topological codewords, are locally indistinguishable \\cite{doi:10.1007/s00220-016-2706-8}."}, {"code_id": "approximate_qecc", "detail": ""}]}}, "qubits_into_qubits": {"code_id": "qubits_into_qubits", "physical": "qubits", "logical": "qubits", "name": "Qubit code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2^n\\)-dimensional (i.e., \\(n\\)-qubit) Hilbert space. Usually denoted as \\(((n,K))\\) or \\(((n,K,d))\\), where \\(d\\) is the code's distance.", "relations": {"parents": [{"code_id": "qecc_finite", "detail": ""}]}}, "matching": {"code_id": "matching", "physical": "qubits", "logical": "qubits", "name": "Matching code", "introduced": "\\cite{arxiv:1501.07779}", "description": "Stub.", "relations": {"parents": [{"code_id": "stabilizer"}, {"code_id": "topological", "detail": "Matching codes were inspired by the Kitaev honeycomb model \\cite{arXiv:cond-mat/0506438}, which realizes \\(\\mathbb{Z}_2\\) topological order."}], "cousins": [{"code_id": "surface", "detail": "Matching code realizes the same topological order as the surface code."}]}}, "quantum_reed_muller": {"code_id": "quantum_reed_muller", "physical": "qubits", "logical": "qubits", "name": "Quantum Reed-Muller code", "introduced": "\\cite{arXiv:quant-ph/9608026}", "description": "A CSS code formed from a classical Reed-Muller code in which polynomials over finite fields encode data. This is done by transforming these polynomials into the stabilizer generator matrices", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "features": {"rate": "\\(\\frac{k}{n}\\), where \\(k = 2^r - {r \\choose t} + 2 \\sum_{i=0}^{t-1} {r \\choose i}\\). Additionally, CSS codes formed from binary Reed-Muller codes achieve channel capacity on erasure channels \\cite{arXiv:1601.04689}.", "general_gates": ["Magic state distillation in all prime dimensions \\cite{doi:10.1103/PhysRevX.2.041021}"], "fault_tolerance": ["Gate switching protocol for universal computation \\cite{arxiv:1403.2734}."], "threshold": ["Between \\(10^{-3}\\) and \\(10^{-6}\\) for depolarizing noise (assuming ideal decoders), see \\cite{doi:10.1088/2058-9565/abb027}"]}, "relations": {"parents": [{"code_id": "css", "detail": ""}], "cousins": [{"code_id": "reed_muller", "detail": "Reed-Muller codes are the classical anologue of these codes."}, {"code_id": "quantum_convolutional", "detail": "Quantum convolutional codes can be derived from Quantum Reed-Muller codes \\cite{arxiv:quant-ph/0701037}."}]}}, "double_semion": {"code_id": "double_semion", "physical": "qubits", "logical": "qudits", "name": "Double-semion code", "introduced": "\\cite{arXiv:cond-mat/0404617}", "description": "Stub.", "relations": {"parents": [{"code_id": "qudit_stabilizer", "detail": "Double-semion code is a \\(\\mathbb{Z}_q\\)-qudit stabilizer code with \\(q=4\\) \\cite{arxiv:2112.11394}."}, {"code_id": "topological", "detail": "When treated as ground states of the code Hamiltonian, the code states realize double-semion topological order, a topological phase of matter that also exists in twisted \\(\\mathbb{Z}_2\\) gauge theory \\cite{doi:10.1007/BF02096988}."}], "cousins": [{"code_id": "surface", "detail": "There is a logical basis for the toric and double-semion codes where each codeword is a superposition of states corresponding to all noncontractible loops of a particular homotopy type. The superposition is equal for the toric code, whereas some loops appear with a \\(-1\\) coefficient for the double semion."}]}}, "movassagh_ouyang": {"code_id": "movassagh_ouyang", "physical": "qubits", "logical": "qubits", "name": "Movassagh-Ouyang Hamiltonian code", "introduced": "\\cite{arXiv:2012.01453}", "description": "This is a family of codes derived via an algorithm that takes as input \\textit{any} binary classical code and outputs a quantum code (note that this framework can be extended to \\(q\\)-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.\n\nThis family strictly generalizes CSS codes (because CSS codes come only from linear or self orthogonal classical codes). These codes can be shown to be realized as a subspace of the ground space of a (geometrically) local Hamiltonian.\n", "protection": "Let \\(C \\subset \\{0,1,\\dots,q-1\\}^n\\) be a classical code with distance \\(d_x\\). Let \\(d_z\\) satisfy \\(q^n > 2 V_q(d_z-1) -1\\), where \\(V_q(r)\\) is the volume of the \\(q\\)-ary Hamming ball of radius \\(r\\). Then the algorithm produces a quantum code with distance \\(d = \\text{min}(d_x,d_z)\\). Asymptotically, the distance scales linearly with \\(n\\).", "features": {"rate": "The rate depends on the classical code, but distance can scale linearly with \\(n\\)."}, "relations": {"parents": [{"code_id": "hamiltonian", "detail": "Movassagh-Ouyang codes reside in the ground space of a local Hamiltonian."}], "cousins": [{"code_id": "stabilizer", "detail": "Many, but not all, Movassagh-Ouyang codes are stabilizer codes."}, {"code_id": "bits_into_bits", "detail": "Movassagh-Ouyang codes are constructed from classical binary codes."}]}}, "steane": {"code_id": "steane", "physical": "qubits", "logical": "qubits", "name": "Steane", "introduced": "\\cite{doi:10.1098/rspa.1996.0136}", "description": "The Steane code is a \\([[7,1,3]]\\) CSS code that uses the classical binary \\([7,4,3]\\) Hamming code for protecting against \\(X\\) errors and its dual \\([7,3,4]\\) for \\(Z\\) errors. The parity-check matrix for the \\([7,4,3]\\) Hamming code is\n\\begin{align}\n  H = \\left(\\begin{matrix}\n    1&0&0&1&0&1&1\\\\\n    0&1&0&1&1&0&1\\\\\n    0&0&1&0&1&1&1\n  \\end{matrix}\\right),\n\\end{align},\nand the check matrix for the Steane code is therefore\n\\begin{align}\n  \\left(\\begin{matrix}\n    0&H\\\\\n    H&0\n  \\end{matrix}\\right).\n\\end{align}\nThe stabilizer group for the Steane code has six generators.\n", "protection": "The Steane code is a distance 3 code. It detects errors on 2 qubits, corrects errors on 1 qubit.", "realizations": ["Realized in a ten qubit QCCD trapped-ion quantum computer \\cite{arXiv:2107.07505}.", "Realized on seven trapped-ion qubits \\cite{arXiv:1403.5426}."], "features": {"fault_tolerance": ["Syndrome measurement can be done with flag qubits \\cite{arXiv:1612.04795} or with no extra qubits \\cite{doi:10.1088/2058-9565/abc6f4}."]}, "relations": {"parents": [{"code_id": "quantum_hamming_css", "detail": "The Steane code is the \\(r=3\\) member of the  \\([\\![2^r-1,2^r-1-2r,3]\\!]\\) quantum Hamming code family."}], "cousins": [{"code_id": "hamming"}]}}, "bacon_shor": {"code_id": "bacon_shor", "physical": "qubits", "logical": "qubits", "name": "Bacon-Shor code", "description": "Stub.", "protection": ""}, "quantum_hamming": {"code_id": "quantum_hamming", "physical": "qubits", "logical": "qubits", "name": "\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming code", "introduced": "\\cite{arXiv:quant-ph/9604038}", "description": "A family of stabilizer codes of distance \\(3\\) that asymptotically saturate quantum Hamming bound.", "protection": "Protects against any single qubit error.", "relations": {"parents": [{"code_id": "stabilizer", "detail": ""}], "cousins": [{"code_id": "quantum_perfect", "detail": "Quantum Hamming codes saturate the asymptotic Hamming bound."}]}}, "gnu_permutation_invariant": {"code_id": "gnu_permutation_invariant", "physical": "qubits", "logical": "qubits", "name": "GNU permutation-invariant code", "introduced": "\\cite{arXiv:1302.3247}", "description": "Can be expressed in terms of Dicke states where the logical states are\n\\begin{align}\n|\\overline{\\pm}\\rangle = \\sum_{\\ell=0}^{n} \\frac{(\\pm 1)^\\ell}{\\sqrt{2^n}} \\sqrt{n \\choose \\ell} |D^m_{g \\ell}\\rangle~.\n\\end{align}\nHere, \\(m\\) is the number of particles used for encoding \\(1\\) qubit, and \\(g, n \\leq m\\) are arbitrary positive integers. The state \\(|D^m_w\\rangle\\) is a Dicke state -- a normalized permutation-invariant state on \\(m\\) qubits with \\(w\\) excitations, i.e., a normalized sum over all basis elements with \\(w\\) ones and \\(m - w\\) zeroes.\n\nA qudit extension of such codes, based on a correspondence with binomial codes, exists \\cite{arXiv:1708.05010}.\n", "protection": "Depends on the family. One family which is completely symmetrized versions of Bacon-Shor codes (parameterized by \\(t\\)) protects against arbitrary weight-\\(t\\) qubit errors. Additionally, codes with large enough length \\((t+1)(3t+1)+t\\) can approximately correct \\(t\\) spontaneous decay errors.", "relations": {"parents": [{"code_id": "permutation_invariant", "detail": ""}], "cousins": [{"code_id": "bacon_shor", "detail": "Symmetrized versions of the Bacon-Shor codes are GNU codes"}, {"code_id": "hamiltonian", "detail": "GNU codes lie within the ground state of ferromagnetic Heisenberg models without an external magnetic field \\cite{doi:10.1103/PhysRevB.103.144417}."}, {"code_id": "approximate_qecc", "detail": "Some GNU codes can protect approximately against amplitude damping errors."}, {"code_id": "binomial", "detail": "Binomial codes and GNU codes are both described by spin-coherent states \\cite{arXiv:1708.05010}."}]}}, "quantum_hamming_css": {"code_id": "quantum_hamming_css", "physical": "qubits", "logical": "qubits", "name": "\\([[2^r, 2^r-1-2r, 3]]\\) Hamming-based CSS code", "description": "Stub.", "relations": {"parents": [{"code_id": "css", "detail": ""}]}}, "quantum_expander": {"code_id": "quantum_expander", "physical": "qubits", "logical": "qubits", "name": "Quantum expander code", "introduced": "\\cite{doi:10.1109/FOCS.2015.55}", "description": "CSS codes constructed from bipartite expander graphs with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as \\(X\\) checks, and the parity check matrix of the other as \\(Z\\) checks.", "protection": "Pauli errors of weight \\(\\leq t\\), distance scales as \\(\\Omega(n^{1/2})\\).", "features": {"rate": "\\([[n,k=\\Theta(n),d=O(\\sqrt{n})]]\\) code with asymptotically constant rate.", "decoders": ["Ref. \\cite{doi:10.1109/FOCS.2015.55} details a linear time decoder, which corrects \\(\\Omega(n^{1/2})\\) adversarial errors."], "threshold": ["Current estimate of \\(2.7 \\cdot 10^{-16}\\) in locally stochastic noise model \\cite{arXiv:1711.08351}."]}, "relations": {"parents": [{"code_id": "quantum_ldpc"}], "cousins": [{"code_id": "expander", "detail": "Quantum expander codes are constructed from classical expander codes."}]}}, "stab_5_1_3": {"code_id": "stab_5_1_3", "physical": "qubits", "logical": "qubits", "name": "\\([[5,1,3]]\\) code", "introduced": "\\cite{arXiv:quant-ph/9602019}", "description": "Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, \\begin{align} \\begin{split} S_1 &= IXZZX \\\\ S_2 &= XZZXI \\\\ S_3 &= ZZXIX \\\\ S_4 &= ZXIXZ. \\end{split} \\end{align}", "protection": "Smallest stabilizer code that protects against a single error on any one qubit. Detects two-qubit errors.", "features": {"transversal_gates": "Pauli gates are transversal."}, "realizations": ["First realized in NMR \\cite{doi:10.1103/PhysRevLett.86.5811}.", "Demonstration with superconducting qubits \\cite{arXiv:1907.04507}."], "relations": {"parents": [{"code_id": "stabilizer", "detail": "\\([[5,1,3]]\\) code is the smallest stabilizer code to correct a single qubit error."}], "cousins": [{"code_id": "quantum_perfect", "detail": "The smallest perfect code."}, {"code_id": "quantum_cyclic", "detail": "\\([[5,1,3]]\\) code is the smallest known example of quantum cyclic code ."}, {"code_id": "hamiltonian", "detail": "\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of Majorana operators \\cite{manual:{Aleksander Kubica, private communication, 2019}}."}, {"code_id": "majorana_stab", "detail": "\\([[5,1,3]]\\) code Hamiltonian is local when expressed in terms of Majorana operators \\cite{manual:{Aleksander Kubica, private communication, 2019}}."}]}}, "freedman_meyer_lou": {"code_id": "freedman_meyer_lou", "physical": "qubits", "logical": "qubits", "name": "Freedman-Meyer-Lou code", "description": "Stub.", "protection": ""}, "cws": {"code_id": "cws", "physical": "qubits", "logical": "qubits", "name": "Codeword stabilized (CWS) code", "introduced": "\\cite{arXiv:0708.1021}", "description": "This family of codes strictly generalizes stabilizer codes. They are usually denoted by \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\) where \\(\\mathcal{G}\\) is a graph and \\(\\mathcal{C}\\) is a \\( (n,K,d) \\) binary classical code. From the graph we form the unique graph state (stabilizer state) \\( |G \\rangle \\). From the classical code we form Pauli \\(Z\\)-type operators \\( W_i = Z^{c_{i,1}} \\otimes \\cdots \\otimes Z^{c_{i,n}} \\), where \\(c_{i,j} \\) is the \\(j\\)-th bit of the \\(i\\)-th classical codeword. The CWS codewords are then \\( | i \\rangle =  W_i | G \\rangle \\).\n\nThere is an alternative description to the one above that is locally Clifford-equivalent. In particular, we can describe CWS codes as \\( \\mathcal{Q} = (S,\\mathcal{W})\\) where \\(S\\) is a stabilizer group and \\( \\mathcal{W} = \\{ w_\\ell \\}_{\\ell = 1}^K \\) is a family of \\(K\\) \\(n\\)-qubit Pauli strings. We then form CWS codeswords as \\( | i \\rangle = w_i | S \\rangle \\), where \\( | S \\rangle \\) is the (unique) stabilizer state of \\(S\\).\n", "protection": "Code distance \\(\\mathcal{Q} = ( \\mathcal{G},\\mathcal{C}) \\) is upper bounded by the distance of the classical code \\(\\mathcal{C} \\).", "features": {"encoders": ["If \\( \\mathcal{C} \\) has an efficient classical encoder, then so does the CWS code \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\)."], "decoders": ["There is no known \\textit{efficient} algorithm to decode \\textit{non-additive} (non-stabilizer) CWS codes."]}, "relations": {"parents": [{"code_id": "qubits_into_qubits", "detail": ""}], "cousins": [{"code_id": "movassagh_ouyang", "detail": "The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other."}]}}, "homological_product": {"code_id": "homological_product", "physical": "qubits", "logical": "qubits", "name": "Homological product code", "introduced": "\\cite{arXiv:1311.0885}", "description": "Stub.", "protection": "", "features": {"fault_tolerance": ["Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state \\cite{arXiv:1807.09783}."], "decoders": ["Union-find \\cite{arXiv:2009.14226}."]}, "relations": {"parents": [{"code_id": "css", "detail": ""}, {"code_id": "quantum_ldpc", "detail": ""}]}}, "css": {"code_id": "css", "physical": "qubits", "logical": "qubits", "name": "Calderbank-Shor-Steane (CSS) stabilizer code", "introduced": "\\cite{arXiv:quant-ph/9512032,doi:10.1103/PhysRevLett.77.793,arXiv:quant-ph/9601029}", "description": "An \\([[n,k,d]]\\) stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The parity check matrix is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}~.\n\\label{eq:parity}\n\\end{align}\n\nEncoding is based on two related \\hyperref[code:binary_linear]{binary linear codes}, an \\([n,k_X,d_X]\\) code \\(C_X\\) and \\([n,k_Z,d_Z]\\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parity} is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees that the \\(X\\)-stabilizers, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizers of associated with \\(H_Z\\).\n\nA CSS code has \\textit{stabilizer weight} \\(w\\) if the highest weight of any stabilizer generator is \\(w\\), i.e., any row and column of \\(H_X\\) and \\(H_Z\\) has weight at most \\(w\\). In the context of comparing weight as well as of noise models biased toward \\(X\\)- or \\(Z\\)-type errors, an extended notation for CSS codes is \\([[n,k,(d_X,d_Z),w]]\\). The quantity \\(\\min\\{d_X,d_Z\\}\\) is often called the \\textit{worst-case minimum distance}.\n\nThere exists a many-to-one mapping from size three chain complexes to CSS codes \\cite{doi:10.1070/RM1997v052n06ABEH002155,arXiv:quant-ph/0605094,arXiv:1311.0885,arXiv:1802.01520} that allows one to extract code properties from topological features of the complexes. Codes constructed in this manner are sometimes called \\textit{homological CSS codes}, but they are equivalent to CSS codes. This mapping has allowed the application of results from topology to error correction, yielding QLDPC codes with favorable properties.\n\nA \\textit{chain complex} of size three is given by binary vector spaces \\(A_2\\), \\(A_1\\), \\(A_0\\) and binary matrices \\(\\partial_{i=1,2}\\) (called \\textit{boundary operators}) \\(A_i\\) to \\(A_{i-1}\\) that satisfy \\(\\partial_1 \\partial_2 = 0\\). Such a complex is typically denoted as\n\\begin{align}\nA_2 \\xrightarrow{\\partial_2} A_1 \\xrightarrow{\\partial_1} A_0~.\n\\label{eq:chain}\n\\end{align}\nOne constructs a CSS code by associating a physical qubit to every basis element of \\(A_1\\), and defining parity-check matrices \\(H_X=\\partial_1^T\\) and \\(H_Z=\\partial_2\\)). That way, the spaces \\(A_0\\) and \\(A_2\\) can be associated with \\(X\\)-type and \\(Z\\)-type Pauli operators, respectively, and boundary operators determine the Paulis making up the stabilizer generators. The requirement \\(\\partial_1 \\partial_2 = 0\\) guarantees that the \\(X\\)-stabilizers associated with \\(H_X\\) commute with the \\(Z\\)-stabilizers associated with \\(H_Z\\).\n\nUsually, the chain complex \\eqref{eq:chain} used in the construction comes from the chain complex associated with a cellulation of a manifold. When the manifold is a two-dimensional surface, its entire chain is used. Higher-dimensional manifolds allow for longer chain complexes, and one can use the three largest non-trivial vector spaces in its chain.\n\nThe reverse mapping is as follows \\cite{arXiv:1311.0885,arXiv:1807.09783}. Given a CSS code with parity check matrices \\(H_X\\) and \\(H_Z\\), let both boundary operators be \\(\\partial = H_Z^TUH_X\\) for an arbitrary invertible matrix \\(U\\). The fact that the stabilizer generators commute ensures that the boundary operator satisfies \\(\\partial^2=0\\), yielding a chain complex.\n", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.\n\nUsing the relation to chain complexes, the number of encoded logical qubits is equal to the dimension of the first \\(\\mathbb{Z}_2\\)-homology of the chain complex, \\(H_1(\\partial, \\mathbb{Z}_2) = \\frac{\\text{Ker}(\\partial_1)}{\\text{Im}(\\partial_2)}\\). The distance of the CSS code is equal to the minimum of the combinatorial (\\(d-1\\))-systole of the cellulated \\(d\\)-dimensional manifold and its dual. For surfaces, there is an upper bound of \\(d \\leq O(\\sqrt{n})\\) on the distance \\cite{arXiv:0810.1983}, therefore codes coming from higher-dimensional spaces are studied for larger distance.\n", "features": {"encoders": ["Stabilizer measurement \\cite{arxiv:1404.2495}."]}, "notes": ["Introduction to CSS dictionary by \\href{https://www.youtube.com/watch?v=SeLpWg_8qlc}{M. Hastings}.", "Original requirement of \\(C_X^\\perp \\subset C_Z\\) \\cite{arXiv:quant-ph/9512032} has been relaxed to absorb \\hyperref[code:hypergraph_product]{hypergraph product} codes."], "relations": {"parents": [{"code_id": "stabilizer", "detail": "Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) weakly self-dual CSS code, with the mapping preserving geometric locality of a code up to a constant factor \\cite{arXiv:1004.3791}."}, {"code_id": "movassagh_ouyang", "detail": "Movassagh-Ouyang codes stem from a prescription that converts an \\textit{arbitrary} classical code into a quantum code."}], "cousins": [{"code_id": "binary_linear", "detail": "Construction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\)."}, {"code_id": "dual", "detail": "CSS codes for which \\(C_X=C_Z \\equiv C\\) are called \\textit{weakly self-dual} since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\)."}]}}, "shor_nine": {"code_id": "shor_nine", "physical": "qubits", "logical": "qubits", "name": "Shor \\([[9,1,3]]\\) code", "introduced": "\\cite{doi:10.1103/PhysRevA.52.R2493}", "description": "Nine-qubit CSS code that is the smallest such code to correct a single-qubit error. Shor's code works by concatenating each qubit of a phase-flip with a bit-flip repetition code. Therefore, the code can correct both type of errors simultaneously. To be specific, a state is phase-flip error-corrected by a three-qubit phase-flip correction code, with parity checks of \\(X_0 X_1I_2\\) and \\(X_0I_1X_2\\) in \\(X\\) basis, where the subscript represents the qubit index. Each logical qubit is encoded using \\begin{align} \\label{eq:phase-flip} \\begin{split} |0\\rangle_{L_P} &= |+_0+_1+_2\\rangle \\\\ |1\\rangle_{L_P} &= |-_0-_1-_2\\rangle . \\end{split} \\end{align} Then, each physical qubit used in \\eqref{eq:phase-flip} is further encoded in the three-qubit bit-flip correction code: \\begin{align} |\\pm _j \\rangle  = \\frac{1}{\\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\\rangle \\pm |1_{j0}1_{j1}1_{j2}\\rangle), \\end{align} each with bit-flip error parity check \\(Z_{j0}Z_{j1}I_{j2}\\) and  \\(Z_{j0}I_{j1}Z_{j2} \\), where \\(j=0,1,2\\). Notice now the phase-flip error parity check is extended as \\(X_j = X_{j0}X_{j1}X_{j2}\\). As a result, the overall parity checks with the flattened qubit index are \\begin{align} \\begin{split} Z_{j0}Z_{j1}I_{j2} &\\rightarrow \\{Z_0Z_1, Z_3Z_4, Z_6Z_7\\} \\\\ Z_{j0}I_{j1}Z_{j2} &\\rightarrow \\{Z_0Z_2, Z_3Z_5, Z_6Z_8\\} \\\\ X_0 X_1I_2  &\\rightarrow  \\{X_0X_1X_2X_3X_4X_5\\}\\\\ X_0 I_1X_2  &\\rightarrow  \\{X_0X_1X_2X_6X_7X_8\\}. \\end{split} \\end{align} The logical state is encoded using \\begin{align} \\begin{split} |\\overline{0}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right)^{\\otimes3}\\\\ |\\overline{1}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle-|111\\rangle\\right)^{\\otimes3}~. \\end{split} \\end{align}", "protection": "The code detects two-qubit errors or corrects an arbitrary single-qubit error.", "realizations": ["Realized in trapped-ion quantum devices, with 98.8(1)\\% and 98.5(1)\\% fidelity for state \\(|\\overline{0}\\rangle\\) and \\(|\\overline{1}\\rangle\\), respectively \\cite{arXiv:2104.01205}. "], "notes": ["Shor's code is the first known quantum error correction code. "], "relations": {"parents": [{"code_id": "quantum_parity", "detail": "Shor's code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes."}], "cousins": [{"code_id": "quantum_repetition", "detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code."}, {"code_id": "quantum_concatenated", "detail": "Shor's code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code."}, {"code_id": "real_projective_plane", "detail": "Shor's code is the smallest surface code defined on the projective plane \\cite{arxiv:quant-ph/9810055}."}]}}, "quantum_parity": {"code_id": "quantum_parity", "physical": "qubits", "logical": "qubits", "name": "Quantum parity code (QPC)", "introduced": "\\cite{arxiv:quant-ph/0501184,arxiv:quant-ph/0006088}", "description": "A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) CSS code family obtained from concatenating an \\(m_1\\)-qubit phase-flip repetition code with an \\(m_2\\)-qubit bit-flip repetition code. Logical codewords are\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}+|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}-|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}~.\n\\end{split}\n\\end{align}\n", "protection": "Has distance \\(d=\\min(m_1,m_2)\\).", "features": {"encoders": ["Non-determinisitic linear-optical encoding \\cite{arxiv:quant-ph/0501184} whose success probability \\(P_{E}\\) is determined by the efficiency \\(\\eta\\) of the photonic encoding circuit. A threshold \\(\\eta > 0.82 \\) exists for the efficiency, above which \\(P_{E}\\to 1\\) as \\(m_1\\to\\infty\\) given particular \\(m_2\\)."]}, "realizations": ["Studied in the context of error-corrected quantum repeaters \\cite{arXiv:1310.5291}."], "relations": {"parents": [{"code_id": "css", "detail": ""}, {"code_id": "quantum_concatenated", "detail": "A QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code."}], "cousins": [{"code_id": "bacon_shor", "detail": "QPC codes are non-gauge instances of Bacon-Shor codes."}]}}, "quantum_repetition": {"code_id": "quantum_repetition", "physical": "qubits", "logical": "qubits", "name": "Quantum repetition code", "description": "Encodes \\(1\\) qubit into \\(n\\) qubits according to \\(|0\\rangle\\to|\\phi_0\\rangle^{\\otimes n}\\) and \\(|1\\rangle\\to|\\phi_1\\rangle^{\\otimes n}\\). Also known as a \\textit{bit-flip} code when \\(|\\phi_i\\rangle = |i\\rangle\\), and a \\textit{phase-flip} code when \\(|\\phi_0\\rangle = |+\\rangle\\) and \\(|\\phi_1\\rangle = |-\\rangle\\).", "protection": "Bit-flip code detects bit-flip errors \\(X\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any phase-flip errors \\(Z\\). Phase-flip code detects phase-flip errors \\(Z\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any bit-flip errors \\(X\\).", "notes": ["Logical basis for the bit-flip code is spanned by GHz (a.k.a. cat) states \\(|0\\rangle^{\\otimes n}\\pm|1\\rangle^{\\otimes n}\\), which are used in Shor error correction."], "realizations": ["15-qubit IBM processor \\cite{arXiv:1709.00990}.", "Sycamore processor by Google Quantum AI \\cite{arXiv:2102.06132}.", "See Table S6 in Ref. \\cite{arXiv:2102.06132} for a history of earlier implementations."], "relations": {"parents": [{"code_id": "css", "detail": ""}], "cousins": [{"code_id": "hamiltonian", "detail": "Bit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions."}]}}, "balanced_product": {"code_id": "balanced_product", "name": "Balanced-product code", "introduced": "\\cite{arxiv:2004.07935}", "description": "Stub.", "relations": {"cousins": [{"code_id": "fiber_bundle", "detail": "Some special cases of balanced product codes are fiber bundle codes \\cite{arXiv:2012.09271}."}, {"code_id": "gauge_stabilizer", "detail": "According to \\cite{arXiv:2012.09271}, distance balancing is a construction for forming balanced-product subsystem codes."}]}}, "hypergraph_product": {"code_id": "hypergraph_product", "physical": "qubits", "logical": "qubits", "name": "Hypergraph product code", "introduced": "\\cite{arXiv:0903.0566,arxiv:1202.0928}", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two binary linear \\textit{seed} codes \\(C_1\\) and \\(C_2\\).", "protection": "The hypergraph product has distance \\(d=O(\\sqrt{n})\\). The number of encoded logical qubits is \\(k=O(k_1k_2)\\) where \\(k_1\\) and \\(k_2\\) are the dimensions of the classical seed codes \\(C_1\\) and \\(C_2\\).", "relations": {"parents": [{"code_id": "lifted_product", "detail": "Lifted-product codes for trivial group \\(G\\) are hypergraph-product codes."}, {"code_id": "homological_product", "detail": "Hypergraph product obtained from the homological product of two length-two chain complexes, i.e., classical binary codes."}]}}, "permutation_invariant": {"code_id": "permutation_invariant", "physical": "qubits", "logical": "qubits", "name": "Permutation-invariant code", "introduced": "\\cite{arXiv:quant-ph/0304153}", "description": "Codes which are stabilized by the symmetric group \\(S_n\\) on \\(n\\) elements, in a generalization of stabilizer codes to binary codes utilizing (non-abelian) group actions (in particular, \\(S_n\\) is non-abelian).", "protection": "Depends on the family. The GNU permutation-invariant family (parameterized by \\(t\\)) protects against arbitrary weight \\(t\\) qubit errors and approximately corrects spontaneous decay errors \\cite{arXiv:1302.3247,doi:10.1103/PhysRevA.93.042340}. Other related codes protect against amplitude damping \\cite{doi:10.1109/TIT.2019.2956142} while admitting a constant number of excitations, and against deletion errors \\cite{arxiv:2102.02494,arXiv:2102.03015}.", "features": {"encoders": ["With quantum harmonic oscillators (superconducting charge qubits in a ultrastrong coupling regime) in \\(O(N)\\) as in \\cite{doi:10.1103/PhysRevA.99.012335}. Can be done in \\(O(N^2)\\) steps using quantum circuits \\cite{arXiv:1904.07358}, or using geometric phase gates in \\(O(N)\\) \\cite{arxiv:1908.01120}."], "decoders": ["For a family of codes, using projection, probability amplitude rebalancing, and gate teleportation can be done in \\(O(N^2)\\) \\cite{arXiv:2102.02494}."]}, "notes": ["Can be constructed using real polynomials for high-dimensional qudit spaces \\cite{doi:10.1016/j.laa.2017.06.031}."], "relations": {"parents": [{"code_id": "qubits_into_qubits", "detail": ""}], "cousins": [{"code_id": "quantum_cyclic", "detail": "The cyclic group of these codes is a subgroup of the \\(S_n\\) symmetric group used in permutation invariant codes."}]}}, "monitored_random_circuits": {"code_id": "monitored_random_circuits", "physical": "groups", "logical": "qubits", "name": "Monitored Random Circuits", "introduced": "\\cite{doi:10.1103/PhysRevX.9.031009,doi:10.1103/PhysRevB.98.205136,arXiv:1808.05949}", "description": "A monitored random circuit is described by a series of intermittant random local projective Pauli measurements with random unitary time-evolution operators. An important sub-family consists of \\textit{Clifford monitored random circuits}, where unitaries are sampled from the Clifford group \\cite{arxiv:1901.08092}. When the rate of projective measurements is independently controlled by a probability parameter \\(p\\), there can exist two stable phases, one described by volume-law entanglement entropy and the other by area-law entanglement entropy. The phases and their transition can be understood from the perspective of quantum error correction, information scrambling, and channel capacities \\cite{arXiv:1903.05124,arXiv:1905.05195}.\n\nMonitored random circuits have a finite information capacity that decays exponentially with respect to system size \\cite{arXiv:1905.05195}. When \\( p = 0 \\), the random circuit achieves channel capacity, meaning that it stores the most amount of information possible. This notion quantifies the recoverability of information and the reversability of the system under the monitored random dynamics. In the volume-law phase (\\( p < p_c \\) for some critical probability \\(p_c\\)), the channel capacity remains non-zero, and the monitored channel projects an initial state into a random error-correcting code \\cite{arXiv:1905.05195}. With appropriately chosen evolution operators and measurements, the code is a stabilizer code whose parameters depend on time, \\( [[n,k(t),d(t)]] \\). A similar notion applies to Haar random circuits with measurements \\cite{arXiv:1911.00008}.\n\nIn this case, the time-evolved projective measurement at time step \\(j\\) is given by \\( P_j = U_{\\tau} \\cdots U_j P_j^\u2019 (U_{\\tau} \\cdots U_j)^{\\dagger} \\). Thus the monitored random circuit just implements a series of projective measurements at various time steps.\n", "protection": "When in the volume-law phase, protects against random projective measurements at a rate \\( p < p_c \\). While the true code distance is not known, it is conjectured to be proportional to the contiguous distance. As first described in Ref. \\cite{arXiv:1905.05195}, the  contiguous distance for these circuits is defined with respect to all partitions of the system.", "features": {"rate": "Rate can be finite \\cite{arXiv:1905.05195}, depending on the family of random codes generated by the circuit.", "encoders": ["The dynamics of the monitored random circuit can be recast in the language of stabilizer codes \\cite{arXiv:1905.05195}. The stabilizer group of the error-correcting code resulting from a monitored Clifford circuit either grows or shrinks with each time step, depending on which projective measurements were performed during the time step.", "One can construct optimal single-copy encoding operations for strong purification transitions \\cite{arXiv:1905.05195}"], "decoders": ["The recovery operation is the reverse unitary transformation with access to the measurement record (for dynamically generated codes with a strong purification transition) \\cite{arXiv:1905.05195}"], "threshold": ["Above the critical measurement rate \\( p_c\\), the natural error correction properties of the circuit can no longer protect the information. This can be interpreted as the code threshold.", "These dynamically generated codes saturate the trade off between density of encoded information and the error rate threshold \\cite{arXiv:1905.05195}"]}, "realizations": ["Measurement induced quantum phases have been realized in a trapped-ion processor \\cite{arXiv:2106.05881}."], "notes": ["Connections to information scrambling in black hole physics, as introduced in Section 11 of \\cite{arXiv:1903.05124}. In particular, monitored random circuits can be viewed as the Hayden-Preskill recovery problem \\cite{doi:10.1103/PhysRevD.100.086001} running backwards in time. In this setting, the volume-law entanglement phase of the monitored circuit describes the phase when information can be recovered from an old black hole (ie, a black hole that is maximally entangled with the early universe).", "Mapping monitored random circuits to statistical mechanics models can help estiamte thresholds and code distances for these systems \\cite{arXiv:2007.03822}."], "relations": {"parents": [{"code_id": "random_circuit", "detail": "Monitored random circuits are random circuits where projective measurements are interspersed throughout the circuit and measurement results are recorded."}], "cousins": [{"code_id": "topological", "detail": "Topological order can be generated in 2D monitored random circuits \\cite{arXiv:2011.06595}"}]}}, "quantum_polar": {"code_id": "quantum_polar", "physical": "qubits", "logical": "qubits", "name": "Quantum polar code", "introduced": "\\cite{arxiv:1109.3195}", "description": "Stub.", "protection": "", "relations": {"parents": [{"code_id": "css", "detail": ""}], "cousins": [{"code_id": "polar", "detail": ""}]}}, "stabilizer_over_gf4": {"code_id": "stabilizer_over_gf4", "physical": "qubits", "logical": "qubits", "name": "Stabilizer code over \\(GF(4)\\)", "introduced": "\\cite{arXiv:quant-ph/9608006}", "description": "An \\([[n,k,d]]\\) stabilizer code whose encoding is based on a self-dual quaternary \\([n, n-k, d^*]_4\\) code over \\(GF(4)^n\\) with respect to the trace inner product where \\(d \\ge d^*\\).\n\\(GF(4)\\) consists of \\(\\{0, 1, w, \\bar{w}\\}\\), with \\(\\bar{w} = w^2 = w + 1\\), \\(\\mathrm{Tr}(x) = x+\\bar{x}\\), and trace inner product \\(u * v = \\mathrm{Tr}(u \\cdot \\bar{v})\\).\nThere is a mapping \\(L\\) between Pauli matrices \\(I, Y, Z, X\\) and \\(0, 1, \\bar{w}, w\\), in turn \\([A, B] \\Leftrightarrow Tr\\langle L(A), L(A)\\rangle\\).\nThe classical self-dual code \\(C\\) over \\(GF(4)^n\\) corresponds to the stabilizer group \\(\\mathsf{S}\\) while \\(C^{\\perp}\\) corresponds to \\(\\mathsf{N(S)}\\).\n", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "relations": {"parents": [{"code_id": "stabilizer", "detail": ""}], "cousins": [{"code_id": "q-ary_linear", "detail": "Quaternary \\(q=4\\) linear codes are used in this construction."}]}}, "xyz_hexagonal": {"code_id": "xyz_hexagonal", "physical": "qubits", "logical": "qubits", "name": "XYZ\\(^2\\) hexagonal stabilizer code", "introduced": "\\cite{arXiv:2112.06036}", "description": "Stub.", "relations": {"parents": [{"code_id": "matching", "detail": ""}]}}, "quantum_ldpc": {"code_id": "quantum_ldpc", "physical": "qubits", "logical": "qubits", "name": "Quantum low-density parity-check (QLDPC) code", "description": "Family of \\([[n,k,d]]\\) stabilizer codes for which the number of qubits participating in each stabilizer generator and the number of stabilizer generators that each qubit participates in are both bounded by a constant as \\(n\\to\\infty\\).", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. Asymptotic scaling of \\(k\\) and \\(d\\) with \\(n\\) is often of interest, and this depends heavily on the code construction.\nA \\textit{good quantum LDPC code} family satisfies \\(k \\in \\theta(n) \\) and \\(d \\in \\theta(n)\\) \\cite{doi:10.1103/PRXQuantum.2.040101}, and the first examples of good codes are a family of \\hyperref[code:lifted_product]{lifted-product codes}.\nA \\textit{geometrically local LDPC code} is an LDPC code where the qubits involved in any syndrome bit are contained in a fixed volume that does not scale with \\(n\\); such codes are limited to having \\(d=O(n^{1-1/D})\\) for \\(D\\)-dimensional lattice geometries \\cite{arxiv:0810.1983}.", "features": {"threshold": ["Quantum LDPC codes with a constant encoding rate can reduce the overhead of fault-tolerant quantum computation to be constant \\cite{arXiv:1310.2984}."]}, "notes": ["Links to code tables \\cite{doi:10.1103/PRXQuantum.2.040101}."], "relations": {"parents": [{"code_id": "stabilizer", "detail": ""}], "cousins": [{"code_id": "ldpc", "detail": ""}, {"code_id": "hamiltonian", "detail": "Codespace is the ground-state space of a local \\textit{code Hamiltonian}, consisting of an equal linear combination of stabilizer generators."}, {"code_id": "dynamic_gen", "detail": "QLDPC codes can arise form a dynamical process \\cite{arxiv:2004.09560}."}]}}, "happy": {"code_id": "happy", "physical": "qubits", "logical": "qubits", "name": "Pastawski-Yoshida-Harlow-Preskill (HaPPY) code", "introduced": "\\cite{arxiv:1503.06237}", "description": "Holographic code constructed out of a network of perfect tensors that tesselates hyperbolic space. Physical qubits are associated with uncontracted tensor legs at the boundary of the tesselation, while logical qubits are associated with uncontracted legs in the bulk. The code serves as a minimal model for several aspects of the AdS/CFT holographic duality. The construction below is described for qubits, but straightforward generalizations exist to cyclic qudits, oscillators, and rotors \\cite{arXiv:1902.07714}.\n\nEncoding is accomplished using a tensor network of \\([[5,1,3]]\\) encoding isometries, which are six-legged perfect tensors (with five legs corresponding to the physical qubits and one for the encoded logical qubit). A \\(2n\\)-legged \\textit{perfect tensor} is proportional to an isometry for any bipartition of its indices into a set \\(A\\) and a complementary set \\(A^{\\perp}\\) such that \\(|A|\\leq|A^{\\perp}|\\).\n\nTo construct the encoding, one first uniformly tiles the hyperbolic AdS/CFT disc using pentagons and hexagons. Then, one places a 6-legged \\([[5,1,3]]\\) encoding tensor at each hexagon and pentagon, contracting legs between neighboring shapes and leaving one leg uncontracted at each pentagon. This construction forms an encoding isometry from the uncontracted legs in the bulk to the uncontracted legs at the boundary.\n", "protection": "Protects against erasure errors and Pauli errors on the boundary qubits.", "features": {"rate": "The pentagon HaPPY code converges to \\(\\frac{1}{\\sqrt{5}} \\approx 0.447\\). The pentagon/hexagon HaPPY code, with alternating layers of pentagons and hexagons in the tiling, has a rate of \\(0.299\\) if the last layer is a pentagon layer and a rate of \\(0.088\\) if the last layer is a hexagon layer.", "encoders": ["Heisenberg-picture encoding is done through \\textit{tensor pushing}. Each bulk operator (logical) is pushed to an operator supported on a portion of the boundary region (physical). Pushing all the bulk operators through results in reconstruction of the boundary."], "transversal_gates": "For locality-preserving physical gates on the boundary, the set of transversally implementable logical operations in the bulk is strictly contained in the Clifford group \\cite{arxiv:2103.13404}.", "decoders": ["Greedy algorithm for decoding specified in Ref. \\cite{arxiv:1503.06237}."], "threshold": ["\\(26\\%\\) for boundary erasure errors on the the pentagon/hexagon HaPPY code, which has alternating layers of pentagons and hexagons in the tiling.", "\\(\\sim 50\\%\\) for boundary erasure errors on the single-qubit HaPPY code, which has a central pentagon encoding one bulk operator and hexagons tiling all other layers", "\\(16.3\\%\\) for boundary Pauli errors on the single-qubit HaPPY code with 3 layers \\cite{arxiv:2008.10206}.", "There is no threshold for the pentagon HaPPY code as a constant number of errors (two) can make bulk recovery impossible."]}, "relations": {"parents": [{"code_id": "holographic"}], "cousins": [{"code_id": "stabilizer", "detail": "The HaPPY code is a stabilizer code because it is defined by a contracted network of stabilizer tensors; see Thm. 6 in Ref. \\cite{arxiv:1503.06237}."}, {"code_id": "stab_5_1_3", "detail": "The \\([[5,1,3]]\\) encoding isometry tiles various holographic codes because its corresponding tensor is perfect \\cite{arXiv:1503.06237}."}]}}, "stab_15_1_3": {"code_id": "stab_15_1_3", "physical": "qubits", "logical": "qubits", "name": "\\([[15,1,3]]\\) Reed-Muller code", "description": "\\([[15,1,3]]\\) CSS code that is most easily thought of as a tetrahedral 3D color code.\nThis code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center.\nThe tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers.\nEach colored cell corresponds to a weight-8 \\(X\\)-check, and each face corresponds to a weight-4 \\(Z\\)-check.\nA logical \\(Z\\) is any weight-3 \\(Z\\)-string along an edge of the entire tetrahedron.\nThe logical \\(X\\) is any weight-7 \\(X\\)-face of the entire tetrahedron.\n", "features": {"rate": "Magic-state distillation scaling exponent \\( \\gamma= \\log_d (n/k)\\approx 2.46\\) \\cite{arXiv:1703.07847}.", "transversal_gates": "A transversal logical \\(T^\\dagger\\) is implemented by applying a \\(T\\) gate on every qubit \\cite{arXiv:quant-ph/9610011,arXiv:1403.2734,arXiv:1612.07330}.", "general_gates": ["Code is often used in magic-state distillation protocols because of its transversal \\(T\\) gate \\cite{arXiv:quant-ph/0403025}."], "fault_tolerance": ["Combining the Steane code and the 15-qubit Reed-Muller code through a fault-tolerant conversion can result in a universal transversal gate set that does not need magic state distillation \\cite{arXiv:1403.2734,arXiv:1703.03860}."]}, "notes": ["The \\([[15,1,3]]\\) code can be converted into the smallest known stabilizer code with a fault-tolerant logical \\(T\\) gate (i.e., the \\([[10,1,2]]\\) code) through a \"morphing procedure\" \\cite{arXiv:2112.01446}."], "relations": {"parents": [{"code_id": "quantum_reed_muller", "detail": "The \\([[15,1,3]]\\) code is often noted as the 15-qubit quantum Reed-Muller code in the literature."}, {"code_id": "quantum_triorthogonal", "detail": "The \\([[15, 1, 3]]\\) code is a triorthogonal code \\cite{arXiv:2107.09684}"}]}}, "quantum_triorthogonal": {"code_id": "quantum_triorthogonal", "physical": "qubits", "logical": "qubits", "name": "Triorthogonal code", "introduced": "\\cite{arXiv:1209.2426}", "description": "A triorthogonal \\(m \\times n\\) binary matrix is triorthogonal if its rows \\(r_1, \\ldots, r_m\\) satisfy \\(|r_i \\cdot r_j| = 0\\) and \\(|r_i \\cdot r_j \\cdot r_k| = 0\\), where addition and multiplication are done on \\(\\mathbb{Z}_2\\). The triorthogonal code associated with the matrix is constructed by mapping non-zero entries in even-weight rows to \\(X\\) operators, and \\(Z\\) operators for each row in the orthogonal complement.", "protection": "Weight \\(t\\) Pauli errors, where \\(t\\) depends on the family. For example, Ref. \\cite{arXiv:1209.2426} provides a family of distance \\(2\\) codes. It also presents a \\([[49, 1, 5]]\\) code.", "features": {"rate": "Depends on the matrix. Ref. \\cite{arXiv:1209.2426} gave a family of \\(\\frac{k}{3k+8}\\) codes with magic-state distillation scaling exponent \\(\\gamma = \\log_2 \\frac{3k+8}{k}\\).", "encoders": ["Encoder for magic states for the code constructed in \\cite{arXiv:1209.2426}."], "transversal_gates": "Admits transversal \\(T\\) gates \\cite{arXiv:1209.2426} and the controlled-controlled-\\(Z\\) gate.", "general_gates": ["Triorthogonal codes can be used for high-quality magic-state distillation \\cite{arXiv:1209.2426}."], "threshold": ["Approximately \\(\\frac{1}{3k + 1}\\) \\cite{arXiv:1209.2426}."]}, "notes": ["Reference \\cite{arXiv:2107.09684} presents a classification of triorthogonal codes up to \\(n + k \\leq 38\\) by associating each triorthogonal code with a Reed-Muller polynomial."], "relations": {"parents": [{"code_id": "css", "detail": ""}], "cousins": [{"code_id": "quantum_reed_muller", "detail": "Classification of triorthongonal codes yields a connection to Reed-Muller polynomials \\cite{arXiv:2107.09684}."}]}}, "lifted_product": {"code_id": "lifted_product", "physical": "qubits", "logical": "qubits", "name": "Lifted product code", "introduced": "\\cite{arXiv:1904.02703}", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two linear \\textit{seed} codes \\(C_1\\) and \\(C_2\\) with a free action of a group \\(G\\). Lifted product codes can also be defined over arbitrary matrix rings.", "protection": "Code performance strongly depends on \\(G\\), but lifted product codes contain \\cite{arXiv:2111.03654} families of QLDPC codes with the parameters \\([[n, k = \\Theta(n), d = \\Theta(n)]]\\).", "features": {"rate": "Lifted product codes include the first examples \\cite{arXiv:2111.03654} of \\textit{good QLDPC codes}, i.e., codes with asymptotically constant rate and linear distance. The existence of such codes proves the QLDPC conjecture \\cite{arXiv:2103.06309}.", "decoders": ["BP-OSD decoder \\cite{arXiv:1904.02703}."]}, "relations": {"parents": [{"code_id": "homological_product", "detail": "Lifted product obtained from the homological product over a group algebra \\(\\mathbb{F}_2 G\\) of two length-two chain complexes over \\(\\mathbb{F}_2 G\\), i.e., classical binary codes with a free action of the group \\(G\\)."}]}}, "xzzx": {"code_id": "xzzx", "physical": "qubits", "logical": "qubits", "name": "XZZX surface code", "introduced": "\\cite{arXiv:2009.07851}", "description": "A family of stabilizer codes whose generators are \\(XZXZ\\) Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "notes": ["Originally formulated as an example of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model \\cite{arxiv:quant-ph/0205004}."], "features": {"threshold": ["\\(50\\%\\) with pure \\(X\\) or \\(Z\\) errors and both a maximum-likelihood decoder and a minimum-weight perfect-matching decoder.", "\\(18.7\\%\\) at standard depolarising noise with a maximum-likelihood decoder.", "For large but finite \\(X\\)- or \\(Z\\)-biased noise, the code's thresholds exceed the zero-rate hashing bound.\nThe gap exceeds \\(2.9\\%\\) when \\(X\\) (\\(Z\\)) error is \\(300\\) times more frequent than other Paulis.\n"]}, "relations": {"parents": [{"code_id": "surface", "detail": "\\(XZZX\\) code is obtained from the surface code by Hadamard gates."}], "cousins": [{"code_id": "fracton", "detail": "Subsystem symmetries play a role in finite-bias decoders for both codes \\cite{arXiv:1901.08061}."}]}}, "real_projective_plane": {"code_id": "real_projective_plane", "physical": "qubits", "logical": "qubits", "name": "Projective-plane surface code", "introduced": "\\cite{arXiv:quant-ph/9810055}", "description": "A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold \\(\\mathbb{R}P^2\\) (in contrast to a genus-\\(g\\) surface). Whereas genus-\\(g\\) surface codes require \\(2g\\) logical qubits, qubit codes on \\(\\mathbb{R}P^2\\) are made from a single logical qubit.", "protection": "If \\(\\mathcal{C}\\) is a cellulation of \\(\\mathbb{R}P^2\\), then the bit-flip distance \\(d_X\\) is the shortest cycle in \\(\\mathcal{C}\\), and the phase-flip distance \\(d_Z\\) is the shortest cycle in the dual cellulation \\(\\mathcal{C}^*\\).", "features": {"rate": "The rate is \\(1/n\\), where \\(n\\) is the number of edges of the particular cellulation."}, "relations": {"parents": [{"code_id": "surface", "detail": "Surface code on the real projective plane."}]}}, "surface": {"code_id": "surface", "physical": "qubits", "logical": "qubits", "name": "Kitaev surface code", "introduced": "\\cite{doi:10.1007/978-1-4615-5923-8_19,arXiv:quant-ph/9707021}", "description": "A family of \\hyperref[code:css]{CSS stabilizer} codes whose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a cellulation of a two-dimensional surface (with a qubit located at each edge of the cellulation). \\textit{Toric code} often either refers to the construction on the two-dimensional torus or is an alternative name for the general construction. The construction on surfaces with boundaries is often called the \\textit{planar code} \\cite{arXiv:quant-ph/9811052}.\n\nThe original construction can be naturally extended to arbitrary dimensional manifolds \\cite{doi:10.1007/978-3-642-01877-0_21}. Given a cellulation, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers are associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\(i+1\\)-faces.\n", "protection": "Toric code on an \\(L\\times L\\) torus is a \\([[2L^2,2,L]]\\) CSS code, and there exists a planar code with \\([[L^2,1,L]]\\) \\cite{arxiv:1111.4022}. More generally, the code distance is related to the homology of the cellulation \\cite{arXiv:quant-ph/0110143}.", "features": {"rate": "Rate depends on the underlying cellulation and manifold. For general 2D manifolds, \\(kd^2\\leq c(\\log k)^2 n\\) for some constant \\(c\\) \\cite{arXiv:1301.6588}, meaning that surface codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\).", "transversal_gates": "Pauli gates on torus geometry.", "general_gates": ["Clifford gates can be implemented via lattice surgery \\cite{arXiv:1111.4022,arXiv:1709.02318} or braiding defects \\cite{arXiv:quant-ph/0610082,arXiv:quant-ph/0703143,arXiv:1208.0928,arXiv:1609.04673}.", "Non-Clifford gates require magic state distillation \\cite{arXiv:1905.06903} or just-in-time decoding \\cite{arXiv:1903.11634}."], "threshold": ["\\(10.9\\%\\) with independent \\(X/Z\\) errors for square tiling \\cite{arXiv:0811.0464}.", "\\(18.9\\%\\) with depolarizing noise for square tiling \\cite{arXiv:1202.1852}.", "\\(50\\%\\) with loss errors for square tiling \\cite{arXiv:0904.3556}.", "\\(3.3\\%\\) with phenomenological noise for square tiling \\cite{arXiv:quant-ph/0401101}.", "\\(0.5-1.1\\%\\) for various error models \\cite{arXiv:1311.5003}."], "encoders": ["Unitary \\cite{arXiv:0712.0348,arXiv:2002.00362,arXiv:2110.02020}.", "Dissipative \\cite{arXiv:1310.1036}.", "Stabilizer measurement-based \\cite{arXiv:1404.2495}."], "decoders": ["Minimum weight perfect-matching \\cite{arXiv:quant-ph/0110143,doi:10.26421/QIC15.1-2-9}, union-find \\cite{arXiv:1709.06218}, renormalization group \\cite{doi:10.26421/QIC14.9-10-1,arXiv:1411.3028}, tensor network \\cite{arXiv:1405.4883}, Markov chain Monte Carlo \\cite{arXiv:1302.2669}, cellular automaton \\cite{arXiv:1511.05579}, machine learning \\cite{arXiv:1610.04238,arXiv:1802.06441,arXiv:1810.07207}."]}, "notes": ["2D and 3D surface code \\href{http://gui.quantumcodes.io/}{visualization tool}.", "Toric code introductions from error-correction perspective by \\href{https://boulderschool.yale.edu/2018/boulder-school-2018-lecture-notes}{J. Haah} and condensed-matter perspective by \\href{https://boulderschool.yale.edu/2016/boulder-school-2016-lecture-notes}{M. Levin and C. Nayak}."], "realizations": ["Distance-two surface codes have been implemented by Andersen et al. \\cite{arXiv:1912.09410}, Erhard et al. \\cite{arXiv:2006.03071}, and Google Quantum AI \\cite{doi:10.1038/s41586-021-03588-y}.", "Signatures of corresponding topological phase of matter detected in superconducting circuits \\cite{arxiv:2104.01180} and two-dimensional arrays of Rydberg atoms \\cite{arXiv:2104.04119}.", "Distance-three surface code implemented at ETH Zurich \\cite{arxiv:2112.03708}."], "relations": {"parents": [{"code_id": "css", "detail": "Plaquette and star operators are stabilizer generators."}, {"code_id": "topological", "detail": "When treated as ground states of the code Hamiltonian, the code states realize \\(\\mathbb{Z}_2\\) topological order, a topological phase of matter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory \\cite{doi:10.1063/1.1665530}."}], "cousins": [{"code_id": "quantum_ldpc", "detail": "Stabilizer generator weights and qubit degrees are given by the properties of the cellulation, and most cellulations yield QLDPC codes."}, {"code_id": "hypergraph_product", "detail": "Planar (toric) code obtained from hypergraph product of two repetition (cyclic) codes."}]}}, "four_dimensional_hyperbolic": {"code_id": "four_dimensional_hyperbolic", "physical": "qubits", "logical": "qubits", "name": "Guth-Lubotzky hyperbolic surface code", "introduced": "\\cite{arXiv:1310.5555}", "description": "A family of LDPC CSS codes with linear rate based on cellulations of four-dimensional manifolds that is based on a natural extension of Kitaev's surface-code construction. The manifolds are shown to have good homology and systolic properties for the purposes of code construction.\n\nIn particular, Guth and Lubotzky \\cite{arXiv:1310.5555} show that there exists \\(\\epsilon\\), a four-dimensional hyperbolic manifold \\(M\\), and a sequence of manifolds \\(M_i\\) such that\neach \\(M_i\\) is a finite sheeted \\href{https://en.wikipedia.org/wiki/Covering_space}{covering} of \\(M\\), and the four-dimensional volumes of the manifolds \\(Vol_4(M_i)\\) of the sequence tend to infinity.\nAlso, the dimension of the second homology and size of systoles are bounded by \\(H_2(M_i, Z_2) \\geq \\frac{Vol_4(M_i)}{100}\\) and \\(Sys_2(M_i) \\geq Vol_4(M_i)^\\epsilon\\), respectively.\n\nThen given any cellulation of \\(M\\), it can naturally be extended to cellulations for each of the manifolds \\(M_i\\) and used to define CSS codes via the homological construction by choosing the size three chain complex consisting of the \\(3,2\\) and \\(1\\)-cells of the cellulations.\n\nFor dense cellulations (i.e. large \\(n\\)) the number of physical qubits for these codes will scale with the volume of the manifolds.\nTherefore, bounds on the dimension of the second homology and size of systoles are achieved in terms of \\(n\\) for large \\(n\\).\n", "protection": "Protection stems from the relationship between properties of manifolds and CSS codes derived from their cellulation. The number of physical \\(k\\) qubits and distance \\(d\\) of the code will scale as \\(\\Omega(n)\\) and \\(\\Omega(n^\\epsilon)\\).", "relations": {"parents": [{"code_id": "surface", "detail": "The Guth-Lubotzky code is an extension of the surface code to the 4D hyperbolic setting \\cite{arxiv:1712.08578}."}]}}, "two_dimensional_hyperbolic_surface": {"code_id": "two_dimensional_hyperbolic_surface", "physical": "qubits", "logical": "qubits", "name": "Two-dimensional hyperbolic surface code", "introduced": "\\cite{arXiv:1506.04029}", "description": "A family of Kitaev surface codes based on a tessellation of a closed 2D manifold with a hyperbolic geometry (i.e., non-Euclidean geometry; think saddle surfaces when defined on a 2D plane).\n\nFor a tessellation involving regular polygons with \\( r \\) sides and \\( s \\) polygons meeting at each edge, the number of logical qubits is given by \\( k = (1-2/r - 2/s) n + 2 \\). Some possible tilings are \\( {r,s}: {7,3}, {5,4} \\). The weight of the stabilizer generators are dependent on the tiling, with \\({5,4}\\) having lower weight than \\({7,3}\\).\n", "protection": "Protects against Pauli errors with distance \\( d \\propto \\log(n) \\). Code parameters are \\( [[n, (1-2/r - 2/s)  n + 2, \\log(n) ]] \\)", "features": {"rate": "Two-dimensional hyperbolic surface codes have an asymptotically constant encoding rate \\( k/n \\) with a distance scaling logarithmically with \\( n\\) when the surface is closed. The encoding rate depends on the tiling \\( {r,s} \\) and is given by \\( k/n = (1-2/r - 2/s) + 2/n \\), which approaches a constant value as the number of physical qubits grows. The weight of the stabilizers is \\( r \\) for \\( Z \\)-checks and \\( s \\) for \\( X \\)-checks. For open boundary conditions, the code reduces to constant distnace.", "decoders": ["Due to the symmetries of hyperbolic surface codes, optimal measurement schedules of the stabilizers can be found \\cite{arXiv:2010.09626}."], "threshold": ["1\\(\\%\\) - 5\\(\\%\\) for a \\({5,4}\\) tiling under minimum-weight decoding \\cite{doi:10.1103/PhysRevA.87.020304}. For larger tilings, the lower bound on the distance decreases, suggesting the threshold will also decrease."]}, "notes": ["See Sec III A of Ref. \\cite{arXiv:2103.06309} for a description of this code.", "Connection to percolation theory as shown in \\cite{arXiv:1205.7036}."], "relations": {"parents": [{"code_id": "surface", "detail": "Surface code on a two-dimensional hyperbolic surface."}]}}, "hybrid_qudit_oscillator": {"code_id": "hybrid_qudit_oscillator", "physical": "qudits", "logical": "groups", "name": "Hybrid qudit-oscillator code", "description": "Encodes a \\(K\\)-dimensional logical Hilbert space into \\(n_1\\) qudits of dimension \\(q\\) and \\(n_2 \\neq 0\\) oscillators, i.e., the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{Z}_q^{n_1} \\times \\mathbb{R}^{n_2}\\).", "protection": "", "relations": {"parents": [{"code_id": "oscillators", "detail": "The physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator."}], "cousins": [{"code_id": "qudits_into_oscillators", "detail": "Hybrid code with \\(n_1=0\\)."}]}}, "gkp": {"code_id": "gkp", "physical": "oscillators", "logical": "qudits", "name": "Gottesman-Kitaev-Preskill (GKP) code", "introduced": "\\cite{doi:10.1103/PhysRevA.64.012310}", "description": "Bosonic qudit-into-oscillator code whose stabilizers are oscillator displacement operators \\(\\hat{S}_q(2\\alpha)=e^{-2i\\alpha \\hat{p}}\\) and \\(\\hat{S}_p(2\\beta)=e^{2i\\beta \\hat{q}}\\). To ensure \\(\\hat{S}_q(2\\alpha)\\) and \\(\\hat{S}_p(2\\beta)\\) generate a stabilizer group that is Abelian, there is another constraint that \\(\\alpha\\beta=2k\\pi\\) where \\(k\\) is an integer. Codewords can be expressed as equal weight superpositions of coherent states on an infinite lattice, such as a square lattice in phase space with spatial period \\(2\\sqrt{\\pi}\\). The exact GKP state is non-normalizable, so approximate constructs have to be considered.", "protection": "For stabilizer \\(\\hat{S}_q(2\\alpha),\\hat{S}_p(2\\beta)\\), code can correct displacement errors up to \\(\\frac{\\alpha}{2}\\) in the \\(q\\)-direction and \\(\\frac{\\beta}{2}\\) at \\(p\\)-direction. Approximately protects against photon loss errors \\cite{doi:10.1103/PhysRevA.93.012315}, outperforming most other codes designed to explicitly protect against loss \\cite{arxiv:1708.05010}. Very sensitive to dephasing errors \\cite{doi:10.1103/PRXQuantum.2.020101}. A biased-noise GKP error correcting code can be prepared by choosing \\(\\alpha\\neq \\beta\\).", "features": {"encoders": ["Preparation of approximate GKP states is studied both theoretically and experimentally on circuit-QED platforms, by putting the GKP lattice inside a Gaussian envelope \\cite{doi:10.1103/PhysRevA.93.012315}, \\cite{doi:10.1103/PhysRevA.97.022341}, \\cite{doi:10.1038/s41586-020-2603-3}."], "transversal_gates": "Clifford gates can be realized by performing linear optics operations, sympletic transformations and displacements \\cite{doi:10.1103/PhysRevA.64.012310}, all of which are Gaussian operations. Pauli gates can be performed using displacement operators.", "general_gates": ["By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements \\cite{doi:10.1103/PhysRevLett.123.200502}."], "decoders": ["Syndrome measruement of displacement error can be done by applying a controlled-displacement controlled by an ancilla qubit. The syndrome information can be obtained by measuring the ancilla qubit after controlled-displacement opearation. See Section. 2D in \\cite{doi:10.1103/PRXQuantum.2.020101}.", "Pauli \\(X\\),\\(Y\\) and \\(Z\\) measurements can be performed by measuring \\(-\\hat{p},\\hat{q}-\\hat{p}\\) and \\(\\hat{q}\\) repectively. If the measurement outcome is closed to an even multiple of \\(\\sqrt{\\pi}\\), then the outcome is +1. If the measurement outcome is closed to an odd multiple of \\(\\sqrt{\\pi}\\), then the outcome is -1. See Section. 2D in \\cite{doi:10.1103/PRXQuantum.2.020101}."]}, "realizations": ["Approximate GKP code is realized on a superconducting microwave cavity \\cite{doi:10.1038/s41586-020-2603-3} and a trapped-ion oscillator \\cite{doi:10.1038/s41586-019-0960-6}."], "relations": {"parents": [{"code_id": "qudits_into_oscillators", "detail": ""}], "cousins": [{"code_id": "approximate_qecc", "detail": "GKP codes approximately protect against photon loss \\cite{arxiv:1708.05010}."}, {"code_id": "stabilizer", "detail": "GKP codes are a continuous-variable analogue of stabilizer codes."}]}}, "oscillators_into_oscillators": {"code_id": "oscillators_into_oscillators", "physical": "oscillators", "logical": "oscillators", "name": "Oscillator-into-oscillator code", "introduced": "\\cite{arXiv:quant-ph/9711021,arXiv:quant-ph/9711049}", "description": "Encodes Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}^k\\) into that on \\(\\mathbb{R}^n\\). Usually denoted as \\(((n,k))_{\\mathbb{R}}\\).", "protection": "", "relations": {"parents": [{"code_id": "oscillators", "detail": "Bosonic code with infinite-dimensional logical subspace."}]}}, "oscillators": {"code_id": "oscillators", "physical": "oscillators", "name": "Bosonic code", "description": "Also called an \\textit{oscillator} or a \\textit{continuous-variable (CV)} code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one \\textit{oscillator} or \\textit{mode} (i.e., one copy of the space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}\\)). Ideal codewords may not be normalizable, so approximate versions have to be constructed.", "protection": "", "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "qudits_into_oscillators": {"code_id": "qudits_into_oscillators", "physical": "oscillators", "logical": "qudits", "name": "Qudit-into-oscillator code", "description": "Encodes \\(K\\)-dimensional Hilbert space into Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}^n\\).", "protection": "", "relations": {"parents": [{"code_id": "oscillators", "detail": "Bosonic code with finite-dimensional logical subspace."}]}}, "very-small-logical-qubit": {"code_id": "very-small-logical-qubit", "physical": "groups", "logical": "qubits", "name": "Very small logical qubit (VSLQ) code", "introduced": "\\cite{doi:10.1103/PhysRevLett.116.150501}", "description": "The two logical codewords are \\(|\\pm\\rangle \\propto (|0\\rangle\\pm|2\\rangle)(|0\\rangle\\pm|2\\rangle)|0\\rangle|0\\rangle\\), where the total Hilbert space is the tensor product of two qudits (whose ground states \\(|0\\rangle\\) and second excited states \\(|2\\rangle\\) are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.", "protection": "Passively protects against single photon loss.", "features": {"encoders": ["Engineering a circuit made of two transmons and two oscillators coupled through three driven superconducting quantum interference devices (SQUIDs) results in passive stabilization of the logical states."], "general_gates": ["Single logical qubit operations implemented by resonant physical qubit driving and phase shifting the SQUID drives.", "A CZ gate between two logical qubits implemented by coupling devices through another driven SQUID and applying a pulse to the coupling squid simultaneously with a single qubit operation on one of the logical qubits."], "decoders": ["Logical qubit can be measured with physical qubit measurements along \\(X\\). Can be implemented by engineering a coupling of one of the qubits to a readout cavity via the interaction \\(\\sigma_x (a+a^\\dagger)\\) \\cite{doi:10.1103/PhysRevLett.115.203601}. This results in an \\(X\\)-dependent shift of the readout cavity resonance which can be measured."]}, "relations": {"parents": [{"code_id": "hybrid_qudit_oscillator", "detail": "VSLQ code yields a logical qubit out of two physical qubits and two oscillators."}], "cousins": [{"code_id": "quantum_repetition", "detail": "Parts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss."}]}}, "chuang-leung-yamamoto": {"code_id": "chuang-leung-yamamoto", "physical": "oscillators", "logical": "qubits", "name": "Chuang-Leung-Yamamoto code", "introduced": "\\cite{doi:10.1103/PhysRevA.56.1114}", "description": "Bosonic Fock-state code that encodes \\(k\\) qubits into \\(n\\) oscillators, with each oscillator restricted to having at most \\(N\\) excitations. Codewords are superpositions of oscillator Fock states, either balanced (i.e., uniform) or unbalanced. Codes can be denoted as \\([[N,n,2^k,d]]\\), which conflicts with \\hyperref[code:stabilizer]{stabilizer code} notation.", "protection": "Protects against amplitude damping for up to \\(t = d-1\\) excitation losses. Defining the \\textit{spacing} between two Fock states \\(|u_1\\cdots u_n\\rangle\\) and \\(|v_1\\cdots v_n\\rangle\\),\n\\begin{align}\n\\text{Spacing}(u,v) = \\frac{1}{2}\\sum_{i=1}^n |u_i - v_i|,\n\\end{align}\nthe code distance \\(d\\) can be defined as the minimial spacing between Fock states making up the codewords.\n", "features": {"rate": "Code rate is \\(\\frac{k}{n \\log_2(N+1)}\\). To correct the loss of up to \\(t\\) excitations with \\(K+1\\) codewords, a code exists with scaling \\(N \\sim t^3 K/2\\).", "encoders": ["Photon Fock state input into a network of beamsplitters, phase shifters, and Kerr media. These operations all preserve total photon number. Beamsplitters and phase shifters take annihilation operators to linear combinations of annihilation operators, and the transformation matrix is unitary. The operations corresponding to Kerr nonlinear media are diagonal in the Fock basis, but they implement phases that in general depend nonlinearly on the number of photons in each mode. State preparation may require ancillary modes and be conditioned on photon-number measurement results."], "decoders": ["Destructive decoding with a photon number measurement on each mode.", "State can be decoded with a network of beamsplitters, phase shifters, and Kerr media."]}, "relations": {"parents": [{"code_id": "fock_state", "detail": ""}]}}, "binomial": {"code_id": "binomial", "physical": "oscillators", "logical": "qudits", "name": "Binomial code", "introduced": "\\cite{arXiv:1602.00008}", "description": "Bosonic rotation codes designed to approximately protect against errors consisting of powers of raising and lowering operators up to some maximum power. Binomial codes can be thought of as spin-coherent states embedded into an oscillator \\cite{arXiv:1708.05010}. The \\(q\\)-dimensional qudit \\((N, S)\\) binomial codeword states are \\(\\{|\\overline{i}\\rangle\\mid i\\in \\mathbb Z_q \\}\\), where\n  \\begin{align}\n    |\\overline{i}\\rangle = \\frac{1}{\\sqrt{q^N}} \\sum_{\\substack{p=0\\\\p\\equiv i \\pmod{q}}}^{(q-1)(N+1)} \\sqrt{\\binom{N+1}{p}_q} \\ket{p(S+1)}.\n  \\end{align}\n  Here, \\(\\binom{N+1}{p}_q\\) are extended binomial coefficients, or polynomial coeffiients, defined recursively as\n  \\begin{align}\n    \\binom{n}{m}_1 \\equiv 1,\\quad \\binom{n}{m}_q \\equiv \\sum_{k=0}^n \\binom{n}{k}\\binom{k}{m-k}_{q-1}.\n  \\end{align}\n", "protection": "An \\((N, S)\\) binomial code protects against \\(L\\) boson losses, \\(G\\) boson gains, and dephasing up to \\(\\hat{n}^{\\D}\\), where \\(S=L+G\\) and \\(N = \\mathrm{max}(L,G,2D)\\). Binomial codes approximately protect against continuous-time amplitude damping, boson loss and gain, and dephasing.", "features": {"decoders": ["Photon loss and dephasing errors can be detected by measuring the phase-space rotation \\(\\exp\\left(2\\pi\\mathrm{i} hat n / (S+1)\\right)\\) and the check operator \\(J_x/J\\) in the spin-coherent state language, where \\(J\\) is the total angular momentum and \\(J_x\\) is the angular momentum in the \\(x\\) direction \\cite{arXiv:1708.05010}. This type of error correction fails for errors that are products of photon loss/gain and dephasing errors. However, for certain \\((N,S)\\) instances of the binomial code, detection of these types of errors can be done.", "Recovery can be done via projective measurements and unitary operations \\cite{arXiv:1602.00008,arXiv:1708.05010}."]}, "realizations": ["Realized in microwave cavities coupled to superconducting circuits \\cite{doi:10.1038/s41567-018-0414-3}."], "notes": ["The mean occupation number, or average Fock-state number in maximally-mixed state of the code, is \\((N+1)(S+1)(q-1)/2 \\), where \\(q\\) is the qudit dimension."], "relations": {"parents": [{"code_id": "bosonic_rotation", "detail": "One can verify by direct calculation that the logical states are eigenstates of the discrete rotation operator. One has freedom in the exact form of the primitive state to choose; see Appendix B.2 of Ref. \\cite{arxiv:1901.08071}."}], "cousins": [{"code_id": "cat", "detail": "For a fixed \\(S\\), binomial codes with \\(N \\to \\infty\\) coincide with cat codes as \\(\\alpha \\to \\infty\\) \\cite{arXiv:1602.00008}."}, {"code_id": "number_phase", "detail": "In the limit as \\(N,S \\to \\infty\\), phase measurement in the binomial code has vanishing variance, just like in a number-phase code \\cite{arxiv:1901.08071}."}]}}, "wasilewski-banaszek": {"code_id": "wasilewski-banaszek", "physical": "oscillators", "logical": "qubits", "name": "Wasilewski-Banaszek code", "introduced": "\\cite{doi:10.1103/PhysRevA.75.042316}", "description": "Three-oscillator Fock-state code encoding a single logical qubit using codewords \\begin{align} \\begin{split} |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{3}}(|003\\rangle+|030\\rangle+|300\\rangle)\\\\ |\\overline{1}\\rangle &= |111\\rangle \\end{split}. \\end{align}", "protection": "Protects against single photon loss in any one mode.", "features": {"encoders": ["A qubit in the dual-rail code can be transferred to this code via a linear optical network using four ancillary modes, each with one photon input. Successful encoding is conditioned on measuring the state \\(|110\\rangle\\) on the last three modes."], "general_gates": ["Single-qubit gates implemented using linear optical networks, sometimes with the addition of auxiliary modes with vacuum input and (conditional) output."], "decoders": ["Destructive measurement with photon number measurements on each mode."]}, "relations": {"parents": [{"code_id": "fock_state", "detail": ""}], "cousins": [{"code_id": "chuang-leung-yamamoto", "detail": ""}]}}, "dual_rail": {"code_id": "dual_rail", "physical": "qubits", "logical": "qubits", "name": "Dual-rail code", "introduced": "\\cite{doi:10.1103/PhysRevA.52.3489}", "description": "Two-mode code encoding a logical qubit in Fock states with one excitation. The logical-zero state is represented by \\(|01\\rangle\\), while the logical-one state is represented by \\(|10\\rangle\\).", "protection": "This is an error-detecting code against one photon loss event; it is often used in photonic quantum devices because of its ease of realization. A single loss event can be detected because, after the loss occurs, the output state \\(|00\\rangle\\) is orthogonal to the codespace. Recovery is not possible, so a successful run of a quantum circuit is conditioned on not losing a photon during the circuit.\n\nFor Deutsch''s  problem specifically, this code protects against errors resulting in states that have the correct photon number, but in the wrong modes \\cite{doi:10.1103/PhysRevA.52.3489}.\n", "features": {"general_gates": ["General gates are performed using beamsplitters and Kerr non-linearities. Universal quantum computing can be achieved with photons in dual-rail encodings using the KLM protocol \\cite{doi:10.1038/35051009} with only linear optical elements and photon detectors."]}, "notes": ["For Deutsch's problem \\cite{doi:10.1098/rspa.1992.0167} with optical qubits, error correction using photon number detection reduces the error probability from \\(\\frac{1}{4} (1+e^{-\\gamma}-2e^{-3\\gamma/2}) \\)   to \\(\\frac{1}{2} (1- sech \\gamma/2)\\)."], "relations": {"parents": [{"code_id": "fock_state", "detail": ""}]}}, "bosonic_rotation": {"code_id": "bosonic_rotation", "physical": "oscillators", "logical": "qudits", "name": "Bosonic rotation code", "introduced": "\\cite{arXiv:1901.08071}", "description": "A single-mode Fock-state bosonic code whose codespace is preserved by a phase-space rotation by a multiple of \\(2\\pi/N\\) for some \\(N\\). The rotation symmetry ensures that encoded states have support only on every \\(N^{\\textrm{th}}\\) Fock state. For example, single-mode Fock-state codes for \\(N=2\\) encoding a qubit admit basis states that are, respectively, supported on Fock state sets \\(\\{|0\\rangle,|4\\rangle,|8\\rangle,\\cdots\\}\\) and \\(\\{|2\\rangle,|6\\rangle,|10\\rangle,\\cdots\\}\\).\n\nEncoding of a \\(q\\)-dimensional logical qudit admit a basis whose elements are eigenstates of the rotation operator \\(\\exp\\left(\\mathrm{i} 2\\pi \\hat{n}/qN \\right)\\), where \\(\\hat{n}\\) is the number operator diagonal in the Fock basis. Basis elements are of the form \\(\\sum_{j=0}^\\infty c_j |j q N + kN \\rangle\\) for some coefficients \\(\\c_j\\) and \\(k\\). This is because the rotation acting on a general Fock-state superposition \\(\\sum_n a_n |n\\rangle\\) yields \\(\\sum_n a_n \\exp\\left(\\mathrm{i} 2\\pi n / qN \\right) |n\\rangle\\). In order for a codeword to be an eigenvector of this operation, \\(a_n\\) must be zero whenever \\(n \\neq (kq+j)N\\) for some \\(k\\).\n\nCodewords can be uniquely specified by choosing a \\emph{primitive} state \\(|\\Theta\\rangle\\). To ensure valid (orthogonal and nonzero) codewords, \\(|\\Theta\\rangle\\) must satisfy the following requirement: for each \\(j \\in \\mathbb{Z}_q\\), \\(|\\Theta\\rangle\\) must have support on the Fock state \\(|(qk_j+j)N\\rangle\\) for at least one \\(k_j \\in \\mathbb{N}_0\\). From such a primitive, the codewords \\(|\\overline{j}\\rangle \\mid j \\in \\mathbb{Z}_q\\) are constructed as \\(|\\overline{j}\\rangle \\propto \\sum_{m=0}^{2N-1} \\mathrm{e}^{2\\pi \\mathrm{i} m (\\hat n  / N + j) / q} |\\Theta\\rangle\\).\n", "protection": "Losses or gains less than \\(N\\) are detectable. Dephasing rotations \\(\\exp(\\mathrm{i}\\theta \\hat{n})\\) can be detected whenever \\(\\theta\\) is roughly less than \\(\\pi/N\\). To get precise bounds on \\(\\theta\\), one needs to analyze the particular bosonic rotation code.", "features": {"general_gates": ["The logical Pauli-\\(Z\\) gate can be the discrete rotation operator \\(\\mathrm{e}^{\\mathrm{i} \\pi \\hat n /N}\\), and the logical Pauli-\\(X\\) gate can be the (note: non-unitary) number-translation operator \\(\\sum_{n=0}^\\infty |n\\rangle\\bra{n+N}\\).", "For qubit codes, a logical phase gate is \\(S = \\mathrm{e}^{\\pi \\mathrm{i} \\hat n^2 / 2N^2}\\).", "The \\(T = \\mathrm{diag}(1,\\exp(\\mathrm{i}\\pi/4))\\) gate can be done via gate teleportation and a resource state \\(\\vert 0_N\\rangle + \\exp(\\mathrm{i}\\pi/4) \\vert 1_N \\rangle\\).", "A controlled-rotation gate between an order \\(N\\) rotation code and an order \\(M\\) rotation code is \\(\\mathrm{CROT}_{NM} = \\mathrm{e}^{(2\\pi\\mathrm{i} / qNM) \\hat n \\otimes \\hat n}\\)."], "decoders": ["One can distinguish (destructively) the codewords by performing a Fock-state number measurement. If a Fock state state \\(|n\\rangle\\) is measured, then one rounds to the nearest integer of the form \\((kq+j)/N\\), and deduces that the true state was \\(|\\overline{j}\\rangle\\).", "One can distinguish states in the dual basis by performing phase estimation on \\(\\mathrm{e}^{\\mathrm{i} \\theta \\hat n}\\). One then rounds the resulting \\(\\theta\\) to the nearest number \\(2\\pi j / qN\\) in order to determine which dual basis state \\(j \\in \\mathbb Z_q\\) it came from."], "encoders": ["The optimal way to prepare codewords depends on the exact rotation code in question \\cite{arXiv:1901.08071}."]}, "relations": {"parents": [{"code_id": "fock_state", "detail": "Single-mode Fock-state codes are typically rotationally invariant."}], "cousins": [{"code_id": "gkp", "detail": "GKP codes utilize the translational symmetry in phase space, while rotation codes utilize rotational symmetry."}]}}, "cat": {"code_id": "cat", "physical": "oscillators", "logical": "qubits", "name": "Cat code", "introduced": "\\cite{arXiv:quant-ph/9809037,arXiv:1207.0679}", "description": "Rotation-symmetric bosonic Fock-state code encoding a \\(q\\)-dimensional qudit into one oscillator. Codewords for a qubit code (\\(q=2\\)) consist of a coherent state \\(|\\alpha\\rangle\\) projected onto a subspace of Fock state number modulo \\(2(S+1)\\). The logical state \\(|\\overline{0}\\rangle\\) is in the \\(\\{|0\\rangle , |2(S+1)\\rangle , |4(S+1)\\rangle \\cdots \\}\\) Fock-state subspace, while \\(|\\overline{1}\\rangle\\) is in the \\(\\{|(S+1)\\rangle, |3(S+1)\\rangle , |5(S+1)\\rangle , |7(S+1)\\rangle \\cdots \\}\\) subspace. An alternative basis, valid for for general \\(q\\) and \\(\\alpha\\neq 0\\), consists of \\(q\\) coherent states distributed equidistanctly around a circle in phase space of radius \\(\\alpha\\).", "protection": "Due to the spacing between sets of Fock states, the distance between two distinct logical states is \\(d=S+1\\). Hence, this code is able to detect \\(S\\)-photon loss error.", "features": {"encoders": ["Lindbladian-based dissipative encoding utilizing multi-photon absorption \\cite{arXiv:1312.2017}.", "Hamiltonian-based 'Kerr-cat' encoding utilizing the Kerr effect \\cite{arXiv:1605.09408}.", "Combined dissipative and Hamiltonian-based encoding utilizing two-photon exchange for \\(S=1\\) codes \\cite{arXiv:2112.05545}."], "general_gates": ["For \\(S=1\\), universal gates can be performed using displacement operators and a rotation based on the Kerr nonlinearity \\cite{arXiv:1312.2017}. For \\(S=2\\), squeezing replaces displacements.", "Holonomic gates utilizing the Berry phase of coherent states are universal \\cite{arxiv:1503.00194}.", "Bias-preserving CNOT gate utilizing a topological Berry phase \\cite{arXiv:1905.00450}."], "fault_tolerance": ["Bias-preserving CNOT gate \\cite{arXiv:1905.00450} is part of a universal bias-preserving gate set that can be made fault tolerant using concatenation \\cite{arXiv:1904.09474,arXiv:1905.00450}."], "decoders": ["Measurement in the Fock basis. For a \\(2(S+1)\\) cat code, a number measurement returns outcome \\(2(S+1)k\\), if \\(k\\) is even, then it corresponds to logical 0 state; if \\(k\\) is odd, then it corresponds to logical 1 state."]}, "realizations": ["Two-legged (\\(S=1\\)) cat code has been realized by two superconducting cavities coupled through a Josephson junction \\cite{doi:10.1126/science.aaa2085}.", "Four-legged (\\(S=2\\)) cat code has been realized in superconducting circuit \\cite{doi:10.1038/nature18949}. This paper is the first break-even point of quantum error-correction, where the lifetime of a logical qubit is on par with the lifetime of the noisiest constituent of the system."], "relations": {"parents": [{"code_id": "bosonic_rotation", "detail": "The cat code is a bosonic rotation code whose primitive state is the coherent state \\(|\\alpha\\rangle\\) \\cite{arxiv:1901.08071}."}], "cousins": [{"code_id": "number_phase", "detail": "In the limit as \\(N,S \\to \\infty\\), phase measurement in the cat code has vanishing variance, just like in a number-phase code \\cite{arxiv:1901.08071}."}, {"code_id": "hamiltonian", "detail": "Two-legged cat codewords form ground-state subspace of a Kerr Hamiltonian \\cite{arXiv:1605.09408}."}]}}, "number_phase": {"code_id": "number_phase", "physical": "oscillators", "logical": "qubits", "name": "Number phase code", "introduced": "\\cite{arxiv:1901.08071}", "description": "Bosonic rotation code consisting of superpositions of Pegg-Barnett phase states \\cite{doi:10.1088/0305-4470/19/18/030},\n\\begin{align}\n|\\phi\\rangle \\equiv \\frac{1}{\\sqrt{2\\pi}}\\sum_{n=0}^{\\infty} \\mathrm{e}^{\\mathrm{i} n \\phi} \\ket{n}.\n\\end{align}\nSince phase states and thus the ideal codewords are not normalizable, approximate versions need to be constructed. The codes' key feature is that, in the ideal case, phase measurement has zero uncertainty, making it a good canditate for a syndrome measurement.\n\nLogical states of an order-\\(N\\) number-phase qubit encoding are \\(|\\overline{0}\\rangle= \\sum_{m=0}^{2N-1} |\\phi = m\\pi/N\\rangle\\) and \\(|\\overline{1}\\rangle = \\sum_{m=0}^{2N-1} (-1)^m |\\phi=m\\pi/N\\rangle\\). By performing the summation over \\(m\\), one finds that \\(|\\overline{0}\\rangle\\) is supported on Fock states \\(|2kN\\rangle\\), while \\(|\\overline{1}\\rangle\\) is supported on states \\(|(2k+1)N\\rangle\\), for \\(k \\geq 0\\).\n", "protection": "Number-phase codes of order \\(N\\) detect up to \\(N\\) photon loss or gain errors, and dephasing up to \\(\\theta = \\pi/N\\).", "features": {"decoders": ["Measurement done in the logical \\(X\\), or dual, basis has zero uncertainty in the case of ideal number phase codes. Approximate number-phase codes are characterized by vanishing phase uncertainty.", "Number measurement can be done by using the CROT gate \\(\\mathrm{e}^{(2\\pi \\mathrm{i} / NM) \\hat n \\otimes \\hat n}\\). See Section 4.B.1 of Ref. \\cite{arxiv:1901.08071}."], "fault_tolerance": ["Fault-tolerant computation schemes with number-phase codes have been proposed based on concatenation with Bacon-Shor subsystem codes \\cite{arxiv:1901.08071}."]}, "relations": {"parents": [{"code_id": "bosonic_rotation", "detail": "Number-phase codes are bosonic rotation codes with the primitive state is a Pegg-Barnett phase state \\cite{doi:10.1088/0305-4470/19/18/030}."}], "cousins": [{"code_id": "rotor_gkp", "detail": "Number phase codes are a manifestation of planar-rotor GKP codes in an oscillator. Both codes protect against small shifts in angular degrees of freedom."}]}}, "fock_state": {"code_id": "fock_state", "physical": "oscillators", "logical": "qudits", "name": "Fock-state bosonic code", "description": "Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. The simplest example is the dual-rail code, which has codewords consisting of single Fock states \\(|10\\rangle\\) and \\(|01\\rangle\\). This code can detect a single loss error since a loss operator in either mode maps one of the codewords to a different Fock state \\(|00\\rangle\\). More involved codewords consist of several well-separated Fock states such that multiple loss events can be detected and corrected.", "protection": "Code distance \\(d\\) is the minimum distance (assuming some metric) between any two labels of Fock states corresponding to different code basis states. For a single mode, \\(d\\) is the minimum absolute value of the difference between any two Fock-state labels; such codes can detect up to \\(d-1\\) loss events. Multimode distances can be defined analogously; see, e.g., \\hyperref[code:chuang-leung-yamamoto]{Chuang-Leung-Yamamoto codes}.", "relations": {"parents": [{"code_id": "qudits_into_oscillators", "detail": ""}], "cousins": [{"code_id": "binary_linear", "detail": "Fock-state code distance is a natural extension of Hamming distance between binary strings."}, {"code_id": "qubits_into_qubits", "detail": "Fock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators \\cite{manual:{Victor V. Albert, private communication, 2016}}. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations \\cite{arxiv:2111.08894}."}]}}, "group_quantum": {"code_id": "group_quantum", "physical": "groups", "logical": "groups", "name": "Group quantum code", "description": "Encodes a \\textit{logical} Hilbert space, finite- or infinite-dimensional, into a \\textit{physical} Hilbert space of \\(\\ell^2\\)-normalizable functions on a second-countable unimodular group. For \\(K\\)-dimensional logical subspace and for groups \\(G^{\\times n}\\), can be denoted as \\(((n,K))_G\\). When the logical subspace is the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(G^{\\times k}\\), can be denoted as \\([[n,k]]_G\\). Ideal codewords may not be normalizable, depending on whether \\(G\\) is continuous and/or noncompact, so approximate versions have to be constructed.", "protection": "", "relations": {"parents": [{"code_id": "qecc", "detail": ""}], "cousins": [{"code_id": "qecc_finite", "detail": "Group quantum codes whose physical spaces are constructed using finite groups are finite-dimensional."}, {"code_id": "qudits_into_qudits", "detail": "Group quantum codes whose physical spaces are constructed using modular-integer groups are \\(\\mathbb{Z}_q\\)-qudit codes."}, {"code_id": "oscillators", "detail": "Group quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes."}]}}, "rotor_gkp": {"code_id": "rotor_gkp", "physical": "groups", "logical": "qudits", "name": "Rotor GKP code", "introduced": "\\cite{arxiv:quant-ph/0008040,arxiv:1911.00099}", "description": "GKP code protecting against small angular position and momentum shifts of a planar rotor.", "relations": {"parents": [{"code_id": "group_gkp", "detail": ""}], "cousins": [{"code_id": "gkp", "detail": "GKP (rotor GKP) codes protect against shifts in linear (angular) degrees of freedom."}]}}, "molecular": {"code_id": "molecular", "physical": "groups", "logical": "rigid_bodies", "name": "Molecular code", "introduced": "\\cite{arXiv:1911.00099}", "description": "Encodes finite-dimensional Hilbert space into the Hilbert space of \\(\\ell^2\\)-normalizable functions on the group \\(SO_3\\). Construction is based on nested subgroups \\(H\\subset K \\subset SO_3\\), where \\(H,K\\) are finite. The \\(|K|/|H|\\)-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\).", "protection": "Protects against generalized bit-flip errors \\(g\\in SO_3\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "notes": ["Physical space characterizes orientations of a rigid body in 3D, which correspond to rotational states of an asymmetric molecule."], "relations": {"parents": [{"code_id": "group_gkp", "detail": ""}]}}, "group_gkp": {"code_id": "group_gkp", "physical": "groups", "logical": "groups", "name": "Group GKP code", "introduced": "\\cite{arXiv:1911.00099}", "description": "Group code whose construction is based on nested subgroups \\(H\\subset K \\subset G\\). Logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\), and can be finite- or infinite-dimensional. Extension of the \\hyperref[code:gkp]{GKP code} construction.", "protection": "Protects against generalized bit-flip errors \\(g\\in G\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "relations": {"parents": [{"code_id": "group_quantum", "detail": ""}], "cousins": [{"code_id": "oscillators_into_oscillators", "detail": "For logical and physical spaces based on the real line \\(\\mathbb{R}\\)."}, {"code_id": "css", "detail": "For an \\(n\\)-qubit CSS code, the nested group construction \\(C_1^\\perp \\subseteq C_2 \\subset \\mathbb{Z}_2^{\\times n}\\)."}, {"code_id": "gkp", "detail": "For a single-mode qubit GKP code, the nested group construction is \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\)."}]}}, "stab_3_1_2": {"code_id": "stab_3_1_2", "physical": "qudits", "logical": "qudits", "name": "Three qutrit Code", "introduced": "\\cite{arXiv:quant-ph/9901025}", "description": "A \\([[3,1,2]]_3\\) prime-qudit CSS code with stabilizer generators \\(ZZZ\\) and \\(XXX\\). The code defines a quantum secret-sharing scheme and serves as a minimal model for the AdS/CFT holographic duality. The codewords are\n\\begin{align}\n  \\begin{split}\n    | \\overline{0} \\rangle &= \\frac{1}{\\sqrt{3}} (| 000 \\rangle + | 111 \\rangle + | 222 \\rangle) \\\\\n    | \\overline{1} \\rangle &= \\frac{1}{\\sqrt{3}} (| 012 \\rangle + | 120 \\rangle + | 201 \\rangle) \\\\\n    | \\overline{2} \\rangle &= \\frac{1}{\\sqrt{3}} (| 021 \\rangle + | 102 \\rangle + | 210 \\rangle)~.\n  \\end{split}\n\\end{align}\nThe elements in the superposition of each logical codeword are related to each other via cyclic permutations.\n", "protection": "Detects single qutrit errors and protects against a single-qutrit erasure. There does not exist a three-qubit code with analogous properties.\n\nThe code is an example of a \\( ((n = 3, k = 2)) \\) threshold scheme where a secret (the quantum information) is split into \\( n \\) shares and can be reconstructed by \\( k \\) pieces.\n\nThey key property of this code is that the reduced density matrix of any single qutrit is maximally mixed, meaning no information can be extracted from that qutrit. Therefore, a single qutrit tells you nothing about the encoded message, but access to any two pairs of qutrits will reveal the secret.\n", "features": {"rate": "k/n = 1/3", "encoders": ["In addition to thinking about the encoding of states, it is also interesting to look at the trasformation of operators from the physical space into the logical space. Due to the unique structure and recovery protocol of the three qutrit code, the representation of a logical operator \\( \\overline{O} \\) is not unique. Instead, \\( \\overline{O} \\) can be constructed from unitary matricies with support on only two out of the three qutrits. Therefore, the logical operator has valid representations constructed from support on different sets of two qutrits. This operator construction is directly analogous to the construction of operators in the bulk (at the center) of the AdS\\(_3\\)-Rindler reconstruction. The three-qutrit code can then be used to describe how these local bulk operators are protected against localized boundary errors \\cite{arXiv:1411.7041}.", "This construction is related to the cleaning lemma \\cite{arXiv:0810.1983}, which was introduced in the context of constructing self-correcting quantum memories from stabilizer codes with geometrically-local generators. In this lemma, subspaces can be \\textit{cleaned out} by removing operators with support on a subset of qutrits."], "decoders": ["The quantum information (the secret) can be recovered from a unitary transformation acting on only two qutrits, \\( U_{ij} \\ocross I \\), where \\(U_{ij}\\) acts on qutrits \\(i,j\\) and \\(I\\) is the identity on the remaining qutrit. By the cyclic structure of the codewords, this unitary transformation performs a permutation that recovers the information and stores it in one of the two qutrits involved in recovery."]}, "notes": ["Connections to Ads/CFT from the perspetive of how arbitrary operators are encoded into the logical space. This encoding is analagous and helps explain why operators acting on the bulk are protected against localized boundary errors \\cite{arXiv:1411.7041}."], "relations": {"parents": [{"code_id": "qudit_css", "detail": "Smallest single-erasure correcting qudit code for \\(q>2\\)."}], "cousins": [{"code_id": "quantum_secret_sharing", "detail": "Three-qutrit code defines a minimal secret-sharing scheme \\cite{arXiv:quant-ph/9901025} that is substantially generalized by approximate secret-sharing codes."}, {"code_id": "holographic", "detail": "Three-qutrit code is a minimal model for holography \\cite{arxiv:1411.7041,arXiv:1607.03901}."}]}}, "frobenius": {"code_id": "frobenius", "physical": "qudits", "logical": "qudits", "name": "Frobenius code", "introduced": "\\cite{arXiv:1011.5814}", "description": "Let \\(C\\) be a quantum cyclic code on \\(n\\) \\(\\mathbb{Z}_p\\)-qudits. \\(C\\) is a Frobenius code if there exists a positive integer \\(t\\) such that \\(n\\) divides \\(p^t +1\\).", "protection": "Protects against Pauli noise.", "features": {"decoders": ["Adapted from the Berlekamp decoding algorithm for classical BCH codes. There exists a polynomial time quantum algorithm to correct errors of weight at most \\(\\tau\\), where \\(\\delta=2\\tau+1\\) is the BCH distance of the code \\cite{arXiv:1011.5814}. "]}, "notes": ["Frobenius codes that are also stabilizer codes have been completely classified. No such codes exist when \\(t\\) is odd. All such codes with even \\(t\\) can be directly constructed."], "relations": {"parents": [{"code_id": "qudits_into_qudits"}], "cousins": [{"code_id": "quantum_cyclic"}]}}, "qudit_stabilizer": {"code_id": "qudit_stabilizer", "physical": "qudits", "logical": "qudits", "name": "\\(\\mathbb{Z}_q\\)-qudit stabilizer code", "description": "An \\(((n,p^k,d))_q\\) (with \\(q\\) not necessarily prime) stabilizer code is denoted as \\([[n,k]]_q\\) or \\([[n,k,d]]_q\\), where \\(d\\) is the code's distance. Stub.", "protection": "", "relations": {"parents": [{"code_id": "qudits_into_qudits", "detail": ""}]}}, "polynomial": {"code_id": "polynomial", "physical": "qudits", "logical": "qudits", "name": "\\(\\mathbb{Z}_p\\)-qudit polynomial code (QPyC)", "introduced": "\\cite{arxiv:quant-ph/9910059}", "description": "Also called \\textit{quantum Reed-Solomon code}. Stub.", "protection": "", "relations": {"parents": [{"code_id": "qudit_css", "detail": ""}], "cousins": [{"code_id": "reed_solomon", "detail": ""}, {"code_id": "cyclic", "detail": ""}]}}, "prime_qudit_stabilizer": {"code_id": "prime_qudit_stabilizer", "physical": "qudits", "logical": "qudits", "name": "\\(\\mathbb{Z}_p\\)-qudit stabilizer code", "introduced": "\\cite{arXiv:quant-ph/9705052}", "description": "An \\(((n,p^k,d))_p\\) (with \\(p\\) prime) stabilizer code is denoted as \\([[n,k]]_p\\) or \\([[n,k,d]]_p\\), where \\(d\\) is the code's distance. Logical subspace is the joint \\(+1\\) eigenspace of a set of \\(p^{n-k}\\) commuting qudit Pauli operators forming the code's stabilizer group, which cannot contain \\(-I\\). The distance is the minimum weight of an error that implements a nontrivial logical operation on the code.", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.  More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a generalized Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{\\hat{N}(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "relations": {"parents": [{"code_id": "qudit_stabilizer", "detail": ""}, {"code_id": "galois_stabilizer", "detail": "A prime-qudit stabilizer code is a Galois-qudit stabilizer code with \\(m=1\\)."}]}}, "qudits_into_qudits": {"code_id": "qudits_into_qudits", "physical": "qudits", "logical": "qudits", "name": "\\(\\mathbb{Z}_q\\)-qudit code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the group \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\). Usually denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined, and with \\(q=p\\) when the dimension is prime.", "relations": {"parents": [{"code_id": "qecc_finite", "detail": ""}]}}, "qudit_css": {"code_id": "qudit_css", "physical": "qubits", "logical": "qubits", "name": "\\(\\mathbb{Z}_q\\)-qudit CSS code", "description": "Often, but not always, defined for prime qudits (\\(q=p\\)). Stub.", "relations": {"parents": [{"code_id": "qudit_stabilizer", "detail": ""}], "cousins": [{"code_id": "css", "detail": "Extension of CSS codes to modular-integer qudits."}]}}, "skew-cyclic_galois_css": {"code_id": "skew-cyclic_galois_css", "physical": "qudits", "logical": "qudits", "name": "Skew-cyclic CSS code", "introduced": "\\cite{doi:10.1016/j.disc.2020.112189}", "description": "Stub.", "relations": {"parents": [{"code_id": "galois_css"}], "cousins": [{"code_id": "skew_cyclic", "detail": "Skew-cyclic CSS codes are constructed from classical skew-cylic codes."}]}}, "galois_stabilizer": {"code_id": "galois_stabilizer", "physical": "galois", "logical": "galois", "name": "Galois-qudit stabilizer code", "introduced": "\\cite{arXiv:quant-ph/0005008}", "description": "An \\(((n,p^k,d))_{GF(q)}\\) stabilizer code is denoted as \\([[n,k]]_{GF(q)}\\) or \\([[n,k,d]]_{GF(q)}\\), where \\(d\\) is the code's distance. Stub.", "relations": {"parents": [{"code_id": "galois_into_galois", "detail": ""}]}}, "galois_true_stabilizer": {"code_id": "galois_true_stabilizer", "physical": "galois", "logical": "galois", "name": "Galois-qudit true stabilizer code", "description": "Also called a linear stabilizer code. A \\([[n,k,d]]_{GF(q)}\\) stabilizer code whose stabilizer's symplectic representation forms a linear subspace. In other words, the set of \\(q\\)-ary vectors representing the stabilizer group is closed under both addition and multiplication by elements of \\(GF(q)\\). In contrast, Galois-qudit stabilizer codes admit sets of vectors that are closed under addition only.\n\nThe number of generators \\(r\\) is a multiple of \\(m\\) (recall that \\(q=p^m\\) for Galois qudits). As a result, the number \\(k=n-r/m\\) of logical qudits is an integer.\n", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.", "relations": {"parents": [{"code_id": "galois_stabilizer", "detail": ""}], "cousins": [{"code_id": "q-ary_linear", "detail": "A true Galois-qudit stabilizer code is the closest quantum analogue of a \\(q\\)-ary linear code because the \\(q\\)-ary vectors defining each code form a linear subspace."}]}}, "binary_quantum_goppa": {"code_id": "binary_quantum_goppa", "physical": "galois", "logical": "galois", "name": "Binary quantum Goppa Code", "introduced": "\\cite{arxiv:quant-ph/0501074,doi:10.1007/s11128-006-0047-9}", "description": "Also known as a \\textit{quantum AG code}. Binary quantum Goppa codes are a family of \\( [[n,k,d]]_{GF(q)} \\) Galois-qudit stabilizer codes for \\( q=2^m \\), generated using classical Goppa codes.\n\nLet \\( F/GF(q) \\) be an algebraic function field of one variable, \\(\\sigma \\) be an automorphism of order 2\nof \\(F\\) which leaves \\(GF(q)\\) invariant, and \\(P_1, \\cdots, P_n \\) be pairwise distinct places of degree one such that \\( \\sigma P_i = P_j\\) for all\n\\(i,j = 1, \\cdots, n\\). A place \\( P_i \\) of \\( F/ GF(q) \\) is the unique maximal ideal of a discrete valuation ring of the function field. Let \\( \\nu \\) be a  differential\nthat satisfies the properties guaranteed by  the strong approximation theorem of discrete evaluations. Let \\(G\\) be a divisor such that \\( \\sigma G = G \\) and the\ndiscrete valuation corresponding to place \\(P_i \\) of \\(G\\) and the discrete valuation corresponding to place \\(\\sigma P_i \\) of \\(G\\) are both 0 for all \\(i\\). Then we can define\na code \\( C(G)  = \\{ f(P_1), \\cdots, f(P_n), f(\\sigma P_1), \\cdots , f(\\sigma P_n) | f \\in \\mathcal{L}(G)\\} \\subset GF(q^{2n})\\) and\na code \\(C(H)\\) where \\(H = (P_1 + \\cdots + P_n + \\sigma P_1 + \\cdots + \\sigma P_n) - G + \\nu \\). Then the dual of \\(C(G)\\) with respect to the weighted symplectic inner\nproduct with weights \\(s_i\\) on \\( GF(q^n) \\) is equivalent to \\(C(H)\\). Therefore, the orthogonal code of \\(C(G)\\) is generated by \\(H\\). Using these properties and the assumption\nthat \\(H\\) is a subgroup of \\(G\\), we can construct a classical Goppa code \\(C(D,G)\\), where \\(D\\) is the sum of all \\(P_i\\). Using \\(C(D,G)\\), we can construct a \\([[n,k,d]]_{GF(q)}\\) quantum stabilizer code such that\n\\(k  = \\text{dim} G - \\text{dim}(G-P_1 - \\cdots - P_n - \\sigma P_1 - \\cdots  - \\sigma P_n) - n~.\\)\n", "protection": "Protects against weight t errors where \\( 0 < t \\leq  \\lfloor \\frac{d^*-g-1}{2} \\rfloor \\) where \\( d^* = \\text{deg} G + 2 -2g \\) and \\(g\\) is the genus of the function field and \\(d \\geq n - \\lfloor \\frac{deg G}{2} \\rfloor\\).", "features": {"encoders": ["Encoding defined in Matsumoto \\cite{arxiv:quant-ph/0107129} uses a technique from Ashikhmin and Knill \\cite{arxiv:quant-ph/0005008} to encode quantum stabilizer codes."], "decoders": ["Farran algorithm \\cite{arxiv:math/9910151}."]}, "relations": {"parents": [{"code_id": "galois_stabilizer", "detail": ""}], "cousins": [{"code_id": "css", "detail": "Goppa codes can be constructed using CSS codes over hyperelliptic curves \\cite{doi:10.1007/s11128-006-0047-9}. The construction provided here is Matsumoto's construction."}, {"code_id": "goppa", "detail": "Classical Goppa codes are used to construct their quantum versions."}]}}, "galois_into_galois": {"code_id": "galois_into_galois", "physical": "galois", "logical": "galois", "name": "Galois-qudit code", "introduced": "\\cite{doi:10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T}", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the \\textit{Galois field} \\(GF(q)\\) and with \\(q\\) being a power of a prime \\(p\\). A Galois field can be thought of as a vector space whose basis vectors are the \\(m\\) roots of some polynomial and whose coefficients (i.e., field) are \\(p\\)th roots of unity. Codes can be denoted as \\(((n,K))_{GF(q)}\\) or \\(((n,K,d))_{GF(q)}\\), whenever the code's distance \\(d\\) is defined.", "notes": ["Introduction to Galois qudits by \\href{https://ethz.ch/content/vp/en/conferences/2014/qec/05_thursday/dab6ca18-7453-4197-aaaa-8b1964ece714.html}{Gottesman}."], "relations": {"parents": [{"code_id": "qecc_finite", "detail": ""}], "cousins": [{"code_id": "qudits_into_qudits", "detail": "A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) \\(\\mathbb{Z}_q\\)-qudits \\cite{arXiv:quant-ph/0005008}; see Sec. 5.3 of Ref. \\cite{arxiv:quant-ph/0501074}. The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently."}]}}, "quantum_secret_sharing": {"code_id": "quantum_secret_sharing", "physical": "galois", "logical": "galois", "name": "Approximate secret-sharing code", "introduced": "\\cite{arXiv:quant-ph/0503139}", "description": "A family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes approximately correcting errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) qubits, i.e., with approximate distance approaching the no-cloning bound \\(n/2\\). Constructed using a non-degenerate CSS code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an \\(t\\)-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.", "protection": "Corrects up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors with fidelity exponentially lose to 1.", "features": {"encoders": ["Uses a quantum authentication scheme, which is a keyed system in which a valid state has high fidelity, and a classical secret-sharing scheme."], "decoders": ["Decoding is analagous to reconstruction in a secret sharing scheme and is done in polynomial time. The only required operations are verification of quantum authentication, which is a pair of polynomial-time quantum algorithms that check if the fidelity of the received state is close to 1, and erasure correction for a stabilizer code, which involves solving a system of linear equations."]}, "relations": {"parents": [{"code_id": "galois_css", "detail": "The code required to construct this code must be a non-degenerate Galois-qubit CSS code."}], "cousins": [{"code_id": "approximate_qecc", "detail": "Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors."}, {"code_id": "galois_polynomial", "detail": "Polynomial codes can be used for a specific construction of this code."}, {"code_id": "reed_solomon", "detail": "The classical information in this code is encoded using a Reed-Solomon code."}]}}, "galois_css": {"code_id": "galois_css", "physical": "galois", "logical": "galois", "name": "Galois-qudit CSS code", "description": "Stub.", "relations": {"parents": [{"code_id": "galois_stabilizer", "detail": ""}], "cousins": [{"code_id": "css", "detail": "Extension of qubit CSS codes to Galois qudits."}, {"code_id": "qudit_css", "detail": ""}]}}, "galois_polynomial": {"code_id": "galois_polynomial", "physical": "galois", "logical": "galois", "name": "Galois-qudit polynomial code (QPyC)", "introduced": "\\cite{arxiv:quant-ph/9906129}", "description": "Stub.", "protection": "Also called \\textit{quantum Reed-Solomon code}.", "relations": {"parents": [{"code_id": "galois_css", "detail": ""}], "cousins": [{"code_id": "polynomial", "detail": ""}, {"code_id": "reed_solomon", "detail": ""}, {"code_id": "cyclic", "detail": ""}]}}, "distance_balanced": {"code_id": "distance_balanced", "name": "Distance-balanced code", "introduced": "\\cite{arxiv:1611.03790,arxiv:2004.07935}", "description": "CSS stabilizer code constructed from another CSS code using a distance-balancing procedure.", "relations": {"parents": [{"code_id": "css", "detail": ""}, {"code_id": "quantum_ldpc", "detail": "Distance-balancing procedure can yield QLDPC codes; see Thm. 1 in Ref. \\cite{arxiv:1611.03790}."}], "cousins": [{"code_id": "balanced_product", "detail": "According to \\cite{arXiv:2012.09271}, distance balancing is used to form balanced-product subsystem codes."}, {"code_id": "quantum_ldpc", "detail": "Distance-balancing procedure can yield QLDPC codes; see Thm. 1 in Ref. \\cite{arxiv:1611.03790}."}, {"code_id": "gauge_stabilizer", "detail": ""}]}}, "dynamic_gen": {"code_id": "dynamic_gen", "name": "Dynamically-generated quantum error-correcting code", "introduced": "\\cite{arXiv:0708.4025}", "description": "Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process.", "protection": "", "relations": {"parents": [{"code_id": "oecc", "detail": ""}]}}, "quantum_concatenated": {"code_id": "quantum_concatenated", "name": "Concatened code", "description": "A concatened code is a combination of two codes, an inner code \\(C\\) and an outer code \\(C^\\prime\\), where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code \\(C^\\prime\\), and then one encodes each of the physical registers of \\(C^\\prime\\) in an inner code \\(C\\).", "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "quantum_cyclic": {"code_id": "quantum_cyclic", "name": "Quantum cyclic code", "introduced": "\\cite{arXiv:1007.1697}", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits) is cyclic if a cyclic permutation of the subsystems leaves the code subspace invariant.", "protection": "Cyclic symmetry guarantees that if a single subsystem is protected against some noise, then all other subsystems are also.", "features": {"decoders": ["Adapted from the Berlekamp decoding algorithm for classical BCH codes \\cite{arXiv:1007.1697}."]}, "notes": ["Many examples have been found by computer algebra programs. Ref. \\cite{arXiv:1007.1697} give examples of \\([[17,1,7]]\\) and \\([[17,9,3]]\\) quantum cyclic codes."], "relations": {"parents": [{"code_id": "qecc"}], "cousins": [{"code_id": "cyclic"}]}}, "topological": {"code_id": "topological", "name": "Topological code", "description": "Stub.", "relations": {"parents": [{"code_id": "hamiltonian", "detail": "Codespace is either the ground-state or low-energy subspace of a geometrically local Hamiltonian admitting a topological phase."}], "cousins": [{"code_id": "quantum_ldpc", "detail": "Stabilizer-based topological codes (e.g., the surface code) on appropriate tesselations are QLDPC."}]}}, "random_circuit": {"code_id": "random_circuit", "name": "Random-circuit code", "description": "Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.", "protection": "", "relations": {"parents": [{"code_id": "dynamic_gen", "detail": ""}]}}, "approximate_qecc": {"code_id": "approximate_qecc", "name": "Approximate quantum code", "introduced": "\\cite{arxiv:quant-ph/9704002,doi:10.1070/RM1997v052n06ABEH002155,arXiv:quant-ph/0307138,arXiv:quant-ph/0503139,arXiv:0907.5391}", "description": "Stub.", "relations": {"parents": [{"code_id": "qecc", "detail": ""}]}}, "holographic": {"code_id": "holographic", "name": "Holographic code", "introduced": "\\cite{arxiv:1503.06237}", "description": "A code whose encoding isometry serves to model aspects of the AdS/CFT holographic duality. Encodes operators in the bulk of the Anti de Sitter (AdS) space, represented by logical qudits, into operators on the boundary of the corresponding Conformal Field Theory (CFT), represented by physical qudits. Encoding can often be represented by a tensor network associated with a tiling of hyperbolic space. See Defn 4.3 of Ref. \\cite{arxiv:2108.11402} for a technical formulation.\n\nTypically, the encoding isometry \\(U\\) obeys the \\textit{entanglement-wedge reconstruction condition}, which states that for any boundary region \\(R\\), any bulk operator \\(O\\) localized to the entanglement wedge of \\(R\\) must be implementable by some boundary operator \\(\\tilde{O}\\) localized to \\(R\\). Formally, \\(UO = \\tilde{O}U\\) and \\([\\tilde{O},UU^\\dagger] = 0\\). The entanglement wedge is the space enclosed within the Ryu\u2013Takayanagi surface in the bulk (minimal surface) with boundary \\(R\\).\n", "protection": "Protects against erasure errors on the boundary. Error-correction properties are often stated in the Heisenberg picture, i.e., in terms of which logical operators can be \\textit{reconstructed} after erasures. Specifically, bulk operators outside the entanglement wedges of the erased boundary operators can be reconstructed using the remaining boundary operators. However, the protection can be nontrivial, and may only apply to a subalgebra of bulk operators \\cite{arxiv:1411.7041,arXiv:1612.00017}.", "features": {"transversal_gates": "There exist holographic approximate codes with arbitrary transversal gate sets for any compact Lie group \\cite{arxiv:2108.11402}.", "threshold": ["The ideal holographic code (perfect representation of AdS/CFT) should be able to protect a central bulk operator against erasures of half of the physical qubits on the boundary, in line with AdS-Rindler reconstruction \\cite{arxiv:1503.06237}."]}, "notes": ["All Boundary global symmetries must be dual to bulk gauge symmetries, and vice versa \\cite{arxiv:1810.05338}."], "relations": {"parents": [{"code_id": "oaecc", "detail": "Properties of holographic codes are often quantified in the Heisenberg picture, i.e., in terms of operator algebras \\cite{arxiv:1411.7041,arXiv:1612.00017}."}]}}, "fracton": {"code_id": "fracton", "name": "Fracton code", "description": "A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.", "protection": "", "relations": {"parents": [{"code_id": "hamiltonian", "detail": "Codespace is the ground-state subspace of a geometrically local Hamiltonian admitting a fracton phase."}], "cousins": [{"code_id": "topological", "detail": ""}]}}, "hamiltonian": {"code_id": "hamiltonian", "name": "Hamiltonian-based code", "description": "Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy. When the physical space is a tensor product of subsystems, the Hamiltonian is typically \\textit{local}, consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., \\hyperref[code:quantum_ldpc]{quantum LDPC codes}). When the physical space is endowed with a geometry, the Hamiltonian is typically \\textit{geometrically local}, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., \\hyperref[code:topological]{topological codes}).", "protection": "Typically determined from the underlying physical properties of the Hamiltonian.", "features": {"encoders": ["Lindbladian-based dissipative encoding can be constructed for a codespace that is the ground-state subspace of a frustration-free Hamiltonian \\cite{arXiv:0809.0613,arXiv:1112.4860,arxiv:0803.1447,arxiv:1802.00010}."]}, "relations": {"parents": [{"code_id": "oecc", "detail": ""}]}}, "fusion": {"code_id": "fusion", "name": "Fusion-based quantum computing (FBQC) code", "introduced": "\\cite{arXiv:2101.09310}", "description": "Fusion Based Quantum Computing, or FBQC, describes a fault tolerant way to produce \\textit{fusion networks}, or large entangled states starting from small constant-sized entangled resource states along with destructive measurements called \\textit{fusions}. These large states can be produced asychronously in the fusion framework and can be used as resources, as in measurement-based quantum computation (MBQC), or as logical states of topological codes. The difference from ordinary MBQC is that error-correction is baked into the state-generation protocol.", "protection": "Protects against erasure, Pauli errors, photon loss, fusion failure from non-determinism, and faulty resource states. Redundancy in fusion outcomes is captured by the check operator group. Fusion measurement outcomes form a syndrome that allows to correct for Pauli errors. There is no physical error correction, and decoding output is simply used to update the Pauli frame.", "features": {"encoders": ["Resource state generators, which produce small constant size cluster states, and Fusion measurements (Bell fusions)."], "general_gates": ["Clifford gates by creating topological features such as boundaries, defects, or twists, which can be done by single qubit measurements.", "Logical gates can be performed by code deformation.", "Non Clifford gates by Magic-state injection", "Logical Clifford operations can be kept track of using the classical Pauli-frame register and need not be explicitly applied at the quantum level."], "fault_tolerance": ["Fusion networks are constructed in a fault tolerant way (as a stabilizer code), and they can be created in a way that naturally encodes topological fault tolerance."], "threshold": ["\\(11.98\\%\\) against erasure in fusion measurements.", "\\(1.07\\%\\) against Pauli error.", "In linear optical systems, can tolerate \\(10.4\\%\\) probability of photon loss in each fusion.", "\\(43.2\\%\\) against fusion failure."]}, "relations": {"parents": [{"code_id": "stabilizer", "detail": "The resource states in FBQC are small stabilizer states, and after fusion measurements, the outputs are stabilizers (conditioned on measurement outcomes)."}], "cousins": [{"code_id": "topological", "detail": "Arbitrary topological codes can be created using FBQC, as can topological features such as defects and boundaries, by modifying fusion measurements or adding single qubit measurements."}, {"code_id": "fock_state", "detail": "While FBQC is a general framework, an intended application to linear-optical quantum computing will likely utilize small Fock-state bosonic codes such as the dual-rail code."}]}}, "quantum_perfect": {"code_id": "quantum_perfect", "name": "Perfect quantum code", "description": "A non-degenerate code constructed out of \\(q\\)-dimensional qudits and having parameters \\(((n,K,2t+1))\\) is perfect if \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the quantum Hamming bound\n\\begin{align}\n\\sum_{j=0}^{t}(q^2-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a qubit \\(q=2\\) code with one logical qubit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(3n+1 \\leq 2^{n-1}\\). The bound can be saturated only at certain \\(n\\).\n\nFor qubit codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-\\frac{t}{n}\\log_{2}3-H(t/n),\n\\end{align}\nwhere \\(H\\) is the binary entropy function.\n", "protection": "Perfect codes have been classified. For qubits (\\(q=2\\)), the only codes are the stabilizer code family \\([[(4^r-1)/3, (4^r-1)/3 - 2r, 3]]\\) for \\(r \\geq 2\\) \\cite{arxiv:quant-ph/9607027,arxiv:quant-ph/9608006}. For qudits, the family is parameterized by \\(K=q^{n-2r}\\) for \\(n=\\frac{q^{2r}-1}{q^{2}-1}\\) and \\(r \\geq 2\\); all codes correct a single error (\\(t=1\\)) \\cite{arxiv:0907.0049,doi:10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T}. The trivial code (\\(k=n\\)) is also perfect.", "features": {"rate": "\\(k/n\\to 1\\) asymptotically with \\(n\\)."}, "relations": {"parents": [{"code_id": "qudits_into_qudits", "detail": ""}, {"code_id": "galois_into_galois", "detail": ""}], "cousins": [{"code_id": "perfect", "detail": "A classical (quantum) perfect code saturates the classical (quantum) Hamming bound."}]}}, "fermions": {"code_id": "fermions", "physical": "fermions", "logical": "fermions", "name": "Fermionic code", "description": "Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators \\cite{arXiv:quant-ph/0003137}.", "protection": "", "relations": {"parents": [{"code_id": "qecc_finite", "detail": ""}], "cousins": [{"code_id": "qubits_into_qubits", "detail": "While the Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation \\cite{arXiv:cond-mat/0010440}, codes based on the two algebras have different notions of locality and thus qualitatively different physical interpretations."}, {"code_id": "oscillators", "detail": "Bosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom."}]}}, "majorana_stab": {"code_id": "majorana_stab", "physical": "fermions", "logical": "fermions", "name": "Majorana stabilizer code", "introduced": "\\cite{arXiv:1004.3791}", "description": "Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as \\textit{Majorana stabilizers}. The codespace is the mutual \\(+1\\) eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as \\([[n,k,d]]_{f}\\) \\cite{arXiv:1703.00459}, where \\(n\\) is the number of fermionic modes.", "protection": "Detects products of Majorana operators with weight up to \\(d-1\\). Physically, protects against dephasing errors caused by coupling of fermion density to the environment and bit-flip errors caused by quasiparticle poisoning processes.", "relations": {"parents": [{"code_id": "fermions", "detail": ""}, {"code_id": "stabilizer", "detail": "The Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators. In addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code \\cite{arXiv:cond-mat/0506438,arXiv:1004.3791}. However, Pauli- and Majorana-based stabilizer codes have different notions of locality \\cite{arXiv:cond-mat/0010440} and are thus useful for different physical platforms."}], "cousins": [{"code_id": "dual", "detail": "Classical weakly self-dual codes can be used to construct Majorana stabilizer codes \\cite{arXiv:1703.00459}. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors \u2013 akin to the binary symplectic representation \u2013 and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a weakly self-dual classical code. A weakly self-dual classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\)."}, {"code_id": "css", "detail": "When constructing a Majorana stabilizer code from a weakly self-dual classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space \\cite{arXiv:1004.3791,arXiv:1703.00459}. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different weakly self-dual classical codes with an odd number of bits, as is often done in the CSS construction."}, {"code_id": "cyclic", "detail": "Cyclic codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also weakly self-dual \\cite{arXiv:1703.00459}."}, {"code_id": "reed_muller", "detail": "Majorana stabilizer codes can be constructed by weakly self-dual Reed-Muller codes \\cite{arXiv:1703.00459}. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code."}]}}}