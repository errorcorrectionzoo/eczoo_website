{"oaecc": {"name": "Operator-algebra error-correcting code", "description": "Stub.", "notes": [], "introduced": "\\cite{arXiv:quant-ph/0203105,arxiv:quant-ph/0608071,arXiv:0705.1574,doi:10.1142/S0219749908003839}", "short_name": "Operator-algebra QECC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "oaecc"}, "eacq": {"name": "Entanglement-assisted hybrid classical-quantum (EACQ) code", "description": "Stub.", "notes": [], "introduced": "\\cite{arXiv:0802.2414,arxiv:1911.12260,arxiv:2202.02184}", "short_name": "EACQ", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "eacq"}, "classical_into_quantum": {"protection": "", "name": "Classical-into-quantum code", "description": "Code designed specifically for transmission of classical information through non-classical channels, e.g., quantum channels, hybrid quantum-classical channels, or channels with classical inputs and quantum outputs. Such codes include maps from a classical alphabet into a quantum Hilbert space.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "classical_into_quantum", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "polar_for_quantum": {"name": "Quantum-classical polar code", "description": "Polar code used to transmit classical information over channels with classical inputs and quantum outputs.\n", "notes": [], "introduced": "\\cite{arxiv:1109.2591,arxiv:1701.03397}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Codes achieve the symmetric Holevo information for sending classical information over any quantum channel.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Quantum-limited successive-cancellation (SC) joint-detection receiver \\cite{arxiv:1109.2591}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "polar_for_quantum"}, "niset_andersen_cerf": {"name": "Niset-Andersen-Cerf code", "description": "Classical-into-quantum code encoding two-mode coherent states \\(\\{|\\alpha\\rangle, |\\beta\\rangle\\}\\) into four modes such that the complex values \\((\\alpha,\\beta)\\) are recoverable after a single-mode erasure. There are two variations of the storage procedure: a deterministic protocol that offers recovery against a single mode erasure, and a probabalistic that can protect against multiple errors with post selection. This code is effectively protecting classical information stored in \\((\\alpha,\\beta)\\) using quantum operations.", "notes": [], "introduced": "\\cite{arXiv:0710.4858}", "short_name": "", "logical": "q-ary_digits", "realizations": ["Realized in Ref. \\cite{doi:10.1038/nphoton.2010.168} in an optical system with 3 beam-splitters. The fidelity peaked around \\(0.6\\) for deterministic approach, and around \\(0.77\\) for the probabilistic approach (with a 25\\% chance of error)."], "features": {"general_gates": [], "encoders": ["After an EPR pair preparation, use 2 continuous CNOT and 2 continuous inverse CNOT gates to entangle a bosonic EPR pair with initial states \\(|\\alpha \\rangle\\) and \\(|\\beta \\rangle\\).", "Alternate optical encoder using a two-mode squeezed vacuum state and two balanced beam splitters to mix the input coherent states with the EPR pair."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Optical decoder using three beam splitters, electronic gain detectors, and two phase-insensitive amplifiers as described in Ref. \\cite{arXiv:0710.4858}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "The deterministic protocol protects against a single erasure error on a known mode. This recovers one state perfectly and the other state with fidelity \\(F = \\frac{1}{1 + e^{-2 r}}\\) for an initial EPR pair squeezed with variance \\(e^{-2r}\\). The probabalistic protocol utilizes post-selection to protect against multiple erasures with state-dependent fidelity.", "code_id": "niset_andersen_cerf"}, "ecc": {"name": "Error-correcting code (ECC)", "description": "Code designed for transmission of classical information through classical channels in a robust way.\n", "notes": [], "introduced": "", "short_name": "ECC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "ecc"}, "analog": {"name": "Analog code", "description": "Encodes states (codewords) into coordinates in the \\(n\\)-dimensional real coordinate space \\(\\mathbb{R}^n\\).\nThe number of codewords may be infinite because the coordinate space is infinite-dimensional, so various restricted versions have to be constructed in practice.\n\nAnalog codes provide ways of encoding digital or analog information into the frequency, amplitude, and phase of one or more analog waveforms for transmission through, e.g., an optical fiber or free space.\nThis is due to Kotelnikov's \\cite{manual:{V. A. Kotelnikov, \u201cThe theory of optimum noise immunity,\u201d PhD Thesis, Molotov Energy Institute, Moscow, Jan. 1947}} and Shannon's \\cite{doi:10.1109/JRPROC.1949.232969} fundamental observation that a discretized electromagnetic signal of finite-bandwidth can be represented as a point in \\(\\mathbb{R}^n\\).\nQuestions of capacity of electromagnetic communication channels then translate to packing problems in \\(\\mathbb{R}^n\\) \\cite{doi:10.1007/978-1-4757-6568-7}.\n\nIn the electromagnetic context, the information stored in the code is called the \\textit{bitstream}, coordinates used for encoding are often called \\textit{signal points} and form a \\textit{constellation}, and \\(\\mathbb{R}^n\\) is called the \\textit{signal space}.\n\nAn analog code is mapped into a time-dependent electromagnetic signal using a \\textit{modulation scheme} \\cite{doi:10.1007/b100498,doi:10.1017/9781316822708}.\nThere is a close relation between abstract real-space encodings and modulation schemes, so analog codes are often named after modulation schemes.\n\nLinear modulation schemes encode points into amplitudes of electromagnetic waveforms.\n\\textit{Pulse-amplitude modulation (PAM)} associates each point with a real-valued amplitude of one quadrature of an electromagnetic waveform \\cite[Sec. 10.5]{doi:10.1017/9781316822708}.\n\\textit{Quadrature amplitude modulation (QAM)} associates each pair of points with a complex-valued two-quadrature amplitude of band-limited signal \\cite[Ch. 16]{doi:10.1017/9781316822708}.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Random analog codes can achieve the capacity of the additive Gaussian white-noise channel \\cite{doi:10.1002/j.1538-7305.1959.tb03905.x}; see the book \\cite{doi:10.1007/978-1-4757-6568-7} for more details. Deterministic sets of constellations from quadrature rules can also achieve capacity \\cite{doi:10.1109/ALLERTON.2010.5706965}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Each signal point is assigned its own Voronoi cell, and a received point is mapped back to the center of the Voronoi cell that it is located upon reception."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "The primary application of analog codes is to transmist information using electromagnetic signals. The primary noise channel for such signals is the \\textit{additive Gaussian white-noise channel (AGWN)}, which adds a random Gaussian-distributed displacement to each signal point.\nProtection of a constellation thus depends on how far apart its points are in terms of the Euclidean distance.\nAs usual, there is a tradeoff between packing of space and level of protection.\n", "code_id": "analog"}, "points_into_spheres": {"name": "Constant-energy code", "description": "Code whose codewords are points on a hypersphere whose radius squared is called the \\textit{energy}.\nTypically, only angular distances between points are relevant for code performance, so one can normalize codewords of a constant-energy code to obtain up a spherical code, i.e., a constant energy code with energy one.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "points_into_spheres"}, "spherical": {"name": "Spherical code", "description": "Code whose codewords are points on an \\(n\\)-dimensional sphere \\(S^{n}\\) with radius one.\nIt is denoted as \\((n,M,\\rho)\\), where \\(n\\) is the code \\textit{dimension}, \\(M\\) is the size or number of codewords, and \\(\\rho\\) is the \\textit{squared minimum distance}, i.e., the smallest Euclidean distance between pairs of distinct codewords,\n\\begin{align}\n  \\rho=\\min\\left\\{ \\left\\Vert x-y\\right\\Vert ^{2}\\,\\text{s.t.}\\,x,y\\in C,\\,\\,x\\neq y\\right\\}~.\n\\end{align}\n\nA spherical code can be defined using the Gram matrix \\(G = XX^T\\), where the rows of \\(X\\) are the codeword vectors.\nThe Gram matrix is symmetric, positive-definite, and has all diagonal elements equal to one.\nThe code dimension is equal to the rank of \\(G\\), which can be less than the dimension of the codeword vectors.\n\nSpherical codeword components are often taken from a discrete set of real values called an \\textit{alphabet}.\nFor example, codewords of any length-\\(n\\) binary code can be mapped into spherical codewords with alphabet \\(\\{\\pm 1/\\sqrt{n} \\}\\) via the antipodal mapping \\(0\\to +1\\) and \\(1 \\to -1\\) \\cite[Example 1.2.1]{preset:EricZin}.\n", "notes": ["See the book \\cite{preset:EricZin} for more details."], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "The Euclidean distance between two points is related to the dot product as\n\\begin{align}\n  \\left\\Vert x-y\\right\\Vert^{2} = 2-2x \\cdot y~,\n\\end{align}\nwhere \\(x\\cdot y\\) is the Euclidean inner product. As a result, the \\textit{angular distance},\n\\begin{align}\n  \\theta=\\arccos(x\\cdot y) \\in[0,\\pi]~,\n\\end{align}\ncan be equivalently used to quantify code performance.\n\nDenote \\(A_n(\\rho)\\) to be the largest possible size of a spherical code with distance \\(\\rho\\).\nSpherical code parameters \\((n,M,\\rho)\\) as well as \\(A_n(\\rho)\\) satisfy the following three \\textit{Rankin bounds} \\cite{doi:10.2307/1969393,manual:{Davenport, H., & Hajos, G. (1951). Aufgabe 35. Math. Lapok, 58.},doi:10.1017/S2040618500033219}\n\\begin{align}\n  \\begin{split}\n  \\rho & \\leq\\frac{2M}{M-1}\\\\\n  A_{n}\\left(\\rho\\right) & \\leq n+1\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,2<\\rho\\leq4\\\\\n  A_{n}\\left(2\\right) & \\leq2n~.\n  \\end{split}\n\\end{align}\n", "code_id": "spherical"}, "simplex_spherical": {"name": "Simplex spherical code", "description": "Spherical \\((n,n+1,2+2/n)\\) code whose codewords are all permutations of the \\(n+1\\)-dimensional vector \\((1,1,\\cdots,1,-n)\\), up to normalization.\nCodewords are all equidistant and their components add up to zero.\nFor example, the spherical simplex code in \\(n=3\\) makes up the corners of a tetrahedron.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "Simplex spherical codes for \\(2 < \\rho \\leq 4\\) saturate the first two Rankin bounds \\cite{preset:EricZin}.\n", "code_id": "simplex_spherical"}, "biorthogonal": {"name": "Biorthogonal spherical code", "description": "Spherical \\((n,2n,2)\\) code whose codewords are all permutations of the \\(n\\)-dimensional vectors \\((0,0,\\cdots,0,\\pm1)\\), up to normalization.\nFor example, the biorthogonal code in \\(n=3\\) makes up the corners of an octahedron.\n\nThe set of permutations of \\((0,0,\\cdots,0,1)\\) forms an orthogonal set and yields the biorthogonal code when combined with the set of permutations of \\((0,0,\\cdots,0,-1)\\).\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "Biorthogonal spherical codes saturate the third Rankin bound \\cite{preset:EricZin}.\n", "code_id": "biorthogonal"}, "binary_antipodal": {"name": "Binary signal constellation", "description": "An \\((n,K,4d/n)\\) spherical code obtained from a binary \\((n,K,d)\\) code via a component-wise \\textit{antipodal mapping} (also known as a \\textit{Euclidean-space image}) \\(0\\to +1\\) and \\(1 \\to -1\\) \\cite[Example 1.2.1]{preset:EricZin}.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "binary_antipodal"}, "lattice_shell": {"name": "Lattice-shell code", "description": "Spherical code whose codewords are scaled versions of points on a lattice.\nEach code is constructed by normalizing a set of lattice vectors in one or more \\textit{shells}, i.e., sets of lattice points lying on a hypersphere.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "lattice_shell"}, "dfour_spherical": {"name": "\\(D_4\\) lattice-shell code", "description": "Spherical code whose codewords are points on the \\(D_4\\) lattice.\nThe smallest shell of the lattice consists of the 24 permutations of the four vectors \\((0,0,\\pm 1,\\pm 1)\\), yielding a \\((4,24,1)\\) code.\nThe next highest shell consists of the 16 vectors \\((\\pm 1,\\pm 1,\\pm 1,\\pm 1)\\) and the 8 permutations of the vectors \\((0,0,0,\\pm 2)\\), yielding a equivalent instance of the \\((4,24,1)\\) code.\nThe union of the two codes yields the \\((4,48,2(1-1/\\sqrt{2}))\\) code.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "dfour_spherical"}, "icosahedron": {"name": "Icosahedron code", "description": "Spherical \\((3,12,2-2/\\sqrt{5})\\) code whose codewords are the vertices of the icosahedron, or like in the centers the faces of a dodecahedron.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "Optimal configuration of 12 points in 3D space \\cite[pg. 76]{preset:EricZin}.", "code_id": "icosahedron"}, "snub_cube": {"name": "Snub-cube code", "description": "Spherical \\((3,24,0.55384)\\) code whose codewords are the vertices of the snub cube.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "Optimal configuration of 24 points in 3D space \\cite[pg. 78]{preset:EricZin}.", "code_id": "snub_cube"}, "hessian_polyhedron": {"name": "Hessian polyhedron code", "description": "Spherical \\((6,27,3/2)\\) code whose codewords are the vertices of the Hessian polyhedron.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "hessian_polyhedron"}, "600cell": {"name": "600-cell code", "description": "Spherical \\((4,120,(3-\\sqrt{5})/2)\\) code whose codewords are the vertices of the 600-cell.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "600cell"}, "polytope": {"name": "Polytope code", "description": "Spherical code whose codewords are the vertices of a polytope.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "polytope"}, "square_antiprism": {"name": "Square-antiprism code", "description": "Spherical \\((3,8,4(4-\\sqrt{2})/7)\\) code whose codewords are the vertices of the square antiprism.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "Optimal configuration of nine points in 3D space \\cite[pg. 73]{preset:EricZin}.", "code_id": "square_antiprism"}, "pam": {"name": "Pulse-amplitude modulation (PAM) code", "description": "Encodes a \\(q\\)-ary digit into a constellation of equally spaced points on the real line.\nFor example, a \\(q\\)-PAM scheme for \\(q=8\\) could encode the constellation \\(\\{ \\pm \\alpha,\\pm 3\\alpha,\\pm 5\\alpha, \\pm 7\\alpha \\}\\) with real scaling factor \\(\\alpha\\).\nThe points in the constellation are typically associated with one quadrature of an electromagnetic signal.\n", "notes": [], "introduced": "", "short_name": "PAM", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "pam"}, "psk": {"name": "Phase-shift keyring (PSK) code", "description": "A \\(q\\)-ary phase-shift keyring (\\(q\\)-PSK) encodes one \\(q\\)-ary digit of information into a constellation of \\(q\\) points distributed equidistantly on a circle in \\(\\mathbb{C}\\) or, equivalently, \\(\\mathbb{R}^2\\).\nFor example, such a constellation could be\n\\begin{align}\n  \\{1,e^{i\\frac{2\\pi}{q}},\\cdots,e^{i\\frac{2\\pi}{q}(q-1)}\\}~.\n\\end{align}\nEach point is typically associated with a complex amplitude of an electromagnetic signal, and information is encoded into the phase of that signal.\n", "notes": [], "introduced": "", "short_name": "PSK", "logical": "reals", "realizations": ["Telephone-line modems: 1967 Milgo 4400/48 and international standard V.27 used 8-PSK \\cite{manual:{International Telecommunication Union-T, Recommendation V.27ter: 4800/2400 Bits Per Second Modem Standardized For Use in the General Switched Telephone Network, 1984}}."], "features": {"general_gates": [], "encoders": [], "rate": "Nearly achieves Shannon AWGN capacity for one-dimensional constellations in the limit of infinite signal to noise \\cite[Fig. 11.7]{doi:10.1017/CBO9780511811401}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "psk"}, "bpsk": {"name": "Binary PSK (BPSK) code", "description": "Also called a \\textit{binary antipodal modulation}, \\textit{phase-reversal keyring (PRK)}, or \\textit{antipodal signaling}.\nEncodes one bit of information into a constellation of antipodal points \\(\\pm\\alpha\\) for complex \\(\\alpha\\).\nThese points are typically associated with two phases of an electromagnetic signal in a PAM, PSK, or QAM scheme.\n", "notes": [], "introduced": "\\cite{doi:10.1002/j.1538-7305.1948.tb00917.x}", "short_name": "BPSK", "logical": "reals", "realizations": ["Telephone-line modems throughout 1950s and 1960s: Bell 103 and 202, as well as international standards V.21 \\cite{manual:{International Telecommunication Union-T, Recommendation V.21: 300 bits per second duplex modem standardized for use in the general switched telephone network, 1984}} and V.23 \\cite{manual:{International Telecommunication Union-T, Recommendation V.23: 600/1200-baud modem standardized for use in the general switched telephone network, 1988}}."], "features": {"general_gates": [], "encoders": [], "rate": "Achieve capacity of AGWN in the low signal-to-noise regime \\cite{doi:10.1109/ALLERTON.2010.5706965} (see also \\cite{doi:10.1002/j.1538-7305.1948.tb00917.x}). BPSK concatenated with quantum-classical polar codes achieves the Holevo capacity for the pure-loss channel \\cite{arxiv:1202.0533}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "bpsk"}, "qpsk": {"name": "Quadrature PSK (QPSK) code", "description": "Also known as \\textit{quadriphase PSK}, \\textit{4-PSK}, or \\textit{4-QAM}.\nQuaternary encoding into a constellation of four points distributed equidistantly on a circle.\nFor the case of \\(\\pi/4\\)-QPSK, the constellation is \\(\\{e^{\\pm i\\frac{\\pi}{4}},e^{\\pm i\\frac{3\\pi}{4}}\\}\\).\n", "notes": [], "introduced": "\\cite{doi:10.1109/TCE.1962.6373228}", "short_name": "QPSK", "logical": "reals", "realizations": ["Japanese and North American digital cellular and personal systems \\cite{doi:10.1109/25.289416}.", "Telephone-line modems: 1962 Bell 201 and international standard V.24 \\cite{manual:{International Telecommunication Union-T, Recommendation V.24: List of definitions for interchange circuits between data terminal equipment (DTE) and data circuit-terminating equipment (DCE), 1988}}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "qpsk"}, "qam": {"name": "Quadrature-amplitude modulation (QAM) code", "description": "Encodes into points into a subset of points lying on in \\(\\mathbb{R}^{2}\\), here treated as \\(\\mathbb{C}\\).\nEach pair of points is associated with a complex amplitude of an electromagnetic signal, and information is encoded into both the norm and phase of that signal \\cite[Ch. 16]{doi:10.1017/9781316822708}.\n\nQAM schemes with \\(q\\) complex coordinates are often called \\(q\\)-QAM, and \\(q\\) is often a power of two in order to further concatenate with a binary code.\n", "notes": [], "introduced": "", "short_name": "QAM", "logical": "reals", "realizations": ["Optical communication (e.g., Ref. \\cite{doi:10.1109/JLT.2015.2510034}).", "Telephone-line modems: 1971 Codex 9600C and international standard V.29 used 16-QAM \\cite{manual:{International Telecommunication Union-T, Recommendation V.29: 9600 Bits Per Second Modem Standardized For Use on Point-to-Point 4-Wire Leased Telephone-Tpe Circuits, 1993}}."], "features": {"general_gates": [], "encoders": [], "rate": "Nearly achieves Shannon AWGN capacity for two-dimensional constellations in the limit of infinite signal to noise \\cite[Fig. 11.8]{doi:10.1017/CBO9780511811401}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "qam"}, "eeight": {"name": "\\(E_8\\) Gosset lattice code", "description": "BW lattice in dimension \\(8\\), which is the lattice corresponding to the \\([8,4,4]\\) Hamming code via the mod-two lattice construction.\n", "notes": [], "introduced": "\\cite{manual:{Gosset, Thorold. \"On the regular and semi-regular figures in space of n dimensions.\" Messenger of Mathematics 29 (1900): 43-48.}}", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "The \\(E_8\\) lattice has a nominal coding gain of \\(2\\).\n", "code_id": "eeight"}, "leech": {"name": "Leech lattice code", "description": "Lattice in 24 dimensions that exhibits optimal packing.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "The \\(E_8\\) lattice has a nominal coding gain of \\(4\\).\n", "code_id": "leech"}, "construction_a": {"name": "Mod-2 lattice code", "description": "Lattice constructed from a binary linear \\([n,k,d]\\) code using Construction A \\cite{doi:10.1007/978-1-4757-6568-7}.\nEach binary codeword \\(c\\) of the code is mapped to an infinite set of points \\(x\\) such that \\(x = c\\) modulo two.\nLinearity of the code ensures that the resulting set of points forms a lattice.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "", "code_id": "construction_a"}, "dfour": {"name": "\\(D_4\\) lattice code", "description": "BW lattice in dimension \\(4\\), which is the lattice corresponding to the \\([4,1,4]\\) repetition and \\([4,3,2]\\) SPC codes via the mod-two lattice construction.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "The \\(D_4\\) lattice has a nominal coding gain of \\(\\sqrt{2}\\).\n", "code_id": "dfour"}, "points_into_lattices": {"name": "Lattice-based code", "description": "Encodes states (codewords) in coordinates of an \\(n\\)-dimensional lattice. The number of codewords may be infinite because the coordinate space is infinite-dimensional, so various restricted versions have to be constructed in practice. Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.", "notes": ["See book \\cite{doi:10.1007/978-1-4757-6568-7} for an introduction and overview of lattices."], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "Lattices are characterized by the \\textit{minimum (Euclidean) distance} \\(d_{\\text{min}}\\) between two lattice points, the \\textit{kissing number} \\(K_{\\text{min}}\\) of nearest neighbors at each lattice point, and the \\textit{volume} \\(V=\\det G\\), which is equal to the determinant of the lattice generator matrix \\(G\\).\n\nThe \\textit{nominal coding gain} \\(\\gamma_{c}\\) (a.k.a. \\textit{Hermite parameter}) of an \\(n\\)-dimensional lattice is\n\\begin{align}\n  \\gamma_{c}=\\left(d_{\\text{min}}/\\sqrt[n]{V}\\right)^{2}~,\n\\end{align}\ncharacterizing the ratio of the level of protection to the required spatial resources.\n", "code_id": "points_into_lattices"}, "barnes_wall": {"name": "Barnes-Wall (BW) lattice code", "description": "Member of a family of \\(2^{m+1}\\)-dimensional lattices, denoted as BW\\(_{2^{m+1}}\\), that are the densest lattices known.\nMembers include the integer square lattice \\(\\mathbb{Z}^2\\), \\(D_4\\), the Gosset \\(E_8\\) lattice, and the \\(\\Lambda_{16}\\) lattice, corresponding to \\(m\\in\\{0,1,2,3\\}\\), respectively.\n", "notes": [], "introduced": "", "short_name": "", "logical": "reals", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "reals", "protection": "BW lattices in dimension \\(2^{m+1}\\) have a nominal coding gain of \\(2^{m/2}\\).\nTheir kissing number is \\(K_{\\text{min}} = \\prod_{i=1}^{m+1} (2^i + 2)\\).\n", "code_id": "barnes_wall"}, "regenerating": {"name": "Regenerating code (RGC)", "description": "Stub.", "notes": [], "introduced": "", "short_name": "RGC", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "", "code_id": "regenerating"}, "matrix_computation": {"name": "Matrix computation code", "description": "Encoding that provides an extra redundancy for distributed matrix computation algorithms such as matrix multiplication. Parallelized algorithms distribute a desired computation over many nodes, and a key performance bottleneck is due to some nodes completing their individual tasks much later than other nodes. Matrix computation codes provide a layer of redundancy such that the computation can be performed without having all nodes finish their piece of the computation.\n", "notes": [], "introduced": "", "short_name": "", "logical": "matrices", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "Allows computation to complete without waiting for \\textit{stragglers}, or nodes that either do not finish or finish their portion of the computation much later than all other nodes.", "code_id": "matrix_computation"}, "rank_metric": {"name": "Rank-metric code", "description": "Also called a \\textit{Delsarte code}. Each codeword is a \\textit{matrix} over \\(GF(q)\\), with codewords forming a \\(GF(q)\\)-linear subspace, and with the metric being the rank of the difference of matrices. The distance \\(d\\) is the minimum rank of all nonzero matrices in the code. Rank-metric codes on \\(n\\times m\\) matrices are denoted as \\([n\\times m,k,d]_q\\).\n\nThe number of codewords satisfies \\(k \\leq \\max(n, m) M\\), where \\(M\\) is the maximum rank of all matrices in the code. Codes that achieve this bound with equality are called \\textit{Delsarte optimal anticodes}.\n", "notes": ["See Ref. \\cite{arXiv:1410.1333} for a discussion of MacWilliams identities and the relationship between rank metric and Gabidulin codes."], "introduced": "\\cite{doi:10.1016/0097-3165(78)90015-8}", "short_name": "", "logical": "matrices", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Polynomial-reconstruction Berlekamp-Welch based decoder \\cite{doi:10.1007/11779360_4}.", "Berlekamp-Massey based decoder \\cite{doi:10.1109/ISIT.2004.1365435}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "Protects against errors with rank \\(\\leq \\lfloor \\frac{d-1}2 \\rfloor\\).", "code_id": "rank_metric"}, "alamouti": {"name": "Alamouti code", "description": "The simplest OSTBC, with two time slots, two channels, and with unitary coding matrix\n\\begin{align}\n  \\begin{pmatrix}c_{1} & c_{2}\\\\\n  -c_{2}^{\\star} & c_{1}^{\\star}\n  \\end{pmatrix}~,\n\\end{align}\nwhere \\(c_i\\) are complex numbers.\n", "notes": [], "introduced": "\\cite{doi:10.1109/49.730453}", "short_name": "", "logical": "q-ary_digits", "realizations": ["Wireless standards since: 3G, LTE, LTE-Advanced, and 5G.", "WiFi standards: 802.11n, 802.11ad, 802.11ay, etc."], "features": {"general_gates": [], "encoders": [], "rate": "The only OSTBC with unity rate.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "", "code_id": "alamouti"}, "matrices_into_matrices": {"name": "Matrix-based code", "description": "Encodes \\(K\\) states (codewords) in an \\(m\\times n\\)-dimensional \\textit{matrix} of coordinates over a field (e.g., the Galois field \\(GF(q)\\) or the complex numbers \\(\\mathbb{C}\\)).", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "", "code_id": "matrices_into_matrices"}, "spacetime": {"name": "Spacetime code (STC)", "description": "Code designed for wireless transmission of information (via, e.g., radio waves) such that the sender can send multiple times from multiple locations. A spacetime code uses a modulation scheme to encode a message into signals that are sent at different times through different antennas, thereby utilizing both spatial and temporal (i.e., \\textit{spacetime}) degrees of freedom.\n", "notes": ["See the chapter \\cite{doi:10.1016/B978-0-12-385055-3.00002-X} or the Ch. 28 of Ref. \\cite{doi:10.1201/9781315147901} for an introduction to spacetime coding."], "introduced": "\\cite{doi:10.1109/18.661517}", "short_name": "STC", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "", "code_id": "spacetime"}, "spacetime_block": {"name": "Spacetime block code (STBC)", "description": "In a space-time block code, \\(n\\) spatially separated channels transmit symbols in \\(T\\) time slots. These symbols can be arranged in a \\(T\\times n\\) matrix where the columns correspond to the channels, and the rows correspond to the time slots. The codewords \\(\\{X\\}\\) are \\(T\\times n\\) matrices such that the codeword difference matrices have rank \\(n\\), and \\(\\min_{X\\neq 0}\\det(XX^*)\\) is maximized.", "notes": [], "introduced": "\\cite{doi:10.1109/49.730453}", "short_name": "STBC", "logical": "q-ary_digits", "realizations": ["High data-rate wireless communication, e.g., WiMAX (IEEE 802.16m) \\cite{doi:10.1007/s11235-013-9846-3,doi:10.1109/JSTSP.2008.922508,doi:10.1109/MWC.2006.1678163}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "Provides protection against errors due to thermal noise and destructive interference arising from traversing an environment with scattering, reflection, and/or refraction.", "code_id": "spacetime_block"}, "mbr": {"name": "Minimum-bandwidth regenerating (MBR) code", "description": "Stub.", "notes": [], "introduced": "", "short_name": "MBR", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "", "code_id": "mbr"}, "orth_spacetime_block": {"name": "Orthogonal Spacetime Block Code (OSTBC)", "description": "The codewords are \\(T\\times n\\) matrices as defined for spacetime codes, with the additional condition that columns of the coding matrix are orthogonal. The parameter \\(n\\) is the number of channels, and \\(T\\) is the number of time slots.", "notes": [], "introduced": "\\cite{doi:10.1109/49.730453}", "short_name": "OSTBC", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "The greatest rate which can be achieved is \\(\\frac{n_0+1}{2n_0}\\), where either \\(n=2n_0\\) or \\(n=2n_0-1\\) \\cite{doi:10.1109/TIT.2003.817426}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Maximum-likelihood decoding can be achieved with only linear processing \\cite{doi:10.1109/49.753730}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "If the matrix \\(C-C'\\), where \\(C\\) and \\(C'\\) are distinct codewords, has minimum rank \\(b\\), the code has diversity order \\(bn_R\\) (see Ref. \\cite{doi:10.1201/9781315147901}, Sec. 28.2.1), where \\(n_R\\) is the number of receivers. The maximum possible diversity order is \\(nn_R\\).", "code_id": "orth_spacetime_block"}, "msr": {"name": "Minimum-storage regenerating (MSR) code", "description": "Stub.", "notes": [], "introduced": "", "short_name": "MSR", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "", "code_id": "msr"}, "maximum_rank_distance": {"name": "Maximum-rank distance (MRD) code", "description": "Also called an \\textit{optimal rank-distance} code. An \\([n\\times m,k,d]_q\\) rank-metric code whose parameters are such that the Singleton-like bound\n\\begin{align}\nk \\leq \\max(n, m) (\\min(n, m) - d + 1)\n\\end{align}\nbecome an equality.\n", "notes": [], "introduced": "\\cite{doi:10.1016/0097-3165(78)90015-8,manual:{E. M. Gabidulin, \"Theory of Codes with Maximum Rank Distance\", Problemy Peredachi Informacii, Volume 21, Issue 1, \\emph{3\u201316} (1985)},doi:10.1109/18.75248}", "short_name": "MRD", "logical": "matrices", "realizations": ["Useful for error and erasure correction in network coding \\cite{arXiv:cs/0703061,arXiv:0711.0708}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "", "code_id": "maximum_rank_distance"}, "tensor": {"name": "Tensor-product code", "description": "Also called \\textit{tensor code}, \\textit{Kroneckerian code}, or \\textit{product code}. A matrix-based code constructed out of two linear binary or \\(q\\)-ary codes \\(C_A,C_B\\) in an outer-product construction denoted as \\(C_A \\otimes C_B\\). Its dual is sometimes called the \\textit{check-product} code \\cite[Lemma 3.3]{arxiv:2209.11405}.\n\nCodewords are those matrices whose column vectors are in \\(C_A\\) and whose row vectors are in \\(C_B\\).\nIn other words, the matrix-valued codewords \\(c\\) of a tensor code satisfy the parity check equation \\(H_A c H^{\\text{T}}_B = 0\\).\n", "notes": ["See Refs. (\\cite{preset:MacSlo}, Ch. 18; \\cite{manual:{Wolf, Jack Keil. \"An introduction to tensor product codes and applications to digital storage systems.\" 2006 IEEE Information Theory Workshop-ITW 2006 Chengdu. IEEE, 2006.}}) for expositions."], "introduced": "\\cite{doi:10.1109/TIT.1954.1057464,doi:10.1109/TIT.1965.1053802,preset:Forney,doi:10.1109/TIT.1970.1054477}", "short_name": "", "logical": null, "realizations": ["Construction can be used in magnetic recording by taking the tensor product of a Reed-Solomon code and a parity-check code \\cite{doi:10.1109/TMAG.2005.861043}."], "features": {"general_gates": [], "encoders": [], "rate": "Rate of the tensor-product code \\(C_A \\otimes C_B\\) is a product of the rates of the codes \\(C_A\\) and \\(C_B\\).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["The simple decoding algorithm (first decode all columns with \\(C_1\\), then all rows with \\(C_2\\)) corrects up to \\((d_A d_B-1)/4 \\) errors.", "Algorithms such as generalized minimum-distance decoding \\cite{doi:10.1109/TIT.1966.1053873} or the min-sum algorithm can decode all errors of weight up to \\((d_A d_B-1)/2\\). Error location may be coupled with Viterbi decoding for every faulty sub-block \\cite{doi:10.1109/TMAG.2005.861043}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "matrices", "protection": "For linear codes \\(C_A=[n_A,k_A,d_A]\\) and \\(C_B=[n_B,k_B,d_B]\\), the resulting tensor code is \\(C_A \\otimes C_B=[n_A n_B,k_A k_B,d_A d_B]\\).\nTensor codes can be useful for protecting against burst errors \\cite{doi:10.1109/TIT.1971.1054690,doi:10.1109/TIT.1973.1055085}.\n\nMany (but not all \\cite{doi:10.1007/11538462_40}) tensor codes are \\textit{robustly testable} \\cite{arXiv:cs/0408066,doi:10.1007/11830924_29,doi:10.1007/978-3-540-85363-3_24}, a property useful for constructing LTCs \\cite{doi:10.1145/1236457.1236459}, including a family of \\(c^3\\)-LTCs \\cite{arxiv:2111.04808}. Duals of tensor codes formed by two random linear codes are also robustly testable, a property useful for constructing asymptotically good QLDPC codes \\cite{arxiv:2206.07750,arxiv:2206.09973} and proving distance bounds \\cite{arxiv:2208.05537}.\n", "code_id": "tensor"}, "nonlinear_ag": {"name": "Nonlinear AG code", "description": "Nonlinear \\(q\\)-ary code constructed by evaluating functions on an algebraic curve.\n", "notes": [], "introduced": "\\cite{arXiv:math/0104115,doi:10.1109/TIT.2003.813559,arXiv:math/0308046,doi:10.1007/978-3-0348-7865-4_18,doi:10.1109/TIT.2005.856977}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Certain nonlinear code sequences beat the Tsfasman-Vladut-Zink bound, outperforming linear AG codes.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "nonlinear_ag"}, "q-ary_parity_check": {"name": "\\(q\\)-ary parity-check code", "description": "Also known as a \\textit{sum-zero} code. An \\([n,n-1,2]_q\\) linear \\(q\\)-ary code whose codewords consist of the message string appended with a parity-check digit such that the sum over all coordinates of each codeword is zero.", "notes": [], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "q-ary_parity_check"}, "q-ary_digits_into_q-ary_digits": {"name": "Galois-field \\(q\\)-ary code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) \\(q\\)-ary coordinates over the field \\(GF(q)=\\mathbb{F}_q\\) and has distance \\(d\\). Usually denoted as \\((n,K,d)_q\\). The distance is the minimum number of coordinates where two strings in the code differ.", "notes": ["Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by Brouwer \\cite{manual:{Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.}}, are maintained by M. Grassl at this \\href{http://codetables.markus-grassl.de/}{website}."], "introduced": "", "short_name": "\\(q\\)-ary", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["For small \\(n\\), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}.", "Given a received string \\(x\\) and an error bound \\(e\\), a \\textit{list decoder} returns a list of all codewords that are at most \\(e\\) from \\(x\\). The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\)."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.", "code_id": "q-ary_digits_into_q-ary_digits"}, "q-ary_additive": {"name": "Additive \\(q\\)-ary code", "description": "A \\(q\\)-ary code whose codewords are closed under addition, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword.", "notes": [], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "q-ary_additive"}, "q-ary_hamming": {"name": "\\(q\\)-ary Hamming code", "description": "Member of an infinite family of perfect linear \\(q\\)-ary codes with parameters \\([(q^r-1)/(q-1),(q^r-1)/(q-1)-r, 3]_q\\) for \\(r \\geq 2\\).", "notes": [], "introduced": "\\cite{manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Can detect 1-bit and 2-bit errors, and can correct 1-dit errors.", "code_id": "q-ary_hamming"}, "q-ary_linear": {"name": "Linear \\(q\\)-ary code", "description": "An \\((n,K,d)_q\\) linear code is denoted as \\([n,k,d]_q\\), where \\(k=\\log_{q}K\\) need not be an integer. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any \\(q\\)-ary digits \\(\\alpha,\\beta\\).\n\nLinear codes can be defined in terms of a \\textit{generator matrix} \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a message \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its \\textit{standard} or \\textit{systematic form} \\(G = [I_k~~A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) \\(q\\)-ary matrix.\n", "notes": ["Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\).", "University of Salzburg's \\href{http://mint.sbg.ac.at/table.php?i=c}{MinT application} generates an optimal parameter table for a linear code \\([n,k,d]_q\\), contingent on an optional fluctuation of maximal Hamming code distance, rank, and length, along with other specifications."], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Soft-decision maximum-likelihood trellis-based decoder \\cite{doi:10.1109/TIT.1978.1055821}.", "Random linear codes over large fields are list-recoverable and list-decodable up to near-optimal rates \\cite{arXiv:1704.02420}.", "Extensions of algebraic-geometry decoders to linear codes \\cite{manual:{R. Kotter. A unified description of an error locating procedure for linear codes. In D. Yorgov, editor, Proc. 3rd International Workshop on Algebraic and Combinatorial Coding Theory, pages 113\u2013117, Voneshta Voda, Bulgaria, June 1992. Hermes.},doi:10.1016/0012-365X(92)90567-Y}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set such that the difference of any pair of distinct elements of the set is a codeword.", "code_id": "q-ary_linear"}, "gabidulin": {"name": "Gabidulin code", "description": "Also called a \\textit{vector rank-metric code}. A linear code over \\(GF(q^N)\\) that corrects errors over rank metric instead of the traditional Hamming distance. Every element \\(GF(q^N)\\) can be written as an \\(N\\)-dimensional vector with coefficients in \\(GF(q)\\), and the rank of a set of elements is rank of the matrix formed by their coefficients.\n\nGiven \\(X^n=\\text{span}\\{x_i\\}\\), an \\(n\\)-dimensional vector space over \\(GF(q^N)\\) (where \\(q\\) is a power of a prime number), the \\textit{rank metric} \\(d(x, y)\\) is defined via the rank norm \\(r(x, q) = \\mathrm{rank}(A(x))\\), where\n\\begin{align}\nA(x) = \\begin{pmatrix} a_{11} & a_{12} & \\ldots & a_{1n} \\\\ a_{21} & a_{22} & \\ldots & a_{2n} \\\\  a_{N1} & a_{N2} & \\ldots & a_{Nn}~, \\end{pmatrix}\n\\end{align}\nand \\(x_i = a_{1i} u_1 + a_{2i} u_2 + \\ldots + a_{Ni}u_N \\) for some fixed basis \\(\\{u_i\\}_{i=1}^N\\).\n", "notes": [], "introduced": "\\cite{manual:{E. M. Gabidulin, \\textit{Theory of Codes with Maximum Rank Distance}, Problemy Peredachi Informacii, Volume 21, Issue 1, \\emph{3\u201316} (1985)},doi:10.1109/18.75248}", "short_name": "", "logical": "q-ary_digits", "realizations": ["Public-key cryptosystems \\cite{doi:10.1007/s10623-003-6151-2}.", "Digital watermarking. The Gabidulin code provides efficient correction against luminance tampering and image-slicing distortion due to the consistency of the rank against alterations such as column swapping \\cite{doi:10.1109/ICASSP.2018.8462647}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Fast decoder based on a transform-domain approach \\cite{arXiv:0901.2483}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Set of vectors \\(\\{x_1, x_2, \\ldots, x_M\\}\\) determines a rank code with distance \\(d=\\min d(x_i, x_j)\\). The code with distance \\(d\\) corrects all errors with rank of the error not greater than \\(\\lfloor (d-1)/2\\rfloor\\).", "code_id": "gabidulin"}, "ipp": {"name": "Identifiable parent property (IPP) code", "description": "Stub.", "notes": [], "introduced": "\\cite{doi:10.1006/jcta.1997.2851}", "short_name": "IPP", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "ipp"}, "alternant": {"name": "Alternant code", "description": "Given a length-\\(n\\) GRS code \\(C\\) over \\(GF(q^m)\\), an alternant code is the \\(GF(q)\\)-subfield subcode of the dual of \\(C\\).\n", "notes": [], "introduced": "\\cite{doi:10.1016/S0019-9958(74)80005-7}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "alternant"}, "ag": {"name": "Algebraic-geometry (AG) code", "description": "Binary or \\(q\\)-ary code constructed from an algebraic curve of some genus over a finite field via the evaluation construction, the residue construction, or more general constructions that yield nonlinear codes. Linear AG codes from the first two constructions are also called \\textit{geometric Goppa codes}.\n\nIn alternative conventions (not used here), AG codes are restricted to be linear and/or include \\hyperref[code:evaluation_varieties]{evaluation} codes defined using algebraic varieties more general than curves.\n", "notes": ["See book by Goppa \\cite{doi:10.1007/978-94-015-6870-8}."], "introduced": "\\cite{manual:{V. D. Goppa, \u201cCodes Associated with Divisors\u201d, Probl. Peredachi Inf., 13:1 (1977), 33\u201339; Problems Inform. Transmission, 13:1 (1977), 22\u201327},manual:{V. D. Goppa, \u201cCodes on algebraic curves\u201d, Dokl. Akad. Nauk SSSR, 259:6 (1981), 1289\u20131290},manual:{V. D. Goppa, \u201cAlgebraico-geometric codes\u201d, Izv. Akad. Nauk SSSR Ser. Mat., 46:4 (1982), 762\u2013781; Izv. Math., 21:1 (1983), 75\u201391}}", "short_name": "AG", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Several sequences of linear AG codes beat the Gilbert-Varshamov bound and/or are asymptotically good \\cite{doi:10.1007/BF01884295,doi:10.1006/jnth.1996.0147} (see Ref. \\cite{preset:HPAlgCodes} for details). The rate of any linear AG code satisfies \\begin{align} \\frac{k}{n} \\geq 1 - \\frac{d}{n} - \\frac{1}{\\sqrt{q}-1}~, \\end{align} which comes from the Drinfeld-Vladut bound \\cite{manual:{S. G. Vla\u0306dut\u0327, V. G. Drinfeld, \u201cNumber of points of an algebraic curve\u201d, Funktsional. Anal. i Prilozhen., 17:1 (1983), 68\u201369; Funct. Anal. Appl., 17:1 (1983), 53\u201354}}. Nonlinear AG codes can outperform this bound.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "ag"}, "wozencraft": {"name": "Wozencraft ensemble code", "description": "Stub.", "notes": [], "introduced": "\\cite{manual:{J. L. Massey, Threshold Decoding. Cambridge, MA: M.I.T. Press, 1963.}}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "wozencraft"}, "matrix_product": {"name": "Matrix-product code", "description": "Code constructed using a concatenation procedure that yields a code consisting of all products of codewords in \\(M\\) length-\\(n\\) \\(q\\)-ary codes and an \\(M\\times N\\) \\(q\\)-ary matrix with \\(N\\geq M\\). A prominent subclass is the case with \\(A\\) is non-singular by columns (NSC).\n", "notes": [], "introduced": "\\cite{doi:10.1007/PL00004226}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Decoder up to half of the minimum distance for NSC codes \\cite{doi:10.1007/s00200-009-0113-5}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "matrix_product"}, "dual_additive": {"protection": "", "name": "Dual additive code", "description": "For any \\(q\\)-ary additive code \\(C\\), the dual additive (or orthogonal additive) code is\n\\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{n} ~|~ x \\star y=0 \\forall x\\in C\\},\n\\end{align}\nwhere the trace inner product is \\(x\\star y = \\sum_{i=1}^n \\text{tr}(x_i y_i)\\) for coordinates \\(x_i,y_i\\), and the trace maps elements of the field \\(GF(q)\\) with \\(q=p^m\\) to elements of \\(GF(p)\\) as\n\\begin{align}\n  \\text{tr}(\\gamma)=\\sum_{k=0}^{m-1}\\gamma^{p^{k}}~.\n\\end{align}\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called \\textit{self-orthogonal additive} or \\textit{weakly self-dual additive}. A code that contains its dual, \\(C^\\perp \\subseteq C\\), is called \\textit{dual-containing additive}. A code that is equal to its dual, \\(C^\\perp = C\\), is called \\textit{self-dual additive}. A code is dual-containing additive iff its dual is self-orthogonal additive.\n\nFor cases when \\(q\\) is a square, an alternative definition of dual substitutes the trace inner product for the \\textit{trace-Hermitian inner product}, \\(x\\star y \\to \\sum_{i=1}^n \\text{tr}(x_i y^{\\sqrt{q}}_i)\\). Another extension, relevant to \\hyperref[code:stabilizer_over_gfqsq]{certain stabilizer codes} and reducing to the trace-Hermitian case for \\(q=4\\), is the \\textit{trace-alternating inner product}, \\begin{align}\n  x\\star y \\to \\sum_{i=1}^{n}\\text{tr}\\left(\\frac{x_{i}y_{i}^{\\sqrt{q}}-x_{i}^{\\sqrt{q}}y_{i}}{\\alpha-\\alpha^{q}}\\right)~,\n\\end{align}\nwhere \\(\\{1,\\alpha\\}\\) is a basis of \\(GF(q)\\) over \\(GF(\\sqrt{q})\\). Self-dual additive codes with respect to the trace-Hermitian (trace-alternating) inner product are called \\textit{trace Hermitian (trace-alternating) self-dual additive}; similar definitions hold for self-orthogonal additive and dual-containing additive.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "dual_additive", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "ternary_golay": {"name": "Ternary Golay Code", "description": "A \\([11,6,5]_{GF(3)}\\) perfect ternary linear code with connections to various areas of mathematics, e.g., lattices \\cite{doi:10.1007/978-1-4757-6568-7} and sporadic simple groups \\cite{preset:MacSlo}. Adding a parity bit to the code results in the \\([12, 6, 6]\\) \\textit{extended ternary Golay code}. Up to equivalence, both codes are unique for their respective parameters.\n\nA generator matrix for the ternary Golay code is\n\\begin{align}\n\\left(\\begin{array}{cccccccccccc}\n  1 & 0 & 0 & 0 & 0 & | & 1 & 1 & 1 & 2 & 2 & 0 \\\\\n  0 & 1 & 0 & 0 & 0 & | & 1 & 1 & 2 & 1 & 0 & 2 \\\\\n  0 & 0 & 1 & 0 & 0 & | & 1 & 2 & 1 & 0 & 1 & 2 \\\\\n  0 & 0 & 0 & 1 & 0 & | & 1 & 2 & 0 & 1 & 2 & 1 \\\\\n  0 & 0 & 0 & 0 & 1 & | & 1 & 0 & 2 & 2 & 1 & 1 \\\\\n\\end{array}\\right)~.\n\\end{align}\n", "notes": ["The automorphism group of the ternary Golay code is the Mathieu group \\(\\mathcal{M}_{11}\\), and the automorphism group of the extended ternary Golay code is the Mathieu group \\(\\mathcal{M}_{12}\\), two of the sporadic simple groups."], "introduced": "\\cite{manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}", "short_name": "", "logical": "q-ary_digits", "realizations": ["Code used in football pools with at least one good bet \\cite{doi:10.1016/0097-3165(91)90024-B,doi:10.1007/BF03025254}. In fact, the code was originally constructed by Juhani Virtakallio and published in the Finnish football pool magazine Veikkaaja \\cite{doi:10.1007/BF03025254,manual:{T. M. Thompson, \\emph{From Error-Correcting Codes Through Sphere Packings To Simple Groups}, Mathematical Association of America, 1983.}}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Decoder for the extended ternary Golay code using the tetracode \\cite{doi:10.1109/TIT.1986.1057197}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "ternary_golay"}, "hexacode": {"name": "Hexacode", "description": "The \\([6,3,4]_{GF(4)}\\) self-dual MDS code with generator matrix\n\\begin{align}\n  \\begin{pmatrix}\n  1 & 0 & 0 & 1 & 1 & \\omega\\\\\n  0 & 1 & 0 & 1 & \\omega & 1\\\\\n  0 & 0 & 1 & \\omega & 1 & 1\n  \\end{pmatrix}~,\n\\end{align}\nwhere \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\). Has connections to projective geometry, lattices \\cite{doi:10.1007/978-1-4757-6568-7} and conformal field theory \\cite{arxiv:2003.13700}.\n", "notes": ["See corresponding MinT database entry \\cite{manual:{Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cHexacode.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CHexa.html}}."], "introduced": "\\cite{doi:10.1007/978-1-4757-6568-7}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Bounded-distance decoder requiring at most 34 real operations \\cite{doi:10.1109/18.412695}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "hexacode"}, "tetracode": {"name": "Tetracode", "description": "The \\([4,2,3]_{GF(3)}\\) self-dual MDS code with generator matrix\n\\begin{align}\n  \\begin{pmatrix}1 & 0 & 1 & 1\\\\\n  0 & 1 & 1 & 2\n  \\end{pmatrix}~,\n\\end{align}\nwhere \\(GF(3) = \\{0,1,2\\}\\). Has connections to lattices \\cite{doi:10.1007/978-1-4757-6568-7}.\n", "notes": ["See corresponding MinT database entry \\cite{manual:{Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cTetracode.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CTetra.html}}."], "introduced": "\\cite{doi:10.1007/978-1-4757-6568-7}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "tetracode"}, "dodecacode": {"name": "Dodecacode", "description": "Self-dual \\([12,6,6]_{GF(4)}\\) code whose codewords are cyclic permutations of \\((\\omega 10100100101)\\), where \\(GF(4)=\\{0,1,\\omega,\\bar{\\omega}\\}\\).\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/9608006,arXiv:math/0005266}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "dodecacode"}, "incidence_matrix": {"name": "Incidence-matrix projective code", "description": "Code whose generator matrix is the incidence matrix of points and hyperplanes of a projective spaces. Has been generalized to incidence matrices of other structures (\\cite{doi:10.1006/jcta.2002.3265,manual:{M. Lavrauw, L. Storme, and G. Van de Voorde (2010). \\emph{Linear codes from projective spaces}. In A. Bruen & D. Wehlau (Eds.), Contemporary Mathematics (Vol. 523, pp. 185\u2013202). Providence, RI, USA: American Mathematical Society (AMS).}}; \\cite{doi:10.1201/9781315147901}, Sec. 14.4).\n", "notes": [], "introduced": "\\cite{manual:{E. Prange, \\emph{The use of coset equivalene in the analysis and decoding of group codes}. AIR FORCE CAMBRIDGE RESEARCH LABS HANSCOM AFB MA, 1959.},doi:10.1109/TIT.1967.1053994,manual:{E. Prange, \"Some cyclic error-correcting codes with simple decoding algorithms.\" AFCRC-TN-58-156 (1985).}}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "incidence_matrix"}, "griesmer": {"name": "Griesmer code", "description": "A \\([n,k,d]\\) binary or \\(q\\)-ary linear code is a Griesmer code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Griesmer bound\n\\begin{align}\n  n\\geq\\sum_{j=0}^{k-1}\\left\\lceil \\frac{d}{q^{j}}\\right\\rceil ~,\n\\end{align}\nwhere \\(\\left\\lceil x\\right\\rceil \\) is the ceiling function, becomes an equality.\n\nAn \\([n,2,d]_q\\) code exists if and only if it is not excluded by the Griesmer bound. Every Griesmer code is generated by its minimum-weight codewords \\cite{manual:{S. Dodunekov, Optimal linear codes, Ph.D. Thesis, Sofia, 1985.}}.\n", "notes": [], "introduced": "\\cite{doi:10.1147/rd.45.0532,doi:10.1016/S0019-9958(65)90080-X,manual:{R. R. Varshamov, \\emph{On the general theory of linear coding}, Ph.D. Thesis, Moscow State University, 1959.}}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "griesmer"}, "simplex": {"name": "Simplex code", "description": "Also known as a \\textit{maximum length feedback shift register code}. An \\([n,k,q^{k-1}]_q\\) projective code with \\(n=\\frac{q^k-1}{q-1}\\), denoted as \\(S(q,k)\\). The columns of the generator matrix are in one-to-one correspondence with the elements of the projective space \\(PG(k-1,q)\\), with each column being a chosen representative of the corresponding element. Its dual code is the \\([n,n-k,3]_q\\) \\(q\\)-ary Hamming code. The name of the code comes from the property that, for \\(q=2\\), the codewords form a \\((2^k-1)\\)-simplex of constant edge length if the codewords are interpreted as points in \\(\\mathbb{R}^n\\).\n", "notes": ["See corresponding MinT database entry \\cite{manual:{Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cSimplex Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html}}."], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Due to the small size, it can be decoded according to maximum likelihood.", "Some faster decoders for the \\(q=2\\) case: \\cite{manual:{R. R. Green, \"A serial orthogonal decoder,\" JPL Space Programs Summary, vol. 37\u201339-IV, pp. 247\u2013253, 1966.},doi:10.1109/ITW.2003.1216684}", "A quantum decoder for the \\(q=2\\) case: \\cite{manual:{A. Barg and S. Zhou, \u201cA quantum decoding algorithm for the simplex code\u201d, in Proceedings of the 36th Annual Allerton Conference on Communication, Control and Computing, Monticello, IL, 23\u201325 September 1998 (UIUC 1998) 359\u2013365}}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "simplex"}, "denniston": {"name": "Denniston code", "description": "Projective code that is part of a family of \\([2^{a+i}+2^i-2^a,3,2^{a+i}-2^a]_{GF(2^a)}\\) codes for \\(i < a\\) constructed using Denniston arcs.\n", "notes": [], "introduced": "\\cite{doi:10.1201/9781315371993}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "denniston"}, "projective": {"name": "Projective geometry code", "description": "Linear \\(q\\)-ary \\([n,k,d]\\) code such that columns of its generator matrix \\(G\\) does not contain any repeated columns or the zero column. That way, each column corresponds to a distinct point in the projective space \\(PG(k-1,q)\\) arising from a \\(k\\)-dimensional vector space over \\(GF(q)\\). If the columns are linearly independent, then the codewords are collectively called an \\textit{information set}. Columns of a code's parity-check matrix can similarly correspond to points in projective space. This formulation yields connections to projective geometry, which can be applied to determine code properties.\n\nRecall that a linear code encodes a message \\(h\\) into a codeword \\(c = hG\\). The \\(i\\)th coordinate of a codeword is given the dot product \\(h \\cdot G_{i}\\) with \\(G_{i}\\) being the \\(i\\)th column of the generator matrix. The zero-coordinate condition \\(h \\cdot x = 0\\) defines a hyperplane of points \\(x\\) with normal vector \\(h\\). Therefore, the Hamming weight of the corresponding codeword is the number of points \\(G_i\\) \\textit{not} contained in said hyperplane.\n\nIn general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space (\\cite{doi:10.1007/978-1-4613-0283-4_14}, Thm. 1.1; \\cite{doi:10.1016/S0012-365X(99)00183-1}). Multisets can also be used to construct parity-check matrices of linear codes.\n", "notes": ["See corresponding definition in \\href{http://mint.sbg.ac.at/glossary.php#GProjectiveCode}{MinT}."], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Distance \\(d\\) is \\(n\\) minus the maximum number of points that are contained in a hyperplane. For \\(n \\geq 3\\), a code is projective if and only if the distance of its dual code is at least three.", "code_id": "projective"}, "generalized_reed_muller": {"name": "Generalized RM (GRM) code", "description": "Reed-Muller code GRM\\(_q(r,m)\\) of length \\(n=q^m\\) over \\(GF(q)\\) with \\(0\\leq r\\leq m(q-1)\\). Its codewords are evaluations of the set of all degree-\\(\\leq r\\) polynomials in \\(m\\) variables at a set of distinct points \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) in \\(GF(q)\\).\n\nSince \\(\\beta^q=\\beta\\) for any \\(\\beta\\in GF(q)\\), the above definition is not injective. Replacing each factor in each polynomial as \\(x^q\\to x\\), the above set reduces to the set of all degree-\\(\\leq r\\) polynomials in \\(m\\) variables such that no term has an exponent \\(q\\) or higher on any variable.\n", "notes": ["See books \\cite{doi:10.1017/CBO9781316529836,doi:10.1017/CBO9780511807077,manual:{E. F. Assmus, Jr. and J. D. Key, \u201cPolynomial codes and finite geometries,\u201d in Handbook of Coding Theory, eds. V. S. Pless and W. C. Huffman. Amsterdam: Elsevier, 1998, pp. 1269\u20131343.}} for details of GRM codes."], "introduced": "\\cite{doi:10.1109/TIT.1968.1054127,doi:10.1109/TIT.1968.1054128,doi:10.1016/S0019-9958(70)90214-7}", "short_name": "GRM", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Code parameters for specific \\(m,r\\) are given in Ref. \\cite{doi:10.1007/978-94-011-3810-9}, pg. 46.", "code_id": "generalized_reed_muller"}, "projective_reed_muller": {"name": "Projective RM (PRM) code", "description": "Reed-Muller code for nonzero points \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) whose leftmost nonzero coordinate is one, corresponding to an evaluation code of polynomials over projective coordinates. PRM codes  PRM\\(_q(r,m)\\) for \\(r<q\\) are injective evaluation codes with parameters \\cite{doi:10.1515/9783110811056.77}\n\\begin{align}\n  \\left[ q^m+q^{m-1}\\cdots +1, {m+r \\choose r},(q+1-r)q^{m-1} \\right]~.\n\\end{align}\n", "notes": [], "introduced": "\\cite{doi:10.1016/0012-365X(90)90155-B,doi:10.1109/18.104317}", "short_name": "PRM", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "projective_reed_muller"}, "schubert": {"name": "Schubert code", "description": "Evaluation code of polynomials evaluated on points lying on a Schubert variety.\n", "notes": [], "introduced": "\\cite{doi:10.1007/978-3-642-57189-3_11,doi:10.1109/18.850689}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Minimum distance bounds computed in Refs. \\cite{doi:10.1109/18.850689,doi:10.1023/B:DESI.0000035470.05639.2b,doi:10.1016/j.ffa.2004.09.002}.", "code_id": "schubert"}, "serge": {"name": "Serge-variety RM-type code", "description": "Evaluation code of polynomials evaluated on points lying on a Serge variety.\n", "notes": [], "introduced": "\\cite{doi:10.1006/ffta.2002.0360}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "serge"}, "ruled_surface": {"name": "Ruled-surface code", "description": "Evaluation code of polynomials evaluated on points lying on a ruled surface.\n", "notes": [], "introduced": "\\cite{doi:10.1006/ffta.2001.0313,arXiv:math/0309123}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "ruled_surface"}, "complete_intersections": {"name": "Complete-intersection RM-type code", "description": "Evaluation code of polynomials evaluated on points lying on a complete intersection.\n", "notes": [], "introduced": "\\cite{doi:10.1007/s002000000047}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Distance bounds formulated in Ref. \\cite{doi:10.1016/j.jpaa.2004.08.015}.", "code_id": "complete_intersections"}, "quadric": {"name": "Quadric code", "description": "Evaluation code of polynomials evaluated on points lying on a quadric hypersurface.\n", "notes": [], "introduced": "\\cite{doi:10.1016/0012-365X(75)90017-5,doi:10.1007/BFb0087988}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "quadric"}, "toric_classical": {"name": "Hansen toric code", "description": "Evaluation code of a linear space of polynomials evaluated on points lying on an affine or projective toric variety. If the space is taken to be all polynomials up to some degree, the code is called a \\textit{toric RM-type code} of that degree.\n", "notes": ["See Ref. \\cite{arxiv:1907.13217} for various examples and implementations in Magma."], "introduced": "\\cite{doi:10.1007/978-3-642-57189-3_12,arxiv:math/0208155}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Parameters of toric RM-type codes and various generalizations have been determined in Refs. \\cite{arXiv:math/0512285,arxiv:math/0507598,arxiv:1009.4966,arxiv:1202.0085,arxiv:1706.02114,arxiv:1907.13217}.", "code_id": "toric_classical"}, "grassmannian": {"name": "Grassmannian code", "description": "Evaluation code of polynomials evaluated on points lying on a Grassmannian \\({\\mathbb{G}}(\\ell,m)\\).\n", "notes": [], "introduced": "\\cite{manual:{C. T. Ryan, An application of Grassmannian varieties to coding theory. Congr. Numer. 57 (1987) 257\u2013271.},manual:{C.T. Ryan, Projective codes based on Grassmann varieties, Congr. Numer. 57, 273\u2013279 (1987).},doi:10.1016/0166-218X(90)90112-P}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "grassmannian"}, "deligne_lusztig": {"name": "Deligne-Lusztig code", "description": "Evaluation code of polynomials evaluated on points lying on a Deligne-Lusztig variety.\n", "notes": [], "introduced": "\\cite{doi:10.1006/ffta.2001.0313,manual:{S.H. Hansen, The geometry of Deligne-Lusztig varieties: Higher dimensional AG codes, Ph.D. Thesis, University of Aarhus, 1999.},doi:10.1007/s002290050146,doi:10.1007/BFb0087993}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "deligne_lusztig"}, "flag_variety": {"name": "Flag-variety code", "description": "Evaluation code of polynomials evaluated on points lying on a flag variety.\n", "notes": [], "introduced": "\\cite{doi:10.1016/S0022-4049(02)00188-3}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "flag_variety"}, "hermitian_hypersurface": {"name": "Hermitian-hypersurface code", "description": "Evaluation code of polynomials evaluated on points lying on a Hermitian hypersurface.\n", "notes": [], "introduced": "\\cite{doi:10.1007/978-1-4613-8994-1_4}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "hermitian_hypersurface"}, "residue": {"name": "Residue AG code", "description": "Also called a \\textit{differential code}. Linear \\(q\\)-ary code defined using a set of points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) in \\(GF(q)\\) lying on an algebraic curve \\(\\cal X\\) and a linear space \\(\\Omega\\) of certain rational differential forms \\(\\omega\\). Codewords are evaluations of residues of the differential forms in the specified points,\n\\begin{align}\n  \\left(\\text{Res}_{P_{1}}(\\omega),\\text{Res}_{P_{2}}(\\omega),\\cdots,\\text{Res}_{P_{n}}(\\omega)\\right)\\quad\\quad\\forall\\omega\\in\\Omega~.\n\\end{align}\nThe code is denoted as \\(C_{\\Omega}({\\cal X},{\\cal P},D)\\), where the \\textit{divisor} \\(D\\) determines which rational rational differential forms to use.\n", "notes": [], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": ["Improvements over the McEliece public-key cryptosystem to linear AG codes on curves of arbitrary genus \\cite{doi:10.1023/A:1027351723034}. Only the subfield subcode proposal remains resilient to attacks (\\cite{doi:10.1201/9781315147901}, Sec. 15.7.5.3).", "Algebraic secret-sharing schemes \\cite{doi:10.1007/11818175_31}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Riemann-Roch theorem yields code length \\(n\\), dimension \\(k\\), and a lower bound on distance in terms of features of \\(L\\) and genus of the curve \\(\\cal X\\) (\\cite{doi:10.1201/9781315147901}, Corr. 15.3.13). Distance bounds can also be derived from how an algebraic curve \\(\\cal X\\) is embedded in the ambient projective space \\cite{arXiv:0905.2345}.", "code_id": "residue"}, "goppa": {"name": "Classical Goppa code", "description": "Let \\( G(x) \\)  be a polynomial describing a projective-plane curve with coefficients from \\( GF(q^m) \\) for some fixed integer \\(m\\). Let \\( L \\) be a finite subset of the extension field \\( GF(q^m) \\)  where \\(q\\) is prime, meaning \\( L  = \\{\\alpha_1, \\cdots, \\alpha_n\\} \\) is a subset of nonzero elements of \\( GF(q^m) \\). A Goppa code \\( \\Gamma(L,G) \\) is an \\([n,k,d]_q\\) linear code consisting of all vectors \\(a = a_1, \\cdots, a_n\\) such that \\( R_a(x) =0 \\) modulo \\(G(x)\\), where \\( R_a(x) = \\sum_{i=1}^n \\frac{a_i}{z - \\alpha_i} \\).\n\nGoppa codes are residue AG codes (\\cite{doi:10.1201/9781315147901}, Thm. 15.3.28). Their duals are evaluation codes that are sometimes called \\textit{geometric Reed Solomon codes} (\\cite{preset:HPAlgCodes}, Thm. 2.71).\n", "notes": ["GAP function \\href{https://www.gap-system.org/Manuals/pkg/guava/doc/chap5.html#X7EE808BB7D1E487A}{GoppaCode(G,L)} takes in a polynomial \\(G\\) that satisfies the necessary conditions for a Goppa code and a list \\(L\\) that contains elements in \\(GF(q)\\) that are not roots of \\(G\\). It returns a Goppa code."], "introduced": "\\cite{manual:{V. D. Goppa, \"A new class of linear error-correcting codes\", Probl. Peredach. Inform., vol. 6, no. 3, pp. 24-30, Sept. 1970.},manual:{V. D. Goppa, \"Rational representation of codes and (Lg) codes\", Probl. Peredach. Inform., vol. 7, no. 3, pp. 41-49, Sept. 1971.},doi:10.1109/TIT.1973.1055088}", "short_name": "", "logical": "q-ary_digits", "realizations": ["Initial version of the McEliece public-key cryptosystem \\cite{manual:{R. J. McEliece, A public-key cryptosystem based on algebraic coding theory, Technical report, Jet Propulsion Lab. DSN Progress Report (1978).},doi:10.1007/BF00173300} and its variation by Niederreiter \\cite{manual:{H. Niederreiter (1986). \\emph{Knapsack-type cryptosystems and algebraic coding theory}. Problems of Control and Information Theory. Problemy Upravlenija I Teorii Informacii. 15: 159\u2013166.}} where the generator matrix is replaced by the parity check matrix. Some of these were proven to be insecure since the public key exposes algebraic structure of code \\cite{doi:10.1515/dma.1992.2.4.439}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Algebraic decoding algorithms \\cite{doi:10.1109/TIT.1975.1055350}. If \\( \\text{deg} G(x) = 2t \\) , then there exists a \\(t\\)-correcting algebraic decoding algorithm for \\( \\Gamma(L,G) \\).", "Sugiyama et al. modification of the extended Euclidean algorithm \\cite{doi:10.1016/S0019-9958(75)90090-X,doi:10.1017/CBO9780511606267}.", "Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426}.", "Binary Goppa codes can be decoded using a RS-based decoder \\cite{manual:{Daniel J. Bernstein, \"Understanding binary-Goppa decoding.\" Cryptology ePrint Archive (2022).}}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "The length \\( n = |L| \\) , dimension \\( k \\geq n-mr \\) where \\( r = \\text{deg} G(x) \\), and the minimum distance \\( d \\geq r +1 \\).", "code_id": "goppa"}, "cartier": {"name": "Cartier code", "description": "Subcode of a certain residue AG code that is constructed using the Cartier operator.", "notes": [], "introduced": "\\cite{arxiv:1206.4728}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Cartier codes share similar asymptotic properties as subfield subcodes of residue AG codes, with both families admitting sequences of codes that achieve the Gilbert-Varshamov bound.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "cartier"}, "shimura": {"name": "Tsfasman-Vladut-Zink (TVZ) code", "description": "Member of a family of residue AG codes where \\(\\cal X\\) is either a reduction of a Shimura curve or an elliptic curve of varying genus.", "notes": [], "introduced": "\\cite{doi:10.1002/mana.19821090103}", "short_name": "TVZ", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "TVZ codes exceed the asymptotic Gilbert-Varshamov (GV) bound \\cite{doi:10.1002/mana.19821090103} (see also Ref. \\cite{manual:{Y. Ihara. \"Some remarks on the number of rational points of algebraic curves over finite fields.\" J. Fac. Sci. Univ. Tokyo Sect. IA Math., 28:721-724 (1982),1981.}}). Roughly speaking, this breakthrough result implies that AG codes can outperform random codes. Such families of codes are optimal.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "shimura"}, "plane_curve": {"name": "Plane-curve code", "description": "Evaluation AG code of bivariate polynomials of some finite maximum degree, evaluated at points lying on an affine plane curve.\n", "notes": [], "introduced": "\\cite{doi:10.1109/18.32157}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Generalization of the Peterson algorithm for BCH codes \\cite{doi:10.1109/18.32157}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Bezout's theorem yields parameters \\([n,k,d]\\), which depend on the polynomial used to define the plane curve as well as the maximum degree of the polynomials used for evaluation (\\cite{preset:HPAlgCodes}, pg. 883). Distance bounds can be derived from how the plane curve is embedded in the ambient projective space (\\cite{arXiv:0905.2345}, Thm. 4.1).", "code_id": "plane_curve"}, "elliptic": {"name": "Elliptic code", "description": "Evaluation AG code of rational functions evaluated on points lying on an elliptic curve, i.e., a curve of genus one.\n", "notes": [], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "elliptic"}, "hermitian": {"name": "Hermitian code", "description": "Evaluation AG code of rational functions evaluated on points lying on a Hermitian curve \\(H(x,y) = x^{q+1}  + y^{q+1} - 1\\) over \\(\\mathbb{F}_q = GF(q)\\) in either affine or projective space. Hermitian codes directly improve over RS codes in the sense that RS codes have length at most \\(q\\) while Hermitian codes have length \\(q^3 + 1\\).\n\nHermitian codes of polynomials of total degree at most \\(D\\) can come in affine and epicyclic flavours, depending on whether the evaluations are over the affine plane or the bicyclic plane. The affine codes have length \\(q^3 - q\\) while epicyclic codes have length \\((q-2)(q+1)^2\\). More precisely, fix \\(r, D\\) and let\n\\begin{align}\n  M_D = \\left\\{f(x,y,z) = \\sum_{i+j \\leq D = D}a_{i,j}x^{i}y^{j}z^{D - (i+j)}\\right\\}\n\\end{align}\nbe the message space of degree-\\(D\\) polynomials and\n\\begin{align}\n  S = \\{(x:y:z) \\in PG(2,q) \\mid H(x:y:z) = 0 \\}~,\n\\end{align}\nwhere \\(H(x:y:z) = x^{q+1} + y^{q+1} - z^{q+1}\\) is the homogenized Hermitian curve over the projective plane. The Hermitian code \\( C \\) over is\n\\begin{align}\nC = \\{(f(\\alpha_i))_{\\alpha_i \\in S}, \\: f \\in M_D \\}~.\n\\end{align}\n\nThe form \\(H(u,v,w) = u^{q+1} + v^{q+1} - w^{q+1}\\) is the \\textit{Fermat} version of the Hermitian curve.\nSubstituting \\(u = x+z\\), \\(v = x+y\\), and \\(w = x+y+z \\) yields \\(H(x,y,z) = x^{q+1} - y^{q}z - yz^{q} \\), the \\textit{Stichtenoth} version of the curve.\nIn affine coordinates, the Stichtenoth form of the curve is \\begin{align}\n  f(x,y) = x^{q+1} - y^{q} - y = N(x) - \\text{tr}(y)~,\n\\end{align}\nwhere \\(N(x) := x^{(q^{n}-1)/(q-1)}\\) and \\(\\text{tr} := 1 + x^{q} + \\ldots + x^{q^n}\\) are the field norm and trace of \\(GF(F_{q^n}\\), respectively.\nThe Fermat\nversion can be written as \\(H(u,v,w) = u\\overline{u} + v\\overline{v} - w\\overline{w}\\), where the conjugation map\n\\(\\overline{u} = u^{q}\\) is an isomorphism of \\(\\mathbb{F}_q \\). In fact, when the field of evaluations \\(\\mathbb{F}_{q^2}\\) is viewed as a quadratic extension of\n\\(\\mathbb{F}_q\\) then the conjugation map is an \\(\\mathbb{F}_q\\)-isomorphism that permutes the roots of the quadratic irreducible polynomial\nused to generate \\(\\mathbb{F}_{q^2}\\) from \\( \\mathbb{F}_q[x]\\).\n", "notes": [], "introduced": "\\cite{doi:10.1007/BF01228251,doi:10.1109/TIT.1987.1057327}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "For polynomial evaluations up to degree \\(D\\): if \\(D < q + 1 \\), \\(k = \\frac{(D+1)(D+2)}{2}\\), and if \\(D \\geq q + 1 \\), \\(k = (q+1)D - \\frac{q(q-1)}{2} + 1 \\).\n", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Unique decoding using syndromes and error locator ideals for polynomial evaluations. Note that Hermitian codes are linear codes so we can compute the syndrome of a received vector. Moreover, akin to the error-locator ideals found in decoding Reed-Solomon codes, for the multivariate case we must define an error locator ideal \\(\\Lambda \\) such that the variety of this ideal over \\(\\mathbb{F}^{2}_{q}\\) is exactly the set of errors. The Sakata algorithm uses these two ingredients to get a unique decoding procedure \\cite{doi:10.1016/S0747-7171(88)80033-6}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Distance determined by properties of the Hermitian curve, the underlying field, and the functions used \\cite{doi:10.1007/BFb0087995}; see Ref. \\cite{preset:HPAlgCodes}, Sec. 5.3, for an example. For evaluations of polynomials up to degree \\(D\\), the Hermitian code protects against at least \\(n - (q+1)D\\) errors whenever \\(D < q + 1 \\). If \\(D \\geq q+1 \\), the Hermitian code protects against at least \\(n-k - \\frac{q(q-1)}{2} + 1\\) errors.", "code_id": "hermitian"}, "evaluation": {"name": "Evaluation AG code", "description": "Also called a \\textit{function code}. Evaluation code over \\(GF(q)\\) on a set of points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) in \\(GF(q)\\) lying on an algebraic curve \\(\\cal X\\) whose corresponding vector space \\(L\\) of functions \\(f\\) consists of certain polynomials or rational functions. Codewords are evaluations of all functions at the specified points,\n\\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right) \\quad\\quad\\forall f\\in L~.\n\\end{align}\nThe code is denoted as \\(C_L({\\cal X},{\\cal P},D)\\), where the \\textit{divisor} \\(D\\) (of degree less than \\(n\\)) determines which rational functions to use by prescribing features associated with their zeroes and poles. The original motivation for evaluation codes, which are generalizations of RS codes that expand both the types of functions used as well as the available evaluation points, was to increase code length while maintaining good distance and size.\n\nThe algebraic curve \\(\\cal X\\) used for this construction is the set of zeroes of a nontrivial polynomial that is both smooth and irreducible over any field extension of \\(GF(q)\\). The curve can be defined over affine space or projective space, which contains the affine coordinates as a subset and which can yield an increase in length.\nIf evaluations are made over projective coordinates, then the codewords are evaluations of homogeneous polynomials, and there are relations between such polynomials with polynomials over affine space. See Refs. \\cite{preset:HPAlgCodes,doi:10.1007/978-3-319-51103-0} for more details.\n\nIn the case of polynomial functions \\(f\\), evaluation AG codes reduce to \\hyperref[code:evaluation_polynomial]{polynomial evaluation} codes on algebraic curves. In the general case of rational functions, which are ratios of two polynomials, one can select such features for both the numerator and denominator polynomials. Zeroes of the denominator polynomial are called poles of the rational function, and their multiplicities correspond to orders of the poles. A bookkeeping device for this data is the divisor \\(D\\), and the corresponding vector space of functions defined using the curve \\(\\cal X\\) and the divisor is the \\textit{Riemann-Roch space} \\(L=L(D)\\) (\\cite{doi:10.1201/9781315147901}, pg. 313).\n", "notes": ["See Refs. \\cite{preset:HPAlgCodes,doi:10.1109/18.476214,doi:10.1142/9789812794017_0002,doi:10.1201/9781315147901,doi:10.1017/CBO9780511543401} for surveys and overviews of decoders."], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Generalization of plane-curve decoder \\cite{doi:10.1109/18.57204,manual:{V. Yu. Krachkovskii, \"Decoding of codes on algebraic curves,\" (in Russian), Conference Odessa, 1988.}}. Another decoder \\cite{doi:10.1109/18.165441} was later showed to be equivalent in Ref. \\cite{doi:10.1007/BFb0087989}. Application of several algorthims in parallel can be used to decode up to half the minimum distance \\cite{doi:10.1109/18.45279,doi:10.1109/18.59945}. Computational procedure implementing these decoders is based on an extension of the Berlekamp-Massey algorithm by Sakata \\cite{doi:10.1016/S0747-7171(88)80033-6,doi:10.1016/0890-5401(90)90039-K,doi:10.1109/18.86974}.", "Decoder based on majority voting of unknown syndromes \\cite{doi:10.1109/18.179340} decodes up to half of the minimum distance \\cite{doi:10.1109/18.256485}.", "List decoders generalizing Sudan's RS decoder by Shokrollahi-Wasserman \\cite{doi:10.1109/18.748993} and Guruswami-Sudan \\cite{doi:10.1109/SFCS.1998.743426}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Riemann-Roch theorem yields code length \\(n\\), dimension \\(k\\), and a lower bound on distance in terms of features of \\(L\\) and genus of the curve \\(\\cal X\\) (\\cite{doi:10.1201/9781315147901}, Thm. 15.3.12). The order or Feng-Rao bound, a generalization of the shift bound for cyclic codes, gives a lower bound on the distance of evaluation AG codes \\cite{doi:10.1109/18.179340,doi:10.1515/9783110811056.155,doi:10.1016/j.ffa.2006.09.006}. Connection to semigroups yields another bound \\cite{doi:10.1109/18.333893,preset:HPAlgCodes}.", "code_id": "evaluation"}, "klein_quartic": {"name": "Klein-quartic code", "description": "Evaluation AG code over \\(GF(8)\\) of rational functions evaluated on points lying in the Klein quartic, which is defined by the equation \\(x^3 y + y^3 z + z^3 x = 0\\) (\\cite{preset:HPAlgCodes}, Ex. 2.75).\n", "notes": [], "introduced": "\\cite{doi:10.1109/TIT.1987.1057365}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Dimension \\(k=8\\) and distance \\(d \\geq 13\\). Concatenation with the \\([4,3,2]\\) single parity check code, conversion to a binary code by expressing \\(GF(8)\\) elements as vectors over \\(GF(2)\\), and puncturing yields a \\([91,24,25]\\) binary code that held the world record for codes of length 91 \\cite{manual:{A. M. Barg, G. L. Katsman, M. A. Tsfasman, \u201cAlgebraic-Geometric Codes from Curves of Small Genus\u201d, Probl. Peredachi Inf., 23:1 (1987), 42\u201346; Problems Inform. Transmission, 23:1 (1987), 34\u201338}}.", "code_id": "klein_quartic"}, "q-ary_quad_residue": {"name": "\\(q\\)-ary quadratic-residue (QR) code", "description": "Member of a quadruple of cyclic \\(q\\)-ary codes of prime length \\(n\\) where \\(q\\) is prime and a quadratic residue modulo \\(n\\). The codes are constructed using quadratic residues and nonresidues of \\(n\\).\n\nThe roots of the generator polynomial \\(r(x)\\) of the first code (see \\ref{topic:Cyclic-to-polynomial-correspondence}) are all of the inequivalent quadratic residues of \\(n\\), and the second code's generator polynomial is \\((x-1)r(x)\\). The roots of the generator polynomial \\(a(x)\\) of the third code are all inequivalent nonresidues of \\(n\\), and the fourth code's generator polynomial is \\((x-1)a(x)\\). The codes corresponding to polynomials \\(r,a\\) are often called \\textit{augmented} quadratic-residue codes, while the remaining codes are called \\textit{expurgated}.\n", "notes": ["Introduction of quadratic-residue codes in Refs. \\cite{preset:MacSlo,doi:10.1017/CBO9780511807077}."], "introduced": "", "short_name": "\\(q\\)-ary QR", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "q-ary_quad_residue"}, "q-ary_duadic": {"name": "\\(q\\)-ary duadic code", "description": "Member of a pair of cyclic linear binary codes that satisfy certain relations, depending on whether the pair is \\textit{even-like} or \\textit{odd-like} duadic. Duadic codes exist only when \\(q\\) is a square modulo \\(n\\) \\cite{doi:10.1007/978-3-7091-2786-5_1}.\n\nDuadic codes come in two pairs, an even-like duadic pair and an odd-like duadic pair. All codewords in the respective pairs are \\textit{even-like}, i.e., \\(\\sum_i c_i = 0\\), or \\textit{odd-like}, i.e., \\(\\sum_i c_i \\neq 0\\). A code with all even-like (odd-like) codewords is called even-like (odd-like).\n\nDuadic code pairs can be defined in terms of their idempotent generators (see \\ref{topic:Cyclic-to-polynomial-correspondence}).\nA pair of even-like codes \\(C_1\\) and \\(C_2\\) with respective idempotents \\(e_1\\) and \\(e_2\\) is an \\textit{even-like duadic pair} if (1) \\(e_1(x)+e_2(x)=1-\\frac{1}{n}(1+x+x^2+\\cdots+x^{n-1})\\) and (2) there exists a multiplier \\(\\mu\\) such that \\(C_1 \\mu=C_2\\) and \\(C_2 \\mu=C_1\\).\n\nThere is an odd-like duadic pair \\(\\{D_1,D_2\\}\\) associated with the even-like pair \\(\\{C_1, C_2\\}\\), where \\(1-e_2(x)\\) generates \\(D_1\\) and \\(1-e_1(x)\\) generates \\(D_2\\). The even-pair codes are \\([n,\\frac{n-1}{2}]_q\\) codes while the odd-pair codes are \\([n,\\frac{n+1}{2}]_q\\) codes.\n", "notes": ["Reviews of duadic codes \\cite{doi:10.1007/978-3-7091-2786-5_1,doi:10.1017/CBO9780511807077}."], "introduced": "\\cite{doi:10.1016/0097-3165(86)90066-X,doi:10.1007/978-3-7091-2786-5_1,doi:10.7907/CZA5-PX53,doi:10.1109/TIT.1987.1057300}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "q-ary_duadic"}, "q-ary_bch": {"name": "Bose\u2013Chaudhuri\u2013Hocquenghem (BCH) code", "description": "Cyclic \\(q\\)-ary code, with \\(n\\) and \\(q\\) relatively coprime, whose zeroes are consecutive powers of a primitive \\(n\\)th root of unity \\(\\alpha\\). More precisely, the generator polynomial of a BCH code of \\textit{designed distance} \\(\\delta\\geq 1\\) is the lowest-degree monic polynomial with zeroes \\(\\{\\alpha^b,\\alpha^{b+1},\\cdots,\\alpha^{b+\\delta-2}\\}\\) for some \\(b\\geq 0\\). BCH codes are called \\textit{narrow-sense} when \\(b=1\\), and are called \\textit{primitive} when \\(n=q^r-1\\) for some \\(r\\geq 2\\).\n\nThe code dimension is related to the \\textit{multiplicative order} of \\(q\\) modulo \\(n\\), i.e., the smallest integer \\(m\\) such that \\(n\\) divides \\(q^m-1\\). The dimension of a BCH code is at least \\(n-m(\\delta-1)\\). The field \\(GF(q^m)\\) is the smallest field containing the above root of unity \\(\\alpha\\), and is the splitting field of the polynomial \\(x^n-1\\) (see \\ref{topic:Cyclic-to-polynomial-correspondence}).\n", "notes": ["See books \\cite{preset:MacSlo,preset:LinCostello,doi:10.1017/CBO9780511807077} for expositions on BCH codes and code tables.", "See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes.", "See corresponding MinT database entry \\cite{manual:{Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cCyclic Codes (BCH-Bound).\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CCyclic-BCHBound.html}}."], "introduced": "\\cite{doi:10.1137/0109020}", "short_name": "BCH", "logical": "q-ary_digits", "realizations": ["DVDs, disk drives, and two-dimensional bar codes \\cite{doi:10.1109/TIT.2019.2913389}."], "features": {"general_gates": [], "encoders": [], "rate": "Primitive BCH codes are asymptotically bad \\cite[pg.~269]{preset:MacSlo}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) \\cite{doi:10.1109/TIT.1968.1054109,doi:10.1109/TIT.1969.1054260,preset:Berlekamp} and modification by Burton \\cite{doi:10.1109/TIT.1971.1054655}; see also \\cite{preset:PetersonWeldon,doi:10.1007/978-3-7091-2945-6}.", "Gorenstein-Peterson-Zierler decoder with runtime of order \\(O(n^3)\\) \\cite{doi:10.1109/TIT.1960.1057586,doi:10.1137/0109020} (see exposition in Ref. \\cite{preset:Blahut}).", "Sugiyama et al. modification of the extended Euclidean algorithm \\cite{doi:10.1016/S0019-9958(75)90090-X,doi:10.1017/CBO9780511606267}.", "Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426} and modification by Koetter-Vardy for soft-decision decoding \\cite{doi:10.1109/TIT.2003.819332}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "By the BCH bound, BCH code with designed distance \\(\\delta\\) has true minimum distance \\(d\\geq\\delta\\). BCH codes with different designed distances may coincide, and the largest possible designed distance for a given code is the \\textit{Bose distance}; the true distance may still be larger than that.\n", "code_id": "q-ary_bch"}, "q-ary_cyclic": {"name": "Cyclic linear \\(q\\)-ary code", "description": "A \\(q\\)-ary code of length \\(n\\) is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword. A cyclic code is called \\textit{primitive} when \\(n=q^r-1\\) for some \\(r\\geq 2\\). A \\textit{shortened cyclic code} is obtained from a cyclic code by taking only codewords with the first \\(j\\) zero entries, and deleting those zeroes.\n", "notes": ["See Ch. 7 of Ref. \\cite{preset:MacSlo} for an exposition on cyclic codes."], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Meggitt decoder \\cite{doi:10.1109/TIT.1961.1057659}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Shift bound \\cite{doi:10.1109/TIT.1986.1057134} gives a lower bound on the distance of cyclic \\(q\\)-ary codes.", "code_id": "q-ary_cyclic"}, "meir": {"name": "Meir code", "description": "Locally testable \\([[n,k,d]]_q\\) code with query complexity \\(\\text{poly}(\\log k)\\) and rejection ratio \\(R/n = 1/\\text{poly}(\\log k)\\). Code construction is probabilistic and combinatorial.\n", "notes": [], "introduced": "\\cite{doi:10.1145/1374376.1374419}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "meir"}, "q-ary_ltc": {"name": "\\(q\\)-ary linear LTC", "description": "A \\(q\\)-ary linear code \\(C\\) of length \\(n\\) that is a \\((u,R)\\)-LTC with query complexity \\(u\\) and soundness \\(R>0\\).\nMore technically, the code is a \\((u,R)\\)-LTC if the rows of its parity-check matrix \\(H\\in GF(q)^{r\\times n}\\) have weight at most \\(u\\) and if\n\\begin{align}\n  \\frac{1}{r}|H x| \\geq \\frac{R}{n} D(x,C)\n\\end{align}\nholds for any \\(q\\)-ary string \\(x\\), where \\(D(x,C)\\) is the \\(q\\)-ary Hamming distance between \\(x\\) and the closest codeword to \\(x\\) \\cite[Def. 11]{arxiv:1911.03069}.\n", "notes": [], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "q-ary_ltc"}, "bs-ltc": {"name": "Ben-Sasson-Sudan code", "description": "Locally testable \\([[n,k/2,d]]_{2^m}\\) code with \\(k\\) a power of two, \\(n = k \\log^{c} k\\), and query complexity \\(\\log^{c}k\\) for some universal constant \\(c\\).\n", "notes": [], "introduced": "\\cite{doi:10.1145/1060590.1060631}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "bs-ltc"}, "interleaved_reed_solomon": {"name": "Interleaved RS (IRS) code", "description": "A modification of RS codes where multiple polynomials are used to define each codeword. Each codeword \\(\\mu\\) of a \\(t\\)-interleaved RS code is a string of values of the corresponding set \\(\\{f_\\mu^{(1)},f_\\mu^{(2)},\\cdots,f_\\mu^{(t)}\\}\\) of \\(t\\) polynomials at the points \\(\\alpha_i\\). The vector codewords can be arranged in an array whose rows are ordinary RS codes for each polynomial \\(f^{j}\\), yielding the encoding\n\\begin{align}\n\\mu\\to\\left(\n\\begin{array}{cccc}\n  f_{\\mu}^{(1)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(1)}\\left(\\alpha_{2}\\right) & \\cdots & f_{\\mu}^{(1)}\\left(\\alpha_{n}\\right)\\\\\n  f_{\\mu}^{(2)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(2)}\\left(\\alpha_{2}\\right) &  & f_{\\mu}^{(2)}\\left(\\alpha_{n}\\right)\\\\\n  \\vdots &  & \\ddots & \\vdots\\\\\n  f_{\\mu}^{(t)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(t)}\\left(\\alpha_{2}\\right) & \\cdots & f_{\\mu}^{(t)}\\left(\\alpha_{n}\\right)\n\\end{array}\\right)~.\n\\end{align}\n", "notes": [], "introduced": "", "short_name": "IRS", "logical": "q-ary_digits", "realizations": ["The cross-interleaved RS (CIRC), an IRS code using two shortened RS codes and two forms of interleaving, was used for compact discs (CDs) \\cite{manual:{Odaka K., Sako Y., Iwamoto I., Doi T.; Vries L.B.; SONY: Error correctable data transmission method (Patent US4413340) filing date May 21, 1980.}} (see Ref. \\cite{doi:10.1017/CBO9780511807077}, Sec. 5.6 and Ref. \\cite{doi:10.1109/9780470546345}, Ch. 4)."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Decoder that corrects up to \\(1-\\frac{2k+n}{3n}\\) fraction of random errors \\cite{doi:10.1016/j.tcs.2007.02.043}.", "Decoder that corrects up to \\(1-(\\frac{k}{n})^{2/3}\\) fraction of random errors \\cite{doi:10.1145/780542.780563}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "interleaved_reed_solomon"}, "extended_reed_solomon": {"name": "Extended GRS code", "description": "A GRS code with an additional parity-check coordinate with corresponding evaluation point of zero. In other words, an \\([n+1,k,n-k+2]_q\\) GRS code whose polynomials are evaluated at the points \\((\\alpha_1,\\cdots,\\alpha_n,0)\\). The case when \\(n=q-1\\), multipliers \\(v_i=1\\), and \\(\\alpha_i\\) are \\(i-1\\)st powers of a primitive \\(n\\)th root of unity is an \\textit{extended narrow-sense RS code}.\n\nAn \\([q-1,k,q-k]_q\\) narrow-sense RS code can be extended twice by adding two evaluation points (of which one can be zero) to yield a \\([q+1,k,q-k+2]_q\\) \\textit{doubly extended narrow-sense RS code}.\n", "notes": ["See corresponding MinT database entry \\cite{manual:{Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cExtended Reed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html}}."], "introduced": "", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "extended_reed_solomon"}, "folded_reed_solomon": {"name": "Folded RS (FRS) code", "description": "A linear \\([n/m,k]_{q^m}\\) code that is a modification of an \\([n,k]_q\\) RS code such that evaluations are grouped to yield a code with smaller length. In this case, the evaluation points are all powers of a generating field element \\(\\gamma\\), \\(\\alpha_i=\\gamma^i\\). Each codeword \\(\\mu\\) of an \\(m\\)-folded RS code is a string of \\(n/m\\) symbols, with each symbol being a string of values of a polynomial \\(f_\\mu\\) at consecutive powers of \\(\\gamma\\),\n\\begin{align}\n\\begin{split}\n  \\mu\\to&\\Big(\\left(f_{\\mu}(\\alpha^{0}),\\cdots,f_{\\mu}(\\alpha^{m-1})\\right),\\left(f_{\\mu}(\\alpha^{m}),\\cdots,f_{\\mu}(\\alpha^{2m-1})\\right)\\cdots\\\\&\\cdots,\\left(f_{\\mu}(\\alpha^{n-m}),\\cdots,f_{\\mu}(\\alpha^{n-1})\\right)\\Big)~.\n\\end{split}\n\\end{align}\n", "notes": ["See the book \\cite{preset:GRS} for an introduction to FRS codes.", "A class of FRS codes can be used in the Yamakawa-Zhandry quantum algorithm \\cite{arxiv:2204.02063}."], "introduced": "\\cite{doi:10.1109/TIT.2003.819333}", "short_name": "FRS", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Guruswami and Rudra \\cite{arXiv:cs/0511072,manual:{Atri Rudra. List Decoding and Property Testing of Error Correcting Codes. PhD thesis, University of Washington, 8 2007.}} achieved list-decoding up to \\(1-\\frac{k}{n}-\\epsilon\\) fraction of errors using the Parvaresh-Vardy algorithm \\cite{doi:10.1109/SFCS.2005.29}; see Ref. \\cite{arXiv:1106.0436} for a randomized construction.", "Folded RS codes, concatenated with suitable inner codes, can be efficiently list-decoded up to the Blokh-Zyablov bound \\cite{arXiv:cs/0511072,doi:10.1109/TIT.2008.2008124}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "folded_reed_solomon"}, "parvaresh_vardy": {"name": "Parvaresh-Vardy (PV) code", "description": "Also called a \\textit{correlated RS code}. An IRS code with additional algebraic relations (a.k.a. correlations) between the codeword polynomials \\(\\{f^{(j)}\\}_{j=1}^{t}\\). These relations yielded a list decoder that achieves list-decoding capacity.\n", "notes": [], "introduced": "\\cite{doi:10.1109/SFCS.2005.29}", "short_name": "PV", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["PV codes can be list-decoded up to \\(1-(t k/n)^{1/(t+1)}\\) fraction of errors. This result improves over the Guruswami-Sudan algorithm for ordinary \\hyperref[code:reed_solomon]{RS} codes, which list-decodes up to \\(1-\\sqrt{k/n}\\) fraction of errors."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "", "code_id": "parvaresh_vardy"}, "generalized_reed_solomon": {"name": "Generalized RS (GRS) code", "description": "An \\([n,k,n-k+1]_q\\) linear code that is a modification of the RS code where codeword polynomials are multiplied by additional prefactors. Each message \\(\\mu\\) is encoded into a string of values of the corresponding polynomial \\(f_\\mu\\) at the points \\(\\alpha_i\\), multiplied by a corresponding nonzero factor \\(v_i \\in GF(q)\\),\n\\begin{align}\n  \\mu\\to\\left( v_{1}f_{\\mu}\\left(\\alpha_{1}\\right),v_{2}f_{\\mu}\\left(\\alpha_{2}\\right),\\cdots,v_{n}f_{\\mu}\\left(\\alpha_{n}\\right)\\right)~.\n\\end{align}\n", "notes": [], "introduced": "", "short_name": "GRS", "logical": "q-ary_digits", "realizations": ["Commonly used in mass storage systems such as CDs, DVDs, QR codes etc.", "Various cloud storage systems \\cite{arxiv:1612.01361}.", "Public-key cryptosystems generalizing those that used Goppa codes \\cite{manual:{R. J. McEliece, A public-key cryptosystem based on algebraic coding theory, Technical report, Jet Propulsion Lab. DSN Progress Report (1978).},doi:10.1007/BF00173300,manual:{H. Niederreiter (1986). \\emph{Knapsack-type cryptosystems and algebraic coding theory}. Problems of Control and Information Theory. Problemy Upravlenija I Teorii Informacii. 15: 159\u2013166.}}, some of which were proven to be insecure \\cite{doi:10.1515/dma.1992.2.4.439}. More recent works focus on methods to mask the algebraic structure using subcodes of GRS codes \\cite{doi:10.1007/s10623-003-6151-2}. For example, a key-recovery attack was developed in Ref. \\cite{arXiv:1307.6458} for a variant of masking method proposed in Ref. \\cite{arXiv:1108.2462}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["The decoding process of GRS codes reduces to the solution of a polynomial congruence equation, usually referred to as the key equation. Decoding schemes are based on applications of the Euclid algorithm to solve the key equation.", "Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) \\cite{doi:10.1109/TIT.1968.1054109,doi:10.1109/TIT.1969.1054260,preset:Berlekamp}.", "Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426} and modification by Koetter-Vardy for soft-decision decoding \\cite{doi:10.1109/TIT.2003.819332}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "The code can detect \\(n-k\\) errors, and can correct  errors \\( \\left\\lfloor (n-k)/2\\right\\rfloor  \\) errors.", "code_id": "generalized_reed_solomon"}, "reed_solomon": {"name": "Reed-Solomon (RS) code", "description": "An \\([n,k,n-k+1]_q\\) linear code based on polynomials over \\(GF(q)\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct points in \\(GF(q)\\). An RS code encodes a message \\(\\mu=\\{\\mu_0,\\cdots,\\mu_{k-1}\\}\\) into \\(\\{f_\\mu(\\alpha_1),\\cdots,f_\\mu(\\alpha_n)\\}\\) using a message-dependent polynomial\n\\begin{align}\nf_\\mu(x)=\\mu_0+\\mu_1 x + \\cdots + \\mu_{k-1}x^{k-1}.\n\\end{align}\nIn other words, each message \\(\\mu\\) is encoded into a string of values of the corresponding polynomial \\(f_\\mu\\) at the points \\(\\alpha_i\\),\n\\begin{align}\n  \\mu\\to\\left( f_{\\mu}\\left(\\alpha_{1}\\right),f_{\\mu}\\left(\\alpha_{2}\\right),\\cdots,f_{\\mu}\\left(\\alpha_{n}\\right)\\right) \\,.\n\\end{align}\n\nAn RS code with length \\(n=q-1\\) whose points \\(\\alpha_i\\) are \\(i-1\\)st powers of a primitive \\(n\\)th root of unity is a \\textit{narrow-sense RS code}. In an alternative convention (not used here), the primitive-root case is called an RS code, and the general-root case is a generalized RS code.\n", "notes": ["See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes.", "See corresponding MinT database entry \\cite{manual:{Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cReed\u2013Solomon Code.\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon.html}}.", "Popular summary in \\href{https://www.quantamagazine.org/how-mathematical-curves-power-cryptography-20220919/}{Quanta Magazine}."], "introduced": "\\cite{doi:10.1214/aoms/1177729387,doi:10.1137/0108018}", "short_name": "RS", "logical": "q-ary_digits", "realizations": ["RS Product Code (RSPC) was used in DVDs (see Ref. \\cite{doi:10.1109/9780470546345}, Ch. 4).", "DSL technologies and their variants against impluse noise \\cite{doi:10.1109/ICC.2012.6364040}.", "Cryptographic primitives based on the hardness of decoding RS codes for more than \\(1-\\sqrt{k/n}+\\epsilon\\) errors. This is equivalent to the polynomial reconstruction problem \\cite{doi:10.1007/3-540-45465-9_21}.", "RS codes as outer codes concatenated with convolutional codes are used indirectly in space exploration programs such as Voyager and Galileo. RS codes were part of a temetry channel coding standard issued by the Consultative Committee for Space Data Systems (see Ref. \\cite{doi:10.1109/9780470546345}, Ch. 3).", "The ubiquity of RS codes has yielded off-the-shelf VLSI intergrated-circuit decoding hardware \\cite{doi:10.1109/92.953498} (see also Ref. \\cite{doi:10.1109/9780470546345}, Ch. 5 and 10).", "Automatic repeat request (ARQ) data transmission protocols (see Ref. \\cite{doi:10.1109/9780470546345}, Ch. 7).", "Slow-frequency-hop spread-spectrum transmission (see Ref. \\cite{doi:10.1109/9780470546345}, Chs. 8-9).", "Coded sharding designs in blockchains to increase efficiency \\cite{arXiv:1809.10361}.", "Private Information Retrieval \\cite{doi:10.1109/ISIT45174.2021.9517900}.", "Used in QR-Codes to retrieve damaged barcodes \\cite{manual:{International Organization for Standardization, Information Technology: Automatic Identification and Data Capture Techniques-QR Code 2005 Bar Code Symbology Specification, 2nd ed., IEC18004 (ISO, 2006).}}.", "Wireless communication systems such as 3G, DVB, and WiMAX \\cite{doi:10.1109/PIMRC.2010.5672091}.", "Correcting pooled testing results for SARS-CoV-2 \\cite{doi:10.1126/sciadv.abc5961}."], "features": {"general_gates": [], "encoders": ["Bit-serial encoder \\cite{doi:10.1109/TIT.1982.1056591}.", "\\([n,k,n-k+1]\\) RS code requires an order \\(O(n^2)\\) operations while encoding if a straightforward matrix multiplication is employed and \\(k=\\mathcal{O}(n)\\). Using the FFT algorithm, complexity of evaluating a polynomial at \\(n\\) roots of unity becomes \\(O(n\\log n)\\). The FFT can be generalized to finite fields and rings, which is referred as Number-theoretic Transform (NTT). However, for some values of \\(n\\), which can not be factorized into small primes or do not have \\(n\\) roots of unity, the FFT algorithm fails. Independently developed by \\cite{doi:10.1109/49.1926,doi:10.1016/0097-3165(89)90020-4} and generalized in Ref. \\cite{doi:10.1017/CBO9781139856065}, the additive FFT solves this problem by evaluating the polynomial at \\(n-1\\) roots of unity when \\(n\\) is power of 2."], "rate": "Generic Reed-Solomon codes achieve list-decoding capacity \\cite{arxiv:2206.05256}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Although using iFFT has its counterpart iNNT for finite fields, the decoding is usually standard polynomial interpolation in \\(k=\\mathcal{O}(n\\log^2 n)\\). However, in erasure decoding, encoded values are only erased in \\(r\\) points, which is a specific case of polynomial interpolation and can be done in \\(\\mathcal{O}(n\\log n)\\) by computing product of the received polynomial and an erasure locator polynomial and using long division to find an original polynomial. The long division step can be omitted to increase speed further by only dividing the derivative of the product polynomial, and derivative of erasure locator polynomial evaluated at erasure locations.", "Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) \\cite{doi:10.1109/TIT.1969.1054260,preset:Berlekamp}.", "Gorenstein-Peterson-Zierler decoder with runtime of order \\(O(n^3)\\) \\cite{doi:10.1109/TIT.1960.1057586,doi:10.1137/0109020} (see exposition in Ref. \\cite{preset:Blahut}).", "Berlekamp-Welch decoder with runtime of order \\(O(n^3)\\) \\cite{manual:{E. R. Berlekamp and L. Welch, Error Correction of Algebraic Block Codes. U.S. Patent, Number 4,633,470 1986.}} (see exposition in Ref. \\cite{doi:10.1016/0020-0190(92)90195-2}), assuming that \\(t \\geq (n+k)/2\\).", "Gao decoder using extended Euclidean algorithm \\cite{doi:10.1007/978-1-4757-3789-9_5}.", "Fast-Fourier-transform decoder with runtime of order \\(O(n \\text{polylog}n)\\) \\cite{doi:10.1109/TIT.1978.1055816}.", "List decoders try to find a low-degree bivariate polynomial \\(Q(x,y)\\) such that evaluation of \\(Q\\) at \\((\\alpha_i,y_i)\\) is zero. By choosing proper degrees, it can be shown such polynomial exists by drawing an analogy between evaluation of \\(Q(\\alpha_i,y_i)\\) and solving a homogenous linear equation (interpolation). Once this is done, one lists roots of \\(y\\) that agree at \\(\\geq t\\) points. The breakthrough Sudan list-decoding algorithm corrects up to \\(1-\\sqrt{2R}\\) fraction of errors \\cite{doi:10.1006/JCOM.1997.0439}. Roth and Ruckenstein proposed a modified key equation that allows for correction of more than \\(\\left\\lfloor (n-k)/2 \\right\\rfloor\\) errors \\cite{doi:10.1109/18.817522}. The Guruswami-Sudan algorithm improved the Sudan algorithm to \\(1-\\sqrt{R}\\) \\cite{doi:10.1109/SFCS.1998.743426}; see Ref. \\cite{doi:10.1109/TIT.2006.878164} for bounds. A further modification by Koetter and Vardy is used for soft-decision decoding \\cite{doi:10.1109/TIT.2003.819332} (see also Ref. \\cite{doi:10.1109/26.79287})."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "q-ary_digits", "protection": "Since each polynomial \\(f_{\\mu}\\) is of degree less than \\(k\\), it can be determined from its values at \\(k\\) points. This means that RS codes can correct erasures on up to \\(n-k\\) registers. The resulting distance, \\(d=n-k+1\\), saturates the Singleton bound.", "code_id": "reed_solomon"}, "binary_permutation": {"name": "Binary permutation-based code", "description": "Stub.", "notes": [], "introduced": "\\cite{doi:10.1016/S0019-9958(79)90076-7,doi:10.1016/j.ejc.2009.03.044}", "short_name": "", "logical": "q-ary_digits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "", "code_id": "binary_permutation"}, "group_linear": {"name": "Linear code over \\(G\\)", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates over a group \\(G\\) such that the codewords form a subgroup of \\(G^n\\).", "notes": [], "introduced": "\\cite{doi:10.1109/49.29613,doi:10.1109/18.133243,doi:10.1109/18.104333}", "short_name": "", "logical": "groups", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "", "code_id": "group_linear"}, "group_classical": {"name": "Group-based code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates labeled by elements of a group \\(G\\). The number of codewords may be infinite for infinite groups, so various restricted versions have to be constructed in practice.", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "", "code_id": "group_classical"}, "rank_modulation": {"name": "Rank-modulation Gray code (RMGC)", "description": "Also known as a \\textit{code in permutations}.\nA family of codes that encode a finite set of size \\(M\\) into a group \\(S_n\\) of permutations of \\([n]=(1,2,...,n)\\).\nThey can be derived from Lee-metric codes, Reed-Solomon codes \\cite{doi:10.1109/ISIT.2011.6034261}, quadratic residue codes and most binary codes.\n", "notes": [], "introduced": "\\cite{doi:10.1109/TIT.1969.1054291,doi:10.1109/ISIT.2008.4595285}", "short_name": "RMGC", "logical": "q-ary_digits", "realizations": ["Electronic devices where charges can either increase in an individual cell or decrease in a block of adjacent cells, e.g., flash memories \\cite{doi:10.1109/TIT.2009.2018336}."], "features": {"general_gates": [], "encoders": [], "rate": "Rank modulation codes with code distance \\(d=\\Theta(n^{1+\\epsilon})\\) for \\(\\epsilon\\in[0,1]\\) achieve a rate of \\(1-\\epsilon\\) \\cite{doi:10.1109/ISIT.2010.5513604}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "Protects against errors in the Kendall tau distance on the space of permutations.\nThe Kendall distance between permutations \\(\\sigma\\) and \\(\\pi\\) is defined as the minimum number of adjacent transpositions required to change \\(\\sigma\\) into \\(\\pi\\).\n", "code_id": "rank_modulation"}, "ldgm": {"name": "Low-density generator-matrix (LDGM) code", "description": "Binary or \\(q\\)-ary linear code with a sparse generator matrix. More precisely, a member of an infinite family of \\([n,k,d]\\) codes for which the number of nonzero entries in each row and column of the generator matrix are both bounded by a constant as \\(n\\to\\infty\\). The dual of an LDGM code has a sparse parity-check matrix and is called an LDPC code.\n", "notes": [], "introduced": "", "short_name": "LDGM", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Certain LDGM codes come close to achieving Shannon capacity \\cite{doi:10.1109/LCOMM.2003.813816}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "ldgm"}, "linear": {"protection": "", "name": "Linear code", "description": "A code whose set of codewords is closed under addition and multiplication by elements of its alphabet, which can be either a field or a ring. In other words, for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any alphabet elements \\(\\alpha,\\beta\\). This extra structure yields much information about their properties, making them a large and well-studied subset of codes.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "linear", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "evaluation_polynomial": {"name": "Polynomial evaluation code", "description": "Evaluation code of polynomials at points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) on an algebraic variety \\(\\cal X\\). Codewords\n\\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right)\n\\end{align}\nare evaluations of a linear space \\(L\\) of polynomials \\(f\\). If the space is taken to be all polynomials up to some degree, the code is called a \\textit{Reed-Muller-type code} or \\textit{RM-type code} of that degree.\n\nOne can specify the space \\(L\\) by the number of variables input into the polynomials as well as the polynomials' maximum degree. One can additionally select only polynomials that have zeroes at certain points with certain multiplicities. A bookkeeping device for this data is the divisor \\(D\\), and the corresponding vector space of polynomials defined using the variety \\(\\cal X\\) and the divisor is the \\textit{Riemann-Roch space} \\(L=L(D)\\) (\\cite{doi:10.1201/9781315147901}, pg. 313).\n", "notes": ["See Refs. \\cite{arxiv:0802.2349,arxiv:1907.13217} for reviews."], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "evaluation_polynomial"}, "dual": {"name": "Dual linear code", "description": "For any  \\([n,k]\\) binary or \\(q\\)-ary linear code \\(C\\), the dual (or orthogonal) code,\n\\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{n} ~|~ x\\cdot y=0 \\forall x\\in C\\},\n\\end{align}\nwhere the \\textit{ordinary}, \\textit{standard}, or \\textit{Euclidean} inner product is \\(x\\cdot y = \\sum_{i=1}^n x_i y_i\\) for coordinates \\(x_i,y_i\\).\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called \\textit{self-orthogonal} or \\textit{weakly self-dual}. A code that contains its dual, \\(C^\\perp \\subseteq C\\), is called \\textit{dual-containing}. A code that is equal to its dual, \\(C^\\perp = C\\), is called \\textit{self-dual}. The dual of a dual code is the original code. A code is dual-containing iff its dual is self-orthogonal.\n\nThe dual code \\(C^\\perp\\) is the row space of the parity check matrix of \\(C\\). The dual code is the kernel of the encoding map for \\(C\\), and \\(\\dim C^\\perp = n-k\\).\n\nFor cases when \\(q\\) is a square, an alternative definition of dual substitutes the Euclidean inner product for the \\textit{Hermitian inner product}, \\(x\\cdot y \\to \\sum_{i=1}^n x_i y^{\\sqrt{q}}_i\\). More general inner products can also be considered \\cite{doi:10.1007/s10623-016-0282-8}. Self-dual codes with respect to the Hermitian inner product are called \\textit{Hermitian self-dual}; similar definitions hold for self-orthogonal and dual-containing as well as other inner products.\n", "notes": ["See books \\cite{doi:10.1007/3-540-30731-1,doi:10.1017/CBO9780511807077} for more on self-dual codes.", "See Refs. \\cite{doi:10.1016/j.disc.2004.06.010,arXiv:1706.01694} for constructions of binary self-dual codes.", "See \\href{http://www.unilim.fr/pages_perso/philippe.gaborit/SD/index.html}{Tables of Self-Dual Codes} for a database of self-dual codes over \\(GF(2)\\), \\(GF(3)\\), \\(GF(4)\\) (Euclidean or Hermitian), \\(GF(5)\\), and \\(GF(7)\\). See also Ref. \\cite{doi:10.1016/S1071-5797(03)00011-X}."], "introduced": "\\cite{doi:10.1201/9781315147901}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "The dual of an \\([n,k,d] \\) code is an \\([n,n-k,d']\\) code, where \\(d'\\) is not always related to \\(d\\). The generator matrix of \\(C^\\perp\\) is the parity check matrix of \\(C\\), and visa versa.", "code_id": "dual"}, "ldpc": {"name": "Low-density parity-check (LDPC) code", "description": "Also known as \\textit{Gallager codes}. Binary or \\(q\\)-ary linear code with a sparse parity-check matrix. More precisely, a member of an infinite family of \\([n,k,d]\\) codes for which the number of nonzero entries in each row and column of the parity-check matrix are both bounded by a constant as \\(n\\to\\infty\\). An LDPC code is \\((j,k)\\)-\\textit{regular} if the parity-check matrix has a fixed number of \\(j\\) nonzero entries in each row and \\(k\\) entries in each column; otherwise, the LDPC code is \\textit{irregular}. The dual of an LDPC code has a sparse generator matrix and is called an LDGM code.\n\nA \\textit{parity check} is performed by taking the inner product of a row of the parity-check matrix with a codeword that has been affected by a noise channel. A parity check yields either zero (no error) or one (error) for binary codes, while yielding zero (no error) or a nonzero field element (error) for \\(q\\)-ary codes. Despite the fact that there is more than one nonzero outcome, \\(q\\)-ary linear codes with sparse parity-check matrices are also called LDPC codes.\n", "notes": ["See Kaiserslautern database \\cite{preset:KLdatabase} for explicit representatives of several classes of LDPC codes, including \\(q\\)-ary, WiMAX, multi-edge, and spatially-coupled.", "See pretty-good-codes database \\cite{preset:PGCdatabase} for explicit representatives and benchmarking.", "See Ref. \\cite{doi:10.1007/978-3-0348-7865-4_5} for a review of LDPC codes circa 2005.", "Codes have been benchmarked using AFF3CT toolbox \\cite{doi:10.1016/j.softx.2019.100345}."], "introduced": "\\cite{doi:10.1109/TIT.1962.1057683,manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.}}", "short_name": "LDPC", "logical": null, "realizations": ["5G NR cellular communication for the traffic channel \\cite{doi:10.1109/CSCITA47329.2020.9137797}.", "WiMAX (IEEE 802.16e) \\cite{manual:{LDPC coding for OFDMA PHY. 802.16REVe Sponsor Ballot Recirculation comment, July 2004. IEEE C802.16e04/141r2}}.", "Satellite transmission of digital television \\cite{doi:10.1109/ICARES.2014.7024407}."], "features": {"general_gates": [], "encoders": ["Almost linear-time encoder based on transforming parity-check matrix into upper triangular form \\cite{doi:10.1109/18.910579}."], "rate": "Achieve capacity on the binary symmetric channel under maximum-likelihood decoding \\cite{doi:10.1109/18.748992,doi:10.1109/TIT.1962.1057683,arXiv:cs/0610022}. Some LDPC codes achieve capacity for smaller block lengths under belief-propagation decoding \\cite{arxiv:1201.2999}. Random LDPC codes achieve list-decoding capacity \\cite{arXiv:1909.06430}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Message-passing algorithm called belief propagation (BP) \\cite{manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.},preset:LinCostello}.", "Linear programming \\cite{doi:10.1007/978-1-4939-2864-4_216}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "With high probability, random LDPC codes have constant distance \\cite{manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.}}.", "code_id": "ldpc"}, "ltc": {"name": "Locally testable code (LTC)", "description": "Code for which one can efficiently check whether a given string is a codeword or is far from a codeword. Efficiency of the verification is quantified by the code's \\textit{query complexity} \\(u\\), while effectiveness is quantified by the code's \\textit{soundness} \\(R\\).\n\nTypically, one looks at how \\(R\\) scales with increasing code size for infinite families of codes, defining LTC families as those for which the soundness is asymptotically constant. Such LTC families with asymptotically constant distance, rate, and query complexity are called \\(c^3\\)\\textit{-LTCs}. The first two such families are classical codes arising from the \\hyperref[code:expander_lifted_product]{expander lifted-product} quantum code construction and \\hyperref[code:lr-cayley-complex]{left-right Cayley complex} codes.\n\nA technical definition for codes over binary alphabets is provided as follows; for general alphabets, see Ref. \\cite{doi:10.1007/978-3-642-16367-8_6}.\nThe idea behind LTCs is to be able to reliably test whether a given bit-string \\(x\\) is in the code by only sampling subsets of \\(u\\) bits.\nTo have something to check against, we first have to define a collection of length-\\(u\\) subsets \\(S\\) of bit locations that are called \\textit{allowed local views}.\nA code is LTC if the following two conditions are satisfied \\cite[Thm. 1.1]{arxiv:2111.04808}.\n\nFirst, if \\(x\\) is a codeword, then all of its restrictions \\(x|_S\\) to the subsets \\(S\\) are allowed local views,\n\\begin{align}\n  x\\in C \\Rightarrow x|_S \\in \\{\\text{allowed local views}\\}~.\n\\end{align}\nThis guarantees that codewords can indeed be determined from this limited sampling procedure.\n\nSecond, the probability that a given restriction is not an allowed local view is lower-bounded by the relative distance to the code,\n\\begin{align}\n  \\text{Pr}_S (x|_S\\text{ not allowed local view}) \\geq \\frac{R}{n} D(x,C)~,\n\\end{align}\nwhere \\(D(x,C)\\) is the Hamming distance between \\(x\\) and the closest codeword to \\(x\\). This condition ensures that strings \\(x\\) can be deemed to be not in the codespace with high probability, i.e., with probability increasing as \\(x\\) gets farther from the code.\n", "notes": ["LTCs first appeared implicitly in works on probabilistically checkable proofs (PCPs) \\cite{doi:10.1016/0022-0000(93)90044-W,doi:10.1007/BF01200056,doi:10.1145/146585.146605,doi:10.1145/103418.103428,doi:10.1145/273865.273901,doi:10.1145/278298.278306}; see Ref. \\cite{doi:10.1007/978-3-642-16367-8_6} for a review."], "introduced": "\\cite{doi:10.1145/103418.103428,manual:{Sanjeev Arora. \\emph{Probabilistic checking of proofs and hardness of approximation problems}. UC Berkeley, 1994.},doi:10.1137/S0097539793255151,arxiv:1307.3975}", "short_name": "LTC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "ltc"}, "ecc_finite": {"name": "Finite-dimensional error-correcting code (ECC)", "description": "A \\textit{code} is a subset of a set or \\textit{alphabet}, with each element called a \\textit{codeword}. An \\textit{error-correcting code} consists of \\(K\\) codewords over an alphabet with \\(N\\) elements such that it is possible to recover the codewords from errors \\(E\\) from some error set \\(\\mathcal{E}\\).\n\nA common family of codes are the \\textit{block codes}, intended to encode a piece, or block, of a data stream.\nA block code encodes strings of length \\(k\\), where each character in the string an element of some fixed alphabet \\(\\Sigma\\), into strings of length \\(n\\). In other words, a block code encoding is a map from \\(\\Sigma^k\\) to \\(\\Sigma^n\\), where \\(N = |\\Sigma|^n\\), \\(K=|\\Sigma|^k\\), and \\(|\\Sigma|\\) is the number of elements in the alphabet.\n", "notes": ["The modern theory of error-correcting codes is rooted in the foundational work of C. Shannon \\cite{doi:10.1002/j.1538-7305.1948.tb01338.x}, but error-correcting codes have been used prior to that work \\cite{doi:10.1007/bf03025254}."], "introduced": "\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x}", "short_name": "Finite ECC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Capacity-achieving Guessing Random Additive Noise Decoding (GRAND) \\cite{arxiv:1802.07010}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "A code corrects errors associated with a noise channel if it is possible to recover any codeword after its coordinates have been changed after going through the channel. More technically, an error-correcting code \\((u,\\mathcal{E})\\) is an \\textit{encoder} function \\(u:[1\\cdots K]\\to[1\\cdots N]\\) with a set of correctable errors \\(E:[1\\cdots N]\\to [1\\cdots M]\\) with the following property: there exists a \\textit{decoder} function \\(d:[1\\cdots M]\\to [1\\cdots K]\\) such that for all \\(E\\in\\cal{E}\\) and states \\(x\\in[1\\cdots K]\\), \\(d(E(e(x)))=x\\) \\cite{preset:GottesmanBook}.", "code_id": "ecc_finite"}, "group": {"name": "Group code", "description": "An \\( [n,k] \\) binary or \\(q\\)-ary code based on a finite group \\( G \\) of size \\(n \\). A group code for an abelian group is called an \\textit{abelian group code}.\n\nThe code is a \\( k \\)-dimensional linear subspace of the group algebra of \\( G\\) with coefficients in the field \\(GF(q) = \\mathbb{F}_q\\) with \\(q\\) elements. To be precise, the code must be closed under permutations corresponding to the elements of the group \\( G \\); therefore, \\( G \\) must be a subgroup of the permutation automorphism group of the code, which is defined as the group of permutations of the physical bits that preserve the code space. This leads us to the formal definition of a group code: a group code is an ideal in the group algebra \\( \\mathbb{F}_q G \\).\n", "notes": ["See Ch. 16 of Ref. \\cite{doi:10.1201/9781315147901} and pg. 58 of Ref. \\cite{doi:10.1007/978-94-011-3810-9} for introductions to group codes.", "Not all abelian group codes are for cyclic groups (cyclic codes) or for elementary abelian \\( p \\) groups (e.g. Reed Muller codes \\cite{doi:10.1007/BF01119999}). For example, there is a binary code with parameters \\( [45,13,16] \\) which is an abelian group code for the group \\( G = \\mathbb{Z}_3 \\times \\mathbb{Z}_{15} \\). "], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "group"}, "random": {"name": "Random code", "description": "Code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes, to codes whose multi-step construction is deterministic with the exception of a single step.\n\nTypically, random codes are selected with uniform distribution from some ensemble of codes. For example, a random binary code is a set of \\(2^{K}\\) codewords with length \\(N\\) chosen uniformly from the ensemble of all \\(2^N\\) bit-strings. Each bit in the codeword is randomly chosen between 0 and 1 with equal probability. For another example, a random binary linear code is generated from a random chosen \\(K\\) generators of length \\(N\\), where each bit of the generators is randomly chosen between 0 and 1 with equal probability. Equivalently, a random binary linear code is defined by a randomly generated \\(K\\) by \\(N\\) generator matrix, where each entry is randomly chosen between 0 and 1 with equal probability.\n\nIn both of the above random code constructions, the ensemble size scales exponentially with \\(N\\). A common convention is to think of the resulting code constructions as effectively explicit (as opposed to random) in cases where the ensemble size is independent of \\(N\\) or even when the size scales polynomially with \\(N\\).\n", "notes": ["Shannon's pioneering work \\cite{doi:10.1002/j.1538-7305.1948.tb01338.x} analyzes the distance distribution of the code given a rate. Given \\(N\\) and the rate \\(R\\), the minimum distance of a TRC is given by the GV bound \\(d=N\\delta_{GV}(2R)\\), where \\(\\delta_{GV} = h^{-1}(1-R)\\), \\(0\\le R \\le 1\\), and \\(\\delta_{GV}(x)=0\\) for all other \\(R\\). For a TLC, the minimum distance is given by \\(d=N\\delta_{GV}(R)\\)."], "introduced": "\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x}", "short_name": "", "logical": null, "realizations": ["Distributed storage systems \\cite{doi:10.1109/TPDS.2008.251}."], "features": {"general_gates": [], "encoders": [], "rate": "Typical random codes (TRC) or typical random linear codes (TLC) refer to codes in the respective ensemble that satisfy a certain minimum distance. The relative fraction of typical codes in the ensemble approaches one as \\(N\\) goes to infinity \\cite{doi:10.1002/j.1538-7305.1948.tb01338.x} (see also Ref. \\cite{doi:10.1109/TIT.2002.800480}). Asymptotically, given distance \\(d\\), the maximum rate for a TRC is given by \\(R=\\frac{1}{2}R_{GV}(\\delta)\\) where \\(R_{GV}\\) is the Gilbert\u2013Varshamov (GV) bound \\(R_{GV}=1-h(\\delta)\\), and \\(h(\\delta)=h(\\frac{d}{n})\\) is the binary entropy function. The maximum rate for a TLC is given by \\(R=R_{GV}(d)\\), meaning that TLCs achieve the asymoptic GV bound.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Ball-collision decoding \\cite{doi:10.1007/978-3-642-22792-9_42}.", "Finiasz and Sendrier (FS-ISD) decoding \\cite{doi:10.1007/978-3-642-10366-7_6}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "random"}, "evaluation_varieties": {"name": "Evaluation code", "description": "Code whose codewords are evaluations of functions at certain fixed points. Code properties can be inferred from the structure of the functions and the underlying geometric object containing the points, often using results from algebraic geometry.\n\nLet \\(\\cal{X}\\) be a geometric object that contains a subset \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right) \\) consisting of \\(n\\) points \\(P_j\\). Let \\(L\\) be a vector space over \\(GF(q)\\) of functions \\(f\\) that take values in \\(GF(q)\\). Each \\(f\\in L\\) yields a codeword of an evaluation code \\(C_L({\\cal X},{\\cal P})\\) of the form\n\\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right) \\quad\\quad\\forall f\\in L~.\n\\end{align}\nThis is a linear binary or \\(q\\)-ary code since the functions \\(f\\) take values in \\(GF(q)\\) and form a vector space.\n\nExamples of geometric objects \\(\\cal X\\) include affine or projective spaces over \\(GF(q)\\) as well as subsets of those spaces determined by some constraints. Prominent subsets are \\textit{algebraic varieties}, i.e., sets of solutions of systems of polynomial equations in either affine or projective space. The functions \\(f\\) are typically polynomials or rational functions.\n", "notes": [], "introduced": "\\cite{doi:10.1007/BF02249124,doi:10.1007/978-94-011-3810-9}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Properties of \\(\\cal X\\) can be used to bound the code dimension \\(k\\) and distance \\(d\\). The order or Feng-Rao bound gives a lower bound on the distance of evaluation codes \\cite{doi:10.1142/9789812794017_0004,doi:10.1109/18.335973,doi:10.1109/18.179340,doi:10.1023/A:1008274212057,preset:HPAlgCodes}; see Ref. \\cite{preset:HPAlgCodes}, Ch. 4 and Ref. \\cite{arxiv:0802.2349} for more discussion.", "code_id": "evaluation_varieties"}, "mds": {"name": "Maximum distance separable (MDS) code", "description": "A \\([n,k,d]_q\\) \\(q\\)-ary linear code is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Singleton bound\n\\begin{align}\nd \\leq n-k+1\n\\end{align}\nbecomes an equality. A code is called \\textit{almost MDS} (AMDS) when \\(d=n-k\\). A bound for general \\(q\\)-ary codes can also be formulated; see Thm. 1.9.10 in Ref. \\cite{doi:10.1201/9781315147901}. A code is \\textit{near MDS} (NMDS) if the code and its dual are mode AMDS.\n\nThe codes \\( [n,1,n]_q, [n,n-1,2]_q, [n,n,1]_q \\) for any \\(q\\) are MDS codes. These are called the \\textit{trivial} MDS codes. The only binary MDS codes are the trivial ones.\n", "notes": [], "introduced": "\\cite{doi:10.1109/TIT.1964.1053661}", "short_name": "MDS", "logical": null, "realizations": ["The McEliece Public Key Cryptosystem \\cite{manual:{McEliece, R.J.: A public-key cryptosystem based on algebraic coding theory. DSN Progress Report pp. 114\u2013116 (1978).}} uses algebraic coding theory to secure communications against eavesdropping attack, in which private keys are generator matrices of linear codes, i.e., \\(G\\). Public Keys shared to outside world are scrambled and permutated versions of \\(G\\), i.e., \\(G^\\prime=SGP\\). Data to be encrypted, \\(u\\), is multiplied by public key and added intentional errors \\(e\\), i.e., \\(x=uG^\\prime+e\\). Upon receiving encrypted data, private key owner can apply inverse permutation \\(P^{-1}\\) to \\(x\\), decode the scrambled message given the presence of \\(e\\) errors, and finally unscramble to obtain \\(u\\). Security parameters of the system are \\(n\\) and \\(e\\), hence MDS codes, such as GRS codes may provide the same security level for shorter key sizes, and the private key owner can decode arguably fast enough using known decoding algorithms.", "Automatic repeat request (ARQ) data transmission protocols (\\cite{doi:10.1109/9780470546345}, Ch. 7)."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error-correction properties.", "code_id": "mds"}, "covering": {"name": "Covering code", "description": "A code \\(C\\) in a metric space is covering if the union of balls of some radius centered at the codewords covers the entire space. For example, a \\(q\\)-ary code \\(C\\) is \\(\\rho\\)-covering if \\(\\forall v \\in GF(q)^{n}\\), there is a codeword \\(c \\in C\\) such that the Hamming distance \\(D(c,v)\\leq \\rho\\).\n\nThe \\textit{covering radius} \\(\\rho(C)\\) is the smallest non-negative integer \\(\\rho\\) such that \\(C\\) is \\(\\rho\\)-covering, i.e.\n\\begin{align}\n  \\rho(C)=\\max_{{v\\in GF(q)^{n}}}\\min_{{c\\in C}}d(v,c)~.\n\\end{align}\nFor a linear code \\([n,k]_q\\), the covering radius is the minimum number of columns of the code's parity check matrix which cover \\(GF(q)^{n-k}\\).\n\nThe covering radius satisfies various inequalities. A code \\(C\\) with distance \\(d\\) satisfies the relation\n\\begin{align}\n  \\rho(C)\\geq \\frac{|d-1|}{2}~. \\label{eq:perfect-ref}\n\\end{align}\nLinear \\([n,k]_q\\) codes also satisfy the \\textit{redundancy bound}\n\\begin{align}\n  \\rho(C)\\leq n-k\n\\end{align}\nand the \\textit{sphere covering bound}\n\\begin{align}\n  \\rho(C)\\leq \\min{\\left(p~\\bigg\\rvert \\sum_{i=0}^{p} {n \\choose i}(q-1)^{i}|C| \\geq q^{n}\\right)}~. \\label{eq:spherepacking-perfect-label}\n\\end{align}\nA code is perfect iff it satisfies Eqs. \\eqref{eq:perfect-ref} and \\eqref{eq:spherepacking-perfect-label} with equality.\n\nIn general, finding the covering radius of a given code is difficult. Complexity analysis as well as an extensive study on bounds can be found in Ref. \\cite{manual:{G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, \\emph{Covering Codes}, Elsevier (1997).}}.\n", "notes": ["See book \\cite{manual:{G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, \"Covering codes\". Elsevier, 1997.}} for an expositions on covering codes."], "introduced": "", "short_name": "", "logical": null, "realizations": ["Data compression both with or without compression \\cite{manual:{G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, \\emph{Covering Codes}, Elsevier (1997).}}.", "Football-pool problem: finding the smallest number of bets on a set of matches needed to guarantee at least one bet has at most \\(\\rho\\) errors \\cite{doi:10.2307/2974552,doi:10.1007/BF03025254}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "covering"}, "quasi_perfect": {"name": "Quasi-perfect code", "description": "Perfect codes \\((n,K,d)_q\\) are those for which balls of Hamming radius \\(t=\\left\\lfloor (d-1)/2\\right\\rfloor\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings. \\textit{Quasi-perfect codes} are those for which balls of Hamming radius \\(t\\) are disjoint, while balls of radius \\(t+1\\) cover the space with possible overlaps. In other words, any \\(q\\)-ary string is at most \\(t+1\\) bit flips away from a codeword of a quasi-perfect code.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Correct errors of weight \\(t\\) as well as some errors of weight \\(t+1\\).", "code_id": "quasi_perfect"}, "perfect": {"protection": "", "name": "Perfect code", "description": "An \\((n,K,2t+1)_q\\) binary or \\(q\\)-ary code is perfect if parameters \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the Hamming (a.k.a. sphere-packing) bound\n\\begin{align}\n\\sum_{j=0}^{t}(q-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a binary \\(q=2\\) code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\). Perfect codes are those for which balls of Hamming radius \\(t\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings.\n\nAny perfect linear code is either a repetition code, a Hamming code, or a binary or ternary Golay code \\cite{doi:10.1016/S0019-9958(77)90519-8}. If \\(q\\) is a prime power, any distance-three code is either a Hamming code or a nonlinear code with the same parameters; see Ref. \\cite{doi:10.1201/9781315147901}, pg. 100, for more details.\n\nFor binary codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-h(t/n),\n\\end{align}\nwhere \\(h\\) is the binary entropy function.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "perfect", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "weighed_covering": {"name": "Weighed-covering code", "description": "A binary or \\(q\\)-ary code for which balls of some radius centered at its codewords provide a weighted covering of the Hamming space.\n\nLet the \\textit{outer} or \\textit{weight distribution} of a \\(q\\)-ary string \\(x\\) with respect to a \\(q\\)-ary code \\(C\\) be \\(A(x) = \\left( A_0(x),A_1(x),\\cdots,A_n(x) \\right)\\), where\n\\begin{align}\n  A_j(x) = \\left|\\{ c \\in C~\\text{such that}~ D(c,x)=j \\}\\right|~,\n\\end{align}\nand \\(D\\) is the Hamming distance. Given a tuple \\(m=(m_1,m_2,\\cdots,m_n)\\) of rational numbers, the \\textit{\\(m\\)-density} of the code at \\(x\\) is\n\\begin{align}\n  \\theta(x) = \\sum_{j=0}^n m_j A_j(x)~.\n\\end{align}\n\nA code is an \\textit{\\(m\\)-weighed covering} if \\(\\theta(x)\\geq1\\) for all strings \\(x\\in GF(q)^n\\).\nThe \\textit{\\(m\\)-covering radius} \\(r\\) is the largest \\(j\\) for which \\(m_j\\) is nonzero.\n", "notes": ["See book \\cite{preset:CoveringBook} for an expositions on weighed covering codes and generalized sphere-packing bounds.", "See book \\cite{doi:10.1007/978-3-662-00174-5}, Table 7.5.18 for tables of codes with particular weighed coverings."], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "weighed_covering"}, "nearly_perfect": {"name": "Nearly perfect code", "description": "An \\((n,K,2t+1)\\) binary code is nearly perfect if parameters \\(n\\), \\(K\\), and \\(t\\) are such that the Johnson bound\n\\begin{align}\n  \\frac{{n \\choose t}\\left(\\frac{n-t}{t+1}-\\left\\lfloor \\frac{n-t}{t+1}\\right\\rfloor \\right)}{\\left\\lfloor \\frac{n}{t+1}\\right\\rfloor }+\\sum_{j=0}^{t}{n \\choose j}\\leq2^{n}/K\n\\end{align}\nbecomes an equality (\\cite{doi:10.1017/CBO9780511807077}, Sec. 2.3.5; see also Ref. \\cite{preset:MacSlo}, Ch. 17). All nearly perfect binary codes are either perfect, or correspond to either punctured Preparata codes or one of the \\(2^r-2,2^{2^r-2-r},3)\\) codes for \\(r\\geq 3\\) \\cite{manual:{Kauko Lindstr\u00f6m. \"The nonexistence of unknown nearly perfect binary codes.\" PhD diss., Turun yliopisto, 1975.}}.\n\nSimilar definitions can be made for \\(q\\)-ary codes, but all nearly perfect \\(q\\)-ary codes must be perfect \\cite{manual:{K. Lindstrom and M. J. Aaltonen, \"The nonexistence of nearly perfect nonbinary codes for 1 =< e =< 10\", Ann. Univ. Turku, Ser. A I, No. 172, 1976.},doi:10.1016/S0019-9958(77)90519-8}.\n", "notes": [], "introduced": "\\cite{doi:10.1016/0012-365X(72)90025-8,manual:{N. V. Semakov, V. A. Zinov'ev, G. V. Zaitsev, \u201cUniformly Packed Codes\u201d, Probl. Peredachi Inf., 7:1 (1971), 38\u201350; Problems Inform. Transmission, 7:1 (1971), 30\u201339}}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "nearly_perfect"}, "cyclic": {"name": "Cyclic code", "description": "A code of length \\(n\\) over an alphabet is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword.\n\n\\subsection{Cyclic-to-polynomial correspondence}\n\n\\begin{defterm}{Cyclic-to-polynomial correspondence}\n\\label{topic:Cyclic-to-polynomial-correspondence}\nBinary and \\(q\\)-ary cyclic codes and their properties can be naturally formulated using the theory of polynomials.\nCyclic codes correspond to ideals in a particular polynomial ring. Codewords \\(c_1 c_2 \\cdots c_n\\) of a \\(q\\)-ary Galois-field code can be thought of as coefficients in a polynomial \\(c_1+c_2 x+\\cdots+c_n x^{n-1}\\) in the set of polynomials with \\(q\\)-ary coefficients, \\(\\mathbb{F}_q[x]\\) with \\(\\mathbb{F}_q=GF(q)\\). Polynomials corresponding to codewords of a linear cyclic code form an ideal (i.e., are closed under multiplication and addition) in the ring \\(\\mathbb{F}_q[x]/(x^n-1)\\) (i.e., the set of equivalence classes of polynomials congruent modulo \\(x^n-1\\)). Multiplication of a codeword polynomial \\(c(x)\\) by \\(x\\) in such a ring corresponds to a cyclic shift of the corresponding codeword string.\n\\end{defterm}\n\nCodeword polynomials of a cyclic code can be generated, via multiplication, by a \\textit{generator polynomial} \\(g(x)\\). A particular generator polynomial \\(e(x)\\) has the additional property of being \\textit{idempotent}, i.e., \\(e(x)^2=e(x)\\). Given a generator polynomial, the corresponding \\textit{check polynomial} \\(h(x)=(x^n-1)/g(x)\\) yields zero when multiplying a codeword polynomial. Its coefficients correspond to the code's parity check matrix.\n\nSince the generator polynomial \\(g(x)\\) is a polynomial over \\(GF(q)\\), it can be factorized over some potentially larger \\textit{splitting field} (just like \\(x^2+1\\) can be factorized over the complex numbers but not the reals). Whenever \\(q\\) and \\(n\\) are relatively prime, cyclic codes can also be defined in terms of roots of \\(g(x)\\). Such roots are called \\textit{zeroes} of the code, and they are all powers of a primitive \\(n\\)th root of unity because \\(g(x)\\) is a divisor of \\(x^n-1\\). Since the generator polynomial generates all codeword polynomials \\(c(x)\\) by multiplication by \\(x\\), its zeroes are also zeroes of those polynomials.\n", "notes": [], "introduced": "\\cite{manual:{E. Prange, \\emph{Cyclic Error-Correcting Codes in Two Symbols}, TN-57-/03, (September 1957)},manual:{E. Prange, \\emph{Some cyclic error-correcting codes with simple decoding algorithms}, TN-58-156, (April 1958)},manual:{E. Prange, \\emph{The use of coset equivalence in the analysis and decoding of group codes}, TN-59-/64, (1959)},manual:{E. Prange, \\emph{An algorithm for factoring xn - I over a finite field}. TN-59-/75, (October 1959)},preset:PetersonWeldon}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "cyclic"}, "skew_cyclic": {"name": "Skew-cyclic code", "description": "A classical code \\(C\\) of length \\(n\\) over an alphabet \\(R\\) is skew-cyclic if there exists an automorphism, \\(\\theta\\), of \\(R\\), such that for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the skew-cyclically shifted string \\(\\theta(c_n) \\theta(c_1) \\cdots \\theta(c_{n-1})\\in C\\). We say that \\(C\\) is a \\(\\theta\\)-cyclic code over \\(R\\).", "notes": ["Computer algebra software is used to find most codes of this type. Ref. \\cite{arXiv:math/0604603} gives several examples of codes, which have slightly improved minimum distance for some \\((n,k)\\) codes."], "introduced": "\\cite{arXiv:math/0604603}", "short_name": "", "logical": null, "realizations": ["Not directly implemented, but BCH codes form a subclass, and are used in DVD, solid state drive storage, etc."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Only given for skew-BCH codes, adapted froom standard BCH codes."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "skew_cyclic"}, "quasi_cyclic": {"name": "Quasi-cyclic code", "description": "A code \\(C\\) of length \\(n\\) over an alphabet is quasi-cyclic if, for each codeword \\(c_1 \\cdots c_{\\ell} c_{\\ell+1} \\cdots c_n\\), the string \\(c_{n-\\ell+1} \\cdots c_n c_1 \\cdots c_{n-\\ell}\\) where each entry is cyclically shifted by \\(\\ell\\) increments is also a codeword.\n\nThe generator of an \\([mn_0,mk_0]\\) quasi-cyclic linear code is representable as a block matrix of \\(m \\times m\\) circulant matrices \\cite{manual:{Thomas A. Gulliver, \\href{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.3623}{Construction of quasi-cyclic codes}, Thesis, University of New Brunswick, 1989.}}.\n", "notes": ["A database of quasi-cyclic codes with searchable parameters such as block length and dimension is constructed and displayed \\href{http://www.tec.hkr.se/~chen/research/codes/qc.htm}{here}."], "introduced": "\\cite{doi:10.1109/TIT.1967.1053974}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "quasi_cyclic"}, "parallel_concatenated": {"name": "Parallel concatenated code", "description": "Stub.", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "parallel_concatenated"}, "generalized_concatenated": {"name": "Generalized concatenated code", "description": "Stub.", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "generalized_concatenated"}, "concatenated": {"name": "Concatenated code", "description": "Also called a \\textit{serially concatenated} code \\cite{doi:10.1109/TIT.2005.846392}. Stub.", "notes": [], "introduced": "\\cite{preset:Forney}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Generalized minimum-distance decoding \\cite{doi:10.1109/TIT.1966.1053873}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "concatenated"}, "codes_with_availability": {"protection": "", "name": "Availability code", "description": "Stub.", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "codes_with_availability", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "parallel_recovery": {"protection": "", "name": "Parallel-recovery code", "description": "Stub.", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "parallel_recovery", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "distributed_storage": {"name": "Distributed-storage code", "description": "Designed to encode information into spatial nodes such that it is possible to recover said information after failure of some nodes by accessing the remaining nodes with minimal bandwidth. Stub.", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "distributed_storage"}, "sequential_recovery": {"protection": "", "name": "Sequential-recovery code", "description": "Stub.", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "sequential_recovery", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "locally_recoverable": {"name": "Locally recoverable code (LRC)", "description": "Any code for which, given a codeword \\(x\\) and coordinate \\(i\\), \\(x_i\\) can be recovered from (at most \\(r\\)) other coordinates of \\(x\\). An \\(r\\)-locally recoverable code of length \\(n\\) and dimension \\(k\\) is denoted as an \\((n,k,r)\\) LRC code.\n\nMore technically, a \\(q\\)-ary code \\(C\\) with length \\(n\\) is \\(r\\)-locally recoverable, or \\textit{has locality} \\(r\\), if \\(\\forall i \\in [n]\\), there exists \\(I_i \\subset [n]\\setminus i\\) such that \\(|I_i|\\leq r\\), and the projection of the set \\(\\mathcal{C}(i,a)=\\{x\\in C : x_i=a\\}\\) on to the coordinates in \\(I_i\\), i.e., \\(\\mathcal{C}_{I_i}(i,a)\\) is disjoint from \\(\\mathcal{C}_{I_i}(i,a^\\prime)\\) where \\(a\\neq a^\\prime\\).\n\nThe definition can be generalized to \\(t\\)-LRC code, if every coordinate is recoverable from \\(t\\) disjoint subsets of coordinates. A study on the parameters of \\(t\\)-LRC codes, together with known bounds, can be found in Ref. \\cite{doi:10.1109/TIT.2016.2518663}.\n", "notes": [], "introduced": "", "short_name": "LRC", "logical": null, "realizations": ["An \\((18,14,7)\\) LRC code has beed used in the Windows Azure cloud storage system \\cite{manual:{C. Huang, H. Simitci, Y. Xu, A. Ogus, B. Calder, P. Gopalan, J. Li, and S. Yekhanin. \\emph{Erasure coding in Windows Azure Storage}. In Proc. USENIX Annual Technical Conference (ATC), pgs. 15-26, Boston, Massachusetts, June 2012.}}; see also Sec. 31.3.1.2 in Ref. \\cite{doi:10.1201/9781315147901}."], "features": {"general_gates": [], "encoders": [], "rate": "The rate \\(r\\) of an \\((n,k,r)\\) LRC code satisfies \\begin{align} \\frac{k}{n}\\leq\\frac{r}{r+1}~. \\end{align}", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "The distance, \\(d\\), of an \\((n,k,r)\\) LRC code satisfies \\begin{align} d\\leq n-k-\\left \\lceil\\frac{k}{r}\\right \\rceil+2~,\\label{eq:gen-singleton} \\end{align} where \\(r\\leq k\\). When \\(k=r\\), the bound on the distance gives the Singleton bound. The generalized Singleton bound \\eqref{eq:gen-singleton} does not account for \\(q\\)-ary alphabet size. A more generalized bound (including the non-linear case) is given in Ref. \\cite{doi:10.1109/TIT.2015.2477406}.", "code_id": "locally_recoverable"}, "balanced": {"name": "Balanced code", "description": "An even-length-\\(n\\) binary or \\(q\\)-ary code whose nonzero codewords all have a Hamming weight of \\(n/2\\). A code is \\(\\epsilon\\)\\textit{-balanced} if the relative weight (i.e., weight divided by \\(n\\)) of all nonzero codewords lies in the interval \\([\\frac{1-\\epsilon}{2},\\frac{1+\\epsilon}{2}]\\). A code is \\(\\gamma\\)\\textit{-unbiased} if the relative weight lies in the interval \\((\\frac{1}{2}-\\frac{1}{n^{\\gamma}},\\frac{1}{2}+\\frac{1}{n^{\\gamma}})\\).\n", "notes": [], "introduced": "\\cite{doi:10.1109/TIT.1986.1057136}", "short_name": "", "logical": null, "realizations": ["Balanced length-eight code, known as a 6b/8b encoding, used for balancing direct current in a communications system \\cite{preset:Kees}"], "features": {"general_gates": [], "encoders": ["Efficient encoder \\cite{doi:10.1109/TIT.1986.1057136}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Efficient decoder \\cite{doi:10.1109/TIT.1986.1057136,doi:10.1109/18.52490,doi:10.1109/jsac.2010.100207}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Can detect unidirectional errors, such as a zero going to a one.", "code_id": "balanced"}, "divisible": {"name": "Divisible code", "description": "A linear binary or \\(q\\)-ary code is \\(\\Delta\\)-divisible if the Hamming weight of each of its codewords is divisible by divisor \\(\\Delta\\). A \\(2\\)-divisible (\\(4\\)-divisible) code is called \\textit{even} (\\textit{doubly even}) \\cite{arxiv:2112.11763}. A code is called \\textit{singly even} if all codewords are even and at least one has weight equal to 2 modulo 4.", "notes": ["See Ref. \\cite{arXiv:1012.4134} for an introduction to \\textit{triply even} binary linear codes and their construction from doubly even codes."], "introduced": "\\cite{doi:10.1007/BF01223730}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "divisible"}, "constant_weight": {"name": "Constant-weight code", "description": "Also known as an \\textit{\\(m\\)-in-\\(n\\)} or \\({n \\choose m}\\) code. A linear binary or \\(q\\)-ary code whose codewords all have the same Hamming weight.\n", "notes": ["Tables of binary constant-weight codes for \\(n \\leq 28\\) \\cite{doi:10.1109/18.59932} and \\(n > 28\\) \\cite{doi:10.37236/1162}.", "See book \\cite{preset:MacSlo} for (Johnson) bounds on the size of constant-weight codes."], "introduced": "", "short_name": "", "logical": null, "realizations": ["Radio-network frequency hopping \\cite{doi:10.37236/1162}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "constant_weight"}, "rings_into_rings": {"name": "Ring code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) coordinates over a ring \\(R\\).", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "rings", "protection": "", "code_id": "rings_into_rings"}, "q-ary_over_zq": {"name": "\\(q\\)-ary code over \\(\\mathbb{Z}_q\\)", "description": "A linear code encoding \\(K\\) states (codewords) in \\(n\\) coordinates over the ring \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\).", "notes": [], "introduced": "", "short_name": "", "logical": "rings", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "rings", "protection": "", "code_id": "q-ary_over_zq"}, "quaternary_over_z4": {"name": "Quaternary code over \\(\\mathbb{Z}_4\\)", "description": "A linear code encoding \\(K\\) states (codewords) in \\(n\\) coordinates over the ring \\(\\mathbb{Z}_4\\) of integers modulo 4.", "notes": ["Code \\href{http://quantumcodes.info/Z4/}{Database}, including quasi-cyclic and quasi-twisted codes \\cite{arxiv:2208.06832}."], "introduced": "", "short_name": "", "logical": "rings", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "rings", "protection": "", "code_id": "quaternary_over_z4"}, "octacode": {"name": "Octacode", "description": "The unique self-dual linear code of length 8 over \\(\\mathbb{Z}_4\\) with generator matrix\n\\begin{align}\n  \\begin{pmatrix}\n  3 & 3 & 2 & 3 & 1 & 0 & 0 & 0\\\\\n  3 & 0 & 3 & 2 & 3 & 1 & 0 & 0\\\\\n  3 & 0 & 0 & 3 & 2 & 3 & 1 & 0\\\\\n  3 & 0 & 0 & 0 & 3 & 2 & 3 & 1\n  \\end{pmatrix}\\,.\n\\end{align}\n", "notes": [], "introduced": "\\cite{doi:10.1016/0097-3165(93)90070-O,doi:10.1007/978-1-4757-6568-7,arXiv:math/0208001}", "short_name": "", "logical": "rings", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "rings", "protection": "", "code_id": "octacode"}, "rings_linear": {"name": "\\(R\\)-linear code", "description": "A code of length \\(n\\) over a ring \\(R\\) is \\(R\\)-linear if it is a submodule of \\(R^n\\).", "notes": [], "introduced": "", "short_name": "", "logical": "rings", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "rings", "protection": "", "code_id": "rings_linear"}, "convolutional": {"name": "Convolutional code", "description": "Classical codes that are formed using generator polynomials over the finite field with two elements. The encoder slides across contiguous subsets of the input bit-string (like a convolutional neural network) evaluating the polynomials on that window to obtain a number of parity bits. These parity bits are the encoded information. There are many ways to formulate these codes", "notes": [], "introduced": "\\cite{manual:{Peter Elias. Coding for noisy channels. IRE Convention Records, 3(4):37\u201346, 1955.}}", "short_name": "", "logical": "bits", "realizations": ["A type of convolutional code used in Real-time Application networks \\cite{doi:10.5815/ijcnis.2014.07.03}.", "Mobile and radio communications (3G networks) use convolutional codes concatenated with Reed-Solomon codes to obtain suitable performance \\cite{doi:10.1002/0470866969}.", "A convolutional code with rate 1/2 was used for deep-space and satellite communication \\cite{manual:{Butman, Deutsch, and Miller. Performance of concatenated codes for deep space missions. 1981.}}"], "features": {"general_gates": [], "encoders": ["Evaluation on the generator polynomials. Can be implemented with a small number of XOR gates"], "rate": "Depends on the polynomials used. Using puncturing removal \\cite{doi:10.12928/telkomnika.v10i4.171} the rate for the code can be increased from \\(\\frac{1}{t}\\) to \\(\\frac{s}{t}\\), where \\(t\\) is the number of output bits, and \\(s\\) depends on the puncturing done. This is done by deleting some pieces of the encoder output such that the most-likely decoders remain effective", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Decoders based on the Viterbi algorithm (trellis decoding) were developed first, which result in the most-likely codeword for the encoded bits \\cite{doi:10.1109/TIT.1967.1054010}. Following, other trellis decoders such as the BCJR decoding algorithm \\cite{doi:10.1109/TIT.1974.1055186} were developed later."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "convolutional"}, "tanner": {"name": "Tanner code", "description": "Binary linear code defined on edges on a regular graph \\(G\\) such that each subsequence of bits corresponding to edges in the neighborhood any vertex belong to some \\textit{short} binary linear code \\(C_0\\). Expansion properties of the underlying graph can yield efficient decoding algorithms.\n\nMore technically, let \\(G(V,E)\\) be a \\(\\Delta\\)-regular (not necessarily bipartite) graph with number of vertices \\(|V| = n \\) and number of edges \\(|E| = N = n\\Delta/2\\). Let \\(C_0\\) be a linear binary code of length \\(\\Delta\\) and rate \\(R_0\\). The Tanner code \\(T(G,C_0)\\), whose bits are placed on edges of the graph, consists of the following codewords:\n\\begin{align}\n\\left\\{ c \\in GF(2)^{n}\\,\\text{s.t. }\\forall v\\in V,\\left.c\\right|_{N(v)}\\in C_{0}\\right\\} ~,\n\\end{align}\nwhere \\(\\left.c\\right|_{N(v)}\\) is the subsequence formed by the \\(\\Delta\\) bits located on the neighbors \\(N(v)\\) of the vertex \\(v\\). The dimension of \\(T\\) is at least \\(N -n(\\Delta -\\Delta R_0) = N(2R_0-1)\\geq 0\\) whenever \\(R_0 \\geq \\frac{1}{2}\\).\n", "notes": [], "introduced": "\\cite{doi:10.1109/TIT.1981.1056404}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": ["Quadratic algorithm: This technique works for all linear block codes and encodes using matrix multiplication \\cite{doi:10.1145/258533.258575}.", "Using the non-Abelian Fast Fourier Transform and exploiting the symmetry of the underlying graph, an encoding algorithm that requires \\(O(n^{4/3})\\) has been devised in \\cite{doi:10.1145/258533.258575}.", "A modified construction yields codes that may be encoded in linear time yet maintain similar performance \\cite{doi:10.1109/18.556668}."], "rate": "For a short code \\(C_0\\) with rate \\(R_0\\), the Tanner code has rate \\(R \\geq 2R_0-1\\). If \\(C_0\\) satisfies the Gilbert-Varshamov bound, the rate \\(R \\geq \\delta = 1-2h(\\delta_0)\\), where \\(\\delta\\) (\\(\\delta_0\\)) is the relative distance of the Tanner code (\\(C_0\\)), and \\(h\\) is the binary entropy function.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Parallel decoding algorithm corrects a fraction \\(\\delta_0^2/48\\) of errors for Tanner codes \\cite{doi:10.1109/18.556667}. A modification of said algorithm improves the fraction to \\(\\delta_0^2/4\\) with no extra cost to complexity \\cite{doi:10.1109/18.910593}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Tanner Codes protect against noise on classical bit strings. If \\(C_0\\) is an \\([d, d-t,d'> d(\\gamma_0 +\\frac{\\lambda}{d})]_2\\) code and G is an \\((N, M, 2, d, \\rho,\\alpha)\\)- expander where \\(\\rho = \\gamma_0 (\\gamma_0 +\\frac{\\lambda}{d})\\), then the Tanner Code \\(T(G, C_0)\\) has rate \\(1-\\frac{M}{N}t\\) and relative distance \\(\\geq \\gamma_0(\\gamma_0+\\frac{\\lambda}{d})\\).", "code_id": "tanner"}, "levenshtein": {"name": "Levenshtein code", "description": "Binary codes constructed from combining two codes \\(A'\\) constructed out of Hadamard matrices.\n\nLet \\(H_n\\) be a normalized Hadamard matrix. The generator matrix for an \\((n-1,n,n/2)\\) code \\(A_n\\) is obtained by taking \\(H_n\\), replacing the +1's by 0's and the -1's by 1's, and deleting the first column. Taking only the codewords of \\(A_n\\) which begin with 0 and deleting the leading 0 yields the generator matrix of an \\((n-2,n/2,n/2)\\) code \\(A_n'\\).\n\nNext, apply the following way of combining codes. Suppose we have an \\((n_1,M_1,d_1)\\) code \\(C_1\\) and an \\((n_2,M_2,d_2)\\) code \\(C_2\\). The combined \\((an_1+bn_2,\\min(M_1,M_2),ad_1+bd_2)\\) code \\(a C_1\\bigoplus b C_2\\) may be constructed by pasting \\(a\\) copies of \\(C_1\\) and \\(b\\) copies of \\(C_2\\) together and omitting the last \\(|M_1-M_2|\\) rows. Applying this to construct a Levenshtein code with length \\(n\\) and distance \\(d\\), define \\(k=\\lfloor d/(2d-n)\\rfloor\\), \\(a=d(2k+1)-n(k+1)\\), and \\(b=kn-d(2k-1)\\). If \\(n\\) is even, construct \\(\\frac{a}{2}A_{4k}'\\bigoplus\\frac{b}{2}A_{4k+4}'\\). If \\(n\\) is odd and \\(k\\) is even, construct \\(aA_{2k}\\bigoplus\\frac{b}{2}A_{4k+4}'\\). If \\(n\\) is odd and \\(k\\) is odd, construct \\(\\frac{a}{2}A_{4k}'\\bigoplus b A_{2k+2}\\).\n", "notes": [], "introduced": "\\cite{manual:{V.I. Levenshtein, \\emph{Application of Hadamard matrices to a problem in coding theory}, Problems of Cybernetics, vol. 5, GIFML, Moscow, 1961, 125\u2013136.}}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Levenshtein codes meet the Plotkin bound \\(K\\leq 2\\left\\lfloor\\frac{d}{2d-n}\\right\\rfloor\\), where \\(K\\) is the number of codewords, \\(d\\) is the distance, and \\(n\\) is the length, and with the assumption that the Hadamard matrices for such parameters exist. The general proof depends on the correctness of Hadamard's conjecture \\cite{preset:MacSlo}.", "code_id": "levenshtein"}, "polar": {"name": "Polar code", "description": "In its basic version, a binary linear polar code encodes \\(K\\) message bits into \\(N=2^n\\) bits. The linear transformation that defines the code is given by the matrix \\(G^{(n)}=B_N G^{\\otimes n}\\), where \\(B_N\\) is a certain \\(N\\times N\\) permutation matrix, and \\(G^{\\otimes n}\\) is the \\(n\\)th Kronecker power of the \\(2\\times 2\\) \\textit{kernel} matrix \\(G=\\left[\\begin{smallmatrix}1 & 0\\\\ 1 & 1 \\end{smallmatrix}\\right]\\). To encode \\(K\\) message bits, one forms an \\(N\\)-vector \\(u\\) in which \\(K\\) coordinates represent the message bits. The remaining \\(N-K\\) coordinates are set to some fixed values and are said to be \\textit{frozen}. The codeword \\(x \\in \\{0,1\\}^N\\) is obtained as \\(x=u G^{\\otimes n}\\).\n\nThe choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.\n\nThere are multiple variants of the above basic construction, in particular relying on other kernel matrices. The codes can be defined for nonbinary alphabets, and they can be adjusted to support tasks such as lossless and lossy compression, successive refinement, communication over the mulitple access channel, communication over the wiretap channel, and many others.\n", "notes": ["For more details, see Ch. 32 of Ref. \\cite{doi:10.1201/9781315147901}.", "See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes.", "See pretty-good-codes database \\cite{preset:PGCdatabase} for explicit representatives and benchmarking.", "Codes have been benchmarked using AFF3CT toolbox \\cite{doi:10.1016/j.softx.2019.100345}."], "introduced": "\\cite{doi:10.1109/TIT.2009.2021379}", "short_name": "", "logical": "bits", "realizations": ["Code control channels for the 5G NR (New Radio) interfaces \\cite{manual:{3rd Generation Partnership Project (3GPP), \\emph{Technical specification group radio access network}, 3GPP TS 38.212 V.15.0.0, 2017.}}."], "features": {"general_gates": [], "encoders": [], "rate": "Supports reliable transmission at rates \\(K/N\\) approaching the Shannon capacity of the channel under the successive cancellation decoder \\cite{doi:10.1109/TIT.2009.2021379}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Successive cancellation (SC) decoder \\cite{doi:10.1109/TIT.2009.2021379}.", "Successive cancellation list (SCL) decoder \\cite{doi:10.1109/TIT.2015.2410251} and a modification utilizing sequence repetition (SR-List) \\cite{arXiv:2205.08857}.", "Soft cancellation (SCAN) decoder \\cite{doi:10.1109/JSAC.2014.140515,doi:10.1109/ICC.2013.6655247}.", "Belief propagation (BP) decoder \\cite{doi:10.1109/LCOMM.2008.080017}.", "Noisy quantum gate-vased decoder \\cite{arxiv:2210.10854}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Protects against various types of noise in the communication channel, for instance, errors, erasures, or other types of noise. Distance plays no role in the analysis of its properties, and is much lower than the largest possible value given \\(K,N\\).", "code_id": "polar"}, "justesen": {"name": "Justesen code", "description": "Binary linear code resulting from generalized concatenation of a Reed-Solomon (RS) outer code with multiple inner codes sampled from the Wozencraft ensemble, i.e., \\(N\\) distinct binary inner codes of dimension \\(m\\) and length \\(2m\\). Justesen codes are parameterized by \\(m\\), with length \\(n=2mN\\) and dimension \\(k=mK\\), where \\((N=2^m-1,K)\\) is the RS outer code over \\(GF(2^m)\\).", "notes": [], "introduced": "\\cite{doi:10.1109/TIT.1972.1054893}", "short_name": "", "logical": "bits", "realizations": ["Generating small-bias sample spaces, i.e., probability distributions that parity functions cannot typically distinguish from the uniform distribution \\cite{doi:10.1145/100216.100244}."], "features": {"general_gates": [], "encoders": [], "rate": "The first asymptotically good codes. Rate is \\(R_m=k/n=K/2N\\geq R\\) and the relative minumum distance satisfy \\(\\delta_m=d_m/n\\geq 0.11(1-2R)\\), where \\(K=\\left\\lceil 2NR\\right\\rceil\\) for asymptotic rate \\(0<R<1/2\\); see pg. 311 of Ref. \\cite{preset:MacSlo}.\n\nThe code can be improved and extend the range of \\(R\\) from 0 to 1 by \\textit{puncturing}, i.e., by erasing \\(s\\) digits from each inner codeword. This yields a code of length \\(n=(2m-s)N\\) and rate \\(R=mk/(2m-s)N\\). The lower bound of the distance of the punctured code approaches \\(d_m/n=(1-R/r)H^{-1}(1-r)\\) as \\(m\\) goes to infinity, where \\(r\\) is the maximum of 1/2 and the solution to \\(R=r^2/(1+\\log(1-h^{-1}(1-r)))\\), and \\(h\\) is the binary entropy function.\n", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Generalized minimum distance decoding \\cite{doi:10.1109/TIT.1972.1054893}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "justesen"}, "tornado": {"name": "Tornado code", "description": "Stub.", "notes": [], "introduced": "\\cite{doi:10.1145/285243.285258,doi:10.1145/258533.258573,doi:10.1109/18.910575}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": ["Linear-time encoder."], "rate": "Come arbitrarily close to the capacity of the binary erasure channel.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Linear-time decoder."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "tornado"}, "vt_single_deletion": {"name": "Binary Varshamov-Tenengolts (VT) code", "description": "Nearly optimal binary deletion-correcting code. Given integers \\(n\\geq 1\\) and \\(a\\in\\{0,1,\\dots,n\\}\\), the associated binary Varshamov-Tenengolts code \\(C_{n,a}\\) corresponds to the set\n\n\\begin{align}\nC_{n,a}=\\left\\{x\\in\\{0,1\\}^n: \\sum_{i=1}^n i~x_i = a\\mod (n+1) \\right\\}.\n\\end{align}", "notes": [], "introduced": "\\cite{manual:{R. R. Varshamov and G. M. Tenengolts, \\emph{Codes which correct single asymmetric errors} (translated to English), Autom. Remote Control, 26(2), 286-290 (1965)},manual:{V. I. Levenshtein, \\emph{Binary codes capable of correcting deletions, insertions and reversals} (translated to English), Soviet Physics Dokl., 10(8), 707-710 (1966).}}", "short_name": "Binary VT", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Rate-\\(1\\) code, with \\(\\log n+1\\) bits of redundancy when \\(a=0\\). Nearly optimal.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Decoder based on checksums \\(\\sum_{i=1}^n i~x_i^{\\prime}\\) of corrupted codewords \\(x_i^{\\prime}\\) \\cite{manual:{V. I. Levenshtein, \\emph{Binary codes capable of correcting deletions, insertions and reversals} (translated to English), Soviet Physics Dokl., 10(8), 707-710 (1966).},manual:{V. I. Levenshtein, \\emph{Binary codes capable of correcting spurious insertions and deletions of one} (translated to English), Prob. Inf. Transmission, 1(1), 8-17 (1965).}}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Corrects a single asymmetric error (a \\(0\\) mapped to a \\(1\\)), a single deletion, or a single insertion of an arbitrary bit in an arbitrary position for any choice of \\(a\\).", "code_id": "vt_single_deletion"}, "binary_linear": {"name": "Linear binary code", "description": "An \\((n,2^k,d)\\) linear code is denoted as \\([n,k]\\) or \\([n,k,d]\\), where \\(d\\) is the code's distance. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword. A code that is not linear is called \\textit{nonlinear}.\n\nLinear codes can be defined in terms of a \\textit{generator matrix} \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a message \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its \\textit{standard} or \\textit{systematic form} \\(G = [I_k~A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) binary matrix.\n", "notes": ["Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by A. E. Brouwer \\cite{manual:{Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.}}, are maintained by M. Grassl at this \\href{http://codetables.markus-grassl.de/}{website}."], "introduced": "", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "A family of linear codes \\(C_i = [n_i,k_i,d_i]\\) is \\textit{asymptotically good} if the asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Decoding an arbitary linear binary code is \\(NP\\)-complete \\cite{doi:10.1109/TIT.1978.1055873}.", "Slepian's standard-array decoding \\cite{doi:10.1002/j.1538-7305.1960.tb03958.x}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set for which no two elements of the set add up to a codeword.\n\nLinear codes admit a \\textit{parity check matrix} \\(H\\), whose columns make up a set of \\textit{parity checks}, i.e., a maximal linearly independent set of vectors that are in the kernel of \\(G\\). It follows that\n\\begin{align}\n  G H^{\\text{T}} = 0 \\mod 2~.\n\\end{align}\n\nThe decision problem corresponding to finding the minimum distance is also \\(NP\\)-complete \\cite{doi:10.1109/18.641542}, and approximating the weight enumerator is \\(\\#P\\)-complete \\cite{arXiv:cs/0304044}.\n", "code_id": "binary_linear"}, "ta-shma": {"name": "Ta-Shma zigzag code", "description": "Member of a family of \\(\\epsilon\\)-balanced codes that nearly achieves the asymptotic Gilbert-Varshamov bound. The codes have relative distance \\(\\frac{1}{2}-\\frac{\\epsilon}{2}\\) and rate of order \\(\\Omega (\\epsilon^{2+\\beta})\\) for \\(\\beta\\to 0\\) as \\(n\\to\\infty\\) \\cite{arxiv:2011.05500}.\n", "notes": [], "introduced": "\\cite{doi:10.1145/3055399.3055408}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Unique and list decoders \\cite{arxiv:2011.05500}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "ta-shma"}, "luby_transform": {"name": "Luby transform (LT) code", "description": "Erasure codes based on fountain codes. They improve on random linear fountain codes by having a much more efficient encoding and decoding algorithm.\n\nLT codes can be constructed as follows. First, randomly choose a degree \\(d_n\\) from a degree distribution depending on total size \\(K\\). Then, randomly choose \\(d_n\\) distinct source packets and let the packet to be transmitted \\(\\hat{p}_n\\) be the bitwise sum of the chosen input packets. This forms a graph connecting encoded packets to source packets.\n", "notes": [], "introduced": "\\cite{doi:10.1109/SFCS.2002.1181950}", "short_name": "LT", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Sum-product algorithm, often called a peeling decoder \\cite{doi:10.1017/CBO9780511791338,manual:{David J. C. MacKay. 2002. Information Theory, Inference & Learning Algorithms. Cambridge University Press, USA}}, similar to belief propagation \\cite{doi:10.1145/3501714.3501727}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "luby_transform"}, "anticode": {"name": "Anticode", "description": "Code for which the distance between any two codewords is less than or equal to some value \\(\\delta\\) called the maximum distance. Anticodes can be used to construct codes that saturate the Griesmer bound; see Refs. \\cite{doi:10.1201/9781315371993,doi:10.1016/S0012-365X(99)00183-1,preset:MacSlo} for more details.", "notes": [], "introduced": "\\cite{doi:10.1049/el:19700293,doi:10.1049/el:19740269}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "anticode"}, "fountain": {"name": "Fountain code", "description": "Code based on the idea of generating an endless stream of custom encoded packets for the receiver. The code is designed so that the receiver can recover the original transmission of size \\(Kl\\) bits after receiving at least \\(K\\) packets each of \\(l\\) bits.\n\nThe simplest example of a fountain code is the random linear fountain code. Take some message of size \\(Kl\\) and split into \\(K\\) packets, \\(p_0, p_1, ..., p_K\\). For each packet \\(\\hat{p}_n\\) to be transmitted do the following: Generate \\(K\\) random bits \\(G_{nk}\\) and let \\(\\hat{p}_n\\) be the bitwise sum of the source packets when \\(G_{nk}\\) is 1,\n\\begin{align}\n\\hat{p}_n = \\sum_{k=1}^K p_k G_{kn}~.\n\\end{align}\nError correction can then be applied to each packet.\n", "notes": ["Review on fountain codes can be found in Refs. \\cite{doi:10.1049/ip-com:20050237,manual:{Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7\u201312). IEEE.}}."], "introduced": "\\cite{doi:10.1145/285243.285258}", "short_name": "", "logical": "bits", "realizations": ["Designed for servers sending data to many recipients, such as during broadcasting or file distribution \\cite{doi:10.1109/TIT.2006.874390,doi:10.1109/MASS.2012.6502540}."], "features": {"general_gates": [], "encoders": [], "rate": "Random linear fountain codes approach the Shannon limit as the file size \\(K\\) increases. However, they do not have a fixed encoding rate.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Invert the fragment generator matrix resulting from the continuous encoding process. If exactly \\(K\\) packets are received, then the probability of decoding correctly is \\(0.289\\). Extra packets increase this probability exponentially. The decoding runtime is dominated by the matrix inversion step, which takes order \\(O(n^3)\\) time."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Designed to protect against erasures during broadcasting of information by a sender to multiple receivers.", "code_id": "fountain"}, "batch": {"name": "Batch code", "description": "Binary code designed for minimizing the total amount of storage and the worst-case maximal load on any devices in a distributed system.\n\nAn \\((n,N,k,m,t)\\) batch code encodes a length-\\(n\\) string \\(x_1,\\cdots,x_n\\) into an \\(m\\)-tuple of strings of total length \\(N\\) (are also called buckets), such that for each \\(k\\)-tuple of distinct indices \\(i_1,i_2,...,i_k\\), the entries \\(x_{i_1},...,x_{i_k}\\) can be decoded by reading at most \\(t\\)-symbols from each bucket. If each bucket of a batch code contains a single symbol, then the \\((n,N,k,m)\\) batch code is \\textit{primitive}.\n\nA multi-user generalization of batch code is named multiset batch code. If, for any multiset \\(i_1, i_2, ..., i_k \\in [n]\\), there is a partition of buckets into subsets \\(S_1, ..., S_k \\subset [m]\\) such that each \\(x_{i_j}\\) can be recovered by reading at most one symbol from each bucket in \\(S_j\\), then the \\((n, N, k, m)\\) code is a \\textit{multiset batch code}.\n\nCombining two batch codes \\(C_1\\) and \\(C_2\\), which are \\((n_1,N_1,k_1,m_1)\\) and \\((n_2,N_2,k_2,m_2)\\) batch codes respectively, yields a composite batch code \\(C_1\\otimes C_2\\), which is an \\((n_1, m_1N_2, k_1 k_2, m_1 m_2)\\) batch code.\n", "notes": [], "introduced": "\\cite{doi:10.1145/1007352.1007396}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "batch"}, "homological_classical": {"name": "Graph homology code", "description": "This code's properties are derived from the size two chain complex associated with a particular graph. Given a connected simplicial (no self loops or muliedges) graph \\(G = (V, E)\\), which is not a tree, with incidence matrix \\(\\Gamma\\) we can construct a code by choosing a parity check matrix which consists of all the linearly independent rows of \\(\\Gamma\\). This is a \\([n,k,d]\\) code with \\(n = |E|\\), \\(k = 1 - \\mathcal{X}(G) = 1-|V|+|E|\\), where \\( \\mathcal{X}(G)\\) is the euler characteristic of the graph. The code distance is equal to the shortest size of a cycle, guaranteed to exist since \\(G\\) is not a tree.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/0605094}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "homological_classical"}, "raptor": {"name": "Raptor (RAPid TORnado) code", "description": "Raptor codes are concatenated erasure codes with two layers: an outer \\textit{pre-code} and a Luby-Transform (LT) inner code.\nThe pre-code is a linear binary erasure code, which is applied first to the input to create some redundant data.\nThe LT code is then applied to the intermediate symbols from the pre-code to generate final output symbols to be transmitted.\n\nThe parameters for a Raptor code are \\( (k, C, \\Omega(x)) \\), with \\(C\\) being the pre-code with dimension \\( k \\), and \\( \\Omega(x) \\) being the degree distribution for the LT code.\n\nThe times to encode and decode source blocks are both linear. The space requirement is \\(1/R \\), where \\(R\\) is the rate of the pre-code. Raptor codes with the simplest output distribution (LT code) are called \\textit{pre-code-only} (PCO).\n", "notes": ["There is an open source RaptorQ implementation in \\href{https://openrq-team.github.io/openrq/}{Java} and \\href{https://github.com/cberner/raptorq}{Rust}."], "introduced": "\\cite{doi:10.1109/TIT.2006.874390,manual:{Petar Maymounkov, \\emph{Online codes}, Technical report, New York University, 2002.}}", "short_name": "Raptor", "logical": "bits", "realizations": ["Two versions of Raptor codes have been standardized by IETF: \\href{https://datatracker.ietf.org/doc/html/rfc5053}{R10} and the more recent \\href{http://tools.ietf.org/html/rfc6330}{RaptorQ}. RaptorQ is used in mobile multimedia broadcasts as specified in ETSI technical specifications. It is also used in the mobile \\href{https://www.atsc.org/wp-content/uploads/2016/01/A331S33-174r6-Signaling-Delivery-Sync-FEC.pdf}{Next Gen TV} standard.", "Raptor codes are useful in scenarios where erasure (i.e. weak signal or noisy channel) is common, such as in military or disaster scenarios."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Raptor codes can be decoded using inactivation decoding \\cite{arXiv:1706.05814}, a combination of belief-propogation and Gaussian elimination decoding."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "As a type of fountain code, a Raptor code is designed to correct erasures. The error probability of Raptor codes is measured in terms of its overhead, which is how many additional symbols are received above the dimension of the input \\(k\\). This relationship can vary widely depending on the input pre-code and degree distribution. For a well-designed degree distribution, the error probability of a Raptor code is directly related to the error probability of the pre-code's decoder. In other words, if there is a linear time decoder for the pre-code that has subexponentially small error probability, then the Raptor code's error probability will decrease exponentially with increasing overhead (past the \\(n-k\\) overhead symbols necessary for the pre-code).", "code_id": "raptor"}, "reed_muller": {"name": "Reed-Muller (RM) code", "description": "Member of the RM\\((r,m)\\) family of linear binary codes derived from multivariate polynomials. The code parameters are \\([2^m,\\sum_{j=0}^{r} {m \\choose j},2^{m-r}]\\), where \\(r\\) is the \\textit{order} of the code satisfying \\(0\\leq r\\leq m\\).\nFirst-order RM codes are also called \\textit{biorthogonal} codes, while \\(m\\)th order RM codes are also called \\textit{universe} codes.\n\\textit{Punctured RM codes} RM\\(^*(r,m)\\) are obtained from RM codes by deleting one or more coordinates from each codeword.\n\nGenerator matrices of RM codes are constructed using the \\((u|u+v)\\) construction by starting from the \\(2^m\\)-dimensional matrix \\(F^{(m)}=\\left(\\begin{smallmatrix}1 & 0\\\\\n1 & 1\n\\end{smallmatrix}\\right)^{\\otimes m}\\), labeling its rows top-to-bottom from \\(0\\) to \\(2^m-1\\), converting the labels to binary strings of length \\(m\\), and deleting all rows whose labels have a Hamming weight less than \\(m-r\\). The recursive nature of the tensor product in the matrix \\(F^{(m)}\\) implies that RM\\((r,m)\\) is a subcode of RM\\((r+1,m)\\).\n\nAnother way to generate RM codewords is to list all outcomes of all polynomials of \\(m\\) binary variables of degree at most \\(r\\) \\cite{arXiv:2002.03317} (see also Ch. 13 of Ref. \\cite{preset:MacSlo}).\n", "notes": ["See Chs. 13-15 of Ref. \\cite{preset:MacSlo} for details of RM codes and their variants.", "See Ref. \\cite{doi:10.1109/TIT.1972.1054732} for the weight distribution of the \\(2^{26}\\) cosets of the \\((32,6)\\) first-order RM code, obtained in part by hand computation."], "introduced": "\\cite{doi:10.1109/irepgelc.1954.6499441,doi:10.1109/tit.1954.1057465,manual:{N. Mitani, \\emph{On the transmission of numbers in a sequential computer}, delivered at the National Convention of the Inst. of Elect. Engineers of Japan, November 1951.}}", "short_name": "RM", "logical": "bits", "realizations": ["Deep-space communication \\cite{doi:10.1007/bfb0036046,manual:{E.C. Posner, \\emph{Combinatorial Structures in Planetary Reconnaissance} in Error Correcting Codes, ed. H.B. Mann, Wiley, NY 1968.}}. For example, the \\((32, 6, 16)\\) RM code was used for the Mariner 9 spacecraft."], "features": {"general_gates": [], "encoders": [], "rate": "Achieves capacity of the binary erasure channel \\cite{doi:10.1109/TIT.2017.2673829} and of the binary memoryless symmetric (BMS) channel under bitwise maximum-a-posteriori decoding \\cite{arxiv:2110.14631}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Reed decoder with \\(r+1\\)-step majority decoding corrects \\(\\frac{1}{2}(2^{m-r}-1)\\) errors \\cite{doi:10.1109/irepgelc.1954.6499441} (see also Ch. 13 of Ref. \\cite{preset:MacSlo}).", "Sequential code-reduction decoding \\cite{doi:10.1109/TIT.1973.1055023}.", "First-order (\\(r=1\\)) RM codes admit specialized decoders \\cite{manual:{E.C. Posner, \\emph{Combinatorial Structures in Planetary Reconnaissance} in Error Correcting Codes, ed. H.B. Mann, Wiley, NY 1968.}}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "reed_muller"}, "expander": {"name": "Expander code", "description": "Expander codes are binary linear codes whose parity check matrices are derived from the adjacency matrix of bipartite expander graphs. In particular, the rows of the parity check matrix correspond to the right nodes of the bipartite graph and the columns correspond to the left nodes. The codespace is equivalent to all subsets of the left nodes in the graph that have an even number of edges going into every right node of the graph. Since the expander graph is only left regular, these codes do not qualify as LDPC codes.\n\nExpander codes are important because they admit efficient encoding and decoding algorithms and are asymptotically good (i.e., their rate and normalized distance are constant). The rate and distance of the expander code depend on specific parameters of the corresponding graph. A (\\(n, m, D, \\gamma, \\alpha\\)) bipartite expander graph is defined as a \\(D\\)-left-regular graph with \\(n\\) left nodes, and \\(m\\) right nodes such that for any subset of left nodes \\(S\\) of size at most \\(\\gamma n\\) the neighborhood \\(N(S)\\) is at least of size \\(\\alpha|S|\\). Given a (\\(n, m, D, \\gamma, (1-\\epsilon)D\\)) expander graph, the corresponding expander code has rate of \\(1 - m/n\\) and a distance of at least \\(2(1-\\epsilon)\\gamma n\\) for any \\(\\epsilon < 1/2\\). Explicit constructions for expander graphs with any ratio \\(n/m\\) are known where \\(D = \\text{polylog}(n/m)\\), \\(\\gamma = \\Omega(1/D)\\) and arbitrary \\(\\epsilon\\) \\cite{doi:10.1145/509907.510003}.\n", "notes": [], "introduced": "\\cite{doi:10.1109/18.556667}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": ["Multiplication by generator matrix with runtime \\(O(n^2)\\)"], "rate": "The rate is \\(1 - m/n\\) where \\(n\\) is the number of left nodes and \\(m\\) is the number of right nodes in the bipartite expander graph.", "magic_scaling_exponent": "", "fault_tolerance": ["The flip decoding algorithm is fault tolerant against parity check errors \\cite{doi:10.1109/18.556668}; see also \\href{http://courses.csail.mit.edu/6.440/spring08/index.html}{course notes} by M. Sudan."], "threshold": [], "decoders": ["Decoding can be done in \\(O(n)\\) runtime using a greedy \\textit{flip} algorithm. The algorithm consists of flipping a bit of the received word if it will result in a greater number of satisfied parity checks. This is repeated until a codeword is reached."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Bit flip errors of weight at most \\((d-1)/2\\) where \\(d\\) is the distance of the code and is linear in \\(n\\), the number of physical bits.", "code_id": "expander"}, "fibonacci_model": {"name": "Fibonacci code", "description": "The code is defined on an \\(L\\times L/2\\) lattice with one bit on each site, where \\(L=2^N\\) for an integer \\(N\\geq 2\\). The codewords are defined to satisfy the condition that, for each lattice site \\((x,y)\\), the bits on \\((x,y)\\), \\((x+1,y)\\), \\((x-1,y)\\) and \\((x,y+1)\\) (where the lattice is taken to be periodic in both directions) contain an even numbers of \\(1\\)'s.\nThe codewords can be generated using a one-dimensional cellular automaton of length \\(L\\) (periodic). The \\(2^L\\) possible initial states correspond to the \\(2^L\\) codewords. For each generation, the state of each cell is the xor sum of that cell and its two neighbors in the previous generation. After \\(L/2-1\\) generations, the entire history generated by the automaton corresponds to a codeword, where the initial state is the first row of the lattice, the first generation is the second row, etc.\n", "notes": [], "introduced": "\\cite{arXiv:2002.11738}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["An efficient algorithm base on minimum-weight perfect matching \\cite{arXiv:2002.11738}, which can correct high-weight errors that span the lattice, with failure rate decaying super-exponentially with \\(L\\)."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Protects against small weight errors and string-like errors. The code distance is more than \\(L\\), but the exact value is unknown.\n", "code_id": "fibonacci_model"}, "bits_into_bits": {"name": "Binary code", "description": "Encodes \\(K\\) states (codewords) in \\(n\\) binary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)\\). The distance is the minimum Hamming distance between a pair of distinct codewords.", "notes": [], "introduced": "", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["For few-bit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}.", "Given a received string \\(x\\) and an error bound \\(e\\), a \\textit{list decoder} returns a list of all codewords that are at most \\(e\\) from \\(x\\) in Hamming distance. The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\)."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "A binary code \\(C\\) \\textit{corrects} \\(t\\) errors in the Hamming distance if\n\\begin{align}\n  \\forall x \\in C~,~D(x,x+y) < D(x' , x+y)\n\\end{align}\nfor all codewords \\(x' \\neq x\\) and all \\(y\\) such that \\(|y|=t\\), where \\(D\\) is the \\textit{Hamming distance} and \\(|y| = D(y,0) \\). A code corrects \\(t\\) errors if and only if \\(d \\geq 2t+1\\), i.e., a code corrects errors on \\(t \\leq \\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates. In addition, a code detects errors on up to \\(d-1\\) coordinates, and corrects erasure errors on up to \\(d-1\\) coordinates.\n\nPerformance of binary codes can also be measured with respect to deletions and insertions of bits into the codewords. In this case, the metric measuring distance of an error word to the nearest codeword is the \\textit{deletion distance}: given vectors \\(u,v\\), this distance is one-half the smallest number of deletions and insertions needed to change \\(u\\) to \\(v\\). A code \\(C\\) corrects \\(e\\) delections if all codewords are separated by at least \\(e+1\\) in the deletion distance \\cite{arxiv:math/0207197}.\n", "code_id": "bits_into_bits"}, "binary_duadic": {"name": "Binary duadic code", "description": "Member of a pair of cyclic linear binary codes that satisfy certain relations, depending on whether the pair is \\textit{even-like} or \\textit{odd-like} duadic. Duadic codes exist for lengths \\(n\\) that are products of powers of primes, with each prime being \\(\\pm 1\\) modulo \\(8\\) \\cite{doi:10.1007/978-3-7091-2786-5_1}.\n\nDuadic codes come in two pairs, an even-like duadic pair and an odd-like duadic pair. All codewords in the respective pairs are \\textit{even-like}, i.e., \\(\\sum_i c_i = 0\\), or \\textit{odd-like}, i.e., \\(\\sum_i c_i = 1\\). A code with all even-like (odd-like) codewords is called even-like (odd-like).\n\nDuadic code pairs can be defined in terms of their idempotent generators (see \\ref{topic:Cyclic-to-polynomial-correspondence}).\nA pair of even-like codes \\(C_1\\) and \\(C_2\\) with respective idempotents \\(e_1\\) and \\(e_2\\) is an \\textit{even-like duadic pair} if (1) \\(e_1(x)+e_2(x)=1-\\frac{1}{n}(1+x+x^2+\\cdots+x^{n-1})\\) and (2) there exists a multiplier \\(\\mu\\) such that \\(C_1 \\mu=C_2\\) and \\(C_2 \\mu=C_1\\).\n\nThere is an odd-like duadic pair \\(\\{D_1,D_2\\}\\) associated with the even-like pair \\(\\{C_1, C_2\\}\\), where \\(1-e_2(x)\\) generates \\(D_1\\) and \\(1-e_1(x)\\) generates \\(D_2\\). The even-pair codes are \\([n,\\frac{n-1}{2}]\\) codes while the odd-pair codes are \\([n,\\frac{n+1}{2}]\\) codes.\n", "notes": ["Reviews of duadic codes \\cite{doi:10.1007/978-3-7091-2786-5_1,doi:10.1017/CBO9780511807077}."], "introduced": "\\cite{doi:10.1109/TIT.1984.1056944}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Since duadic codes are cyclic, the BCH bound can be used to determine their minimum distance.", "code_id": "binary_duadic"}, "binary_quad_residue": {"name": "Binary quadratic-residue (QR) code", "description": "Member of a quadruple of cyclic binary codes of prime length \\(n=8m\\pm 1\\) for \\(m\\geq 1\\) constructed using quadratic residues and nonresidues of \\(n\\).\n\nThe roots of the generator polynomial \\(r(x)\\) of the first code (see \\ref{topic:Cyclic-to-polynomial-correspondence}) are all of the inequivalent quadratic residues of \\(n\\), and the second code's generator polynomial is \\((x-1)r(x)\\). The roots of the generator polynomial \\(a(x)\\) of the third code are all inequivalent nonresidues of \\(n\\), and the fourth code's generator polynomial is \\((x-1)a(x)\\). The codes corresponding to polynomials \\(r,a\\) are often called \\textit{augmented} quadratic-residue codes, while the remaining codes are called \\textit{expurgated}.\n", "notes": ["Introduction of quadratic-residue codes in Refs. \\cite{preset:MacSlo,doi:10.1017/CBO9780511807077}."], "introduced": "", "short_name": "Binary QR", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "binary_quad_residue"}, "bch": {"name": "Binary BCH code", "description": "Cyclic binary code of odd length \\(n\\) whose zeroes are consecutive powers of a primitive \\(n\\)th root of unity \\(\\alpha\\) (see \\ref{topic:Cyclic-to-polynomial-correspondence}). More precisely, the generator polynomial of a BCH code of \\textit{designed distance} \\(\\delta\\geq 1\\) is the lowest-degree monic polynomial with zeroes \\(\\{\\alpha^b,\\alpha^{b+1},\\cdots,\\alpha^{b+\\delta-2}\\}\\) for some \\(b\\geq 0\\). BCH codes are called \\textit{narrow-sense} when \\(b=1\\), and are called \\textit{primitive} when \\(n=2^r-1\\) for some \\(r\\geq 2\\).\n\nThe code dimension is related to the \\textit{multiplicative order} of \\(2\\) modulo \\(n\\), i.e., the smallest integer \\(m\\) such that \\(n\\) divides \\(2^m-1\\). The dimension of a BCH code with \\(\\delta=2t+1\\) is at least \\(n-mt\\). The field \\(GF(2^m)\\) is the smallest field containing the above root of unity \\(\\alpha\\), and is the splitting field of the polynomial \\(x^n-1\\) (see \\ref{topic:Cyclic-to-polynomial-correspondence}).\n", "notes": ["See books \\cite{preset:MacSlo,preset:LinCostello,doi:10.1017/CBO9780511807077} for expositions on BCH codes and code tables.", "See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes.", "See corresponding MinT database entry \\cite{manual:{Rudolf Sch\u00fcrer and Wolfgang Ch. Schmid. \u201cCyclic Codes (BCH-Bound).\u201d From MinT\u2014the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CCyclic-BCHBound.html}}."], "introduced": "\\cite{doi:10.1016/s0019-9958(60)90287-4,doi:10.1016/S0019-9958(60)90870-6,manual:{A. Hocquenghem, Codes correcteurs d'Erreurs, Chiffres (Paris), vol.2, pp.147-156, 1959.}}", "short_name": "", "logical": "bits", "realizations": ["Satellite communication \\cite{manual:{Cheung, K-M., and F. Pollara. \"Phobos lander coding system: Software and analysis.\" The Telecommunications and Data Acquisition Report (1988).}}"], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Peterson decoder with runtime of order \\(O(n^3)\\) \\cite{doi:10.1109/TIT.1960.1057586,manual:{S. Arimoto, \"Encoding and decoding of p-ary group codes and the correction system,\" Information Processing in Japan (in Japanese), vol. 2, pp. 320-325, Nov. 1961.}} (see exposition in Ref. \\cite{preset:Blahut}).", "Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) \\cite{doi:10.1109/TIT.1969.1054260,preset:Berlekamp} and modification by Burton \\cite{doi:10.1109/TIT.1971.1054655}; see also \\cite{preset:PetersonWeldon,doi:10.1007/978-3-7091-2945-6}.", "Sugiyama et al. modification of the extended Euclidean algorithm \\cite{doi:10.1016/S0019-9958(75)90090-X,doi:10.1017/CBO9780511606267}.", "Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "By the BCH bound, BCH code with designed distance \\(\\delta\\) has true distance \\(d\\geq\\delta\\). BCH codes with different designed distances may coincide, and the largest possible designed distance for a given code is the \\textit{Bose distance}; the true distance may still be larger than that.\n", "code_id": "bch"}, "zetterberg": {"name": "Zetterberg code", "description": "Family of binary cyclic \\([2^{2s}+1,2^{2s}-4s+1]\\) codes with distance \\(d>5\\) generated by the minimal polynomial \\(g_s(x)\\) of \\(\\alpha\\) over \\(GF(2)\\), where \\(\\alpha\\) is a primitive \\(n\\)th root of unity in the field \\(GF(2^{4s})\\). They are quasi-perfect codes and are one of the best known families of double-error correcting binary linear codes", "notes": [], "introduced": "\\cite{doi:10.1109/TIT.1962.1057682}", "short_name": "", "logical": "bits", "realizations": ["Code used to provide better protection of data transmission with its double error correcting capacity \\cite{doi:10.1109/TIT.1961.1057659}."], "features": {"general_gates": [], "encoders": [], "rate": "The rate is given by \\(1-\\frac{4s}{n}\\), which is asymptotically good, with a minimum distance of 5.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Kallquist first described an algebraic decoding theorem \\cite{manual:{P. Kallquist, \"Decoding of Zetterberg codes,\" in Proc. Fourth Joint Swedish-Soviet Workshop on Inform. Theory, Gotland, Sweden, Aug. 27-Sept. 1, 1989, p. 305-300}}. A faster version was later provided in Ref. \\cite{doi:10.1109/18.149509} and further modified in Ref. \\cite{doi:10.1109/LCOMM.2010.07.100784}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Correct at least all weight-2 errors.", "code_id": "zetterberg"}, "binary_cyclic": {"name": "Cyclic linear binary code", "description": "A binary code of length \\(n\\) is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword. A cyclic code is called \\textit{primitive} when \\(n=2^r-1\\) for some \\(r\\geq 2\\). A \\textit{shortened cyclic code} is obtained from a cyclic code by taking only codewords with the first \\(j\\) zero entries, and deleting those zeroes.\n", "notes": ["See Ch. 7 of Ref. \\cite{preset:MacSlo} for an exposition on cyclic codes."], "introduced": "", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Meggitt decoder \\cite{doi:10.1109/TIT.1961.1057659}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Shift bound \\cite{doi:10.1109/TIT.1986.1057134} gives a lower bound on the distance of cyclic binary codes.", "code_id": "binary_cyclic"}, "golay": {"name": "Golay code", "description": "A \\([23, 12, 7]\\) perfect binary linear code with connections to various areas of mathematics, e.g., lattices \\cite{doi:10.1007/978-1-4757-6568-7} and sporadic simple groups \\cite{preset:MacSlo}. Adding a parity bit to the code results in the \\([24, 12, 8]\\) \\textit{extended Golay code}. Up to equivalence, both codes are unique for their respective parameters.\n\nTo construct the Golay code, one can use the great dodecahedron to generate codewords by placing message bits on the faces and calculating the parity bits that live on the 12 vertices of the inner icosahedron.\n", "notes": ["The automorphism group of the Golay code is the Mathieu group \\(\\mathcal{M}_{23}\\), and the automorphism group of the extended Golay code is the Mathieu group \\(\\mathcal{M}_{24}\\), two of the sporadic simple groups."], "introduced": "\\cite{manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}", "short_name": "", "logical": "bits", "realizations": ["Used in the Voyager 1 and 2 spacecraft \\cite{doi:10.1029/JA092iA13p14873}.", "Radio communications \\cite{manual:{E. E. Johnson. An Efficient Golay Codec For MIL-STD-188-141A and FED-STD-1045. Department of Electrical and Computer Engineering, New Mexico State University, 1991.}}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Majority decoding for the extended Golay code \\cite{doi:10.1016/0097-3165(71)90043-4}.", "Decoder for the extended Golay code using the hexacode \\cite{doi:10.1109/TIT.1986.1057197}.", "Both Golay codes have a trellis representation and can thus be decoded using trellis decoding \\cite{doi:10.1142/9789814287517_0004,doi:10.1049/el:19931456}.", "Bounded-distance decoder requiring at most 121 real operations \\cite{doi:10.1109/18.412695}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "golay"}, "bsghsv-ltc": {"name": "Ben-Sasson-Goldreich-Harsha-Sudan-Vadhan (BGHSV) code", "description": "Locally testable \\([[n,k,d]]\\) code with \\(n = k^{1+\\epsilon}\\) and query complexity of order \\(O(1/\\epsilon)\\) for any \\(\\epsilon > 0\\).\n", "notes": [], "introduced": "\\cite{doi:10.1145/1007352.1007361}", "short_name": "BGHSV", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "bsghsv-ltc"}, "gs-ltc": {"name": "Goldreich-Sudan code", "description": "Locally testable \\([[n,k,d]]\\) code with \\(n = k^{1+O(1/u)}\\) and distance \\(\\Omega(n)\\) for query complexity \\(u\\). The same work also presented a probabilistic construction of codes of size \\(k^{1+o(1)}\\).\n", "notes": [], "introduced": "\\cite{doi:10.1145/1162349.1162351}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "gs-ltc"}, "bssvw-ltc": {"name": "Ben-Sasson-Sudan-Vadhan-Wigderson (BSVW) code", "description": "Locally testable \\([[n,k,d]]\\) code with \\(n = k \\cdot 2^{\\tilde{O}(\\sqrt{\\log k})}\\) and asymptotically constant query complexity.\n", "notes": [], "introduced": "\\cite{doi:10.1145/780542.780631}", "short_name": "BSVW", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "bssvw-ltc"}, "kmrs-ltc": {"name": "Kopparty-Meir-Ron-Zewi-Saraf (KMRS) code", "description": "Member of a family of locally testable binary linear codes with constant rate, constant relative distance, and subpolynomial query complexity \\(u = (\\log n)^{O(\\log \\log n)}\\)). Later work by Gopi, Kopparty, Oliveira, Ron-Zewi, and Saraf \\cite{doi:10.1109/TIT.2018.2809788} showed that related concatenated codes achieve the Gilbert-Varshamov bound.\n", "notes": [], "introduced": "\\cite{doi:10.1145/3051093,doi:10.1109/TIT.2018.2809788}", "short_name": "KMRS", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "kmrs-ltc"}, "long": {"name": "Long code", "description": "Locally testable \\([[2^{2^k},k,d]]\\) code. The encoder maps a \\(k\\)-bit string into a codeword that consists of the values of all Boolean functions on the \\(k\\)-bit string. The code is not practical, but is useful for certain probabilistically checkable proof (PCP) constructions \\cite{arxiv:1002.3864}.\n", "notes": [], "introduced": "\\cite{doi:10.1145/502090.502098,doi:10.1137/S0097539796302531}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "long"}, "binary_ltc": {"name": "Binary linear LTC", "description": "A binary linear code \\(C\\) of length \\(n\\) that is a \\((u,R)\\)-LTC with query complexity \\(u\\) and soundness \\(R>0\\).\nMore technically, the code is a \\((u,R)\\)-LTC if the rows of its parity-check matrix \\(H\\in GF(2)^{r\\times n}\\) have weight at most \\(u\\) and if\n\\begin{align}\n  \\frac{1}{r}|H x| \\geq \\frac{R}{n} D(x,C)\n\\end{align}\nholds for any bitstring \\(x\\), where \\(D(x,C)\\) is the Hamming distance between \\(x\\) and the closest codeword to \\(x\\) \\cite[Def. 11]{arxiv:1911.03069}.\n", "notes": [], "introduced": "", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "binary_ltc"}, "dinur": {"name": "Dinur code", "description": "Member of infinite family of locally testable \\([[n,n/\\text{polylog}(n),d]]\\) codes with vanishing rate. Code construction relies on a construction utilizing tensor-product codes \\cite{arXiv:cs/0408066}.\n", "notes": [], "introduced": "\\cite{doi:10.1145/1236457.1236459}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "dinur"}, "lr-cayley-complex": {"name": "Left-right Cayley complex code", "description": "Binary code constructed on a left-right Cayley complex using a pair of base codes \\(C_A,C_B\\) and an expander graph such that codewords for a fixed graph vertex are codewords of the tensor code \\(C_A \\otimes C_B\\). A family of such codes is one of the first \\(c^3\\)-LTCs.\n", "notes": [], "introduced": "\\cite{arxiv:2111.04808}", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "lr-cayley-complex"}, "hadamard": {"name": "Hadamard code", "description": "Also known as a \\textit{Walsh code} or \\textit{Walsh-Hadamard code}. An \\([2^k,k,2^{k-1}]\\) balanced binary code dual to an extended Hamming Code.", "notes": [], "introduced": "", "short_name": "", "logical": "bits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "hadamard"}, "repetition": {"name": "Repetition code", "description": "\\([n,1,n]\\) binary linear code encoding one bit of information into an \\(n\\)-bit string. The length \\(n\\) needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a \\((n,1)\\)-Hamming code.", "notes": [], "introduced": "", "short_name": "", "logical": "bits", "realizations": ["Repetition codes, in conjunction with other codes, were used in magnetic disks \\cite{doi:10.1109/TCOM.1984.1096094}."], "features": {"general_gates": [], "encoders": [], "rate": "Code rate is \\(\\frac{1}{n}\\), code distance is \\(n\\).", "magic_scaling_exponent": "", "fault_tolerance": ["Triple modular redundancy (TMR) error-correction protocol \\cite{doi:10.1147/rd.62.0200}; see Ref. \\cite{arXiv:2111.08894} for a pedagogical explanation."], "threshold": ["Suppose each bit has probability \\(p\\) of being received correctly, independent for each bit. The probability that a repetition code is received correctly is \\(\\sum_{k=0}^{(n-1)/2}\\frac{n!}{k!(n-k)!}p^{n-k}(1-p)^{k}\\). If \\(\\frac{1}{2}\\leq p\\), then people can always increase the probability of success by increasing the number of physical bit \\(n\\)."], "decoders": ["Calculate the Hamming weight \\(d_H\\) of the code. If \\(d_H\\leq \\frac{n-1}{2}\\), decode the code as 0. If \\(d_H\\geq \\frac{n+1}{2}\\), decode the code as 1.", "Automaton-like decoders for the repetition code on a 2D lattice, otherwise known as the classical 2D Ising model, were developed by Toom \\cite{manual:{A. L. Toom, \u201cNonergodic Multidimensional System of Automata\u201d, Probl. Peredachi Inf., 10:3 (1974), 70\u201379; Problems Inform. Transmission, 10:3 (1974), 239\u2013246},doi:10.1007/978-1-4612-2168-5_18}. An automaton by Gacs yields a decoder for a 1D lattice \\cite{doi:10.1023/A:1004823720305}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Detects errors on up to \\(\\frac{n-1}{2}\\) coordinates, corrects erasure errors on up to \\(\\frac{n-1}{2}\\) coordinates. The generator matrix is \\(G=\\left[\\begin{smallmatrix}1 & 1&\\cdots& 1 & 1 \\end{smallmatrix}\\right]\\).", "code_id": "repetition"}, "gray": {"name": "Gray code", "description": "The first Gray code \\cite{manual:{Gray, Frank. \"Pulse code communication.\" United States Patent Number 2632058 (1953).}}, now called the \\textit{binary reflected Gray code}, is a trivial code that orders length-\\(n\\) binary strings such that nearest-neighbor strings differ by only one digit.\n\nA simple example is the case \\(n=2\\), also known as the \\textit{Gray map}, which produces the ordering \\(0\\to 00\\), \\(1\\to 01\\), \\(2\\to 11\\), and \\(3\\to 10\\).\nThe Gray map differs in the last two numbers from the usual binary expansion of the natural numbers, which maps \\(0\\to 00\\), \\(1\\to 01\\), \\(2\\to 10\\), and \\(3\\to 11\\).\n\nLayout out the Gray-map output strings counterclockwise on the corners of a 1D square, gray codes have been generalized such that nearest-neighbor strings differ by only one digit when the strings are arranged in higher-dimensional hypercubes \\cite{doi:10.1002/j.1538-7305.1958.tb03887.x}.\nFurther generalizations called \\textit{combinatorial Gray codes} \\cite{doi:10.1137/0209013} refer to methods to generate organize combinatorial objects such that successive objects differ in some particular way. Particular \\(q\\)-ary extensions \\cite{doi:10.1109/TSMCB.2012.2210706} of Gray codes may be useful in digital imaging and signal processing.\n", "notes": ["See Refs. \\cite{doi:10.1137/S0036144595295272,doi:10.1201/9780429332760-9,arxiv:2202.01280} reviews of various Gray codes."], "introduced": "\\cite{manual:{Gray, Frank. \"Pulse code communication.\" United States Patent Number 2632058 (1953).},doi:10.1002/j.1538-7305.1958.tb03887.x,doi:10.1137/0209013}", "short_name": "", "logical": "bits", "realizations": ["Three-dimensional imaging \\cite{doi:10.1364/AO.36.004463}.", "Broadcasting and communication \\cite{doi:10.1109/12.29465}."], "features": {"general_gates": [], "encoders": ["Efficient encoder for binary reflected Gray code \\cite{doi:10.1145/360336.360343}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "gray"}, "parity_check": {"name": "Single parity-check (SPC) code", "description": "Also known as a \\textit{sum-zero} or \\textit{even-weight} code. An \\([n,n-1,2]\\) linear binary code whose codewords consist of the message string appended with a parity-check bit such that the parity (i.e., sum over all coordinates of each codeword) is zero. If the Hamming weight of a message is odd (even), then the parity bit is one (zero). This code requires only one extra bit of overhead and is therefore inexpensive.", "notes": [], "introduced": "", "short_name": "", "logical": "bits", "realizations": ["Can be realized on almost every communication device. SPCs are some of the earliest error-correcting codes (\\cite{doi:10.1201/9781315115870}, Ch. 27)."], "features": {"general_gates": [], "encoders": [], "rate": "The code rate is \\(\\frac{n}{n+1}\\to 1\\) as \\(n\\to\\infty\\).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["If the receiver finds that the parity information of a codeword disagrees with the parity bit, then the receiver will discard the information and request a resend.", "Wagner's rule yields a procedure that is linear in \\(n\\) \\cite{doi:10.1109/TIT.1954.1057466} (see \\cite[Sec. 29.7.2]{doi:10.1017/9781316822708} for a description)."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "This code cannot protect information, it can only detect 1-bit error.", "code_id": "parity_check"}, "hamming": {"name": "Hamming code", "description": "An infinite family of perfect linear codes with parameters \\((2^r-1,2^r-r-1, 3)\\) for \\(r \\geq 2\\). Their \\(r \\times (2^r-1) \\) parity check matrix \\(H\\) has all possible non-zero \\(r\\)-bit strings as its columns.\n\nA generator matrix for the \\([7,4,3]\\) Hamming code is\n\\begin{align}\n\\left(\\begin{array}{ccccccccccc}\n  1 & 0 & 0 & 0 & 1 & 1 & 0\\\\\n  0 & 1 & 0 & 0 & 1 & 0 & 1\\\\\n  0 & 0 & 1 & 0 & 0 & 1 & 1\\\\\n  0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\\right)~.\n\\end{align}\n", "notes": ["See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes."], "introduced": "\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x,doi:10.1002/j.1538-7305.1950.tb00463.x,manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}", "short_name": "", "logical": "bits", "realizations": ["Commonly used when error rates are very low, for example, computer RAM or integrated circuits \\cite{doi:10.1109/SBCCI.2002.1137643}.", "Hamming-code based matrix embedding used in steganography \\cite{manual:{Crandall, Ron. \"Some notes on steganography.\" Posted on steganography mailing list 1998 (1998): 1-6.},doi:10.1007/3-540-45496-9_21}."], "features": {"general_gates": [], "encoders": [], "rate": "Asymptotic rate \\(k/n = 1-\\frac{\\log n}{n} \\to 1\\) and normalized distance \\(d/n \\to 0\\).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "Can detect 1-bit and 2-bit errors, and can correct 1-bit errors.", "code_id": "hamming"}, "weight_two": {"name": "Weight-two code", "description": "A length-\\(n\\) binary code whose codewords all have Hamming weight two. Such codes provide slightly extra redundancy for storage of small-scale information such as ZIP codes or decimal digits.\n\nFor example, the two-in-five code has a size 10, thereby providing an encoding for the decimal digits 0 through 9. Such a code detects some single bit-flips as well as unidirectional errors using the fact that each codeword is weight-two. The code fails for any sequence of flips that maintains the constant weight.\n", "notes": ["See Ch. 19 of book \\cite{doi:10.1201/9781315147901} on weight-two codes."], "introduced": "\\cite{manual:{R. W. Hamming, Letter, April 5, 1978.}}", "short_name": "", "logical": "bits", "realizations": ["Two-in-five, also known as the two-out-of-five code, was used in the United States Postal Service's POSTNET barcode system as well as the Postal Alpha-numeric Encoding Technique (PLANET).", "Two-in-five code forms the numerical part of the \\textit{Code 39} barcode encoding.", "Two-in-five code was used on early IBM computers \\cite{doi:10.1145/1457838.1457879,manual:{T. M. Thompson, \\emph{From Error-Correcting Codes Through Sphere Packings To Simple Groups}, Mathematical Association of America, 1983.}}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "weight_two"}, "one_hot": {"name": "One-hot code", "description": "Also known as an \\textit{\\(1\\)-in-\\(n\\)} code. A length-\\(n\\) binary code whose codewords are those with Hamming weight one. The reverse of this code, where all codewords have Hamming weight \\(n-1\\) is called a \\textit{one-cold} code.\n", "notes": [], "introduced": "", "short_name": "", "logical": "bits", "realizations": ["The bi-quinary code, a combination of one-hot 1-in-2 and 1-in-5 one-hot codes to encode decimal digits, was used in several early computers (\\cite{doi:10.1201/9781315115870}, Ch. 27).", "Marking the state of a finite automaton \\cite{doi:10.1109/43.41505}.", "Used in machine-learning based classification tasks because one-hot encodings, as opposed to integer encodings, do not presume an order \\cite{doi:10.5120/ijca2017915495}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "bits", "protection": "", "code_id": "one_hot"}, "metrological": {"name": "Metrological code", "description": "Linear subspace of a Hilbert space whose basis states satisfy only a part of the \\term{Knill-Laflamme conditions}. The satisfied part of the conditions ensures that the code can be used for local parameter estimation.\n\nLetting \\(\\Pi = U U^\\dagger\\) be the codespace projector for encoding isometry \\(U\\) and projecting a pair of errors \\(E_i,E_j\\) from an error set \\(\\cal E\\) into the two-dimensional codespace yields\n\\begin{align}\n  \\Pi E_{i}^{^{\\dagger}}E_{j}\\Pi=c_{ij}\\,\\Pi+x_{ij}\\overline{X}+y_{ij}\\overline{Y}+z_{ij}\\overline{Z}\n\\end{align}\nwith error-matrix element \\(c_{ij}\\) and logical-error coefficients\n\\begin{align}\n  \\left\\{ x,y,z\\right\\} _{ij}={\\textstyle \\frac{1}{2}}\\text{Tr}\\left(\\left\\{ \\overline{X},\\overline{Y},\\overline{Z}\\right\\} E_{i}^{^{\\dagger}}E_{j}\\right)~.\n\\end{align}\nIf all three logical-error coefficients are zero, then the \\term{Knill-Laflamme conditions} are satisfied, and the code is a \\hyperref[code:qecc]{QECC}. If only one of the three coefficients is zero, then the code is the more general metrological code.\n", "notes": [], "introduced": "\\cite{arxiv:2207.13707}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Physical noise can cause logical errors along one of the three axes, i.e., either logical-\\(X\\), \\(Y\\), or \\(Z\\), depending on what basis is used. Codes protect against logical errors along the remaining two axes.\n\nA metrological code defined in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits) has distance \\(d\\) if the above conditions are satisfied for an error set \\(\\cal E\\) consisting of errors supported on \\(d-1\\) subsystems of less.\n", "code_id": "metrological"}, "oecc": {"name": "Subsystem quantum error-correcting code", "description": "A subsystem code, also known as an \\textit{operator QECC} or \\textit{gauge QECC}, encodes information in a subsystem \\(\\mathsf{A}\\) of the code space \\(\\mathsf{C}\\), which is part of the system Hilbert space \\(\\mathsf{H}\\), as\n\\begin{align}\n\\mathsf{H}=\\mathsf{C} \\oplus \\mathsf{C}^{\\perp} = \\mathsf{A} \\otimes \\mathsf{B} \\oplus \\mathsf{C}^{\\perp}~.\n\\end{align}\nFollowing an error, it is sufficient to revert back to the original state modulo a transformation on the auxiliary or \\textit{gauge} subsystem \\(\\mathsf{B}\\). The subsystem \\(\\mathsf{B}\\) therefore gives additional freedom to the error correction process, and is said to encode \\textit{gauge qubits} when its dimension is a power of two. While strictly speaking all operator QECCs are also ordinary QECCs, the attachment of a subsystem to a code allows for a wider variety of encoding procedures, fault-tolerant logical operations, and efficient error-correction protocols.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/0412076,arXiv:quant-ph/0504189}", "short_name": "Subsystem QECC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Necessary and sufficient \\cite{arxiv:quant-ph/0506069} error-correction conditions are, for all errors \\(E_a,E_b\\) in an error set \\(\\cal{E}\\),\n\\begin{align}\nP E^{\\dagger}_a E_b P = I_{\\mathsf{A}} \\otimes g_{ab}^{\\mathsf{B}}\n\\end{align}\nwhere \\(P\\) is a projector onto the codespace \\(\\mathsf{C}\\), and \\(g_{ab}^{\\mathsf{B}}\\) is an arbitrary operator on the gauge subsystem.\n", "code_id": "oecc"}, "quantum_into_quantum": {"protection": "", "name": "Quantum code", "description": "Code designed for transmission of quantum information through a quantum channel for the purposes of robust storage, communication, or sensing. Transmission can be performed with side information or entanglement.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "quantum_into_quantum", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "eaqecc": {"name": "Entanglement-assisted (EA) QECC", "description": "QECC whose encoding and decoding utilizes pre-shared entanglement between sender and receiver.", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0608027,arxiv:quant-ph/0610092}", "short_name": "EAQECC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "eaqecc"}, "eaoecc": {"name": "Entanglement-assisted (EA) operator QECC", "description": "Subsystem QECC whose encoding and decoding utilizes pre-shared entanglement between sender and receiver.", "notes": [], "introduced": "\\cite{arxiv:0708.2142,doi:10.1109/ISIT.2007.4557160}", "short_name": "EAOQECC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "eaoecc"}, "quantum_convolutional": {"name": "Quantum convolutional code", "description": "Stub.", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0511016}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "quantum_convolutional"}, "eastab": {"name": "Entanglement-assisted (EA) stabilizer code", "description": "Constructed using a variation of the stabilizer formalism designed to utilize pre-shared entanglement between sender and receiver. An EA stabilizer code is denoted as \\([[n,k;c]]\\) or \\([[n,k,d;c]]\\), where \\(d\\) is the code's distance, and \\(c\\) is the number of required pre-shared maximally entangled Bell states.'\n", "notes": ["See Ref. \\cite{arxiv:2207.05647} for code tables and bounds on performance."], "introduced": "\\cite{arxiv:quant-ph/0608027,arxiv:quant-ph/0610092}", "short_name": "EA stabilizer", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "eastab"}, "xs_stabilizer": {"name": "XS stabilizer code", "description": "A type of stabilizer code where stabilizer generators are elements of the group \\( \\{\\alpha I, X, \\sqrt{Z}]\\}^{\\otimes n} \\), with \\( \\sqrt{Z} = \\text{diag} (1, i)\\). The codespace is a joint \\(+1\\) eigenspace of a set of stabilizer generators, which need not commute to define a valid codespace.\n", "notes": [], "introduced": "\\cite{arXiv:1404.5327}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "xs_stabilizer"}, "eth": {"name": "Eigenstate thermalization hypothesis (ETH) code", "description": "Also called a \\textit{thermodynamic code} \\cite{arxiv:1902.07714}. An \\(n\\)-qubit approximate code whose codespace is formed by eigenstates of a translationally-invariant quantum many-body system which satisfies the Eigenstate Thermalization Hypothesis (ETH). ETH ensures that codewords cannot be locally distinguished in the thermodynamic limit. Relevant many-body systems include 1D non-interacting spin chains, Motzkin chains, or Heisenberg models.\n\nETH requires that for ordered energy eigenstates \\(|E_l\\rangle\\) and any local observable \\(O\\),\n\\begin{align}\n|\\langle E_l|O|E_l\\rangle-\\langle E_{l+1}|O|E_{l+1}\\rangle|\\leq\\exp(-cn)\n\\end{align}\nfor a constant \\(c\\). This implies that energy eigenstates around some energy \\(\\bar E\\) are approximately locally indistinguishable from one another, as their reduced density matrices on any subsystem are both approximately thermal at energy \\(\\bar E\\). In this way, global information is protected from local measurements by the environment as \\(n\\to\\infty\\).\n", "notes": [], "introduced": "\\cite{arxiv:1710.04631}", "short_name": "ETH", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["An explicit universal recovery channel for the ETH code is given in \\cite{arXiv:1906.03669}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Approximately protects against erasure errors at known locations. Translation invariance alone is sufficient for good approximate error-correcting properties in a many-body spectrum, including in integrable models \\cite{arxiv:1710.04631}. The ETH code generated from the spectrum of the translation-invariant 1D Heisenberg spin chain \\cite{arxiv:1710.04631} has recovery infidelity (against the erasure of a constant number of sites) scale as \\(\\epsilon_\\text{worst}=O(1/n)\\) \\cite{arxiv:1902.07714}.", "code_id": "eth"}, "qubits_into_qubits": {"name": "Qubit code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2^n\\)-dimensional (i.e., \\(n\\)-qubit) Hilbert space. Usually denoted as \\(((n,K))\\) or \\(((n,K,d))\\), where \\(d\\) is the code's distance.\n", "notes": ["There is a relation between one-way entanglement distillation protocols and QECCs \\cite{arXiv:quant-ph/9604024}."], "introduced": "", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}. For few-qubit codes (\\(n\\) is small), maximum-likelihood decoding can be based by creating a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "A convenient and often considered error set is the \\textit{Pauli error} or \\textit{Pauli string} basis. For a single qubit, this set consists of products of powers of the Pauli matrices\n\\begin{align}\n  X=\\begin{pmatrix}0 & 1\\\\\n  1 & 0\n  \\end{pmatrix}\\,\\,\\text{ and }\\,\\,Z=\\begin{pmatrix}1 & 0\\\\\n  0 & -1\n  \\end{pmatrix}~.\n\\end{align}\nFor multiple qubits, error set elements are tensor products of elements of the single-qubit error set.\n\nThe Pauli error set is a unitary and Hermitian basis for linear operators on the multi-qubit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a prototypical nice error basis \\cite{arxiv:quant-ph/9608048}. The distance associated with this set is often the minimum weight of a Pauli string that implements a nontrivial logical operation in the code. The minimum weight of a Pauli error that has a non-zero expectation value for some code basis state is called the \\textit{diagonal distance} \\cite{arXiv:2107.11286}. Codes whose distance is greater than the diagonal distance are degenerate.\n", "code_id": "qubits_into_qubits"}, "qubit_stabilizer": {"name": "Qubit stabilizer code", "description": "Also called a \\textit{Pauli stabilizer code}. An \\(((n,2^k,d))\\) qubit stabilizer code is denoted as \\([[n,k]]\\) or \\([[n,k,d]]\\), where \\(d\\) is the code's distance. Logical subspace is the joint eigenspace of commuting Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace of a set of \\(2^{n-k}\\) commuting Pauli operators which do not contain \\(-I\\). The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation in the code.\n\nEach stabilizer code can be represented by a \\((n-k) \\times 2n\\) \\textit{check matrix} (a.k.a. \\textit{stabilizer generator matrix}) \\(H=(A|B)\\), where each row \\((a|b)\\) is the binary symplectic representation of an element from a set of generating elements of the stabilizer group. The check matrix can be brought into standard form via Gaussian elimination \\cite{doi:10.1017/CBO9780511976667}.\n\nThe stabilizer commutation condition can equivalently be stated in the symplectic representation. A pair of \\(n\\)-qubit stabilizers with symplectic representations \\((a|b)\\) and \\((a^{\\prime}|b^{\\prime})\\) commute iff their symplectic inner product is zero,\n\\begin{align}\n  a \\cdot b^{\\prime} + a^{\\prime}\\cdot b = \\sum_{j=1}^{n} a_j b^{\\prime}_j + a^{\\prime}_i b_i = 0~.\n\\end{align}\nSymplectic representations of stabilizer group elements thus form a self-orthogonal subspace of \\(GF(2)^{2n}\\) with respect to the symplectic inner product.\n", "notes": ["Tables of bounds and examples of stabilizer codes for various \\(n\\) and \\(k\\), based on algorithms developed in Ref. \\cite{doi:10.1007/978-3-540-37634-7_13}, are maintained by M. Grassl at this \\href{http://codetables.markus-grassl.de/}{website}.", "Stabilizer error-recovery circuits can be simulated efficiently using dedicated software (e.g., STIM \\cite{arxiv:2103.02202})."], "introduced": "\\cite{arXiv:quant-ph/9605005,arXiv:quant-ph/9705052}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Logical gates implemented via constant-depth quantum circuits of \\(D\\)-dimensional geometrically local stabilizer codes lie in the \\(D\\)th level of the Clifford hierarchy \\cite{arxiv:1206.1609}.", "With pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates \\cite{arXiv:1603.03948}."], "encoders": ["Circuits consisting of CNOT, Hadamard, and phase gates using algorithm based on the Gottesman-Knill theorem \\cite{arXiv:quant-ph/0406196}.", "Circuits obtained by first constructing the CWS form of the code \\cite{arXiv:0803.3232,arXiv:0708.1021}. These consist of \\(n\\) Hadamard gates, a classical encoder which takes at most \\(n\\) CX gates for a single-qubit encoding code, and at most \\(n(n-1)/2\\) CZ gates to create the needed graph state.", "Dissipative preparation, for which codespace is steady-state space of a Lindbladian \\cite{arXiv:1310.1036}.", "Lindbladian-based dissipative encoding \\cite{arxiv:quant-ph/9707049,arXiv:1310.1036} that does not give a speedup, in terms of scaling with \\(n\\), over circuit-based encoders \\cite{arxiv:1310.1037}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["With pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates \\cite{arXiv:1603.03948}.", "Fault-tolerant error correction scheme by Shor \\cite{arXiv:quant-ph/9605011}, which is based on repeated measurements. A modification uses adaptive measurements \\cite{arxiv:2208.05601}.", "Generalization of Steane error correction stabilizer codes \\cite[Sec. 3.6]{manual:{Yoder, Theodore., \\emph{DSpace@MIT} Practical Fault-Tolerant Quantum Computation (2018)}}.", "Fault-tolerant error correction scheme by Knill (a.k.a. telecorrection \\cite{arxiv:quant-ph/0601066}), which is based on teleportation \\cite{arxiv:quant-ph/0410199,arXiv:quant-ph/0312190}.", "GHz state distillation for Steane error correction \\cite{arxiv:2109.06248}."], "threshold": ["Computational thresholds against stochastic local noise can be achieved through repeated use of concatenatenation, and can rely on the same small code in every level \\cite{arxiv:quant-ph/9702058,arxiv:quant-ph/9906129,arXiv:quant-ph/9705031,arXiv:quant-ph/0504218}. The resulting code is highly degenerate, with all but an exponentially small fraction of generators having small weights. Circuit and measurement designs have to take case of the few stabilizer generators with large weights in order to be fault tolerant."], "decoders": ["The structure of stabilizer codes allows for \\textit{syndrome-based decoding}, where errors are corrected based on the results of stabilizer measurements (\\textit{syndromes}). The size of the circuit extracting the syndrome depends on the weight of its corresponding stabilizer generator. Maximum-likelihood decoding is \\(NP\\)-complete in general \\cite{arxiv:1009.1319,manual:{Kuo, Kao-Yueh, and Chung-Chin Lu. \"On the hardness of decoding quantum stabilizer codes under the depolarizing channel.\" 2012 International Symposium on Information Theory and its Applications. IEEE, 2012.}}. Degenerate maximum-likelihood decoding is \\(\\#P\\)-complete in general \\cite{arxiv:1310.3235}, although can be polynomial-time for specific codes like the surface code \\cite{arxiv:1405.4883}.", "Trellis decoder, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) \\cite{arXiv:quant-ph/0512041}.", "Quantum extension of GRAND decoder \\cite{arxiv:2208.02744}.", "Deep neural-network probabilistic decoder \\cite{arxiv:1705.09334}."], "code_capacity_threshold": ["Bounds on code capacity thresholds using maximum-likelihood (ML) decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model \\cite{arxiv:quant-ph/0110143,arXiv:1208.2317,arXiv:1311.7688,arXiv:1809.10704}."], "transversal_gates": ""}, "physical": "qubits", "protection": "Detects errors on up to \\(d-1\\) qubits, and corrects erasure errors on up to \\(d-1\\) qubits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).\n\nA stabilizer code is geometrically local if the support of the stabilizer generators is bounded by a ball of size independent of \\(n\\). There is an upper bound of \\(d \\leq O(L^{D-1})\\) on the distance \\cite{arXiv:0810.1983} of geometrically local stabilizer codes arranged in a \\(D\\)-dimensional lattice of length \\(L\\) with \\(n=L^D\\).\n", "code_id": "qubit_stabilizer"}, "quantum_reed_muller": {"name": "Quantum Reed-Muller code", "description": "A CSS code formed from a classical Reed-Muller code (or its punctured versions) in which polynomials over finite fields encode data. This is done by transforming these polynomials into the stabilizer generator matrices.", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9608026}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Magic state distillation in all prime dimensions \\cite{doi:10.1103/PhysRevX.2.041021}"], "encoders": [], "rate": "\\(\\frac{k}{n}\\), where \\(k = 2^r - {r \\choose t} + 2 \\sum_{i=0}^{t-1} {r \\choose i}\\). Additionally, CSS codes formed from binary Reed-Muller codes achieve channel capacity on erasure channels \\cite{arXiv:1601.04689}.", "magic_scaling_exponent": "", "fault_tolerance": ["Gate switching protocol for universal computation \\cite{arxiv:1403.2734}."], "threshold": ["Between \\(10^{-3}\\) and \\(10^{-6}\\) for depolarizing noise (assuming ideal decoders), see \\cite{doi:10.1088/2058-9565/abb027}"], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "code_id": "quantum_reed_muller"}, "movassagh_ouyang": {"name": "Movassagh-Ouyang Hamiltonian code", "description": "This is a family of codes derived via an algorithm that takes as input \\textit{any} binary classical code and outputs a quantum code (note that this framework can be extended to \\(q\\)-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.\n\nThis family strictly generalizes CSS codes (because CSS codes come only from linear or self orthogonal classical codes). These codes can be shown to be realized as a subspace of the ground space of a (geometrically) local Hamiltonian.\n", "notes": [], "introduced": "\\cite{arXiv:2012.01453}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "The rate depends on the classical code, but distance can scale linearly with \\(n\\).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Let \\(C \\subset \\{0,1,\\dots,q-1\\}^n\\) be a classical code with distance \\(d_x\\). Let \\(d_z\\) satisfy \\(q^n > 2 V_q(d_z-1) -1\\), where \\(V_q(r)\\) is the volume of the \\(q\\)-ary Hamming ball of radius \\(r\\). Then the algorithm produces a quantum code with distance \\(d = \\text{min}(d_x,d_z)\\). Asymptotically, the distance scales linearly with \\(n\\).", "code_id": "movassagh_ouyang"}, "quantum_bch": {"name": "Qubit BCH code", "description": "Qubit stabilizer code constructed from a self-orthogonal binary BCH code via the CSS construction, from a Hermitian self-orthogonal quaternary BCH code via the stabilizer-over-\\(GF(4)\\) construction, or by taking a Euclidean self-orthogonal BCH code over \\(GF(2^m)\\), converting it to a binary code, and applying the CSS construction.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9610042,arxiv:quant-ph/9608006,arxiv:quant-ph/9802061,arxiv:quant-ph/9910060}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "quantum_bch"}, "gnu_permutation_invariant": {"name": "GNU permutation-invariant code", "description": "Can be expressed in terms of Dicke states where the logical states are\n\\begin{align}\n|\\overline{\\pm}\\rangle = \\sum_{\\ell=0}^{n} \\frac{(\\pm 1)^\\ell}{\\sqrt{2^n}} \\sqrt{n \\choose \\ell} |D^m_{g \\ell}\\rangle~.\n\\end{align}\nHere, \\(m\\) is the number of particles used for encoding \\(1\\) qubit, and \\(g, n \\leq m\\) are arbitrary positive integers. The state \\(|D^m_w\\rangle\\) is a Dicke state -- a normalized permutation-invariant state on \\(m\\) qubits with \\(w\\) excitations, i.e., a normalized sum over all basis elements with \\(w\\) ones and \\(m - w\\) zeroes.\n\nA qudit extension of such codes, based on a correspondence with binomial codes, exists \\cite{arXiv:1708.05010}.\n", "notes": [], "introduced": "\\cite{arXiv:1302.3247}", "short_name": "GNU", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Depends on the family. One family which is completely symmetrized versions of Bacon-Shor codes (parameterized by \\(t\\)) protects against arbitrary weight-\\(t\\) qubit errors. Additionally, codes with large enough length \\((t+1)(3t+1)+t\\) can approximately correct \\(t\\) spontaneous decay errors.", "code_id": "gnu_permutation_invariant"}, "cws": {"name": "Codeword stabilized (CWS) code", "description": "This family of codes strictly generalizes stabilizer codes. They are usually denoted by \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\) where \\(\\mathcal{G}\\) is a graph and \\(\\mathcal{C}\\) is a \\( (n,K,d) \\) binary classical code. From the graph we form the unique graph state (stabilizer state) \\( |G \\rangle \\). From the classical code we form Pauli \\(Z\\)-type operators \\( W_i = Z^{c_{i,1}} \\otimes \\cdots \\otimes Z^{c_{i,n}} \\), where \\(c_{i,j} \\) is the \\(j\\)-th bit of the \\(i\\)-th classical codeword. The CWS codewords are then \\( | i \\rangle =  W_i | G \\rangle \\).\n\nThere is an alternative description to the one above that is locally Clifford-equivalent. In particular, we can describe CWS codes as \\( \\mathcal{Q} = (S,\\mathcal{W})\\) where \\(S\\) is a stabilizer group and \\( \\mathcal{W} = \\{ w_\\ell \\}_{\\ell = 1}^K \\) is a family of \\(K\\) \\(n\\)-qubit Pauli strings. We then form CWS codeswords as \\( | i \\rangle = w_i | S \\rangle \\), where \\( | S \\rangle \\) is the (unique) stabilizer state of \\(S\\).\n", "notes": [], "introduced": "\\cite{arXiv:0708.1021}", "short_name": "CWS", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": ["If \\( \\mathcal{C} \\) has an efficient classical encoder, then so does the CWS code \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\)."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["There is no known \\textit{efficient} algorithm to decode \\textit{non-additive} (non-stabilizer) CWS codes."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Code distance \\(\\mathcal{Q} = ( \\mathcal{G},\\mathcal{C}) \\) is upper bounded by the distance of the classical code \\(\\mathcal{C} \\). The \\hyperref[code:qubits_into_qubits]{diagonal distance} is upper bounded by \\(\\delta + 1\\), where \\(\\delta\\) is the minimum degree of \\(\\mathcal{G}\\). Computing the distance is generally NP-complete, and is NP-hard for non-degenerate codes \\cite{arXiv:2203.04262}.", "code_id": "cws"}, "css": {"name": "Calderbank-Shor-Steane (CSS) stabilizer code", "description": "An \\([[n,k,d]]\\) stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings. The stabilizer generator matrix is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parity}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:comm}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related \\hyperref[code:binary_linear]{binary linear codes}, an \\([n,k_X,d^\\prime_X]\\) code \\(C_X\\) and \\([n,k_Z,d^\\prime_Z]\\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d^\\prime_X,d^\\prime_Z\\}\\). The \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parity} is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\eqref{eq:comm}.\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n\nA CSS code has \\textit{stabilizer weight} \\(w\\) if the highest weight of any stabilizer generator is \\(w\\), i.e., any row of \\(H_X\\) and \\(H_Z\\) has weight at most \\(w\\). In the context of comparing weight as well as of determining distances for noise models biased toward \\(X\\)- or \\(Z\\)-type errors, an extended notation for \\textit{asymmetric} CSS codes is \\([[n,k,(d_X,d_Z),w]]\\) or \\([[n,k,d_X/d_Z,w]]\\). The quantity \\(\\min\\{d_X,d_Z\\}\\) is often called the \\textit{worst-case minimum distance}.\n\n\n\\subsection{CSS-to-homology correspondence}\n\n\\begin{defterm}{CSS-to-homology correspondence}\n\\label{topic:CSS-to-homology-correspondence}\nCSS codes and their properties can be formulated in terms of homology theory, yielding a powerful correspondence between codes and chain complexes, the primary homological structures.\nThere exists a many-to-one mapping from size three chain complexes to CSS codes \\cite{doi:10.1070/RM1997v052n06ABEH002155,arXiv:quant-ph/0605094,arXiv:1311.0885,arXiv:1802.01520} that allows one to extract code properties from topological features of the complexes. Codes constructed in this manner are sometimes called \\textit{homological CSS codes}, but they are equivalent to CSS codes. This mapping of codes to manifolds allows the application of structures from topology to error correction, yielding \\hyperref[code:generalized_homological_product]{various QLDPC codes} with favorable properties.\n\\end{defterm}\n\nA \\textit{chain complex} of size three is given by binary vector spaces \\(A_2\\), \\(A_1\\), \\(A_0\\) and binary matrices \\(\\partial_{i=1,2}\\) (called \\textit{boundary operators}) \\(A_i\\) to \\(A_{i-1}\\) that satisfy \\(\\partial_1 \\partial_2 = 0\\). Such a complex is typically denoted as\n\\begin{align}\nA_2 \\xrightarrow{\\partial_2} A_1 \\xrightarrow{\\partial_1} A_0~.\n\\label{eq:chain}\n\\end{align}\nOne constructs a CSS code by associating a physical qubit to every basis element of \\(A_1\\), and defining parity-check matrices \\(H_X=\\partial_1^T\\) and \\(H_Z=\\partial_2\\)). That way, the spaces \\(A_0\\) and \\(A_2\\) can be associated with \\(X\\)-type and \\(Z\\)-type Pauli operators, respectively, and boundary operators determine the Paulis making up the stabilizer generators. The requirement \\(\\partial_1 \\partial_2 = 0\\) guarantees that the \\(X\\)-stabilizer generators associated with \\(H_X\\) commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nUsually, the chain complex \\eqref{eq:chain} used in the construction comes from the chain complex associated with a cellulation of a manifold. When the manifold is a two-dimensional surface, its entire chain is used. Higher-dimensional manifolds allow for longer chain complexes, and one can use the three largest non-trivial vector spaces in its chain.\n", "notes": ["Introduction to \\ref{topic:CSS-to-homology-correspondence} by \\href{https://www.youtube.com/watch?v=SeLpWg_8qlc}{M. Hastings}.", "Using linear programming to solve a set of equations and inequalities on weight distribution of a classical self-orthogonal code \\(C=(n, 2^n-k)\\) and its dual, one can find a \\(C\\) such that the \\([[n,k,d]]\\) CSS code constructed using \\(C\\) and its dual would have rate and distance close to the Singleton bound \\cite{arXiv:quant-ph/9608006}."], "introduced": "\\cite{arXiv:quant-ph/9512032,doi:10.1103/PhysRevLett.77.793,arXiv:quant-ph/9601029}", "short_name": "CSS", "logical": "qubits", "realizations": ["Fully homomorphic encryption \\cite{arxiv:1708.09156}.", "Entanglement purification protocols related to quantum key distribution (QKD) \\cite{arxiv:quant-ph/0003004}."], "features": {"general_gates": ["LDPC CSS code symmetries called \\(XZ\\)-dualities allow for fold-transversal gates, i.e., transversal gates followed by qubit permutations \\cite{arxiv:2202.06647}."], "encoders": ["Stabilizer measurement \\cite{arxiv:1404.2495}."], "rate": "For a depolarizing channel with probability \\(p\\), CSS codes allowing for arbitrarily accurate recovery exist with asymptotic rate \\(1-2h(p)\\), where \\(h\\) is the binary entropy function \\cite{arxiv:quant-ph/0110143}.", "magic_scaling_exponent": "", "fault_tolerance": ["Steane error correction \\cite{arXiv:quant-ph/9611027}.", "Homomorphic gadgets fault-tolerant measurement unify Steane and Shor error correction \\cite{arxiv:2211.03625}.", "Parallel syndrome extraction for distance-three codes can be done fault-tolerantly using one flag qubit \\cite{arXiv:2208.00581}."], "threshold": [], "decoders": ["Coherent decoders allow for measurement-free error correction \\cite{arxiv:2109.00086}. One method is table/multi-control decoding \\cite{arXiv:1002.1536}, which scales exponentially with the number of ancillas used in syndrome measurement. Another method, the Ising-based decoder, utilizes the mapping of the effect of the noise to a statistical mechanical model \\cite{arxiv:quant-ph/0110143,arXiv:2002.11733} such that the decoding problem maps to preparation of the ground state of an Ising model."], "code_capacity_threshold": ["Bounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights \\cite{arxiv:1208.2317,arxiv:1412.6172}."], "transversal_gates": "CNOT gates. Self-dual CSS codes admit transversal Clifford gates."}, "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.\n\nUsing the relation to chain complexes, the number of encoded logical qubits is equal to the dimension of the first \\(\\mathbb{Z}_2\\)-homology of the chain complex, \\(H_1(\\partial, \\mathbb{Z}_2) = \\frac{\\text{Ker}(\\partial_1)}{\\text{Im}(\\partial_2)}\\). The distance of the CSS code is equal to the minimum of the combinatorial (\\(d-1\\))-systole of the cellulated \\(d\\)-dimensional manifold and its dual.\n", "code_id": "css"}, "xp_stabilizer": {"name": "XP stabilizer code", "description": "The XP Stabilizer formalism is a generalization of the XS and Pauli stabilizer formalisms, with stabilizer generators taken from the group \\( \\{\\omega I, X, P\\}^{\\otimes n} \\). Here, \\( \\omega \\) is a \\( 2N \\) root of unity, and \\( P = \\text{diag} ( 1, \\omega^2) \\). The codespace is a \\(+1\\) eigenspace of a set of XP stabilizer generators, which need not commute to define a valid codespace.\n\nXP stabilizer codes are classified into XP-regular and XP-non-regular, where the former can be mapped to a CSS code with similar logical operator structure.\n", "notes": [], "introduced": "\\cite{arXiv:2203.00103}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "xp_stabilizer"}, "quantum_parity": {"name": "Quantum parity code (QPC)", "description": "Also called a \\textit{generalized Shor code} \\cite{arxiv:quant-ph/0610088}. A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) CSS code family obtained from concatenating an \\(m_1\\)-qubit phase-flip repetition code with an \\(m_2\\)-qubit bit-flip repetition code. Logical codewords are\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}+|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}-|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}~.\n\\end{split}\n\\end{align}\n", "notes": ["Non-determinisitic linear-optical encoding \\cite{arxiv:quant-ph/0501184} whose success probability \\(P_{E}\\) is determined by the efficiency \\(\\eta\\) of the photonic encoding circuit. A threshold \\(\\eta > 0.82 \\) exists for the efficiency, above which \\(P_{E}\\to 1\\) as \\(m_1\\to\\infty\\) given particular \\(m_2\\).", "Studied in the context of error-corrected quantum repeaters \\cite{arXiv:1310.5291}."], "introduced": "\\cite{arxiv:quant-ph/0501184,doi:10.1038/35051009,arxiv:quant-ph/0006088}", "short_name": "QPC", "logical": "qubits", "realizations": ["The \\([[m^2,1,m]]\\) codes for \\(m\\leq 7\\) have been realized in trapped-ion quantum devices \\cite{arXiv:2104.01205}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Has distance \\(d=\\min(m_1,m_2)\\).", "code_id": "quantum_parity"}, "quantum_polar": {"name": "Quantum polar code", "description": "Entanglement-assisted CSS code utilized in a quantum polar coding scheme producing entangled pairs of qubits between sender and receiver. In such a scheme, the amplitude and phase information of a quantum state is handled in complementary fashion \\cite{arxiv:0803.3096} using an encoding based on classical polar codes. Variants of the initial scheme have been developed for degradable channels \\cite{arxiv:1201.2906} and extended to arbitrary channels \\cite{arxiv:1109.5346}.\n\nThe scheme requires some a-priori quantum side information in the general case, making the associated code entanglement assisted \\cite{arxiv:1109.3195}. The requirement of having quantum side information vanishes when the sum of the amplitude channel fidelity and the phase channel fidelity is not greater than 1. It is shown to vanish for the case of degradable noise channels \\cite{arxiv:1109.5346}. A more complicated quantum polar-coding scheme that does not require pre-shared entanglement has also been derived \\cite{arxiv:1307.1136}.\n", "notes": [], "introduced": "\\cite{arxiv:1109.3195}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "The rate approaches the symmetric coherent information of the quantum noise channel \\cite{arxiv:1201.2906}.", "magic_scaling_exponent": "", "fault_tolerance": ["State preparation of a single logical qubit \\cite{arxiv:2209.06673}."], "threshold": [], "decoders": ["Constructed using classical polar decoders for the amplitude and phase channels."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Protects against Pauli noise and erasures.", "code_id": "quantum_polar"}, "stabilizer_over_gf4": {"name": "Stabilizer code over \\(GF(4)\\)", "description": "An \\([[n,k,d]]\\) stabilizer code constructed from a quaternary classical code using the one-to-one correspondence between the four Pauli matrices \\(\\{I,X,Y,Z\\}\\) and the four elements \\(\\{0,1,\\alpha^2,\\alpha\\}\\) of the quaternary field \\(GF(4)\\).\n\nAn \\(n\\)-qubit Pauli stabilizer can be represented as a length-\\(n\\) quaternary vector. The stabilizer commutation condition corresponds to a zero trace-Hermitian inner product between the corresponding vectors. Stabilizer codes over \\(GF(4)\\) can thus be constructed from classical trace-Hermitian self-orthogonal additive quaternary codes and Hermitian self-orthogonal linear quaternary codes (since the latter are automatically trace-Hermitian self-orthogonal).\nThe classical code corresponds to the stabilizer group \\(\\mathsf{S}\\) while its trace-Hermitian dual corresponds to the normalizer \\(\\mathsf{N(S)}\\).\n\nStabilizer codes over \\(GF(4)\\) can be constructed as follows. Let \\(\\phi\\) be a bijection from a linear binary subspace to \\(GF(4)^n\\). Let \\(C\\) be a trace-Hermitian self-orthogonal additive subcode over \\(GF(4)\\), containing \\(2^{n-k}\\) vectors, such that there are no vectors of weight less than \\(d\\) in \\(C^{\\perp}\\setminus C\\). Then, any eigenspace of the inverse map \\(\\phi^{-1}(C)\\) is an \\([[n, k, d]]\\) stabilizer code over \\(GF(4)\\).\n", "notes": ["Tables of \\([[n,0,d]]\\) codes, corresponding to a self-dual \\(GF(4)\\) representation, at \\href{http://www.ii.uib.no/~larsed/vncorbits/}{this website}."], "introduced": "\\cite{arXiv:quant-ph/9608006}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Characterizing fault-tolerant multi-qubit gates may involve characterizing all global automorphisms of some number of copies of a code that preserve the symplectic inner product \\cite[pg. 9]{arxiv:quant-ph/9703048}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "code_id": "stabilizer_over_gf4"}, "happy": {"name": "Pastawski-Yoshida-Harlow-Preskill (HaPPY) code", "description": "Also known as a \\textit{hyperbolic pentagon code (HyPeC)}.\nHolographic code constructed out of a network of perfect tensors that tesselates hyperbolic space. Physical qubits are associated with uncontracted tensor legs at the boundary of the tesselation, while logical qubits are associated with uncontracted legs in the bulk. The code serves as a minimal model for several aspects of the AdS/CFT holographic duality. The construction below is described for qubits, but straightforward generalizations exist to modular qudits, oscillators, and rotors \\cite{arXiv:1902.07714}.\n\nEncoding is accomplished using a tensor network of five-qubit encoding isometries, which are six-legged perfect tensors (with five legs corresponding to the physical qubits and one for the encoded logical qubit). A \\(2n\\)-legged \\textit{perfect tensor} is proportional to an isometry for any bipartition of its indices into a set \\(A\\) and a complementary set \\(A^{\\perp}\\) such that \\(|A|\\leq|A^{\\perp}|\\).\n\nTo construct the encoding, one first uniformly tiles the hyperbolic AdS/CFT disc using pentagons and hexagons. Then, one places a 6-legged five-qubit encoding tensor at each hexagon and pentagon, contracting legs between neighboring shapes and leaving one leg uncontracted at each pentagon. This construction forms an encoding isometry from the uncontracted legs in the bulk to the uncontracted legs at the boundary.\n", "notes": ["Ref. \\cite{arXiv:2201.11658} discusses the HaPPY code for an AdS_3 space and its relation to a dS_2 \\textit{braneworld} with a conformal boundary."], "introduced": "\\cite{arxiv:1503.06237}", "short_name": "HaPPY", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": ["Heisenberg-picture encoding is done through \\textit{tensor pushing}. Each bulk operator (logical) is pushed to an operator supported on a portion of the boundary region (physical). Pushing all the bulk operators through results in reconstruction of the boundary."], "rate": "The pentagon HaPPY code has an asymptotic rate \\(\\frac{1}{\\sqrt{5}} \\approx 0.447\\). The pentagon/hexagon HaPPY code, with alternating layers of pentagons and hexagons in the tiling, has a rate of \\(0.299\\) if the last layer is a pentagon layer and a rate of \\(0.088\\) if the last layer is a hexagon layer.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["\\(26\\%\\) for boundary erasure errors on the the pentagon/hexagon HaPPY code, which has alternating layers of pentagons and hexagons in the tiling.", "\\(\\sim 50\\%\\) for boundary erasure errors on the single-qubit HaPPY code, which has a central pentagon encoding one bulk operator and hexagons tiling all other layers", "\\(16.3\\%\\) for boundary Pauli errors on the single-qubit HaPPY code with 3 layers \\cite{arxiv:2008.10206}.", "There is no threshold for the pentagon HaPPY code as a constant number of errors (two) can make bulk recovery impossible."], "decoders": ["Greedy algorithm for decoding specified in Ref. \\cite{arxiv:1503.06237}."], "code_capacity_threshold": [], "transversal_gates": "For locality-preserving physical gates on the boundary, the set of transversally implementable logical operations in the bulk is strictly contained in the Clifford group \\cite{arxiv:2103.13404}."}, "physical": "qubits", "protection": "Protects against erasure errors and Pauli errors on the boundary qubits.", "code_id": "happy"}, "quantum_triorthogonal": {"name": "Triorthogonal code", "description": "A triorthogonal \\(m \\times n\\) binary matrix is triorthogonal if its rows \\(r_1, \\ldots, r_m\\) satisfy \\(|r_i \\cdot r_j| = 0\\) and \\(|r_i \\cdot r_j \\cdot r_k| = 0\\), where addition and multiplication are done on \\(\\mathbb{Z}_2\\). The triorthogonal code associated with the matrix is constructed by mapping non-zero entries in even-weight rows to \\(X\\) operators, and \\(Z\\) operators for each row in the orthogonal complement.", "notes": ["Reference \\cite{arXiv:2107.09684} presents a classification of triorthogonal codes up to \\(n + k \\leq 38\\) by associating each triorthogonal code with a Reed-Muller polynomial."], "introduced": "\\cite{arXiv:1209.2426}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Triorthogonal codes can be used for high-quality magic-state distillation \\cite{arXiv:1209.2426}."], "encoders": ["Encoder for magic states for the code constructed in \\cite{arXiv:1209.2426}."], "rate": "", "magic_scaling_exponent": "Depends on the matrix. Reference \\cite{arXiv:1209.2426} gave a family of \\(\\frac{k}{3k+8}\\) codes with magic-state distillation scaling exponent \\(\\gamma = \\log_2 \\frac{3k+8}{k}\\).", "fault_tolerance": ["Universal fault-tolerant gates can be performed without magic-state distillation \\cite{arxiv:1304.3709,arxiv:2210.14074}."], "threshold": ["Approximately \\(\\frac{1}{3k + 1}\\) \\cite{arXiv:1209.2426}."], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "Admits transversal \\(T\\) gates \\cite{arXiv:1209.2426} and the controlled-controlled-\\(Z\\) gate \\cite{arxiv:1304.3709}."}, "physical": "qubits", "protection": "Weight \\(t\\) Pauli errors, where \\(t\\) depends on the family. For example, Ref. \\cite{arXiv:1209.2426} provides a family of distance \\(2\\) codes. It also presents a \\([[49, 1, 5]]\\) code.", "code_id": "quantum_triorthogonal"}, "color": {"name": "Color code", "description": "A family of abelian topological \\hyperref[code:css]{CSS stabilizer} codes defined on a \\(D\\)-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial \\(D\\)-complex obtained as a triangulation of the interior of a \\(D\\)-simplex and (2) is \\(D+1\\)-colorable. Qubits are placed on the \\(D\\)-simplices and generators are supported on suitable simplices \\cite{doi:10.7907/059V-MG69}. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face \\cite{arXiv:1311.0277}.", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0605138}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Magic-state distillation protocols \\cite{doi:10.7907/059V-MG69}.", "Non-clifford gates can be implemented via code switching \\cite{doi:10.7907/059V-MG69}.", "Lattice surgery scheme for 2D layout yields lower resource overhead when compared to analogous surface code scheme \\cite{arXiv:2201.07806}."], "encoders": [], "rate": "For general 2D manifolds, \\(kd^2 \\leq c(\\log k)^2 n\\) for some constant \\(c\\) \\cite{arXiv:1301.6588}, meaning that color codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\).", "magic_scaling_exponent": "", "fault_tolerance": ["Clifford gates can be performed fault-tolerantly on a suitable 2D lattice \\cite{arxiv:quant-ph/0605138}.", "Syndrome measurement \\cite{arXiv:1407.5103}.", "Steane's ancilla-coupled measurement method \\cite{arXiv:1407.5103}"], "threshold": ["\\(\\geq 6.25\\%\\) threshold for 2D color codes with error-free syndrome extraction, and \\(0.1\\%\\) with faulty syndrome extraction \\cite{arXiv:0907.1708}.", "\\(0.46\\%\\) for 3D codes with clustering decoder \\cite{arXiv:1708.07131}.", "\\(1.9\\%\\) for 1D string-like logical operators and \\(27.6\\%\\) for 2D sheet-like operators for 3D codes with noise models using optimal decoding and perfect measurements \\cite{arXiv:1708.07131}.", "\\(0.31\\%\\) noise threshold error rate for gauge code using clustering decoder \\cite{arXiv:1503.08217}.", "\\(0.143\\%\\) with depolarising circuit-level noise using perfect-matching decoder \\cite{arXiv:1407.5103}.", "\\(>0\\%\\) threshold with sweep decoder \\cite{doi:10.7907/059V-MG69}."], "decoders": ["Projection decoder \\cite{doi:10.7907/059V-MG69}.", "Matching decoder gives low logical failure rate \\cite{arXiv:2108.11395}.", "Integer-program-based decoder \\cite{arXiv:1402.3037}.", "Restriction decoder \\cite{doi:10.1088/1367-2630/ab68fd}.", "Cellular-automaton decoder for the \\(XYZ\\) color code \\cite{arxiv:2203.16534}."], "code_capacity_threshold": ["\\(\\geq 6\\%\\) threshold with rescaling-based decoder \\cite{arXiv:2112.09584}."], "transversal_gates": "Transversal CNOT can be implemented via braiding \\cite{arXiv:0806.4827}. Universal transversal gates can be achieved in 3D color code using gauge fixing \\cite{arxiv:1311.0879}, lattice surgery \\cite{arXiv:1407.5103}, or code deformation \\cite{doi:10.1088/1367-2630/13/4/043005,arXiv:0806.4827}."}, "physical": "qubits", "protection": "As with the surface code, the code distance depends on the specific kind of lattice used to define the code. More precisely, the distance depends on the homology of logical string operators \\cite{arXiv:1311.0277}.", "code_id": "color"}, "haah_cubic": {"name": "Haah cubic code", "description": "Class of stabilizer codes on a length-\\(L\\) cubic lattice with one or two qubits per site. We also require that the stabilizer group \\(\\mathsf{S}\\) is translation invariant and generated by two types of operators with support on a cube. In the non-CSS case, these two are related by spatial inversion. For CSS codes, we require that the product of all corner operators is the identity. We lastly require that there are no non-trival ''string operators'', meaning that single-site operators are a phase, and any period one logical operator \\(l \\in \\mathsf{S}^{\\perp}\\) is just a phase. Haah showed in his original construction that there is exactly one non-CSS code of this form, and 17 CSS codes \\cite{arXiv:1101.1962}. The non-CSS code is labeled code 0, and the rest are numbered from 1 - 17. Codes 1-4, 7, 8, and 10 do not have string logical operators \\cite{arXiv:1101.1962,arXiv:1908.08049}.\n\nStraightforward generalizations of the above codes exist to modular qudits, oscillators, and rotors \\cite{manual:{J. Haah, Two generalizations of the cubic code model, \\href{https://online.kitp.ucsb.edu/online/qinfo_c17/haah/}{KITP Conference: Frontiers of Quantum Information Physics, UCSB, Santa Barbara, CA.}},arXiv:1709.04460}.\n", "notes": [], "introduced": "\\cite{arXiv:1101.1962}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["The encoding rate depends on the code implemented, but code 0 has been shown to have \\(k \\ge L\\) (on a periodic finite cubic lattice of side length \\(L\\). In general we expect the number of logical bits to scale as \\(k \\sim L\\)."], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Cubic codes protect against simultaneous independent Pauli errors on different sites (not qubits, since there can be 2 qubits per site). Codes 0-4 are known to have distance \\(d \\ge L\\), meaning they can achieve macroscopic code distance as \\(L\\to\\infty\\).", "code_id": "haah_cubic"}, "matching": {"name": "Matching code", "description": "Stub.", "notes": [], "introduced": "\\cite{arxiv:1501.07779}", "short_name": "", "logical": "qubits", "realizations": ["Braiding of defects has been demonstrated for a five-qubit version of code \\cite{arxiv:1609.07774}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "matching"}, "double_semion": {"name": "Double-semion code", "description": "Stub.", "notes": [], "introduced": "\\cite{arXiv:cond-mat/0404617}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "double_semion"}, "rbh": {"name": "Raussendorf-Bravyi-Harrington (RBH) code", "description": "Stub. (see Sec. III E of \\cite{arXiv:1805.01474})\n", "notes": [], "introduced": "\\cite{arXiv:1805.01474}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Code exhibiting symmetry-protected self-correction. The energy barrier for symmetry-preserving exhitations outside of the code space grows linearly with the lattice width. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the lattice width.\n", "code_id": "rbh"}, "xyz_hexagonal": {"name": "XYZ\\(^2\\) hexagonal stabilizer code", "description": "An instance of the matching code based on the Kitaev honeycomb model. It is described on a hexagonal lattice with \\(XYZXYZ\\) stabilizers on each hexagonal plaquette. Each vertical pair of qubits has an \\(XX\\), \\(YY\\), or \\(ZZ\\) link stabilizer depending on the orientation of the plaquette stabilizers.", "notes": ["Isolated \\(X\\), \\(Y\\), and \\(Z\\) errors lead to unidirectional pairs of plaquette defects along the three directions of the triangular lattice."], "introduced": "\\cite{arxiv:2109.13308,arXiv:2112.06036}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Maximum-likelihood decoding using the EWD decoder \\cite{arxiv:2112.01977}."], "code_capacity_threshold": ["\\(50\\%\\) for pure \\(Z\\), \\(Y\\), or \\(Z\\) noise under maximum-likelihood decoding.", "Threshold matches that of the \\(XZZX\\) code for various bias levels of \\(X\\), \\(Y\\), or \\(Z\\) biased noise  under maximum-likelihood decoding.", "\\(\\sim 18\\%\\) for depolarizing noise under maximum-likelihood decoding."], "transversal_gates": ""}, "physical": "qubits", "protection": "As a stabilizer code with boundaries, protects a single qubit with parameters \\([[2 d^2, 1, d]]\\).", "code_id": "xyz_hexagonal"}, "fractal_surface": {"name": "Fractal surface code", "description": "Kitaev surface code on a fractal geometry, which is obtained by removing qubits from the surface code on a cubic lattice. Stub.", "notes": [], "introduced": "\\cite{arXiv:2108.00018,arXiv:2201.03568}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "fractal_surface"}, "surface-17": {"name": "Surface-17 code", "description": "A \\([[9,1,3]]\\) rotated surface code named for the sum of its 9 data qubits and 8 syndrome qubits. It uses the smallest number of qubits to perform error correction on a surface code with parallel syndrome extraction.", "notes": ["Subject of various numerical studies examining the system for noises and architectures specific to trapped ions \\cite{arXiv:1404.3747,arXiv:1710.01378,arxiv:1910.08495} and superconducting circuits \\cite{arxiv:1612.08208,arxiv:1703.04136,arxiv:2002.07119}"], "introduced": "\\cite{arXiv:1404.3747}", "short_name": "", "logical": "qubits", "realizations": ["Implemented at ETH Zurich by the Wallraff group\n\\cite{arxiv:2112.03708} and on the Zuchongzhi 2.1 superconducting quantum processor \\cite{arxiv:2112.13505}. Both experimental error rates are above the pseudothreshold for this code relative to a single qubit. See Physics viewpoint for a summary \\cite{doi:10.1103/Physics.15.103}.\n"], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Lookup table \\cite{arxiv:1404.3747}."], "code_capacity_threshold": [], "transversal_gates": "Pauli gates, CNOT gate, and \\(H\\) gate (with relabeling)."}, "physical": "qubits", "protection": "Independent correction of single-qubit \\(X\\) and \\(Z\\) errors. Correction for some two-qubit \\(X\\) and \\(Z\\) errors.", "code_id": "surface-17"}, "rotated_surface": {"name": "Rotated surface code", "description": "Also called a \\textit{checkerboard code}. CSS variant of the surface code defined on a square lattice that has been rotated 45 degrees such that qubits are on vertices, and both \\(X\\)- and \\(Z\\)-type check operators occupy plaquettes in an alternating checkerboard pattern.", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0703272,arXiv:1107.3502,arXiv:1202.0928,arXiv:1404.3747}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["A particular choice of CNOT gates during syndrome extraction is required to be fault-tolerant to syndrome qubit errors \\cite{arXiv:1404.3747}."], "threshold": [], "decoders": ["Local neural-network using 3D convolutions, combined with a separate global decoder \\cite{arxiv:2208.01178}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "The \\([[L^2,1,L]]\\) variant of this family includes the \\([[9,1,3]]\\) \\hyperref[code:surface-17]{surface-17} code, named as such because 8 ancilla qubits are used for check operator measurements alongside the 9 physical qubits.", "code_id": "rotated_surface"}, "xzzx": {"name": "XZZX surface code", "description": "Non-CSS variant of the rotated surface code whose generators are \\(XZXZ\\) Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).", "notes": ["A single \\(X\\) or \\(Z\\) error gives rise to two nearby defects, which can be viewed as endpoints of a string. That way, multiple \\(Z\\) errors can be decomposed into a combination of diagonal strings.", "Originally formulated as an example of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model \\cite{arxiv:quant-ph/0205004}."], "introduced": "\\cite{arxiv:quant-ph/0205004,arXiv:2009.07851}", "short_name": "", "logical": "qubits", "realizations": ["Distance-five 25-qubit code implemented on a superconducting quantum processor by Google Quantum AI \\cite{arxiv:2207.06431}. This code outperformed the average of several instances of the smaller distance-three 9-qubit \\(XZZX\\) variant of the \\hyperref[code:surface-17]{surface-17} code realized on the same device, both in terms of logical error probability over 25 cycles and in terms of logical error per cycle. This increase in error-correcting capabilities while using more physical qubits supports the notion of an error threshold. Braiding of defects has been demonstrated for the distance-five code \\cite{arxiv:2210.10255}. Leakage errors have been handled in a separate work in a distance-three code \\cite{arxiv:2211.04728}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["\\(\\sim 4.5\\%\\) using minimum-weight perfect matching decoder for depolarizing noise (bias \\(\\eta=0.5\\)); \\(\\sim 10\\%\\) for infinite \\(Z\\) bias."], "decoders": ["Minimum-weight perfect matching decoder, which can be used for \\(X\\) and \\(Z\\) noise. For \\(Y\\) noise, a variant of the matching decoder could be used like it is used for the XY code in Ref. \\cite{arXiv:1907.02554}."], "code_capacity_threshold": ["\\(50\\%\\) threshold for noise infinitely biased towards \\(X\\) or \\(Y\\) or \\(Z\\) errors using a maximum-likelihood decoder.", "For large but finite \\(X\\)- or \\(Z\\)-biased noise, the code's thresholds exceed the zero-rate hashing bound.  The difference of the threshold from the hashing bound exceeds \\(2.9\\%\\) at a \\(Z\\) or \\(X\\) bias of 300.", "\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder.", "\\(0.817\\%\\) and \\(0.940\\%\\) with minimum-weight perfect matching and belief-matching decoder, respectively, for biased circuit-level noise \\cite{arxiv:2203.04948}.", "\\(4.15\\%\\) when \\(98\\%\\) of depolarizing errors are coverted into erasure errors with union-find decoder on a planar code, vs. \\(0.937\\%\\) for pure depolarizing noise. In Rydberg atomic devices, erasure conversion during gates is promising because the dominant source of noise is spontaneous decay into detectable energy levels outside of the computational subspace \\cite{arxiv:2201.03540}."], "transversal_gates": ""}, "physical": "qubits", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "code_id": "xzzx"}, "freedman_meyer_luo": {"name": "Freedman-Meyer-Luo code", "description": "Hyperbolic surface code constructed using cellulation of a Riemannian Manifold \\(M\\) exhibiting systolic freedom \\cite{doi:10.2140/gtm.1999.2.113}. Codes derived from such manifolds can achieve distances scaling better than \\(\\sqrt{n}\\), something that is impossible using closed 2D surfaces or 2D surfaces with boundaries \\cite{doi:10.1063/1.4726034}. Improved codes are obtained by studying a weak family of Riemann metrics on closed 4-dimensional manifolds \\(S^2\\otimes S^2\\) with the \\(Z_2\\)-homology.\n", "notes": ["See thesis by Fetaya for pedagogical exposition \\cite{arxiv:1108.2886}."], "introduced": "\\cite{doi:10.1201/9781420035377-13}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Codes held a 20-year record the best lower bound on asymptotic scaling of the minimum code distance, \\(d=\\Omega(\\sqrt{n \\sqrt{\\log n}})\\), broken by Ramanujan tensor-product codes.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Four-dimensional manifolds with weak systolic freedom yield \\([[n,2,\\Omega(\\sqrt{n \\sqrt{\\log n}})]]\\) surface codes.", "code_id": "freedman_meyer_luo"}, "xysurface": {"name": "XY surface code", "description": "Also called the \\textit{tailored surface code (TSC)}. Non-CSS derivative of the surface code whose generators are \\(XXXX\\)  and \\(YYYY\\), obtained by mapping \\(Z \\to Y\\) in the surface code.", "notes": [], "introduced": "\\cite{arxiv:1708.08474}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["\\(6.32(3)\\%\\) for infinite \\(Z\\) bias, and thresholds of \\(\\sim 5\\%\\) for \\(Z\\) bias around \\(\\eta = 100\\) using a variant of the minimum-weight perfect matching decoder \\cite{arXiv:1907.02554}."], "decoders": [], "code_capacity_threshold": ["\\(50\\%\\) at infinite \\(Z\\) bias with maximum-likelihood decoder \\cite{arxiv:1812.08186}.", "\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder \\cite{arxiv:1812.08186}."], "transversal_gates": ""}, "physical": "qubits", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "code_id": "xysurface"}, "real_projective_plane": {"name": "Projective-plane surface code", "description": "A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold \\(\\mathbb{R}P^2\\) (in contrast to a genus-\\(g\\) surface). Whereas genus-\\(g\\) surface codes require \\(2g\\) logical qubits, qubit codes on \\(\\mathbb{R}P^2\\) are made from a single logical qubit.", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9810055}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "The rate is \\(1/n\\), where \\(n\\) is the number of edges of the particular cellulation.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "If \\(\\mathcal{C}\\) is a cellulation of \\(\\mathbb{R}P^2\\), then the bit-flip distance \\(d_X\\) is the shortest cycle in \\(\\mathcal{C}\\), and the phase-flip distance \\(d_Z\\) is the shortest cycle in the dual cellulation \\(\\mathcal{C}^*\\).", "code_id": "real_projective_plane"}, "golden_code": {"name": "Golden code", "description": "Variant of the Guth-Lubotzky hyperbolic surface code that uses regular tessellations for 4-dimensional hyperbolic space.\n", "notes": [], "introduced": "\\cite{arXiv:1712.08578}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Nonvanishing rate and asymptotic distance lower bounded by \\(n^0.1\\).", "code_id": "golden_code"}, "four_dimensional_hyperbolic": {"name": "Guth-Lubotzky code", "description": "Hyperbolic surface code based on cellulations of certain four-dimensional manifolds. The manifolds are shown to have good homology and systolic properties for the purposes of code construction, with corresponding codes exhibiting linear rate.\n\nGuth and Lubotzky \\cite{arXiv:1310.5555} show that there exists \\(\\epsilon\\), a four-dimensional hyperbolic manifold \\(M\\), and a sequence of manifolds \\(M_i\\) such that\neach \\(M_i\\) is a finite sheeted \\href{https://en.wikipedia.org/wiki/Covering_space}{covering} of \\(M\\), and the four-dimensional volumes of the manifolds \\(\\text{Vol}_4(M_i)\\) of the sequence tend to infinity.\nAlso, the dimension of the second homology and size of systoles are bounded by \\(H_2(M_i, Z_2) \\geq \\frac{\\text{Vol}_4(M_i)}{100}\\) and \\(\\text{Sys}_2(M_i) \\geq \\text{Vol}_4(M_i)^\\epsilon\\), respectively.\n\nThen given any cellulation of \\(M\\), it can naturally be extended to cellulations for each of the manifolds \\(M_i\\) and used to define CSS codes via the homological construction by choosing the size three chain complex consisting of the \\(3,2\\) and \\(1\\)-cells of the cellulations.\n\nFor dense cellulations (i.e. large \\(n\\)) the number of physical qubits for these codes will scale with the volume of the manifolds.\nTherefore, bounds on the dimension of the second homology and size of systoles are achieved in terms of \\(n\\) for large \\(n\\).\n", "notes": [], "introduced": "\\cite{arXiv:1310.5555}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Protection stems from the relationship between properties of manifolds and CSS codes derived from their cellulation. The number of physical \\(k\\) qubits and distance \\(d\\) of the code will scale as \\(\\Omega(n)\\) and \\(\\Omega(n^\\epsilon)\\), respectively.", "code_id": "four_dimensional_hyperbolic"}, "3d_surface": {"name": "Solid code", "description": "A variant of Kitaev's surface code on a 3D lattice.", "notes": [], "introduced": "\\cite{arxiv:1406.4227}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "3d_surface"}, "hyperbolic_surface": {"name": "Hyperbolic surface code", "description": "An extension of the Kitaev surface code construction to hyperbolic manifolds in dimension two or greater. Given a cellulation of a manifold, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers are associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\(i+1\\)-faces.\n", "notes": [], "introduced": "", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Constructions (see code children below) have yielded distances scaling favorably with the number of qubits. The use of hyperbolic surfaces allows one to circumvent bounds on surface code parameters that are valid for surfaces with bounded geometry.", "code_id": "hyperbolic_surface"}, "two_dimensional_hyperbolic_surface": {"name": "Two-dimensional hyperbolic surface code", "description": "Hyperbolic surface codes based on a tessellation of a closed 2D manifold with a hyperbolic geometry (i.e., non-Euclidean geometry, e.g., saddle surfaces when defined on a 2D plane).\n\nFor a tessellation involving regular polygons with \\( r \\) sides and \\( s \\) polygons meeting at each edge, the number of logical qubits is given by \\( k = (1-2/r - 2/s) n + 2 \\). Some possible tilings are \\( {r,s}: {7,3}, {5,4} \\). The weight of the stabilizer generators are dependent on the tiling, with \\({5,4}\\) having lower weight than \\({7,3}\\).\n", "notes": ["See Sec III A of Ref. \\cite{arXiv:2103.06309} for a description of this code.", "Connection to percolation theory as shown in \\cite{arXiv:1205.7036}."], "introduced": "\\cite{arXiv:1506.04029}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Two-dimensional hyperbolic surface codes have an asymptotically constant encoding rate \\( k/n \\) with a distance scaling logarithmically with \\( n\\) when the surface is closed. The encoding rate depends on the tiling \\( {r,s} \\) and is given by \\( k/n = (1-2/r - 2/s) + 2/n \\), which approaches a constant value as the number of physical qubits grows. The weight of the stabilizers is \\( r \\) for \\( Z \\)-checks and \\( s \\) for \\( X \\)-checks. For open boundary conditions, the code reduces to constant distnace.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["1\\(\\%\\) - 5\\(\\%\\) for a \\({5,4}\\) tiling under minimum-weight decoding \\cite{doi:10.1103/PhysRevA.87.020304}. For larger tilings, the lower bound on the distance decreases, suggesting the threshold will also decrease."], "decoders": ["Due to the symmetries of hyperbolic surface codes, optimal measurement schedules of the stabilizers can be found \\cite{arXiv:2010.09626}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Protects against Pauli errors with distance \\( d \\propto \\log(n) \\). Code parameters are \\( [[n, (1-2/r - 2/s)  n + 2, O(\\log n) ]] \\)", "code_id": "two_dimensional_hyperbolic_surface"}, "higher_dimensional_surface": {"name": "Higher-dimensional surface code", "description": "A family of Kitaev surface codes on planar or toric surfaces of dimension greater than two. Stub.", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0110143}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "higher_dimensional_surface"}, "clifford-deformed_surface": {"name": "Clifford-deformed surface code (CDSC)", "description": "A generally non-CSS derivative of the surface code defined by applying a constant-depth Clifford circuit to the original (CSS) surface code. Unlike the surface code, CDSCs include codes whose thresholds and subthreshold performance are enhanced under noise biased towards dephasing. Examples of CDSCs include the XY code, XZZX code, and random CDSCs.", "notes": [], "introduced": "\\cite{arxiv:2201.07802}", "short_name": "CDSC", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["In order to leverage the benefits of CDSCs into practical universal computation, we have to implement syndrome measurement circuits and fault-tolerant logical gates in a bias-preserving way."], "threshold": [], "decoders": [], "code_capacity_threshold": ["A class of random CDSCs, parametrized by the probabilities \\(\\Pi_{XZ},~ \\Pi_{YZ}\\) of \\(X\\leftrightarrow Z\\) and \\(Y\\leftrightarrow Z\\) Pauli permutations, respectively, has \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.", "Certain translation-invariant CDSCs such as the XY code and the XZZX code also have \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.", "XZZX code and the \\((0.5,\\Pi_{YZ})\\) random CDSCs have a \\(50\\%\\) code capacity threshold for noise infinitely biased towards either Pauli-\\(X\\), \\(Y\\), or \\(Z\\) errors."], "transversal_gates": ""}, "physical": "qubits", "protection": "As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).", "code_id": "clifford-deformed_surface"}, "surface": {"name": "Kitaev surface code", "description": "A family of abelian topological \\hyperref[code:css]{CSS stabilizer} codes\nwhose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings\nassociated to the stars and plaquettes, respectively, of a cellulation of a\ntwo-dimensional surface (with a qubit located at each edge of the\ncellulation). \\textit{Toric code} often either refers to the construction on\nthe two-dimensional torus or is an alternative name for the general\nconstruction. The construction on surfaces with boundaries is often called the\n\\textit{planar code} \\cite{arXiv:quant-ph/9811052}.\n\nThe original construction can be naturally extended to arbitrary \\(D\\)-dimensional\nmanifolds\n\\cite{doi:10.1201/9781420035377-13,doi:10.1007/978-3-642-01877-0_21}. Given a\ncellulation, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers\nare associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are\nassociated with \\(i+1\\)-faces. Such extensions are often called the \\(D\\)\\textit{-dimensional surface} or \\(D\\)\\textit{-dimensional toric} codes.\n\nThe stabilizers of the surface code on the 2-dimensional torus are generated\nby star operators \\(A_v\\) and plaquette operators \\(B_p\\).  Each star operator\nis a product of four Pauli-\\(X\\) operators on the edges adjacent to a vertex\n\\(v\\) of the lattice; each plaquette operator is a product of four Pauli-\\(Z\\)\noperators applied to the edges adjacent to a face, or plaquette, \\(p\\) of the\nlattice (\\ref{figure:toric-code-operators}).\n\n\\begin{figure}\n  \\includegraphics{toric-code-operators}\n  \\caption{Stabilizer generators and logical operators of the 2D surface\n    code on a torus.  The star operators \\(A_v\\) and the plaquette operators\n    \\(B_p\\) generate the stabilizer group of the toric code.  The logical\n    operators are strings that wrap around the torus.}\n  \\label{figure:toric-code-operators}\n\\end{figure}\n\nThe two-dimensional toric code encodes two logical qubits.  We denote by\n\\(\\overline{X}_i,\\overline{Z}_i\\) the logical Pauli-\\(X\\) and Pauli-\\(Z\\)\noperator of the \\(i\\)-th logical qubit.  They can are represented by strings\nof Pauli-\\(X\\) operators or Pauli-\\(Z\\) operators that wrap around the torus\nas shown in \\ref{figure:toric-code-operators}.\n", "notes": ["\\textit{Surfmap} framework provides a way to stitch the surface code to various superconducting-circuit geometries by assigning each superconducting qubit to be either a physical or ancilla qubit, designing stabilizer measurement circuits, and scheduling stabilizer measurements \\cite{arxiv:2111.13729}.", "2D and 3D surface code \\href{http://gui.quantumcodes.io/}{visualization\ntool}.\n", "Tutorials from error-correction perspective by\n\\href{https://boulderschool.yale.edu/2018/boulder-school-2018-lecture-notes}{J. Haah}\nand condensed-matter perspective by\n\\href{https://boulderschool.yale.edu/2016/boulder-school-2016-lecture-notes}{M. Levin\nand C. Nayak}.\n"], "introduced": "\\cite{doi:10.1070/RM1997v052n06ABEH002155,doi:10.1007/978-1-4615-5923-8_19,arXiv:quant-ph/9707021}\n", "short_name": "", "logical": "qubits", "realizations": ["One cycle of syndrome readout on 19-qubit planar and 24-qubit toric codes realized in two-dimensional Rydberg atomic arrays \\cite{arxiv:2112.03923}.\n", "Signatures of corresponding topological phase of matter detected in superconducting circuits \\cite{arxiv:2104.01180} and two-dimensional Rydberg atomic arrays \\cite{arXiv:2104.04119}.\n"], "features": {"general_gates": ["Clifford gates can be implemented via lattice surgery\n\\cite{arXiv:1111.4022,arXiv:1709.02318,arXiv:1808.02892,arXiv:2109.02746},\ntwist-based lattice surgery \\cite{arxiv:2201.05678}, or braiding defects\n\\cite{arXiv:quant-ph/0610082,arXiv:quant-ph/0703143,arXiv:1208.0928,arXiv:1609.04673}.\n", "Non-Clifford gates require magic state distillation\n\\cite{arXiv:1905.06903}, Dehn twists \\cite{arxiv:1806.06078}, or\njust-in-time decoding \\cite{arXiv:1903.11634}.\n"], "encoders": ["For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit \\cite{arXiv:2002.00362,arxiv:2110.02020} or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates \\cite{arXiv:0712.0348,arXiv:1207.0253} (matching a lower bound in Ref. \\cite{arXiv:1810.03912}).", "Lindbladian-based dissipative encoding for the toric code \\cite{arXiv:1310.1036} that does not give a speedup relative to circuit-based encoders \\cite{arxiv:1310.1037}.", "Stabilizer measurement-based circuit of linear depth \\cite{arXiv:quant-ph/0110143,arXiv:1404.2495}."], "rate": "Rate depends on the underlying cellulation and manifold. For general 2D\nmanifolds, \\(kd^2\\leq c(\\log k)^2 n\\) for some constant \\(c\\)\n\\cite{arXiv:1301.6588}, meaning that (1) 2D surface codes with bounded\ngeometry have distance scaling at most as \\(O(\\sqrt{n})\\)\n\\cite{arXiv:0909.5200,doi:10.1063/1.4726034}, and (2) surface codes with\nfinite rate can only achieve an asymptotic minimum distance that is\nlogarithmic in \\(n\\). Higher-dimensional hyperbolic manifolds (see code\nchildren below) yield distances scaling more favorably. Loewner's theorem\nprovides an upper bound for any bounded-geometry surface code\n\\cite{doi:10.1201/9781420035377-13}.\n", "magic_scaling_exponent": "", "fault_tolerance": ["Transversal (non-Clifford) CCZ gate by bringing 2D surface codes together and using just-in-time decoding \\cite{arxiv:1903.11634}. Gate can be simulated by taking 2D slices out of 3D surface codes \\cite{arXiv:2012.08536}.", "Homomorphic measurement protocols for arbitrary surface codes \\cite{arxiv:2211.03625}."], "threshold": ["\\(1.8\\%\\) for circuit-level depolarizing noise under optimal decoder \\cite{arxiv:1609.06373}. \\(0.57\\%\\) for depolarizing noise on data and syndrome qubits as well initialization, gate, and measurement errors under MPWM decoding \\cite{arxiv:1208.0928}. For this model, a logical qubit with a \\(10^{-14}\\) logical error rate requires between \\(10^3\\) to \\(10^4\\) physical qubits and a target gate fidelity above \\(99.9\\%\\). Later work showed that arbitrarily large computations are possible for a physical error rate of approximately \\(10^{-4}\\) \\cite{arxiv:1206.0800}.", "\\(0.35\\%\\) for circuit-level independent \\(X,Z\\) noise under optimal decoder \\cite{arxiv:1609.06373}.", "\\(0.5-2.9\\%\\) for various noise models \\cite{arxiv:0811.0464} (see also Refs. \\cite{arXiv:quant-ph/0207088,arXiv:1311.5003})."], "decoders": ["Maximum-likelihood (ML) \\cite{arxiv:quant-ph/0110143}, which takes time of order \\(O(n^2)\\) for independent \\(X,Z\\) noise \\cite{arxiv:1405.4883}.", "Minimum weight perfect-matching (MWPM) \\cite{arXiv:quant-ph/0110143,arXiv:1307.1740} (based on work by Edmonds on finding a matching in a graph \\cite{doi:10.4153/CJM-1965-045-4,doi:10.6028/jres.069B.013}). Pipeline MWPM \\cite{arXiv:1310.0863,arXiv:2205.09828} - a modification accounting for correlations between events. A modification utilizing the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) \\cite{arxiv:2107.13589}. Correlated matching modifies MWPM to include correlations between \\(X\\) and \\(Z\\)-type errors \\cite{arxiv:1310.0863}. Belief perfect matching is a combination of belief-propagation and MWPM \\cite{arxiv:2203.04948}.", "Renormalization group (RG) \\cite{arXiv:0911.0581,arXiv:1304.6100,arXiv:1411.3028}.", "Markov-chain Monte Carlo \\cite{arXiv:1302.2669}.", "Tensor network \\cite{arXiv:1405.4883}.", "Cellular automaton \\cite{doi:10.7907/AHMQ-EG82,arXiv:1511.05579}.", "Neural network \\cite{arXiv:1610.04238,arXiv:1802.06441,arXiv:1810.07207,arxiv:2208.05758}.", "Union-find \\cite{arXiv:1709.06218}. A subsequent modification utilizes the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) \\cite{arxiv:2107.13589}. Belief union find is a combination of belief-propagation and union-find \\cite{arxiv:2203.04948}.", "Decoders can be augmented with a pre-decoder \\cite{arXiv:2001.11427,arXiv:2208.04660}, which can allow for some processing to be done inside the cryogenic environment of the quantum system \\cite{arxiv:2208.08547}.", "Sliding-window \\cite{arxiv:2209.09219,arxiv:2209.08552} and parallel-window \\cite{arxiv:2209.09219} parallelizable decoders can be combined with many inner decoders, such as MWPM or union-find."], "code_capacity_threshold": ["Independent \\(X,Z\\) noise: \\(10.31\\%\\) under MWPM decoding \\cite{arxiv:quant-ph/0207088} (see also Ref. \\cite{arxiv:1405.4883}). The threshold under ML decoding corresponds to the value of critical point of the two-dimensional random-bond Ising model on the Nishimori line \\cite{arxiv:quant-ph/0110143}, calculated to be \\(10.94 \\pm 0.02\\%\\) in Ref. \\cite{arXiv:cond-mat/0001014}, \\(10.93(2)\\%\\) in Ref. \\cite{arxiv:cond-mat/0106023}, and estimated to be between \\(10.9\\%\\) and \\(11\\%\\) in Ref. \\cite{arxiv:1405.4883}.", "Depolarizing noise: between \\(17\\%\\) and \\(18.5\\%\\) under tensor-network decoding \\cite{arxiv:1405.4883}, and between \\(15\\%\\) and \\(16\\%\\) under RG \\cite{arXiv:0911.0581}, Markov-chain \\cite{arXiv:1302.2669}, or MWPM \\cite{arXiv:0905.0531} decoding. The threshold under ML decoding corresponds to the value of critical point in the disordered eight-vertex Ising model, calculated to be \\(18.9(3)\\%\\) \\cite{arXiv:1202.1852} (see also APS Physics viewpoint \\cite{doi:10.1103/Physics.5.50}).", "Erasure noise: \\(50\\%\\) for square tiling \\cite{arXiv:0904.3556}. There is an inverse relationship between coordination number of the syndrome graph, with the threshold corresponding to a percolation transition \\cite{arxiv:1810.09621}.", "Phenomenological noise: \\(3.3\\%\\) for square tiling \\cite{arXiv:quant-ph/0401101}."], "transversal_gates": "Transversal Pauli gates exist and are based on non-trivial loops on surface.\nTransversal Clifford gates can be done on folded surface codes \\cite{arxiv:1603.02286}.\n"}, "physical": "qubits", "protection": "Toric code on an \\(L\\times L\\) torus is a \\([[2L^2,2,L]]\\) CSS code, and there\nexists a planar code with \\([[L^2,1,L]]\\) \\cite{arxiv:1111.4022}. More\ngenerally, the code distance is related to the homology of the cellulation\n\\cite{arXiv:quant-ph/0110143}.\n\nCoherent physical errors are expected to become incoherent logical errors after MWPM decoding; see corroborating numerical studies performed via the Majorana mapping \\cite{arxiv:1710.02270} as well as analytical bounds \\cite{arxiv:1912.04319}.\n", "code_id": "surface"}, "haar_random": {"name": "Haar-random code", "description": "Haar-random codewords are generated in a process involving averaging over unitary operations distributed accoding to the Haar measure. Haar-random codes are used to prove statements about the capacity of a quantum channel to transmit quantum information \\cite{arXiv:1106.1445}, but encoding and decoding in such \\(n\\)-qubit codes quickly becomes impractical as \\(n\\to\\infty\\).\n\nThere are different approaches to create Haar-random codewords. In the construction of Ref. \\cite{arXiv:quant-ph/0702005}, codewords are produced by performing a unitarily covariant projective measurement on a \\textit{typical} subspace of a tensor-power state. Reference \\cite{arXiv:quant-ph/0702005} showed that the capacity of a noisy quantum channel can be achieved by encoding in such Haar-random codes. In particular, Haar-random codes achieve perfect transmission in the \\(n\\to\\infty\\)) limit by proving that the encoded information becomes decoupled from the environment. This is a necessary and sufficient condition for successful decoding since measurements of the environment should never reveal the encoded information \\cite{arxiv:quant-ph/9604022}.\n\nIntuitively, coupling with the environment can be decreased by projecting the system onto a random codespace. The more qubits that are randomly discarded, the more the codespace is decoupled from the environment. One may ask what is the least amount of qubits that can be discarded, i.e. the largest remaining codespace, that still achieves decoupling. It can be shown through the decoupling inequality \\cite{arXiv:quant-ph/0512247} that the largest possible dimension of the random codespace that achieves arbitrarily large decoupling is exponential in the coherent information of the channel. Therefore, there exist codes that can transmit information with rate equal to the coherent information. Furthermore, these codes can be constructed with high probability by performing a Haar-random isometry embedding a \\(k\\)-dimensional logical subspace into an \\(n\\)-dimensional physical space, where \\(k/n\\) is equal to the coherent information. Such an isometry can be produced by QR decomposition of a Gaussian random matrix \\cite{doi:10.1137/0717034}.\n", "notes": [], "introduced": "\\cite{manual:{Peter W. Shor, \\href{https://github.com/errorcorrectionzoo/eczoo_data/files/7808154/shor.pdf}{The quantum channel capacity and coherent information}, 2002 (obtained from the MSRI Workshop on Quantum Computation website).},arXiv:quant-ph/0702005,arXiv:quant-ph/0304127,arXiv:0712.2558}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "The rate of the code is equal to the coherent information of the channel (i.e. the quantum channel capacity).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Random code achieve the capacity of any noisy quantum channel.", "code_id": "haar_random"}, "crystalline_dynamic_gen": {"name": "Crystalline-circuit code", "description": "Code dynamically generated by unitary Clifford circuits defined on a lattice with some crystalline symmetry. A notable example is the circuit defined on a rotated square lattice with vertices corresponding to iSWAP gates and edges decorated by \\(R_X[\\pi/2]\\), a single-qubit rotation by \\(\\pi/2\\) around the \\(X\\)-axis. This circuit is invariant under space-time translations by a unit cell \\((T, a)\\) and all transformations of the square lattice point group \\(D_4\\).\n\nThe input state to the circuit is taken to be a product stabilizer state with finite entropy density. If the input is translation-invariant, then this periodicity is preserved by the circuit at all later times, so the code is a quantum quasi-cyclic code with unit cell \\(a\\). The initial product state recurs after a time \\(\\tau(n)\\) that is linear in \\(n\\) for \\(n=a 2^k\\), but is thought to be exponential for generic \\(n\\).\n", "notes": [], "introduced": "\\cite{arxiv:2210.10808}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": ["Clifford quantum cellular automaton (CQCA) that preserves crystalline symmetry."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "The code protects against Pauli errors. The circuit composed of iSWAP and \\(R_X[\\pi/2]\\) gates on the square lattice is a \u201cgood scrambler\u201d with non-fractal operator spreading and thus behaves like a random circuit in that regard, motivating the use of contiguous code distance as a proxy for code distance.\n\nFor the \\(D_4\\) example above, the unit cell \\(a=2\\), and the initial product group is chosen to have code rate \\(1/2\\). The parameters of the code are \\([[n, n/2, d(t)]]\\), and the contiguous code distance \\cite{arxiv:0810.1983} grows linearly before saturating at \\(O(n)\\).\n\nSelecting the code defined by the stabilizer group at the time when the contiguous distance is maximized and subjecting it to random erasures, an optimal threshold of \\(1/4\\) is achieved for a subset of system sizes \\cite{arxiv:1703.01517,arxiv:2010.09775}. The subthreshold scaling is competitive with random codes, which obey the random matrix theory ansatz \\cite{arxiv:2010.09775}.\n", "code_id": "crystalline_dynamic_gen"}, "floquet_color": {"name": "Floquet color code", "description": "Stub.\n", "notes": [], "introduced": "\\cite{doi:10.26081/K6F65V}", "short_name": "", "logical": "qubits", "realizations": ["Plaquette stabilizer measurement realized on the IBM Falcon superconducting-qubit device \\cite{arxiv:2210.13154}"], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "floquet_color"}, "t-designs": {"name": "Local Haar-random circuit code", "description": "An \\(n\\)-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal \\(n\\)-qubit states and acting with a random unitary circuit of depth polynomial in \\(n\\). Two states are \\textit{locally indistinguishable} if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about \\(n/2\\) two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries.\nThe above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (\\(D=1\\), while codes for higher-dimensional geometries require \\(O(n^{1/D})\\)-depth circuits \\cite{doi:10.1007/s00220-016-2706-8}. Follow-up work \\cite{arxiv:2010.09775} revealed that optimal code properties require only \\(O(\\sqrt{n})\\)-depth circuits for that case, and \\(O(\\sqrt{n})\\)-depth circuits for a two-dimensional square-lattice geometry.", "notes": [], "introduced": "\\cite{doi:10.1007/s00220-016-2706-8}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": ["Random local circuit of depth proportional to \\(n^{\\alpha}\\), with \\(\\alpha\\) depending on system geometry."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "In a 1D geometry, the code approximately detects any error with support on a segment of length \\(\\leq n/4\\), with deviations exponentially suppressed in \\(n\\).", "code_id": "t-designs"}, "floquet": {"name": "Floquet code", "description": "Dynamically-generated stabilizer-based code whose logical qubits are generated through a particular sequence of check-operator measurements such that the number of logical qubits is larger than when the code is viewed as a static subsystem stabilizer code.\nAfter each measurement in the sequence, the codespace is a joint \\(+1\\) eigenspace of an \\textit{instantaneous stabilizer group (ISG)}, i.e., a particular stabilizer group corresponding to the measurement. The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured in the next step in the sequence. As opposed to subsystem codes, only specific measurement sequences maintain the codespace.\n", "notes": [], "introduced": "\\cite{arXiv:2107.02194}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Protects against single-qubit Pauli noise and check operator measurement errors.", "code_id": "floquet"}, "nonlocal_lowdepth": {"name": "Low-depth random Clifford-circuit code", "description": "An encoder for an \\([[n,k]]\\) quantum error correcting code, is an \\(n\\)-qubit unitary transformation that takes a \\(k\\)-qubit state as input (with \\(k\\leq n\\), and the remaining \\(n-k\\) qubits initialized to \\(|0\\rangle^{\\otimes n-k}\\) ) to give a corresponding state in the codespace as the output. An n-qubit quantum circuit with random 2-qubit Clifford gates can act as an encoder into a code with distance \\(d\\) with high probability, with a size (i.e. number of gates in the circuit) at most \\(O(n^2 log n)\\)). Noting that two gates acting on disjoint qubits could in fact be executed simultaneously, this is equivalent to the depth (number of time steps in the circuit) being at most \\(O(log^3 n)\\).", "notes": [], "introduced": "\\cite{arXiv:1312.7646}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Creates a random \\([[n,k,d]]\\) stabilizer code that detects errors on \\(d-1\\) qubits, and corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "code_id": "nonlocal_lowdepth"}, "honeycomb": {"name": "Honeycomb Floquet code", "description": "Floquet code inspired by the Kitaev honeycomb model \\cite{arXiv:cond-mat/0506438} whose logical qubits are generated through a particular sequence of measurements.\n\nThe code is defined on a hexagonal (honeycomb) lattice with a physical qubit located at each vertex. Edges are labeled \\(x\\), \\(y\\), and \\(z\\), such that one edge of each label meet at every vertex. Check operators are defined as \\(XX\\) acting on any two qubits joined by an \\(x\\) edge, and similarly for \\(y\\) and \\(z\\). The hexagonal lattice is 3-colorable, so the hexagons may be labeled 0, 1, 2 such that no two neighboring hexagons have the same label.\n\nThe code-generating measurement pattern consists of measuring the check operators located on all of the \\(r\\)-labeled edges in round \\(r\\) mod 3. The code space is the \\(+1\\) eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured.\n\nA CSS version of the code has been proposed which loosens the restriction of which sequences to use \\cite{arxiv:2210.02468}.\n", "notes": [], "introduced": "\\cite{arXiv:2107.02194}", "short_name": "", "logical": "qubits", "realizations": ["Plaquette stabilizer measurement realized on the IBM Falcon superconducting-qubit device \\cite{arxiv:2210.13154}"], "features": {"general_gates": ["There are two types of logical operators, \\textit{inner} and \\textit{outer}. An inner logical operator is the product of check operators on a homologically nontrivial cycle. They belong to the stabilizer group as a subsystem code. Outer logical operators have an interpretation in terms of magnetic and electric operators of an embedded surface code, and they do not belong to the stabilizer group of the associated subsystem code."], "encoders": ["Initialization can be performed by preparing each pair of qubits  on an edge in some particular state independently specified by the effective-one-qubit operators (two-qubit Pauli strings centered on an edge) and then beginning the check measurement sequence. This is analogous to projecting a state into the code space by measuring stabilizers."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["One can run a fault-tolerant decoding algorithm by (1) bipartitioning the syndrome lattice into two graphs which are congruent to the Cayley graph of the free abelian group with three generators (up to boundary conditions) and (2) performing a matching algorithm to deduce errors."], "threshold": ["\\(0.2\\%-0.3\\%\\) in a controlled-not circuit model with a correlated minimum-weight perfect-matching decoder \\cite{arXiv:2108.10457}.", "\\(1.5\\%<p<2.0\\%\\) in a circuit model with native two-body measurements and a correlated minimum-weight perfect-matching decoder \\cite{arXiv:2108.10457}. Here, \\(p\\) is the collective error rate of the two-body measurement gate, including both measurement and correlated data depolarization error processes.", "Against circuit-level noise: within \\(0.2\\% \u2212 0.3\\%\\) for SD6 (standard depolarizing 6-step cycle), \\(0.1\\% \u2212 0.15\\%\\) for SI1000 (superconducting-inspired 1000 ns cycle), and \\(1.5\\% \u2212 2.0\\%\\) for EM3 (entangling-measurement 3-step cycle) \\cite{arxiv:2202.11845,arxiv:2202.11829}."], "decoders": ["The ISG has a static subgroup for all time steps \\(r\\geq 3\\) \u2013 that is, a subgroup which remains a subgroup of the ISG for all future times \u2013 given by so-called \\textit{plaquette stabilizers}. These are stabilizers consisting of products of check operators around homologically trivial paths. The syndrome bits correspond to the eigenvalues of the plaquette stabilizers. Because of the structure of the check operators, only one-third of all plaquettes are measured each round. The syndrome bits must therefore be represented by a lattice in spacetime, to reflect when and where the outcome was obtained."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Protective features similar to the surface code: on a torus geometry, the code protects two logical qubits with a code distance proportional to the linear size of the torus. Properties of the code with open boundaries are discussed in Refs. \\cite{arXiv:2110.09545,arXiv:2110.05348}, and various other generalizations have been proposed \\cite{arxiv:2203.11137}.", "code_id": "honeycomb"}, "monitored_random_circuits": {"name": "Monitored random-circuit code", "description": "Error-correcting code arising from a monitored random circuit. Such a circuit is described by a series of intermittant random local projective Pauli measurements with random unitary time-evolution operators. An important sub-family consists of \\textit{Clifford monitored random circuits}, where unitaries are sampled from the Clifford group \\cite{arxiv:1901.08092}. When the rate of projective measurements is independently controlled by a probability parameter \\(p\\), there can exist two stable phases, one described by volume-law entanglement entropy and the other by area-law entanglement entropy. The phases and their transition can be understood from the perspective of quantum error correction, information scrambling, and channel capacities \\cite{arXiv:1903.05124,arXiv:1905.05195}.\n\nMonitored random circuits have a finite information capacity that decays exponentially with respect to system size \\cite{arXiv:1905.05195}. When \\( p = 0 \\), the random circuit achieves channel capacity, meaning that it stores the most amount of information possible. This notion quantifies the recoverability of information and the reversability of the system under the monitored random dynamics. In the volume-law phase (\\( p < p_c \\) for some critical probability \\(p_c\\)), the channel capacity remains non-zero, and the monitored channel projects an initial state into a random error-correcting code \\cite{arXiv:1905.05195}. With appropriately chosen evolution operators and measurements, the code is a stabilizer code whose parameters depend on time, \\( [[n,k(t),d(t)]] \\). A similar notion applies to Haar random circuits with measurements \\cite{arXiv:1911.00008}.\n", "notes": ["Connections to information scrambling in black hole physics, as introduced in Section 11 of \\cite{arXiv:1903.05124}. In particular, monitored random circuits can be viewed as the Hayden-Preskill recovery problem \\cite{doi:10.1103/PhysRevD.100.086001} running backwards in time. In this setting, the volume-law entanglement phase of the monitored circuit describes the phase when information can be recovered from an old black hole (ie, a black hole that is maximally entangled with the early universe).", "Mapping monitored random circuits to statistical mechanics models can help estimate thresholds and code distances for these systems \\cite{arXiv:2007.03822}."], "introduced": "\\cite{doi:10.1103/PhysRevX.9.031009,doi:10.1103/PhysRevB.98.205136,arXiv:1808.05949}", "short_name": "", "logical": "qubits", "realizations": ["Measurement induced quantum phases have been realized in a trapped-ion processor \\cite{arXiv:2106.05881}."], "features": {"general_gates": [], "encoders": ["The dynamics of the monitored random circuit can be recast in the language of stabilizer codes \\cite{arXiv:1905.05195}. The stabilizer group of the error-correcting code resulting from a monitored Clifford circuit either grows or shrinks with each time step, depending on which projective measurements were performed during the time step.", "One can construct optimal single-copy encoding operations for strong purification transitions \\cite{arXiv:1905.05195}"], "rate": "Rate can be finite \\cite{arXiv:1905.05195}, depending on the family of random codes generated by the circuit.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["Above the critical measurement rate \\( p_c\\), the natural error correction properties of the circuit can no longer protect the information. This can be interpreted as the code threshold.", "These dynamically generated codes saturate the trade off between density of encoded information and the error rate threshold \\cite{arXiv:1905.05195}"], "decoders": ["The recovery operation is the reverse unitary transformation with access to the measurement record (for dynamically generated codes with a strong purification transition) \\cite{arXiv:1905.05195}"], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "When in the volume-law phase, protects against random projective measurements at a rate \\( p < p_c \\). While the true code distance is not known, it is conjectured to be proportional to the contiguous distance. As first described in Ref. \\cite{arXiv:1905.05195}, the  contiguous distance for these circuits is defined with respect to all partitions of the system.", "code_id": "monitored_random_circuits"}, "quantum_divisible": {"name": "Quantum divisible code", "description": "Consider a CSS code whose \\(Z\\)-stabilizers are determined by the dual of a classical \\([n, k_1]\\) linear binary code \\(C_1\\), and whose \\(X\\)-stabilizers are determined by a classical \\([n, k_2]\\) binary code \\(C_2 \\subset C_1\\). This code is quantum divisible if all weights in \\(C_2\\) share a common divisor \\(\\Delta > 1\\), and all weights in each coset of \\(C_2\\) in \\(C_1\\) are congruent to \\(\\Delta\\).\n\nFor example, if \\(C_2\\) is the first-order Reed-Muller code, and \\(C_1/ C_2\\) consists of quadratic forms with a bounded rank, then \\([[n = 2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), d = 3]]\\) is a family of quantum divisible codes.\n", "notes": [], "introduced": "\\cite{arXiv:2204.13176}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["The \\([[2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), 3]]\\) quantum divisible code family can serve as outer codes of either the five-qubit \\([[5,1,3]]\\) or Steane \\([[7,1,3]]\\) code to realize a \\(T\\) gate on the inner code. For example, when \\(m=5\\) (\\(m=6\\)), the resulting \\([[31,5,3]]\\) (\\([[63,7,3]]\\)) code yields the \\(T\\) gate on the inner five-qubit (Steane) code."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["The \\(T\\) gate realized by concatenating members of the \\([[2m \u2212 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m \u2212 i), 3]]\\) quantum divisible code family with either the five-qubit \\([[5,1,3]]\\) or Steane \\([[7,1,3]]\\) code is fault-tolerant and does not require magic-state distillation. The gate is performed on the inner five-qubit/Steane code and does require encoding and decoding algorithms to pass between the inner and outer codes."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Distance \\(d\\) is upper bounded by the two classical codes that determine the CSS code.", "code_id": "quantum_divisible"}, "quantum_hamming": {"name": "\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming code", "description": "A family of stabilizer codes of distance \\(3\\) that asymptotically saturate quantum Hamming bound.", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9604038}", "short_name": "\\([[2^r, 2^r-r-2, 3]]\\)", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Concatenations of Hamming codes yield fault-tolerant quantum computation with constant space and quasi-polylogarithmic time overheads \\cite{arxiv:2207.08826}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Protects against any single qubit error.", "code_id": "quantum_hamming"}, "diagonal_clifford": {"name": "\\([[2^r-1, 1, 3]]\\) quantum Reed-Muller code", "description": "Member of CSS code family constructed with a first-order punctured RM\\((1,r)\\) \\([2^r-1,r+1,2^{r-1}-1]\\) code and its even subcode for \\(r \\geq 3\\). Each code transversally implements a member of an infinite family of diagonal gates from the Clifford hierarchy \\cite{arxiv:1608.06596}.", "notes": [], "introduced": "\\cite{arxiv:quant-ph/9908010,arXiv:quant-ph/0611214}", "short_name": "\\([[2^r-1, 1, 3]]\\)", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "\\(Z\\)-rotation by angle \\(-\\pi/2^{r-1}\\) \\cite{arxiv:quant-ph/0611214}."}, "physical": "qubits", "protection": "", "code_id": "diagonal_clifford"}, "quantum_hamming_css": {"name": "\\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS code", "description": "A Hamming-based CSS code is a CCS code constructed with a classical Hamming code \\([2^r-1,2^r-1-r,3]=C_X=C_Z\\) \\textit{a.k.a.} a first-order punctured Reed-Muller code RM\\((r-2,r)\\).", "notes": [], "introduced": "", "short_name": "\\([[2^r-1, 2^r-2r-1, 3]]\\)", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Syndrome measurement can be done with two ancillary flag qubits \\cite{arxiv:1705.02329}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Protects against any single qubit error.", "code_id": "quantum_hamming_css"}, "tfim": {"name": "Transverse-field Ising model (TFIM) code", "description": "A 1D translationally invariant stabilizer code whose encoding is a constant-depth circuit of nearest-neighbor gates on alternating even and odd bonds that consist of transverse-field Ising Hamiltonian interactions. The code allows for perfect state transfer of arbitrary distance using local operations and classical communications (LOCC).", "notes": [], "introduced": "\\cite{arXiv:2205.12998}", "short_name": "TFIM", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": ["1D geometrically local constant-depth brickwork circuit of nearest-neighbor gates on alternating even and odd bonds. Gates are generated by interaction terms of the transverse-field Ising Hamiltonian."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Code distance is 1 for open boundary conditions similar to a repetition code, and 3 for periodic boundary conditions with an encoding circuit depth of 4.", "code_id": "tfim"}, "quantum_h": {"name": "H code", "description": "Family of \\([[k+4,k,2]]\\) CSS codes with transversal Hadamard gates; relevant to magic state distillation. Four stablizer generators are \\(X_1X_2X_3X_4\\), \\(Z_1Z_2Z_3Z_4\\), \\(X_1X_2X_5X_6...X_{k+4}\\), and \\(Z_1Z_2Z_5Z_6...Z_{k+4}\\).", "notes": [], "introduced": "\\cite{arXiv:1210.3388}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["The H codes can be used for high-quality and high-efficiency magic-state distillation \\cite{arXiv:1210.3388}. Their associated multi-level magic states protocols have an efficency advantage over the 10-to-2 and 15-to-1 protocals for output error below \\(10^{-7}\\)."], "encoders": [], "rate": "The H codes are dense, i.e., the rate \\(\\frac{k}{k+4}\\rightarrow 1\\) as \\(k \\rightarrow \\infty\\). The distance is 2. However an \\(r\\)-level concatenation of H codes gives a distance of \\(2^r\\).", "magic_scaling_exponent": "A total of \\(r\\) rounds of magic-state distillation yields a magic-state scaling exponent \\(\\gamma\\to 1\\) as \\(k,r\\rightarrow \\infty\\). This matches a conjectured bound for \\(\\gamma\\) \\cite{arXiv:1209.2426}.", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "Hadamard and \\(TXT^{\\dagger}\\) gates, with the latter Clifford-equivalent to Hadamard, and where \\(T=\\exp(i\\pi(I-Z)/8)\\) is the \\(\\pi/8\\)-rotation gate."}, "physical": "qubits", "protection": "Detects weight-1 Pauli errors. The \\(r\\)-level contatenated H code detects weight Pauli errors up to weight \\(2^r-1\\).", "code_id": "quantum_h"}, "quantum_repetition": {"name": "Quantum repetition code", "description": "Encodes \\(1\\) qubit into \\(n\\) qubits according to \\(|0\\rangle\\to|\\phi_0\\rangle^{\\otimes n}\\) and \\(|1\\rangle\\to|\\phi_1\\rangle^{\\otimes n}\\). Also known as a \\textit{bit-flip} code when \\(|\\phi_i\\rangle = |i\\rangle\\), and a \\textit{phase-flip} code when \\(|\\phi_0\\rangle = |+\\rangle\\) and \\(|\\phi_1\\rangle = |-\\rangle\\).\n\nThe \\(\\pm\\)-basis codewords for the bit-flip code are GHz (a.k.a. cat) states \\(|0\\rangle^{\\otimes n}\\pm|1\\rangle^{\\otimes n}\\). These are ground states of the one-dimensional \\textit{classical Ising model} Hamiltonian \\(H=\\sum_{i} Z_{i}Z_{i+1}\\).\n\nThe \\(\\pm\\)-basis codewords for the phase-flip code are expanded in the computational basis as\n\\begin{align}\n  \\begin{split}\n    |\\overline{+}\\rangle =\\frac{1}{\\sqrt{2^{n-1}}}\\sum_{\\sum_{i}v_{i}=0}|v_{1},\\cdots,v_{n}\\rangle~{\\phantom{,}}\\\\\n    |\\overline{-}\\rangle =\\frac{1}{\\sqrt{2^{n-1}}}\\sum_{\\sum_{i}v_{i}=1}|v_{1},\\cdots,v_{n}\\rangle~,\n  \\end{split}\n\\end{align}\nshowing that the phase-flip code stores information in the total parity of the qubits.\n", "notes": ["Repetition codes can be used to benchmark device performance \\cite{arxiv:2202.11045}."], "introduced": "\\cite{doi:10.1103/PhysRevA.32.3266}", "short_name": "", "logical": "qubits", "realizations": ["NMR: 3-qubit phase-flip code \\cite{arxiv:quant-ph/9802018,arXiv:1108.4842}, with up to two rounds of error correction in liquid-state NMR \\cite{arXiv:1109.4821}.", "Superconducting circuits: 3-qubit phase-flip and bit-flip code by Schoelkopf group \\cite{arXiv:1109.4948}; 3-qubit bit-flip code \\cite{arXiv:1411.5542}; 3-qubit phase-flip code up to 3 cycles of error correction \\cite{arXiv:1508.01388}; IBM 15-qubit device \\cite{arXiv:1709.00990}; IBM Rochester device using 43-qubit code \\cite{arXiv:2004.11037}; Google system performing up to 8 error-correction cycles on 5 and 9 qubits \\cite{arXiv:1411.7403}; Google Quantum AI Sycamore utilizing up to 11 physical qubits and running 50 correction rounds \\cite{arXiv:2102.06132}; Google Quantum AI Sycamore utilizing up to 25 qubits for comparison of logical error scaling with a quantum code \\cite{arxiv:2207.06431} (see also \\cite{arxiv:2211.04728}).", "Continuous error correction protocols have been implemented on a 3-qubit superconducting qubit device \\cite{arxiv:2107.11398}.", "Semiconductor spin-qubit devices: 3-qubit devices at RIKEN \\cite{arXiv:2201.08581} and Delft \\cite{arXiv:2202.11530}.", "Nitrogen-vacancy centers in diamond: 3-qubit phase-flip code \\cite{arXiv:1309.6424,doi:10.1038/s42005-022-00875-6} (see also Ref. \\cite{arXiv:1309.5452}).", "Trapped-ion device: 3-qubit phase-flip algorithm implemented in 3 cycles on high fidelity gate operations \\cite{doi:10.1126/science.1203329}."], "features": {"general_gates": ["Toffoli magic-state preparation protocol \\cite{arXiv:2012.04108}."], "encoders": ["Lindbladian-based dissipative encoding passively protecting against bit flips \\cite{arxiv:quant-ph/0110111,arxiv:1702.08673}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Toffoli magic-state preparation protocol \\cite{arXiv:2012.04108}."], "threshold": [], "decoders": ["Automaton-like decoders for the repetition code on a 2D lattice, otherwise known as the classical 2D Ising model, were developed by Toom \\cite{manual:{A. L. Toom, \u201cNonergodic Multidimensional System of Automata\u201d, Probl. Peredachi Inf., 10:3 (1974), 70\u201379; Problems Inform. Transmission, 10:3 (1974), 239\u2013246},doi:10.1007/978-1-4612-2168-5_18}. An automaton by Gacs yields a decoder for a 1D lattice \\cite{doi:10.1023/A:1004823720305}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Bit-flip code detects bit-flip errors \\(X\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any phase-flip errors \\(Z\\). Phase-flip code detects phase-flip errors \\(Z\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any bit-flip errors \\(X\\). Because they protect against only one type of noise, both codes can be thought of as a classical \\([n,1,d]\\) repetition code with classical distance \\(d=\\left\\lfloor (n-1)/2\\right\\rfloor\\) embedded in a quantum system.", "code_id": "quantum_repetition"}, "stab_4_2_2": {"name": "\\([[4,2,2]]\\) CSS code", "description": "Also known as the \\(C_4\\) code. Four-qubit CSS stabilizer code with generators \\(\\{XXXX, ZZZZ\\} \\) and codewords\n\\begin{align}\n  \\begin{split}\n    |\\overline{00}\\rangle = (|0000\\rangle + |1111\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{01}\\rangle = (|0011\\rangle + |1100\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{10}\\rangle = (|0101\\rangle + |1010\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{11}\\rangle = (|0110\\rangle + |1001\\rangle)/\\sqrt{2}~.\n  \\end{split}\n\\end{align}\nThis code is the smallest single-qubit error-detecting code. It is also the smallest instance of the toric code, and its various single-qubit subcodes are small planar surface codes.\n\nThe subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is a \\([[4,1,2]]\\) code \\cite{arXiv:quant-ph/9704002}, whose \\(\\pm\\)-basis codewords can be written as\n\\begin{align}\n  |\\overline{\\pm}\\rangle = \\frac{1}{2}(|00\\rangle \\pm |11\\rangle)^{\\otimes 2}~.\\\\\n\\end{align}\nThis code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code. The subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\) \\cite{arxiv:quant-ph/0103042} has also been studied against amplitude-damping noise. This subcode \\cite{arxiv:2006.03071} and the subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) \\cite{arxiv:1912.09410}, \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) \\cite{arXiv:2102.06132}, and \\(\\{|\\overline{00}\\rangle,|\\overline{11}\\rangle\\}\\) \\cite{arXiv:2102.13071} are small planar surface codes.\n", "notes": ["Concatenating \\([[4,2,2]]\\) code with surface code can generate 2D topological code with a reasonable circuit-based threshold \\cite{doi:10.26421/QIC16.15-16-1}."], "introduced": "\\cite{arXiv:quant-ph/9603031}", "short_name": "\\([[4,2,2]]\\)", "logical": "qubits", "realizations": ["\\([[4,1,2]]\\) subcode implemented using four-qubit graph state of photons \\cite{arXiv:1404.5498}.\n", "Trapped-ion device by IonQ \\cite{arXiv:1611.06946}.", "Logical state preparation and flag-qubit error correction realized in superconducting-circuit devices by IBM \\cite{arXiv:1705.09259,arXiv:2110.04285}.", "The subcode \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) \\cite{arXiv:1912.09410} and \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) \\cite{arXiv:2102.06132}, treated as a planar surface code, has been realized in superconducting-circuit devices.", "Logical gates between two copies of the subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\), interpreted as lattice surgery between planar surface codes, realized in superconducting circuits \\cite{arXiv:2006.03071}.", "Logical gates for the \\(\\{|\\overline{00}\\rangle,|\\overline{11}\\rangle\\}\\) subcode, treated as a planar code, realized in superconducting circuits \\cite{arXiv:2102.13071}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Preparation of certain states along with transversal gates can be performed fault-tolerantly, but requires post-selection because the code cannot correct errors \\cite{arxiv:1610.03507}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "Transversal Pauli, Hadamard, and two-qubit \\(R\\) gates \\cite{arxiv:1610.03507}."}, "physical": "qubits", "protection": "Detects a single-qubit error \\cite{arXiv:quant-ph/9603031} or single erasure \\cite{arXiv:quant-ph/9610042}. Not able to correct arbitrary single-qubit errors because \\( \\lfloor \\frac{d-1}{2} \\rfloor =0 \\). Approximately corrects a single amplitude damping error \\cite{arXiv:quant-ph/9704002}.", "code_id": "stab_4_2_2"}, "steane": {"name": "\\([[7,1,3]]\\) Steane code", "description": "A \\([[7,1,3]]\\) CSS code that uses the classical binary \\([7,4,3]\\) Hamming code for protecting against \\(X\\) errors and its dual \\([7,3,4]\\) for \\(Z\\) errors. The parity-check matrix for the \\([7,4,3]\\) Hamming code is\n\\begin{align}\n  H = \\left(\\begin{matrix}\n    1&0&0&1&0&1&1\\\\\n    0&1&0&1&1&0&1\\\\\n    0&0&1&0&1&1&1\n  \\end{matrix}\\right),\n\\end{align}\nand the check matrix for the Steane code is therefore\n\\begin{align}\n  \\left(\\begin{matrix}\n    0&H\\\\\n    H&0\n  \\end{matrix}\\right).\n\\end{align}\nThe stabilizer group for the Steane code has six generators.\nLogical codewords are\n\\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{8}}\\Big(|0000000\\rangle+|1010101\\rangle+|0110011\\rangle+|1100110\\rangle\\\\&\\,\\,\\,\\,\\,\\,\\,\\,+|0001111\\rangle+|1011010\\rangle+|0111100\\rangle+|1101001\\rangle\\Big)\\\\|\\overline{1}\\rangle&=\\frac{1}{\\sqrt{8}}\\Big(|1111111\\rangle+|0101010\\rangle+|1001100\\rangle+|0011001\\rangle\\\\&\\,\\,\\,\\,\\,\\,\\,\\,+|1110000\\rangle+|0100101\\rangle+|1000011\\rangle+|0010110\\rangle\\Big)~.\n\\end{split}\n\\end{align}\n", "notes": [], "introduced": "\\cite{doi:10.1098/rspa.1996.0136}", "short_name": "Steane", "logical": "qubits", "realizations": ["Trapped-ion qubits: seven-qubit device in Blatt group \\cite{arXiv:1403.5426}, ten-qubit QCCD device by Quantinuum \\cite{arXiv:2107.07505} (see APS Physics Synopsys \\cite{doi:10.1103/Physics.14.184}). Fault-tolerant universal two-qubit gate set by Monz group \\cite{arxiv:2111.12654}. Logical CNOT gate between two logical qubits, including rounds of correction and fault-tolerant primitives such as flag qubits and pieceable fault tolerance, on a 20-qubit device by Quantinuum \\cite{arxiv:2208.01863}; logical fidelity interval of the combined preparation-CNOT-measurement procedure was higher than that of the unencoded physical qubits.", "Rydberg atom arrays: Lukin group \\cite{arXiv:2112.03923}."], "features": {"general_gates": ["Pieceable fault-tolerant CCZ gate \\cite{arxiv:1603.03948}."], "encoders": ["Nine CNOT and four Hadamard gates (\\cite{doi:10.1201/9781420012293}, Fig. 10.14)."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Pieceable fault-tolerant CCZ gate \\cite{arxiv:1603.03948}.", "Syndrome measurement can be done with ancillary flag qubits \\cite{arXiv:1612.04795,arXiv:1705.02329} or with no extra qubits \\cite{doi:10.1088/2058-9565/abc6f4}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "All single-qubit Clifford gates \\cite{arxiv:quant-ph/9605011,arxiv:0706.1382}."}, "physical": "qubits", "protection": "The Steane code is a distance 3 code. It detects errors on 2 qubits, corrects errors on 1 qubit.", "code_id": "steane"}, "stab_5_1_3": {"name": "Five-qubit perfect code", "description": "Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, \\begin{align} \\begin{split} S_1 &= IXZZX \\\\ S_2 &= XZZXI \\\\ S_3 &= ZZXIX \\\\ S_4 &= ZXIXZ~. \\end{split} \\end{align}", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9602019}", "short_name": "\\([[5,1,3]]\\)", "logical": "qubits", "realizations": ["NMR: Implementation of perfect error correcting code on 5 spin subsystem of labeled crotonic acid for quantum network benchmarking \\cite{arXiv:quant-ph/0101034}. Single-qubit logical gates \\cite{arXiv:1208.4797}.", "Superconducting qubits \\cite{arXiv:1907.04507}.", "Trapped-ion qubits: non-transversal CNOT gate between two logical qubits, including rounds of correction and fault-tolerant primitives such as flag qubits and pieceable fault tolerance, on a 12-qubit device by Quantinuum \\cite{arxiv:2208.01863}.", "Nitrogen-vacancy centers in diamond: fault-tolerant single-qubit Clifford operations \\cite{arxiv:2108.01646}."], "features": {"general_gates": ["Pieceable fault-tolerant CZ, CNOT, and CCZ gates \\cite{arxiv:1603.03948}."], "encoders": ["Four CCZ, four Hadamard, and one \\(Z\\) gate (\\cite{doi:10.1201/9781420012293}, Fig. 10.16).", "Four CNOT and five CPHASE gates \\cite{arxiv:1509.01239}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Pieceable fault-tolerant CZ, CNOT, and CCZ gates \\cite{arxiv:1603.03948}.", "Syndrome measurement can be done with two ancillary flag qubits \\cite{arXiv:1705.02329}."], "threshold": [], "decoders": ["Combined dynamical decoupling and error correction protocol on individually-controlled qubits with always-on Ising couplings \\cite{arxiv:1509.01239}.", "Symmetric decoder correcting all weight-one Pauli errors. The resulting logical error channel after coherent noise has been explicitly derived \\cite{arxiv:2203.01706}."], "code_capacity_threshold": [], "transversal_gates": "Pauli gates are transversal, along with a non-Pauli Hadamard-phase gate \\(SH\\) and three-qubit Clifford operation \\(M_3\\) \\cite{arxiv:quant-ph/9705052}."}, "physical": "qubits", "protection": "Smallest stabilizer code that protects against a single error on any one qubit. Detects two-qubit errors.", "code_id": "stab_5_1_3"}, "shor_nine": {"name": "\\([[9,1,3]]\\) Shor code", "description": "Nine-qubit \\hyperref[code:css]{CSS code} that is the smallest such code to correct a single-qubit error. Logical codewords are\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right)^{\\otimes3}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle-|111\\rangle\\right)^{\\otimes3}~.\n\\end{split}\n\\end{align}\nThe code works by \\hyperref[code:quantum_concatenated]{concatenating} each qubit of a phase-flip with a bit-flip \\hyperref[code:quantum_repetition]{repetition code}. Therefore, the code can correct both type of errors simultaneously.\n\nSpecifically, a state is phase-flip error-corrected by a three-qubit phase-flip \\hyperref[code:quantum_repetition]{repetition code}, with stabilizer generators \\(X_0 X_1I_2\\) and \\(X_0I_1X_2\\) in \\(X\\) basis, where the subscript represents the qubit index. Each logical qubit is encoded using\n\\begin{align}\n\\label{eq:phase-flip}\n\\begin{split}\n  |\\overline{0}\\rangle &= |+_0+_1+_2\\rangle \\\\\n  |\\overline{1}\\rangle &= |-_0-_1-_2\\rangle .\n\\end{split}\n\\end{align}\nThen, each physical qubit used in \\eqref{eq:phase-flip} is further encoded in the three-qubit bit-flip \\hyperref[code:quantum_repetition]{repetition code},\n\\begin{align}\n  |\\pm _j \\rangle  = \\frac{1}{\\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\\rangle \\pm |1_{j0}1_{j1}1_{j2}\\rangle),\n\\end{align}\neach with bit-flip error stabilizer generators \\(Z_{j0}Z_{j1}I_{j2}\\) and  \\(Z_{j0}I_{j1}Z_{j2} \\) with \\(j=0,1,2\\).\nNotice now the phase-flip error stabilizer generator is extended as \\(X_j = X_{j0}X_{j1}X_{j2}\\).\nAs a result, the stabilizer generators with the qubit index flattened are\n\\begin{align}\n\\begin{split}\n  Z_{j0}Z_{j1}I_{j2} &\\rightarrow \\{Z_0Z_1, Z_3Z_4, Z_6Z_7\\} \\\\\n  Z_{j0}I_{j1}Z_{j2} &\\rightarrow \\{Z_0Z_2, Z_3Z_5, Z_6Z_8\\} \\\\\n  X_0 X_1I_2  &\\rightarrow  \\{X_0X_1X_2X_3X_4X_5\\}\\\\\n  X_0 I_1X_2  &\\rightarrow  \\{X_0X_1X_2X_6X_7X_8\\}.\n\\end{split}\n\\end{align}\n", "notes": ["Shor's code is the first known quantum error correction code. "], "introduced": "\\cite{doi:10.1103/PhysRevA.52.R2493}", "short_name": "Shor", "logical": "qubits", "realizations": ["Trapped-ion qubits: state preparation with 98.8(1)\\% and 98.5(1)\\% fidelity for state \\(|\\overline{0}\\rangle\\) and \\(|\\overline{1}\\rangle\\), respectively, by N. Linke group \\cite{arXiv:2104.01205}. Variants of the code to handle coherent noise studied and realized by K. Brown and C. Monroe groups \\cite{arxiv:2105.05068}.", "Optical systems: quantum teleportation of information implemented by J.-W. Pan group on maximally entangled pair of one physical and one logical qubit with fidelity rate of up to 78.6\\% \\cite{arXiv:2009.06242}. All-photonic quantum repeater architecture tested on the same code \\cite{arxiv:2203.07979}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Bit- and phase-flip circuits utilize CNOT and Hadamard gates (\\cite{doi:10.1201/9781420012293}, Fig. 10.6)."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "The code detects two-qubit errors or corrects an arbitrary single-qubit error.", "code_id": "shor_nine"}, "stab_15_1_3": {"name": "\\([[15,1,3]]\\) quantum Reed-Muller code", "description": "\\([[15,1,3]]\\) CSS code that is most easily thought of as a tetrahedral 3D color code.\nThis code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center.\nThe tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers.\nEach colored cell corresponds to a weight-8 \\(X\\)-check, and each face corresponds to a weight-4 \\(Z\\)-check.\nA logical \\(Z\\) is any weight-3 \\(Z\\)-string along an edge of the entire tetrahedron.\nThe logical \\(X\\) is any weight-7 \\(X\\)-face of the entire tetrahedron.\n", "notes": ["The \\([[15,1,3]]\\) code can be converted into the smallest known stabilizer code with a fault-tolerant logical \\(T\\) gate (i.e., the \\([[10,1,2]]\\) code) through a \"morphing procedure\" \\cite{arXiv:2112.01446}."], "introduced": "", "short_name": "\\([[15,1,3]]\\)", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Code is often used in magic-state distillation protocols because of its transversal \\(T\\) gate \\cite{arXiv:quant-ph/0403025}."], "encoders": [], "rate": "", "magic_scaling_exponent": "Magic-state distillation scaling exponent \\( \\gamma= \\log_d (n/k)\\approx 2.46\\) \\cite{arXiv:1703.07847}.", "fault_tolerance": ["Combining the Steane code and the 15-qubit Reed-Muller code through a fault-tolerant conversion can result in a universal transversal gate set that does not need magic state distillation \\cite{arxiv:1304.3709,arXiv:1403.2734,arXiv:1703.03860,arxiv:2210.14074}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "This code is the smallest qubit stabilizer code with a transversal gate outside of the Clifford group \\cite{arxiv:2210.14066}. A transversal logical \\(T^\\dagger\\) is implemented by applying a \\(T\\) gate on every qubit \\cite{arXiv:quant-ph/9610011,arXiv:1403.2734,arXiv:1612.07330}. A subsystem version yields a transversal \\(CCZ\\) gate \\cite{arxiv:1304.3709}. The code fails to have a transversal Hadamard gate; otherwise, it would vioalate the Eastin-Knill theorem."}, "physical": "qubits", "protection": "", "code_id": "stab_15_1_3"}, "check_product": {"name": "Quantum check-product code", "description": "Stub.\n", "notes": [], "introduced": "\\cite{arXiv:2209.11405}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "check_product"}, "ramanujan_tensor_product": {"name": "Ramanujan-complex product code", "description": "CSS code constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.", "notes": ["Codes were first to break a 20-year record set by the \\hyperref[code:freedman_meyer_luo]{Freedman-Meyer-Luo code} for the lower bound on scaling of the minimum distance \\cite{arXiv:2103.06309}."], "introduced": "\\cite{arXiv:2004.07935}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "For 2D Ramanujan complexes, the rate is \\(\\Omega(\\sqrt{ \\frac{1}{n \\log n} })\\), with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}) \\). For 3D, the rate is \\( \\Omega(\\frac{1}{\\sqrt{n}\\log n}) \\) with minimum distance \\(d \\geq \\sqrt{n} \\log n \\).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["For 2D simplicial complexes, cycle code decoder admitting a polynomial-time decoding algorithm can be used \\cite{arXiv:2004.07935}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Without distance balancing, a Ramanujan code can have \\(d_X =\\Omega(\\log n)\\) and \\(d_Z = \\Omega (n)\\). For 2D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d = \\Omega(\\sqrt{n \\log n})\\). For 3D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d= \\Omega(\\sqrt{n} \\log n )\\).", "code_id": "ramanujan_tensor_product"}, "fiber_bundle": {"name": "Fiber-bundle code", "description": "Also called a \\textit{twisted product code}. CSS code constructed by combining a random LDPC code as the base and a cyclic repetition code as the fiber of a fiber bundle. After applying distance balancing, a QLDPC code with distance \\(\\Omega(n^{3/5}\\text{polylog}(n))\\) and rate \\(\\Omega(n^{-2/5}\\text{polylog}(n))\\) is obtained.", "notes": [], "introduced": "\\cite{arxiv:2009.03921}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Rate \\(k/n = \\Omega(n^{-2/5}/\\text{polylog}(n))\\), distance \\(d=\\Omega(n^{3/5}/\\text{polylog}(n))\\). This is the first QLDPC code to achieve a distance scaling better than \\(\\sqrt{n}~\\text{polylog}(n)\\).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Greedy algorithm can be used to efficiently decode \\(X\\) errors, but no known efficient decoding of \\(Z\\) errors yet \\cite{arxiv:2009.03921}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "fiber_bundle"}, "iterated_ramanujan": {"name": "Tensored-Ramanujan-complex product code", "description": "Code constructed in a similar way as the Ramanujan-complex product code, but utilizing tensor products of Ramanujan complexes in order to improve code distance from \\(\\sqrt{n}\\log n\\) to \\(\\sqrt{n}~\\text{polylog}(n)\\). The utility of such tensor products comes from the fact that one of the Ramanujan complexes is a \\textit{collective cosystolic expander} as opposed to just a cosystolic expander.", "notes": [], "introduced": "\\cite{arXiv:2008.09495}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Construction yields explicit QLDPC codes with distance \\(\\sqrt{n}\\log^c n\\) using the \\(c\\)-tensor-product of Ramanujan complexes.", "code_id": "iterated_ramanujan"}, "quantum_tanner": {"name": "Quantum Tanner code", "description": "Stub.", "notes": ["For details, see talk by \\href{https://www.youtube.com/watch?v=5GO3BtJuo3I}{A. Leverrier}."], "introduced": "\\cite{arXiv:2202.13641}", "short_name": "", "logical": "qubits", "realizations": ["Used to obtain explicit lower bounds in the sum-of-squares game \\cite{arXiv:2204.11469}.", "States that, on average, achieve small violations of check operators for quantum Tanner codes require a circuit of non-constant depth to make. They are used in the proof \\cite{arxiv:2206.13228} of the \\textit{No low-energy trivial states} (NLTS) conjecture \\cite{arxiv:1301.1363}."], "features": {"general_gates": [], "encoders": [], "rate": "Asymptotically good QLDPC codes.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Linear-time decoder similar to the small-set-flip decoder for quantum expander codes \\cite{arxiv:2206.06557}.", "Linear-time decoder \\cite{arxiv:2206.07571}.", "Logarithmic-time decoder \\cite{arxiv:2208.05537}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Minimum distance bound obtained using robustness of dual \\hyperref[code:tensor]{tensor-product} codes \\cite{arxiv:2208.05537}.", "code_id": "quantum_tanner"}, "quantum_expander": {"name": "Quantum expander code", "description": "CSS codes constructed from a hypergraph product of bipartite expander graphs with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as \\(X\\) checks, and the parity check matrix of the other as \\(Z\\) checks.", "notes": [], "introduced": "\\cite{arXiv:1504.00822}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "\\([[n,k=\\Theta(n),d=O(\\sqrt{n})]]\\) code with asymptotically constant rate.", "magic_scaling_exponent": "", "fault_tolerance": ["Fault-tolerance with constant overhead can be achieved \\cite{arXiv:1808.03821}."], "threshold": ["Current estimate of \\(2.7 \\cdot 10^{-16}\\) in locally stochastic noise model \\cite{arXiv:1711.08351}."], "decoders": ["Small set-flip linear-time decoder, which corrects \\(\\Omega(n^{1/2})\\) adversarial errors \\cite{arXiv:1504.00822}.", "Log-time decoder \\cite{arxiv:1808.03821}.", "Constant-time decoder \\cite{manual:{A. Grospellier. Constant time decoding of quantum expander codes and application to fault-tolerant quantum computation. PhD thesis, Inria Paris (2019).}}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Pauli errors of weight \\(\\leq t\\), distance scales as \\(\\Omega(n^{1/2})\\).", "code_id": "quantum_expander"}, "homological_product": {"name": "Homological product code", "description": "CSS code formulated using the homological product of two chain complexes (see \\ref{topic:CSS-to-homology-correspondence}). Stub.\n", "notes": [], "introduced": "\\cite{arXiv:1301.1363,arXiv:1311.0885}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state \\cite{arXiv:1807.09783}."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state \\cite{arXiv:1807.09783}."], "threshold": [], "decoders": ["Union-find \\cite{arXiv:2009.14226}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Given two codes \\([[n_a, k_a, d_a, w_a]]\\) for \\(a\\in\\{1,2\\}\\), where \\(w_a\\) denotes the maximum hamming weight of all rows and columns of \\(\\partial_a\\), the homological product code has parameter \\([[n=n_1 n_2, k=k_1 k_2, d\\leq d_1 d_2, w\\leq w_1+w_2]]\\). From this formula, and the fact that a randomly selected boundary operator \\(\\partial\\) yields a CSS code that is good with high probability, we see that the product code has \\(k=\\Theta(n)\\) and \\(w=O(\\sqrt{n})\\) with high probability. The main result in \\cite{arXiv:1311.0885} is to show that the product code actually has linear distance with high probability as well. To sum up, it is shown that we have a family of \\([[n,k=c_1 n, d=c_2 n, w=c_3 \\sqrt{n}]]\\) codes given small enough \\(c_1,c_2,c_3\\).", "code_id": "homological_product"}, "classical_product": {"name": "CSS classical product code", "description": "A CSS code constructed by separately constructing the \\(X\\) and \\(Z\\) check matrices using product constructions from classical codes. A particular \\([[512,174,8]]\\) code performed well \\cite{arxiv:2209.13474} against erasure and depolarizing noise when compared to other notable CSS codes, such as the asymptotically good quantum Tanner codes.\n\nFor example, for \\(H_i^x\\), \\(H_i^z\\) being the \\(X\\) and \\(Z\\) check matrices of CSS codes \\(C_i\\) with \\(i\\in\\{1,2,3,4\\}\\), the 2-fold symmetric classical product code is given by\n\\begin{align}\nH_{\\otimes}^x &:=\\left(\\begin{array}{c}\nH_1^x \\otimes H_2^x \\otimes I \\otimes I \\\\\nI \\otimes I \\otimes H_3^x \\otimes H_4^x\n\\end{array}\\right) \\\\\nH_{\\otimes}^z &:=\\left(\\begin{array}{c}\nH_1^z \\otimes I \\otimes H_3^z \\otimes I \\\\\nI \\otimes H_2^z \\otimes I \\otimes H_4^z\n\\end{array}\\right)~.\n\\end{align}", "notes": [], "introduced": "\\cite{doi:10.1007/s11128-018-2095-3,arxiv:2209.13474}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "classical_product"}, "dhlv": {"name": "Dinur-Hsieh-Lin-Vidick (DHLV) code", "description": "Stub.", "notes": [], "introduced": "\\cite{arxiv:2206.07750}", "short_name": "DHLV", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Asymptotically good QLDPC codes.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Linear-time decoder utilizing the small set-flip decoder \\cite{arxiv:2206.06557} for \\(Z\\) errors and a reconstruction procedure for \\(X\\) errors \\cite{arxiv:2206.07750}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "dhlv"}, "hemicubic": {"name": "Hemicubic code", "description": "Stub.\n", "notes": [], "introduced": "\\cite{arXiv:1911.03069}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "hemicubic"}, "xyz_product": {"name": "XYZ product code", "description": "A non-CSS QLDPC code constructed from three classical codes. The construction of an XYZ product code is similar to that of a hypergraph product code and related codes. The idea is that rather than taking a product of only two classical codes to produce a CSS code, a third classical code is considered, acting with Pauli-\\(Y\\) operators.\n", "notes": [], "introduced": "\\cite{arxiv:2011.09746}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Not much has been proven about the relationship between XYZ-product codes and other codes. The logical dimension depends on properties of the input classical codes, specifically \\textit{similarity invariants} from abstract algebra. It is conjectured that specific instances of XYZ-product codes have a constant encoding rate and a minimum distance of \\(d \\in \\Theta(n^{2/3})\\) \\cite{arxiv:2011.09746}.\n", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "xyz_product"}, "hypergraph_product": {"name": "Hypergraph product code", "description": "A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two binary linear \\textit{seed} codes \\(C_1\\) and \\(C_2\\).", "notes": [], "introduced": "\\cite{arXiv:0903.0566,arxiv:1202.0928}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Code deformation techniques yield Clifford gates \\cite{arXiv:1909.07424}."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["ReShape decoder that uses minimum weight decoders for the classical codes used in the hypergraph construction \\cite{arxiv:2105.02370}.", "Erasure-correction can be implemented approximately with \\(O(n^2)\\) operations, with a probabilistic version running in \\(O(n^{1.5})\\) operations \\cite{arxiv:2208.01002}."], "code_capacity_threshold": [], "transversal_gates": "Hadamard (up to logical SWAP gates) and control-\\(Z\\) on all logical qubits \\cite{arXiv:2204.10812}."}, "physical": "qubits", "protection": "The hypergraph product has distance \\(d=O(\\sqrt{n})\\). The number of encoded logical qubits is \\(k=O(k_1k_2)\\) where \\(k_1\\) and \\(k_2\\) are the dimensions of the classical seed codes \\(C_1\\) and \\(C_2\\).", "code_id": "hypergraph_product"}, "hypersphere_product": {"name": "Hypersphere product code", "description": "Stub.\n", "notes": [], "introduced": "\\cite{arXiv:1608.05089}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "hypersphere_product"}, "heavy_hex": {"name": "Heavy-hexagon code", "description": "Subsystem stabilizer code on the heavy-hexagonal lattice that combines Bacon-Shor and surface-code stabilizers. Encodes one logical qubit into \\(n=(5d^2-2d-1)/2\\) physical qubits with distance \\(d\\). The heavy-hexagonal lattice allows for low degree (at most 3) connectivity between all the data and ancilla qubits, which is suitable for fixed-frequency transom qubits subject to frequency collision errors.\n\nData qubits and ancillas of the code are placed on a heavy-hexagonal lattice (vertices and edges of a tilling of hexagons). A subset of the ancilla qubits are flag qubits used for detecting high-weight errors arising from fewer faults. The code stabilizers for detecting \\(X\\)-type errors are measured by measuring weight-two \\(Z\\)-type gauge operators whose product produces stabilizers of the surface code. \\(X\\)-type stabilizers are column operators corresponding to stabilizers of the Bacon-Shor code, which are measured by taking products of weight-four and weight-two \\(X\\)-type gauge operators.\n", "notes": [], "introduced": "\\cite{arXiv:1907.09528}", "short_name": "", "logical": "qubits", "realizations": ["Logical state preparation and flag-qubit error correction realized in superconducting-circuit devices (specifically, fixed-frequency transmon qubit architectures) by IBM for \\(d=2\\) \\cite{arXiv:1705.09259,arXiv:2110.04285} and \\(d=3\\) \\cite{arxiv:2203.07205}."], "features": {"general_gates": ["Universal gate set achieved with magic state injection and lattice surgery."], "encoders": ["For a logical-zero state, prepare all data qubits in the physical-zero state and then measure the \\(X\\)-type Bacon-Shor stabilizers. For logical-plus state, prepare all data qubits in the physical-plus state and then measure \\(Z\\)-type surface code stabilizers.", "Stabilizer measurement encoding circuits have a constant depth of 10 time steps (excluding ancilla state preparation and measurement)."], "rate": "\\(1/n\\) for a distance-\\(d\\) heavy-hexagon code on \\(n = (5d^2-2d-1)/2\\) qubits.", "magic_scaling_exponent": "", "fault_tolerance": ["All logical gates can be fault-tolerantly implemented using lattice surgery and magic state injection.", "Stabilizer measurements are measured fault-tolerantly using one-flag circuits since some single-fault events can result in weight-two data qubit errors which are parallel to the code's logical operators. Hence, using information from the flag-qubit measurements is crucial to fault-tolerantly measure the code stabilizers."], "threshold": ["\\(0.45\\%\\) for \\(X\\) errors under a full circuit-level depolarizing noise model (obtained from Monte Carlo simulations).", "\\(Z\\)-errors have no threshold given the \\(X\\)-type Bacon-Shor stabilizers."], "decoders": ["Any graph-based decoder can be used, such as MWPM and Union Find. However, edge weights must be dynamically renormalized using flag-qubit measurement outcomes after each syndrome measurement round.", "Machine-learning decoder \\cite{arxiv:2210.09730}."], "code_capacity_threshold": [], "transversal_gates": "CNOT gates are transveral for this code. However, for most architectures, all logical gates would be implemented using lattice surgery methods."}, "physical": "qubits", "protection": "Protects against Pauli noise. The code has no threshold for \\(Z\\)-type Pauli errors since they are detected by Bacon-Shor-type stabilizers.", "code_id": "heavy_hex"}, "subsystem_surface": {"name": "Subsystem surface code", "description": "Stub.\n", "notes": ["See \\cite[Sec. III.C3]{arxiv:1302.3428} for an exposition."], "introduced": "\\cite{arxiv:1207.1443}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Gauge fixing and changing the order in which check operators are measured yields a fault-tolerant decoder \\cite{arxiv:2010.09626}."], "threshold": ["\\(0.81\\%\\) threshold for circuit-level depolarizing noise under a variant of MWPM and using gauge-fixing and specific measurement schedules \\cite{arxiv:2010.09626}, improving the \\(0.67\\%\\) threshold for standard measurement schedules \\cite{arxiv:1207.1443}.", "\\(2.22\\%\\) threshold for circuit-level infinitely biased noise under a variant of MWPM and using gauge-fixing and specific measurement schedules \\cite{arxiv:2010.09626}, improving the \\(0.52\\%\\) threshold with standarn measurement schedules."], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "subsystem_surface"}, "subsystem_stabilizer": {"name": "Subsystem qubit stabilizer code", "description": "Also called a \\textit{gauge stabilizer code}. A stabilizer code with some of its logical qubits denoted as \\textit{gauge} qubits and not used for storage of logical information. Note that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by \\([[n,k,r,d]]\\), similar to stabilizer codes, but with an extra parameter \\(r\\) denoting the number of gauge qubits.\n\nTo create these codes proceed as follows. Choose \\(2n\\) operators \\(\\{ \\tilde{X}_j,\\tilde{Z}_j\\}_{j=1}^n\\) from \\(\\mathsf{P}_n\\), the Pauli group on \\(n\\) qubits, such that they obey the same commutation relations as the regular \\(n\\)-qubit Pauli generators \\( \\{X_j,Z_j\\}_{j=1}^n \\) (the subscript on these latter operators indicates the single qubit the Pauli matrix acts on). The tilde operators might act on more than one physical (or \\textit{bare}) qubit but they behave as if they acted only on a single qubit. WLOG we can choose a stabilizer group as \\( \\mathsf{S} = \\langle Z_1,\\dots,Z_s \\rangle \\). It follows that the normalizer of \\(\\mathsf{S} \\) is \\( N(\\mathsf{S}) = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_n, \\tilde{X}_{s+1},\\dots, \\tilde{X}_n \\rangle \\). We now choose a gauge group as \\( \\mathsf{G} = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_s, \\tilde{X}_{s+1}, \\tilde{Z}_{s+1}, \\dots, \\tilde{X}_{s+r}, \\tilde{Z}_{s+r} \\rangle \\) with \\( s + r \\leq n \\). The logical group is choosen as \\( \\mathsf{L} = N(\\mathsf{S})/\\mathsf{G} \\simeq \\langle \\tilde{X}_{s+r+1},\\tilde{Z}_{s+r+1}, \\dots, \\tilde{X}_n,\\tilde{Z}_n \\rangle \\). Now the codespace \\( C \\) is as usual the \\(+1\\) eigenspace of the stabilizer \\( \\mathsf{S} \\). But the gauge and logical groups have further decomposed this space into \\( C = A \\otimes B \\simeq (\\mathbb{C}^2)^{\\otimes k} \\otimes (\\mathbb{C}^2)^{\\otimes r} \\). Thus the Hilbert space is partitioned into 3 sets; \\(k\\) logical qubits, \\(r\\) gauge qubits, and \\(s\\) stabilizer qubits, with \\(s+r+k=n\\).\n", "notes": ["When the gauge group \\( \\mathsf{G} \\) is abelian, the above is reduced to the standard stabilizer formalism."], "introduced": "\\cite{arXiv:quant-ph/0508131}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Logical Clifford gates can be implemented fault-tolerantly for subsystem codes of distance at least three \\cite{arxiv:2210.14074}."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Logical Clifford gates can be implemented fault-tolerantly for subsystem codes of distance at least three \\cite{arxiv:2210.14074}."], "threshold": [], "decoders": ["Syndrome measurements are obtained by first measuring gauge operators of the code and taking their products, which give the stabilizer measurement outcomes."], "code_capacity_threshold": ["For correlated Pauli noise, bounds can be obtained by mapping the effect of noise on the code to a statistical mechanical model \\cite{arXiv:1809.10704}."], "transversal_gates": ""}, "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. More generally, a set of errors \\( \\{ E_a \\} \\) is correctable iff \\( E_aE_b \\not\\in N(\\mathsf{S}) \\setminus \\mathsf{G} \\) for all pairs \\(a,b\\). The distance of the code is the minimal weight of operators in \\( N(\\mathsf{S}) \\setminus \\mathsf{G}\\).", "code_id": "subsystem_stabilizer"}, "bacon_shor": {"name": "Bacon-Shor code", "description": "CSS subsystem stabilizer code defined on an \\(m_1 \\times m_2\\) lattice of qubits. It is said to be symmetric when \\(m_1=m_2\\). The \\(X\\)-type and \\(Z\\)-type stabilizers defined as \\(X\\) and \\(Z\\) operators acting on all qubits on adjacent columns and rows, respectively. Let \\(O_{i,j}\\) denote an operator acting on the qubit at a position \\((i,j)\\) on the lattice, with \\(i\\in\\{0,1,\\ldots ,m_1-1\\}\\) and \\(j\\in\\{0,1,\\ldots,m_2-1\\}\\). The code's stabilizer group is\n\\begin{align}\n\\mathsf{S}=\\langle X_{i,*}X_{i+1,*},Z_{*,j}Z_{*,j+1}\\rangle~,\n\\end{align}\nwith generators expressed as products of nearest-neightbour 2-qubit gauge operators,\n\\begin{align}\n\\begin{split}\nX_{i,*}X_{i+1,*}= \\bigotimes_{k=0}^{m_2-1} X_{i,k}X_{i+1,k} \\\\\nZ_{*,j}Z_{*,j+1}=\\bigotimes_{k=0}^{m_1-1} Z_{k,j}Z_{k,j+1}~.\n\\end{split}\n\\end{align}\nSyndrome extraction can be done by measuring these gauge operators, which are on fewer qubits and local.\n\nThe error-detecting \\([[4,1,2]]\\) Bacon-Shor code, which reduces to a subcode of the \\hyperref[code:stab_4_2_2]{\\([[4,2,2]]\\) code} for a particular gauge configuration, has gauge operators \\(\\{XIXI,IIXX,ZIZI,IZIZ\\}\\). The shortest error-correcting Bacon-Shor code is \\([[9,1,3]]\\) with four stabilizer generators\n\\begin{align}\n  \\begin{array}{ccccccccc}\n    X & X & X & X & X & X & I & I & I\\\\\n    I & I & I & X & X & X & X & X & X\\\\\n    Z & Z & I & Z & Z & I & Z & Z & I\\\\\n    I & Z & Z & I & Z & Z & I & Z & Z\n  \\end{array}\n\\end{align}\nand eight gauge generators\n\\begin{align}\n  \\begin{array}{ccccccccc}\n  X & I & I & X & I & I & I & I & I\\\\\n  I & X & I & I & X & I & I & I & I\\\\\n  I & I & I & X & I & I & X & I & I\\\\\n  I & I & I & I & X & I & I & X & I\\\\\n  Z & Z & I & I & I & I & I & I & I\\\\\n  I & I & I & Z & Z & I & I & I & I\\\\\n  I & Z & Z & I & I & I & I & I & I\\\\\n  I & I & I & I & Z & Z & I & I & I\n  \\end{array}~.\n\\end{align}\nIf the physical qubits are arranged in a three-by-three square, the \\(Z\\)-type (\\(X\\)-type) gauge operators are supported on qubits in the same row (column). The code reduces to the \\hyperref[code:shor_nine]{Shor code} for a particular gauge configuration.\n", "notes": ["See \\cite[Sec. III.C1]{arxiv:1302.3428} for an exposition."], "introduced": "\\cite{doi:10.1103/PhysRevA.52.R2493,arxiv:quant-ph/0506023}", "short_name": "", "logical": "qubits", "realizations": ["Trapped-ion qubits: state preparation, logical measurement, and stabilizer measurement for nine-qubit Bacon-Shor code demonstrated on a 13-qubit device by M. Cetina and C. Monroe groups \\cite{arxiv:2009.11482}."], "features": {"general_gates": ["Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively \\cite{manual:{Yoder, Theodore., \\emph{DSpace@MIT} Practical Fault-Tolerant Quantum Computation (2018)}}."], "encoders": [], "rate": "A non-LDPC family of Bacon-Shor codes achieves a distance of \\(\\Omega(n^{1-\\epsilon})\\) with sparse gauge operators.", "magic_scaling_exponent": "", "fault_tolerance": ["Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively \\cite{manual:{Yoder, Theodore., \\emph{DSpace@MIT} Practical Fault-Tolerant Quantum Computation (2018)}}."], "threshold": ["A lower bound of \\(1.94 \\times 10^{-4}\\) for the accuracy threshold was proved for Bacon-Shor code with 5 levels of concatenation, using Steane method of FTEC \\cite{arxiv:quant-ph/0610063}.", "The three dimensional version offers the possibility of being a self-correcting quantum memory \\cite{doi:10.1103/PhysRevA.73.012340}."], "decoders": ["While check operators are few-body, stabilizer weights scale with the number of qubits, and stabilizer expectation values are obtained by taking products of gauge-operator expectation values. It is thus not clear how to extract stabilizer values in a fault-tolerant manner \\cite{arxiv:2009.03921,arXiv:2107.02194}."], "code_capacity_threshold": [], "transversal_gates": "Logical Hadamard is transversal in symmetric Bacon-Shor codes up to a qubit permutation \\cite{arxiv:quant-ph/0610063} and can be implemented with teleportation \\cite{arXiv:quant-ph/0002039}. Bacon-Shor codes on an \\(m \\times mk\\) lattice admit transversal \\(k\\)-qubit-controlled \\(Z\\) gates \\cite{arXiv:1705.01686}."}, "physical": "qubits", "protection": "The \\([[m_1 m_2,1,min(m_1,m_2)]]\\) variant has distance \\(d=min(m_1,m_2)\\). In a symmetric 3-dimensional case (defined on a cubic lattice) with \\(L^3\\) qubits, the code has the parameters \\([[L^3,1,L]]\\).", "code_id": "bacon_shor"}, "bravyi_bacon_shor": {"name": "Bravyi-Bacon-Shor (BBS) code", "description": "An \\([[n,k,d]]\\) CSS subsystem stabilizer code generalizing Bacon-Shor codes to a larger set of qubit geometries. Defined through a binary matrix \\(A\\) such that physical qubits live on sites \\((i,j)\\) whenever \\(A_{i,j}=1\\). The gauge group is generated by 2-qubit operators, including \\(XX\\) interations between any two qubits sharing a column in \\(A\\), and \\(ZZ\\) interations between two qubits sharing a row. The code parameters are: \\(n=\\sum_{i,j}A_{i,j}\\), \\(k=\\text{rank}(A)\\), and the distance is the minimum weight of any row or column.", "notes": [], "introduced": "\\cite{arxiv:1008.1029}", "short_name": "BBS", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits, where \\(d\\) is the minimum weight of a row or column in \\(A\\) \\cite{arXiv:2002.06257}.", "code_id": "bravyi_bacon_shor"}, "subsystem_color": {"name": "Subsystem color code", "description": "Stub.\n", "notes": [], "introduced": "\\cite{arxiv:0908.4246,arxiv:1311.0879}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "subsystem_color"}, "hybrid_qudit_oscillator": {"name": "Hybrid qudit-oscillator code", "description": "Encodes a \\(K\\)-dimensional logical Hilbert space into \\(n_1\\) qudits of dimension \\(q\\) and \\(n_2 \\neq 0\\) oscillators, i.e., the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{Z}_q^{n_1} \\times \\mathbb{R}^{n_2}\\).", "notes": [], "introduced": "", "short_name": "", "logical": "groups", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "", "code_id": "hybrid_qudit_oscillator"}, "single-mode": {"name": "Single-mode bosonic code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a single bosonic mode.", "notes": [], "introduced": "", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "single-mode"}, "oscillators_into_oscillators": {"name": "Oscillator-into-oscillator code", "description": "Also called an \\textit{analog quantum code}. Encodes \\(k\\) bosonic modes into \\(n\\) bosonic modes.", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9711021,arXiv:quant-ph/9711049}", "short_name": "", "logical": "oscillators", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "oscillators_into_oscillators"}, "oscillators": {"name": "Bosonic code", "description": "Also called an \\textit{oscillator} or a \\textit{continuous-variable (CV)} code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one \\textit{oscillator} (a.k.a. \\textit{bosonic mode} or \\textit{qumode}). States of a single oscillator are elements of the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}\\)). Ideal codewords may not be normalizable because the space is infinite-dimensional, so approximate versions have to be constructed in practice.", "notes": ["Reviews on bosonic codes can be found in Refs. \\cite{arxiv:2008.13471,arxiv:2010.08699,arXiv:2111.08894,arxiv:2211.05714}.", "For an introduction to continuous-variable quantum systems, see the books \\cite{doi:10.1142/p489,doi:10.1201/9781315118727}."], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "An error set relevant to \\hyperref[code:oscillator_stabilizer]{bosonic stabilizer} codes is the set of \\textit{displacement operators}, a bosonic analogue of the Pauli string basis for \\hyperref[code:qubits_into_qubits]{qubit} codes. For a single mode, its elements are products of exponentials of the mode's position and momentum operators, acting on the mode's position states \\(|y\\rangle\\) for \\(y\\in\\mathbb{R}\\) as\n\\begin{align}\n  e^{-iq\\hat{p}}\\left|y\\right\\rangle =\\left|y+q\\right\\rangle \\,\\,\\text{ and }\\,\\,e^{iq\\hat{x}}\\left|y\\right\\rangle =e^{iq y}\\left|y\\right\\rangle ~,\n\\end{align}\nwhere \\(q\\in\\mathbb{R}\\). For multiple modes, error set elements are tensor products of elements of the single-qudit error set, characterized by the vector of coefficients \\(\\xi\\in\\mathbb{R}^{2n}\\).\n\nThe displacement error set is a unitary basis for trace-class linear operators on the \\(n\\)-mode Hilbert space that is Dirac-orthonormal under the Hilbert-Schmidt inner product \\cite{doi:10.1103/PhysRev.177.1857}. There are two definitions of code distance associated with displacements. The definition inherited from qubit codes is the minimum weight of a displacement operator (i.e., number of nonzero entries in \\(\\xi\\)) that implements a nontrivial logical operation in the code. The second definition is the minimum Euclidean distance (i.e., \\(\\ell^2\\)-norm of \\(\\xi\\)) such that the corresponding displacement implements a nontrivial logical operation in the code.\n\nAn error set relevant to \\hyperref[code:fock_state]{Fock-state bosonic} codes is the set of loss operators associated with the \\textit{amplitude damping} (a.k.a. \\textit{photon loss} or \\textit{attenuation}) noise channel, a common form of physical noise in bosonic systems. For a single mode, loss operators are proportional to powers of the mode's annihilation operator \\(a=(\\hat{x}+i\\hat{p})/\\sqrt{2}\\), where \\(\\hat x\\) (\\(\\hat p\\)) is the mode's position (momentum) operator, and with the power signifying the number of particles lost during the error. For multiple modes, error set elements are tensor products of elements of the single-mode error set. A definition of distance associated with this error set is the minimum weight of a loss error that implements a nontrivial logical operation in the code.\n\nAn related error set is the set of powers of the Susskind\u2013Glogower phase operator \\(\\frac{1}{\\sqrt{a a^\\dagger}} a\\) \\cite{doi:10.1103/PhysicsPhysiqueFizika.1.49} and its adjoint (a.k.a. phasors \\cite{doi:10.1016/0003-4916(91)90037-9}) along with Fock-space rotations generated by the occupation number operator \\(a^\\dagger a\\). These also allow one to expand trace-class operators, but do not form an orthonormal set \\cite{arxiv:2211.05714}. These operators are correspong to a polar-like decomposition of a single mode, complementing the cartesian-like decomposition in terms of position and momentum displacements.\n", "code_id": "oscillators"}, "qudits_into_oscillators": {"name": "Qudit-into-oscillator code", "description": "Encodes \\(K\\)-dimensional Hilbert space into \\(n\\) bosonic modes.", "notes": [], "introduced": "", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Given an encoding of a finite-dimensional code, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program \\cite{arXiv:quant-ph/0109155,arXiv:quant-ph/0307138} (see also Ref. \\cite{arXiv:0706.3400}). This approximate QEC technique can be adapted to bosonic codes as long as they are restricted to a finite-dimensional subspace of the oscillator Hilbert space \\cite{arXiv:1708.05010}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "qudits_into_oscillators"}, "very-small-logical-qubit": {"name": "Very small logical qubit (VSLQ) code", "description": "The two logical codewords are \\(|\\pm\\rangle \\propto (|0\\rangle\\pm|2\\rangle)(|0\\rangle\\pm|2\\rangle)|0\\rangle|0\\rangle\\), where the total Hilbert space is the tensor product of two qudits (whose ground states \\(|0\\rangle\\) and second excited states \\(|2\\rangle\\) are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.", "notes": [], "introduced": "\\cite{doi:10.1103/PhysRevLett.116.150501}", "short_name": "VSLQ", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Single logical qubit operations implemented by resonant physical qubit driving and phase shifting the SQUID drives.", "A CZ gate between two logical qubits implemented by coupling devices through another driven SQUID and applying a pulse to the coupling squid simultaneously with a single qubit operation on one of the logical qubits."], "encoders": ["Engineering a circuit made of two transmons and two oscillators coupled through three driven superconducting quantum interference devices (SQUIDs) results in passive stabilization of the logical states."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Logical qubit can be measured with physical qubit measurements along \\(X\\). Can be implemented by engineering a coupling of one of the qubits to a readout cavity via the interaction \\(\\sigma_x (a+a^\\dagger)\\) \\cite{doi:10.1103/PhysRevLett.115.203601}. This results in an \\(X\\)-dependent shift of the readout cavity resonance which can be measured."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "Passively protects against single photon loss.", "code_id": "very-small-logical-qubit"}, "two-legged-cat": {"name": "Two-component cat code", "description": "Code whose codespace is spanned by two coherent states \\(\\left|\\pm\\alpha\\right\\rangle\\) for nonzero complex \\(\\alpha\\). An orthonormal basis for the codespace consists of the bosonic \\textit{cat states}\n\\begin{align}\n  |\\overline{\\pm}\\rangle=\\frac{\\left|\\alpha\\right\\rangle \\pm\\left|-\\alpha\\right\\rangle }{\\sqrt{2\\left(1\\pm e^{-2|\\alpha|^{2}}\\right)}}\n\\end{align}\nfor any complex \\(\\alpha\\).\n", "notes": ["Pedagogical introduction to cat codes in the context of microwave cavities can be found in Refs. \\cite{arXiv:2203.03222,manual:{Shruti Puri, \\href{https://physinfo.fr/houches2019/files/Puri_v1.pdf}{QEC when the noise is biased}, 2019.}}, and in the context of optical systems in books \\cite{doi:10.1093/acprof:oso/9780198509141.001.0001,doi:10.1142/9781860948169_0009,doi:10.1002/9783527695805}."], "introduced": "\\cite{arXiv:quant-ph/9809037}", "short_name": "", "logical": "qubits", "realizations": ["Lindbladian-based \\cite{arXiv:1412.4633,arxiv:1705.02401} and Hamiltonian-based 'Kerr-cat' \\cite{arxiv:1907.12131} encodings have been achieved in superconducting circuit devices by the Devoret group; Ref. \\cite{arxiv:1705.02401} also demonstrated a displacement-based gate. The Lindbladian-based scheme has further achieved a suppression of bit-flip errors that is exponential in the average photon number \\cite{arXiv:1907.11729} up to a bit-flip time of 1ms. A bit-flip time of 1s has been achieved in a similar system in the classical bit regime \\cite{arxiv:2204.09128}.", "Approximate version realized in a superconducting circuit device by the Wang group \\cite{arxiv:2004.09322}."], "features": {"general_gates": ["Universal gates in the quantum optical setting can be performed using teleportation, Bell measurements, displacements, and rotations \\cite{arXiv:quant-ph/0306004}. An earlier protocol requires a non-linear interaction and uses state teleportation \\cite{arxiv:quant-ph/0109077}.", "Universal gates in the microwave setting can be performed using displacement operators and a rotation based on the Kerr nonlinearity \\cite{arXiv:1312.2017}. Kerr nonlinearity converts coherent states into Yurke-Stoler states \\cite{doi:10.1103/PhysRevLett.57.13}.", "Bias-preserving Hamiltonian-based CNOT gate utilizing an \\(X\\) gate with a topological Berry phase \\cite{arxiv:1904.09474,arXiv:1905.00450}. Bias-preserving SWAP gate \\cite{arxiv:2009.10756}."], "encoders": ["Lindbladian-based dissipative encoding \\cite{arXiv:1312.2017} utilizing two-photon absorption \\cite{doi:10.1103/PhysRevLett.60.1836,doi:10.1103/PhysRevA.50.4330,doi:10.1103/PhysRevA.49.490,doi:10.1103/PhysRevA.49.2785}. Encoding passively protects against cavity dephasing, suppressing dephasing noise exponentially with \\(|\\alpha|^2\\) \\cite{arXiv:1312.2017}.", "Hamiltonian-based 'Kerr-cat' encoding utilizing the Kerr-effect Hamiltonian \\cite{arXiv:1605.09408} (see also Ref. \\cite{arxiv:1510.02566}).", "Colored dissipation \\cite{arxiv:2107.09198}.", "Combined dissipative and Hamiltonian-based encoding utilizing two-photon exchange with an ancillary qubit \\cite{arXiv:2112.05545}.", "Critical encoding at non-zero detuning \\cite{arxiv:2208.04928}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Fault-tolerant error-correction procedure using small amplitude coherent states \\cite{arxiv:0707.0327}.", "Bias-preserving Hamiltonian-based CNOT gate \\cite{arXiv:1905.00450} is part of a universal bias-preserving gate set that can be made fault tolerant using concatenation \\cite{arXiv:1904.09474,arXiv:1905.00450}.", "Ancilla qubits encoded in two-component cat codes yield fault-tolerant syndrome extraction circuits \\cite{arxiv:1807.09334}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Two-legged cat codes for large \\(\\alpha\\) provide protection against modal dephasing, i.e., diffusion of the angular degree of freedom of the mode. They do not protect against photon loss events, but there exist modifications based on sign alternation \\cite{arXiv:1901.05358}, squeezing \\cite{arXiv:2201.02570,arxiv:2210.13406,arxiv:2210.13406}, and detuning \\cite{arxiv:2211.03689} that can add such protection.", "code_id": "two-legged-cat"}, "cat": {"name": "Cat code", "description": "Rotation-symmetric bosonic Fock-state code encoding a \\(q\\)-dimensional qudit into one oscillator. Codewords for a qubit code (\\(q=2\\)) consist of a coherent state \\(|\\alpha\\rangle\\) projected onto a subspace of Fock state number modulo \\(2(S+1)\\). The logical state \\(|\\overline{0}\\rangle\\) is in the \\(\\{|0\\rangle , |2(S+1)\\rangle , |4(S+1)\\rangle \\cdots \\}\\) Fock-state subspace, while \\(|\\overline{1}\\rangle\\) is in the \\(\\{|(S+1)\\rangle, |3(S+1)\\rangle , |5(S+1)\\rangle , |7(S+1)\\rangle \\cdots \\}\\) subspace. An alternative basis, valid for general \\(q\\) and \\(\\alpha\\neq 0\\), consists of \\(q\\) coherent states distributed equidistantly around a circle in phase space of radius \\(\\alpha\\).\n", "notes": [], "introduced": "\\cite{arXiv:1207.0679}", "short_name": "", "logical": "qubits", "realizations": ["Four-legged (\\(S=1\\)) cat code has been realized in a superconducting circuit device \\cite{arXiv:1602.04768}. This paper is the first to reach break-even error-correction, where the lifetime of a logical qubit is on par with the lifetime of the noisiest constituent of the system."], "features": {"general_gates": ["Holonomic gates utilizing the Berry phase of coherent states are universal \\cite{arxiv:1503.00194}.", "Universal gates in the microwave setting for the \\(S=1\\) code can be performed using squeezing operators and a rotation based on the Kerr nonlinearity \\cite{arXiv:1312.2017}."], "encoders": ["Lindbladian-based dissipative encoding utilizing multi-photon generalization of two-photon absorption \\cite{doi:10.1103/PhysRevLett.60.1836,doi:10.1103/PhysRevA.50.4330,doi:10.1103/PhysRevA.49.490,doi:10.1103/PhysRevA.49.2785}. Encoding passively protects against modal dephasing, suppressing dephasing noise exponentially with \\(|\\alpha|^2\\) \\cite{arXiv:1312.2017}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Measuring the Fock-state number modulo \\(2S\\) can be used to determine if photon loss or excitation errors occurred."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Due to the spacing between sets of Fock states, the distance between two distinct logical states is \\(d=S+1\\). Hence, this code is able to detect \\(S\\)-photon loss error.", "code_id": "cat"}, "coherent_constellation": {"name": "Coherent-state constellation quantum code", "description": "Qudit-into-oscillator code whose codewords can succinctly be expressed as superpositions of a countable set of coherent states that is called a \\textit{constellation}. Some useful constellations form a group (see \\hyperref[code:gkp]{gkp}\\hyperref[code:cat]{cat} or \\hyperref[code:2t_qutrit]{\\(2T\\)-qutrit} codes) while others make up a Gaussian quadrature rule \\cite{arxiv:1603.05970,doi:10.1109/ISIT.2016.7541749}.\n", "notes": [], "introduced": "", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Coherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the quantum capacity of the thermal noise channel \\cite{arxiv:1603.05970,doi:10.1109/ISIT.2016.7541749}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "coherent_constellation"}, "2t_qutrit": {"name": "2T-qutrit code", "description": "Two-mode qutrit code constructed out of superpositions of coherent states whose amplitudes make up the binary tetrahedral group \\(2T\\).\nThe codespace is a particular three-dimensional subspace of the 24-dimensional two-mode coherent-state subspace,\n\\begin{align}\n  \\mathrm{Span}( \\{|\\sqrt{2} e^{i (2k+1) \\pi/4} \\alpha\\rangle |0\\rangle,  |0\\rangle |\\sqrt{2} e^{i (2k+1) \\pi/4} \\alpha\\rangle, |e^{i k\\pi/2} \\alpha\\rangle |e^{i \\ell \\pi/2} \\alpha\\rangle \\: : \\: 0\\leq  k, \\ell \\leq 3\\})\n\\end{align}\nfor any \\(\\alpha \\geq 0\\).\nA basis can be constructed whose elements are equal superpositions of coherent states whose amplitudes make up cosets of the quaternion subgroup \\(Q\\) in \\(2T\\).\n", "notes": [], "introduced": "", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Logical phase-flip can be implemented using an excitation-preserving Gaussian transformation. Degree-four polynomial in the lowering operators of the two modes serves as a non-unitary logical bit-flip. Rotations of either mode by \\(\\pi/4\\) are logical gates that swap two logical codewords."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "2t_qutrit"}, "homological_cv": {"name": "Homological bosonic code", "description": "An \\([[n,1]]_{\\mathbb{R}}\\) \\hyperref[code:analog_stabilizer]{Gaussian CSS code} defined using homological structres associated with an \\(n-1\\) simplex. Relevant to the study of spacetime replication of quantum information \\cite{arxiv:1210.0913}.\n\nStabilizer generators are defined by two orthogonal subspaces of the \\(C_1\\) in the chain complex. \\(C_X = \\partial_2 C_2\\) and \\(C_P = \\partial_1^T Q\\) for some \\(Q \\subset C_0\\). The standard approach would use \\(Q = C_0\\), which would mean the logical dimension would be the dimension of the 1st homology group \\(H^1\\). However, \\(H^1\\) is trivial for the \\(n-1\\) simplex, so one chooses \\(Q \\neq C_0\\) such that exactly one stabilizer is removed, yielding a stabilizer code instead of a single stabilized state.\n", "notes": ["Proposed experimental optical procedure for realizing the simplest non-trival code with 5 modes \\cite{arXiv:1601.02544}."], "introduced": "\\cite{arXiv:1601.02544}", "short_name": "", "logical": "oscillators", "realizations": [], "features": {"general_gates": [], "encoders": ["Encoding depends on the specific dimension, but can generally be done using generalized conditional-rotation and Fourier-transform gates."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Decoding requires a different circuit for each possible erasure error, with no general circuit decoding any possible erasure error. Every circuit relies on a generalized conditional rotation, which Ref. \\cite{arXiv:1601.02544} calls the \\textit{QND Gate} and which is defined as \\(QND_c | x , y \\rangle = |x + c y, y \\rangle\\)."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Protects against certain types of erasure errors (depending on the specific dimension). Certain constructions also protect arbitrary sized errors on multiple photon states.", "code_id": "homological_cv"}, "analog_surface": {"name": "Analog surface code", "description": "Also called a \\textit{continuous-variable (CV) surface code}. An analog CSS version of the Kitaev surface code.\n", "notes": ["See \\cite[Sec. III.C2]{arxiv:1302.3428} for an exposition."], "introduced": "\\cite{arXiv:0711.0820}", "short_name": "", "logical": "oscillators", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Shift-based decoder \\cite{arxiv:1810.00047}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "analog_surface"}, "lloyd_slotine": {"name": "Lloyd-Slotine nine-mode code", "description": "A \\([[9,1,3]]_{\\mathbb{R}}\\) analogue CSS version of Shor's nine-qubit code.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9711021}", "short_name": "", "logical": "oscillators", "realizations": ["Optical network by the Furusawa group \\cite{arXiv:0811.3734}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "lloyd_slotine"}, "gkp": {"name": "Gottesman-Kitaev-Preskill (GKP) code", "description": "Bosonic qudit-into-oscillator code whose stabilizers are oscillator displacement operators \\(\\hat{S}_q(2\\alpha)=e^{-2i\\alpha \\hat{p}}\\) and \\(\\hat{S}_p(2\\beta)=e^{2i\\beta \\hat{x}}\\). To ensure \\(\\hat{S}_q(2\\alpha)\\) and \\(\\hat{S}_p(2\\beta)\\) generate a stabilizer group that is Abelian, there is another constraint that \\(\\alpha\\beta=2k\\pi\\) where \\(k\\) is an integer. Codewords can be expressed as equal weight superpositions of coherent states on an infinite lattice, such as a square lattice in phase space with spatial period \\(2\\sqrt{\\pi}\\). The exact GKP state is non-normalizable, so approximate constructs have to be considered.", "notes": ["GKP codes were obtained after iterative numerical optimization of encoding and recovery against photon loss, starting with Haar-random states \\cite{arXiv:1801.07271}.", "Reviews on GKP codes presented in Refs. \\cite{arxiv:2002.11008,arXiv:2106.12989}."], "introduced": "\\cite{arXiv:quant-ph/0008040}", "short_name": "GKP", "logical": "qudits", "realizations": ["Motional degree of freedom of a trapped ion: GKP encoding realized with the help of post-selection \\cite{arxiv:1807.01033,arXiv:1907.06478}, followed by realization of reduced form of GKP error correction, where displacement error syndromes are measured to one bit of precision using an ion electronic state \\cite{arxiv:2010.09681}.", "Microwave cavity coupled to superconducting circuits: reduced form of GKP error correction, where displacement error syndromes are measured to one bit of precision using an ancillary transmon \\cite{arxiv:1907.12487}.", "Single-qubit \\(Z\\)-gate has been demonstrated in the single-photon subspace of an infinite-mode space \\cite{arxiv:1904.01351}, in which time and frequency become bosonic conjugate variables of a single effective bosonic mode.", "In signal processing, GKP state position-state wavefunctions are related to Dirac combs \\cite{doi:10.1007/978-1-4612-2016-9}."], "features": {"general_gates": ["By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements \\cite{arxiv:1903.00012}."], "encoders": ["Preparation of approximate GKP states is studied both theoretically and experimentally by putting the GKP lattice inside a Gaussian envelope \\cite{arxiv:1506.05033,doi:10.1103/PhysRevA.97.022341,doi:10.1038/s41586-020-2603-3,arxiv:1910.03673}.", "Dissipative stabilization of finite-energy GKP states using stabilizers conjugated by a \\textit{cooling} (\\cite{arxiv:1310.7596}, Appx. B) or \\textit{damping} operator, i.e., a damped exponential of the total occupation number \\cite{arXiv:2009.07941,arxiv:2010.09681}.", "Two Josephson junctions coupled by a gyrator \\cite{arxiv:2002.07718}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Clifford gates can be realized by performing linear-optical operations, sympletic transformations and displacements, all of which are Gaussian operations. Pauli gates can be performed using displacement operators. Clifford gates are fault tolerant in the sense that they map bounded-size errors to bounded-size errors \\cite{arXiv:quant-ph/0008040}.", "Error correction scheme is fault-tolerant to displacement noise as long as all input states have displacement errors less than \\(\\sqrt{\\pi}/6\\) \\cite{arxiv:quant-ph/0510107}."], "threshold": [], "decoders": ["Syndrome measurement can be done by applying a controlled-displacement controlled by an ancilla qubit. The syndrome information can be obtained by measuring the ancilla qubit after controlled-displacement opearation. See Section. 2D in \\cite{arxiv:2106.12989}.", "Pauli \\(X\\),\\(Y\\) and \\(Z\\) measurements can be performed by measuring \\(-\\hat{p},\\hat{x}-\\hat{p}\\) and \\(\\hat{x}\\) repectively. If the measurement outcome is closed to an even multiple of \\(\\sqrt{\\pi}\\), then the outcome is +1. If the measurement outcome is closed to an odd multiple of \\(\\sqrt{\\pi}\\), then the outcome is -1. See Section. 2D in \\cite{arxiv:2106.12989}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "For stabilizer \\(\\hat{S}_q(2\\alpha),\\hat{S}_p(2\\beta)\\), code can correct displacement errors up to \\(\\frac{\\alpha}{2}\\) in the \\(q\\)-direction and \\(\\frac{\\beta}{2}\\) at \\(p\\)-direction. Approximately protects against photon loss errors \\cite{arxiv:1506.05033,arxiv:1708.05010}, outperforming most other codes designed to explicitly protect against loss \\cite{arxiv:1708.05010}. Very sensitive to dephasing errors \\cite{arxiv:2106.12989}. A biased-noise GKP error correcting code can be prepared by choosing \\(\\alpha\\neq \\beta\\).", "code_id": "gkp"}, "analog_stabilizer": {"name": "Analog stabilizer code", "description": "Also known as a \\textit{linear} or \\textit{Gaussian stabilizer code}. Oscillator-into-oscillator stabilizer code encoding \\(k\\) logical modes into \\(n\\) physical modes. An \\(((n,k,d))_{\\mathbb{R}}\\) analog stabilizer code is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.\n\nAnalog stabilizer codes admit continuous stabilizer group of displacements.  This group can equivalently be defined in terms of its Lie algebra. The codespace is equivalently the common \\(0\\)-eigenvalue eigenspace of the Lie algebra generators, which are mutually commuting linear combinations of oscillator position and momentum operators called \\textit{nullifiers} \\cite{arxiv:0903.3233} or \\textit{annihilators}. A analog stabilizer code admitting a set a set of nullifiers such that each nullifier consists of either position or momentum operators is called an \\textit{analog CSS code}.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": ["A Gaussian operation acting on position states."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Homodyne measurement of nullifiers yields real-valued syndromes, and recovery can be performed by displacements conditional on the syndromes."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Protect against erasures of at most \\(d-1\\) modes, or arbitrarily large dispalcements on those modes. If an error operator does not commute with a nullifier, then that error is detectable. Protection of logical modes against small displacements cannot be done using only Gaussian resources \\cite{arxiv:0811.3128,arxiv:1810.00047} (see also \\cite{arxiv:quant-ph/0204052,arxiv:quant-ph/0204085}). There are no such restrictions for non-Gaussian noise \\cite{arxiv:0811.3616}.", "code_id": "analog_stabilizer"}, "oscillator_stabilizer": {"name": "Bosonic stabilizer code", "description": "Also known as a \\textit{continuous-variable (CV) stabilizer code}. Bosonic code whose codespace is defined as the common \\(+1\\) eigenspace of a group of mutually commuting displacement operators. Displacements form the stabilizers of the code, and have continuous eigenvalues, in contrast with the discrete set of eigenvalues of qubit stabilizers. As a result, exact codewords are non-normalizable, so approximate constructions have to be considered.\n\nStabilizer codewords encoding a finite-dimensional codespace admit a discrete infinite stabilizer group. Such \\hyperref[code:qudits_into_oscillators]{qudit-into-oscillator} stabilizer codes are \\hyperref[code:gkp]{GKP} and \\hyperref[code:multimodegkp]{multimode GKP} codes.\n\nStabilizer codewords encoding a logical oscillator (i.e., CV quantum information) admit either a discrete or a continuous stabilizer group. The former, called GKP-stabilizer codes, are obtained from multimode GKP codes by removing stabilizer generators for some of the modes. The latter can be defined in terms of the continuous group's Lie algebra, i.e., as the common \\(0\\)-eigenvalue eigenspace of mutually commuting linear combinations of oscillator position and momentum operators called \\textit{nullifiers} \\cite{arxiv:0903.3233} or \\textit{annihilators}. An \\hyperref[code:oscillators_into_oscillators]{oscillator-into-oscillator} stabilizer code encoding \\(k\\) logical modes into \\(n\\) physical modes is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0405064}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Protective properties can be delineated in terms of the nullifiers or displacements, and the most natural noise model for such codes is displacement noise. If an error operator does not commute with a stabilizer group element, then that error is detectable. Oscillator-into-oscillator stabilizer codes protect against erasures of a subset of modes, while GKP codes protect against sufficiently small displacements in any number of modes.", "code_id": "oscillator_stabilizer"}, "gkp-stabilizer": {"name": "GKP-stabilizer code", "description": "Stub.", "notes": [], "introduced": "\\cite{arXiv:1903.12615}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["Thresholds against displacement noise cannot be obtained without ideal (i.e., non-normalizable) codewords \\cite{arxiv:2102.05545}."], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "gkp-stabilizer"}, "braunstein": {"name": "Braunstein five-mode code", "description": "A \\([[5,1,3]]_{\\mathbb{R}}\\) analog stabilizer version of the five-qubit perfect code.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9711049}", "short_name": "", "logical": "oscillators", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Error correction can be done using linear-optical elements and feedback \\cite{doi:10.1038/27850}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "braunstein"}, "gkp-cluster-state": {"name": "GKP cluster-state concatenated code", "description": "Multi-mode code encoding logical qubits into a cluster-state stabilizer code concatenated with a single-mode GKP code. Provides a way to perform a continuous-variable (CV) analogue of fault-tolerant measurement-based qubit computation.\n\nA cluster state of GKP qubits on a graph is made by applying two-mode \\(C_Z\\)-type gates \\(e^{\\pm i \\hat{x}\\otimes\\hat{x}}\\) to a tensor product of \\(|\\overline{+}\\rangle\\) logical GKP states on each vertex. Logical Clifford gates are performed on the cluster state using CV measurement-based computation \\cite{arxiv:quant-ph/0605198,arxiv:0903.3233}, i.e., via a combination of linear-optical gates and homodyne measurements on subsets of vertices. Magic-state distillation is required for universal computation. GKP error correction can be naturally combined with CV measurement-based protocols since the performance of both is quantified by a squeezing parameter.\n", "notes": [], "introduced": "\\cite{arXiv:1310.7596}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": ["Single-mode logical Clifford gates can be performed using Gaussian operations and measurements on a 1D GKP cluster state, while two-mode logical Clifford gates require a 2D cluster state. Magic-state distillation using photon-counting can be used for a non-Clifford logical \\(\\pi/8\\) gate."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["First encoding demonstrating the possibility of fault-tolerant measurement-based computation with CV cluster states. A fault-tolerance threshold can be achieved by concatenating existing fault-tolerant schemes for qubit-based cluster-state encodings with the GKP code \\cite{arXiv:1310.7596}.", "Hybrid cluster state consisting of GKP qubits at some modes and squeezed states at others has been proposed to work in a fault-tolerant scheme \\cite{arxiv:2010.02905}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "", "code_id": "gkp-cluster-state"}, "multimodegkp": {"name": "Multi-mode GKP code", "description": "Generalization of the GKP code to \\(n\\) bosonic modes whose stabilizer group is an infinite countable group of oscillator displacement operators.\n\nDisplacement operators on \\(n\\) modes can be written as\n\\begin{align}\nD(\\xi) = \\exp \\left\\{-i \\sqrt{2\\pi} {\\xi}^\\mathrm{T} J \\hat{q} \\right\\} , \\quad \\xi \\in \\mathbb{R}^{2n}~,\n\\end{align}\nwhere \\(\\hat{q}\\) is a \\(2n\\)-dimensional vector position and momentum operators of the modes, the symplectic form\n\\begin{align}\nJ = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} \\otimes I_n = \\begin{pmatrix}\n0 &  I_n \\\\\n-I_n  & 0 \\end{pmatrix}~,\n\\end{align}\nand \\(I_n\\) is the identity matrix. A group generated by a set of independent displacement operators is given by a lattice \\({\\mathcal{L}}\\)\n\\begin{align}\n\\langle D(\\xi_1) ,\\dots,  D(\\xi_{m})  \\rangle = \\{ e^{ i \\phi_M (\\xi) } D(\\xi) ~\\vert~ \\xi \\in {\\mathcal{L}} \\}\n\\end{align}\nand becomes a valid stabilizer group when every symplectic inner product between lattice vectors yields an integer. In other words, the corresponding lattice is symplectically integral, corresponding to an integer-valued symplectic Gram matrix \\(A\\),\n\\begin{align}\nA_{ij}={\\xi}^T_i J \\xi_j \\in \\mathbb{Z}~.\n\\end{align}\nThe \\(m=2n\\) case yields multimode GKP codes encoding a finite-dimensional logical subspace, while removing some displacements yields GKP-stabilizer codes encoding an infinite-dimensional logical subspace. Codes defined on a hyper-rectangular lattice are \\textit{CSS GKP} codes, and more general lattices, obtained by Gaussian transformations, yield non-CSS codes.\n\nThe centralizer for the stabilizer group within the displacement operators for the \\(m=2n\\) case can be identified with the symplectic dual lattice \\({\\mathcal{L}}^{\\perp}\\) (i.e. all points in \\(\\mathbb{R}^{2n}\\) that have integer symplectic inner product with all points in \\({\\mathcal{L}}\\) ), such that logical operations are identified with the dual quotients \\({\\mathcal{L}}^{\\perp}/{\\mathcal{L}}\\). The size of this dual quotient is the determinant of the Gram matrix, yielding the logical dimension \\(d=\\sqrt{\\| \\det{A}\\|}\\) \\cite{arXiv:quant-ph/0008040}.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/0008040,arXiv:quant-ph/0105058}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": ["By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements \\cite{arXiv:1903.00012}."], "encoders": ["Multi-mode GKP codes with fixed \\(n\\) and prime-dimensional logical Hilbert space are symplectically related to a disjoint product of single-mode GKP codes on \\(n\\) modes, such that encoding via Gaussian unitaries is possible.", "Dissipative stabilization of finite-energy GKP states using stabilizers conjugated by \\textit{cooling} (\\cite{arxiv:1310.7596}, Appx. B) or \\textit{damping} operator, i.e., a damped exponential of the total occupation number \\cite{arXiv:2009.07941,arxiv:2201.12337}."], "rate": "Transmission schemes with multimode GKP codes achieve, up to a constant-factor offset, the capacity of displacement-noise and thermal-noise Gaussian loss channels \\cite{arXiv:quant-ph/0105058,arXiv:1708.07257,arXiv:1801.04731,arXiv:1801.07271}. Particular lattice families of multimode GKP codes achieve the hashing bound of the displacement noise channel \\cite{arxiv:quant-ph/0105058}.", "magic_scaling_exponent": "", "fault_tolerance": ["Logical Clifford operations are given by Gaussian unitaries, which map bounded-size errors to bounded-size errors \\cite{arXiv:quant-ph/0008040}."], "threshold": [], "decoders": ["The MLD decoder for Gaussian displacement errors is realized by evaluating a lattice theta function, and in general the decision can be approximated by either solving (approximating) the closest vector problem (CVP) or by using other effective iterative schemes when e.g. the lattice represents a concatenated GKP code \\cite{arXiv:1810.00047,arXiv:1908.03579,arXiv:2109.14645,arxiv:2111.07029}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "The level of protection against displacement errors is quantified by the Euclidean code distance \\(\\Delta=\\min_{x\\in {\\mathcal{L}}^{\\perp}\\setminus {\\mathcal{L}}} \\|x\\|_2\\) \\cite{arXiv:2109.14645}.", "code_id": "multimodegkp"}, "chuang-leung-yamamoto": {"name": "Chuang-Leung-Yamamoto (CLY) code", "description": "Bosonic Fock-state code that encodes \\(k\\) qubits into \\(n\\) oscillators, with each oscillator restricted to having at most \\(N\\) excitations. Codewords are superpositions of oscillator Fock states which have exactly \\(N\\) total excitations, and are either uniform (i.e., balanced) superpositions or unbalanced superpositions. Codes can be denoted as \\([[N,n,2^k,d]]\\), which conflicts with \\hyperref[code:stabilizer]{stabilizer code} notation.\n\nA simple example of a CLY code is a two-mode \"0-2-4\" qubit code with codewords\n\\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{2}}\\left(|40\\rangle+|04\\rangle\\right)\\\\\n  |\\overline{1}\\rangle&=|22\\rangle~.\n\\end{split}\n\\end{align}\n", "notes": [], "introduced": "\\cite{doi:10.1103/PhysRevA.56.1114}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": ["Photon Fock state input into a network of beamsplitters, phase shifters, and Kerr media. These operations all preserve total photon number. Beamsplitters and phase shifters take annihilation operators to linear combinations of annihilation operators, and the transformation matrix is unitary. The operations corresponding to Kerr nonlinear media are diagonal in the Fock basis, but they implement phases that in general depend nonlinearly on the number of photons in each mode. State preparation may require ancillary modes and be conditioned on photon-number measurement results."], "rate": "Code rate is \\(\\frac{k}{n \\log_2(N+1)}\\). To correct the loss of up to \\(t\\) excitations with \\(K+1\\) codewords, a code exists with scaling \\(N \\sim t^3 K/2\\).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Destructive decoding with a photon number measurement on each mode.", "State can be decoded with a network of beamsplitters, phase shifters, and Kerr media."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Protects against amplitude damping for up to \\(t = d-1\\) excitation losses. Defining the \\textit{spacing} between two Fock states \\(|u_1\\cdots u_n\\rangle\\) and \\(|v_1\\cdots v_n\\rangle\\),\n\\begin{align}\n\\text{Spacing}(u,v) = \\frac{1}{2}\\sum_{i=1}^n |u_i - v_i|,\n\\end{align}\nthe code distance \\(d\\) can be defined as the minimial spacing between Fock states making up the codewords.\n", "code_id": "chuang-leung-yamamoto"}, "wasilewski-banaszek": {"name": "Wasilewski-Banaszek code", "description": "Three-oscillator Fock-state code encoding a single logical qubit using codewords \\begin{align} \\begin{split} |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{3}}(|003\\rangle+|030\\rangle+|300\\rangle)\\\\ |\\overline{1}\\rangle &= |111\\rangle \\end{split}. \\end{align}", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0702075}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Single-qubit gates implemented using linear optical networks, sometimes with the addition of auxiliary modes with vacuum input and (conditional) output."], "encoders": ["A qubit in the dual-rail code can be transferred to this code via a linear optical network using four ancillary modes, each with one photon input. Successful encoding is conditioned on measuring the state \\(|110\\rangle\\) on the last three modes."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Destructive measurement with photon number measurements on each mode."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Protects against single photon loss in any one mode.", "code_id": "wasilewski-banaszek"}, "dual_rail": {"name": "Dual-rail quantum code", "description": "Two-mode code encoding a logical qubit in Fock states with one excitation. The logical-zero state is represented by \\(|01\\rangle\\), while the logical-one state is represented by \\(|10\\rangle\\). The two modes of the encoding can represent temporal or spatial modes, corresponding to a \\textit{time-bin} or \\textit{frequency-bin} encoding.", "notes": ["For Deutsch's problem \\cite{doi:10.1098/rspa.1992.0167} with optical qubits, error correction using photon number detection reduces the error probability from \\(\\frac{1}{4} (1+e^{-\\gamma}-2e^{-3\\gamma/2}) \\)   to \\(\\frac{1}{2} (1- \\text{sech} \\gamma/2)\\).", "See review \\cite{arxiv:quant-ph/0512071} for more details."], "introduced": "\\cite{doi:10.1103/PhysRevA.52.3489}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": ["General gates are performed using beamsplitters and Kerr non-linearities. Universal quantum computing can be achieved with photons in dual-rail encodings using the KLM protocol \\cite{doi:10.1038/35051009} with only linear optical elements and photon detectors."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Dual-rail qubits can be used to convert leakage and amplitude damping noise into erasure noise \\cite{arxiv:2208.05461}."], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "This is an error-detecting code against one photon loss event; it is often used in photonic quantum devices because of its ease of realization. A single loss event can be detected because, after the loss occurs, the output state \\(|00\\rangle\\) is orthogonal to the codespace. Recovery is not possible, so a successful run of a quantum circuit is conditioned on not losing a photon during the circuit.\n\nFor Deutsch''s  problem specifically, this code protects against errors resulting in states that have the correct photon number, but in the wrong modes \\cite{doi:10.1103/PhysRevA.52.3489}.\n", "code_id": "dual_rail"}, "paircat": {"name": "Pair-cat code", "description": "Two- or higher-mode extension of cat codes whose codewords are right eigenstates of powers of products of the modes' lowering operators. Many gadgets for cat codes have two-mode pair-cat analogues, with the advantage being that such gates can be done in parallel with a dissipative error-correction process.\n\nTwo-mode codewords are supported by Fock states with occupation number \\(\\hat{n}_2-\\hat{n}_1\\) fixed to some integer \\(\\Delta\\). In the \\textit{two-component} case, \\(|\\overline{0}_{\\gamma,\\Delta}\\rangle \\sim |\\gamma_\\Delta \\rangle + (-1)^\\Delta |i\\gamma_\\Delta\\rangle\\) and \\(|\\overline{1}_{\\gamma,\\Delta}\\rangle \\sim |\\gamma_\\Delta\\rangle - (-1)^\\Delta |i \\gamma\\rangle\\), where\n\\begin{align}\n|\\alpha_\\Delta \\rangle \\propto \\sum_{n=0}^\\infty \\frac{\\alpha^{2n+\\Delta}}{\\sqrt{n! (n+\\Delta)!}} |n,n+\\Delta\\rangle\n\\end{align}\nis the corresponding pair-coherent state \\cite{doi:10.1007/BF01646483,doi:10.1103/PhysRevLett.57.827,doi:10.1364/JOSAB.5.001940} with complex amplitude \\(\\alpha\\), up to normalization.\n", "notes": [], "introduced": "\\cite{arxiv:1801.05897}", "short_name": "", "logical": "qubits", "realizations": ["Microwave cavities coupled to superconducting circuits by the Wang group \\cite{arxiv:2209.11643}."], "features": {"general_gates": ["Hamiltonian \\(X\\), \\(XX\\), \\(Z\\) gates, holonomic \\(Z\\) gate, control-phase gate.", "Bias-preserving gates \\cite{arxiv:2208.06913}."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Lindbladian-based dissipative encoding utilizing two-mode two-photon absorption \\cite{doi:10.1103/PhysRevLett.57.827}. Encoding passively protects against cavity dephasing, suppressing dephasing noise exponentially with \\(\\gamma^2\\)."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "The occupation-number differences form the syndromes, as opposed to the photon number parity for the single-mode cat code. Any loss even combination that changes the relative differences of photons between modes is a detectable error. The two-mode two-component paircat code can detect arbitrary single-mode losses, but cannot detect simultaneous photon loss in both modes. An \\(n\\)-mode code can detect any loss errors of at most \\(n-1\\) weight. Higher numbers of legs correspond to more pair-coherent state present in the codewords, and allow for protection against simulataneous losses.", "code_id": "paircat"}, "chebyshev": {"name": "Chebyshev code", "description": "Single-mode bosonic Fock-state code that can be used for error-corrected sensing of a signal Hamiltonian \\({\\hat n}^s\\), where \\({\\hat n}\\) is the occupation number operator. Codewords for the \\(s\\)th-order Chebyshev code are\n\\begin{align}\n\\begin{split}\n\\ket{\\overline 0} &=\\sum_{k \\text{~even}}^{[0,s]} \\tilde{c}_k \\Ket{\\left\\lfloor M\\sin^2\\left( k\\pi/{2s}\\right) \\right\\rfloor},\\\\\n\\ket{\\overline 1} &= \\sum_{k \\text{~odd}}^{[0,s]} \\tilde{c}_k \\Ket{\\left\\lfloor M\\sin^2 \\left(k\\pi/{2s}\\right) \\right\\rfloor},\n\\end{split}\n\\end{align}\nwhere \\(\\tilde{c}_k>0\\) can be obtained by solving a system of order \\(O(s^2)\\) linear equations, and where \\(\\lfloor x \\rfloor\\) is the floor function. The code approaches optimality for sensing the signal Hamiltonian as \\(M\\) increases.\n", "notes": [], "introduced": "\\cite{arxiv:1811.01450}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "The \\(s\\)th-order code corrects errors from the set \\(\\{I,a,a^{\\dagger},{\\hat n},{\\hat n}^2,\\cdots,{\\hat n}^{s-1}\\}\\).", "code_id": "chebyshev"}, "numopt": {"name": "Numerically optimized code", "description": "Bosonic Fock-state code obtained from a numerical minimization procedure, e.g., from enforcing error-correction criteria against some number of losses while minimizing average occupation number.\n\nThe smallest numerically optimized code is the \\(\\sqrt(17)\\) code,\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{\\sqrt{6}}\\left(\\sqrt{7-\\sqrt{17}}|0\\rangle+\\sqrt{\\sqrt{17}-1}|3\\rangle\\right)\\\\\n|\\overline{1}\\rangle&=\\frac{1}{\\sqrt{6}}\\left(\\sqrt{9-\\sqrt{17}}|1\\rangle-\\sqrt{\\sqrt{17}-3}|4\\rangle\\right)~,\n\\end{split}\n\\end{align}\ncorrecting a single loss error. The average occupation number of the codewords is \\(\\approx 1.6\\), which is \\(0.4\\) photons lower than that of the smallest binomial code with the same level of protection.\n", "notes": [], "introduced": "\\cite{arXiv:1602.00008,arxiv:1708.05010}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Number phase codes protect from a finite number of loss events. However, unlike Fock-state codes, their protection does not stem from a Fock-state spacing.", "code_id": "numopt"}, "constant_excitation_permutation_invariant": {"name": "Constant-excitation permutation-invariant code", "description": "Stub.\n", "notes": [], "introduced": "\\cite{arXiv:1809.09801}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "", "code_id": "constant_excitation_permutation_invariant"}, "fock_state": {"name": "Fock-state bosonic code", "description": "Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. The simplest example is the dual-rail code, which has codewords consisting of single Fock states \\(|10\\rangle\\) and \\(|01\\rangle\\). This code can detect a single loss error since a loss operator in either mode maps one of the codewords to a different Fock state \\(|00\\rangle\\). More involved codewords consist of several well-separated Fock states such that multiple loss events can be detected and corrected.", "notes": [], "introduced": "", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Code distance \\(d\\) is the minimum distance (assuming some metric) between any two labels of Fock states corresponding to different code basis states. For a single mode, \\(d\\) is the minimum absolute value of the difference between any two Fock-state labels; such codes can detect up to \\(d-1\\) loss events. Multimode distances can be defined analogously; see, e.g., \\hyperref[code:chuang-leung-yamamoto]{Chuang-Leung-Yamamoto codes}.", "code_id": "fock_state"}, "binomial": {"name": "Binomial code", "description": "Bosonic rotation codes designed to approximately protect against errors consisting of powers of raising and lowering operators up to some maximum power. Binomial codes can be thought of as spin-coherent states embedded into an oscillator \\cite{arXiv:1708.05010}.\n\nA simple example of a binomial code is the \"0-2-4\" qubit code with codewords\n\\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{2}}\\left(|0\\rangle+|4\\rangle\\right)\\\\\n  |\\overline{1}\\rangle&=|2\\rangle~.\n\\end{split}\n\\end{align}\n\n\nGeneral \\(q\\)-dimensional qudit \\((N, S)\\) binomial codeword states are \\(\\{|\\overline{i}\\rangle\\mid i\\in \\mathbb Z_q \\}\\), where\n  \\begin{align}\n    |\\overline{i}\\rangle = \\frac{1}{\\sqrt{q^N}} \\sum_{\\substack{p=0\\\\p\\equiv i \\pmod{q}}}^{(q-1)(N+1)} \\sqrt{\\binom{N+1}{p}_q} \\ket{p(S+1)}.\n  \\end{align}\n  The set \\( \\ket{i} \\mid i \\in \\mathbb{N}\\) is the set of Fock states. Also, \\(\\binom{N+1}{p}_q\\) are extended binomial coefficients, or polynomial coeffiients, defined recursively as\n  \\begin{align}\n    \\binom{n}{m}_1 \\equiv 1,\\quad \\binom{n}{m}_q \\equiv \\sum_{k=0}^n \\binom{n}{k}\\binom{k}{m-k}_{q-1}.\n  \\end{align}\n  The extended binomial coefficients \\( \\binom{n}{m}_q \\) are also the coefficients of \\( x^m \\) in the polynomial \\( (1 + x + \\cdots + x^{q-1})^n \\).\n", "notes": ["The mean occupation number, or average Fock-state number in maximally-mixed state of the code, is \\((N+1)(S+1)(q-1)/2 \\), where \\(q\\) is the qudit dimension."], "introduced": "\\cite{arXiv:1602.00008}", "short_name": "", "logical": "qudits", "realizations": ["Microwave cavities coupled to superconducting circuits: state transfer between a binomial codeword to another system \\cite{arxiv:1712.05832}, error-correction protocol nearly reaching break-even \\cite{arxiv:1805.09072}, and a teleported CNOT gate \\cite{arxiv:1810.04690}."], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Photon loss and dephasing errors can be detected by measuring the phase-space rotation \\(\\exp\\left(2\\pi\\mathrm{i} \\hat{n} / (S+1)\\right)\\) and the check operator \\(J_x/J\\) in the spin-coherent state language, where \\(J\\) is the total angular momentum and \\(J_x\\) is the angular momentum in the \\(x\\) direction \\cite{arXiv:1708.05010}. This type of error correction fails for errors that are products of photon loss/gain and dephasing errors. However, for certain \\((N,S)\\) instances of the binomial code, detection of these types of errors can be done.", "Recovery can be done via projective measurements and unitary operations \\cite{arXiv:1602.00008,arXiv:1708.05010}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "An \\((N, S)\\) binomial code protects against \\(L\\) boson losses, \\(G\\) boson gains, and dephasing up to \\(\\hat{n}^{D}\\), where \\(S=L+G\\) and \\(N = \\mathrm{max}(L,G,2D)\\).  Binomial codes approximately protect against continuous-time amplitude damping, boson loss and gain, and dephasing.", "code_id": "binomial"}, "bosonic_rotation": {"name": "Bosonic rotation code", "description": "A single-mode Fock-state bosonic code whose codespace is preserved by a phase-space rotation by a multiple of \\(2\\pi/N\\) for some \\(N\\). The rotation symmetry ensures that encoded states have support only on every \\(N^{\\textrm{th}}\\) Fock state. For example, single-mode Fock-state codes for \\(N=2\\) encoding a qubit admit basis states that are, respectively, supported on Fock state sets \\(\\{|0\\rangle,|4\\rangle,|8\\rangle,\\cdots\\}\\) and \\(\\{|2\\rangle,|6\\rangle,|10\\rangle,\\cdots\\}\\).\n\nEncoding of a \\(q\\)-dimensional logical qudit admit a basis whose elements are eigenstates of the rotation operator \\(\\exp\\left(\\mathrm{i} 2\\pi \\hat{n}/qN \\right)\\), where \\(\\hat{n}\\) is the number operator diagonal in the Fock basis. Basis elements are of the form \\(\\sum_{j=0}^\\infty c_j |(kq+j)N \\rangle\\) for some coefficients \\(c_j\\) and \\(k\\). This is because the rotation acting on a general Fock-state superposition \\(\\sum_n a_n |n\\rangle\\) yields \\(\\sum_n a_n \\exp\\left(\\mathrm{i} 2\\pi n / qN \\right) |n\\rangle\\). In order for a codeword to be an eigenvector of this operation, \\(a_n\\) must be zero whenever \\(n \\neq (kq+j)N\\) for some \\(k\\).\n\nCodewords can be uniquely specified by choosing a \\emph{primitive} state \\(|\\Theta\\rangle\\). To ensure valid (orthogonal and nonzero) codewords, \\(|\\Theta\\rangle\\) must satisfy the following requirement: for each \\(j \\in \\mathbb{Z}_q\\), \\(|\\Theta\\rangle\\) must have support on the Fock state \\(|(k_j q+j)N\\rangle\\) for at least one \\(k_j \\in \\mathbb{N}_0\\). From such a primitive, the codewords \\(\\{|\\overline{j}\\rangle \\mid j \\in \\mathbb{Z}_q\\}\\) are constructed as\n\\begin{align}\n|\\overline{j}\\rangle \\propto \\sum_{m=0}^{2N-1} \\mathrm{e}^{2\\pi \\mathrm{i} m (\\hat n  / N + j) / q} |\\Theta\\rangle~.\n\\end{align}\n", "notes": [], "introduced": "\\cite{arXiv:1901.08071}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": ["The logical Pauli-\\(Z\\) gate can be the discrete rotation operator \\(\\mathrm{e}^{\\mathrm{i} \\pi \\hat n /N}\\), and the logical Pauli-\\(X\\) gate can be the (note: non-unitary) number-translation operator \\(\\sum_{n=0}^\\infty |n\\rangle\\bra{n+N}\\).", "For qubit codes, a logical phase gate is \\(S = \\mathrm{e}^{\\pi \\mathrm{i} \\hat n^2 / 2N^2}\\).", "The \\(T = \\mathrm{diag}(1,\\exp(\\mathrm{i}\\pi/4))\\) gate can be done via gate teleportation and a resource state \\(\\vert 0_N\\rangle + \\exp(\\mathrm{i}\\pi/4) \\vert 1_N \\rangle\\).", "A controlled-rotation gate between an order \\(N\\) rotation code and an order \\(M\\) rotation code is \\(\\mathrm{CROT}_{NM} = \\mathrm{e}^{(2\\pi\\mathrm{i} / qNM) \\hat n \\otimes \\hat n}\\)."], "encoders": ["The optimal way to prepare codewords depends on the exact rotation code in question \\cite{arXiv:1901.08071}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["One can distinguish (destructively) the codewords by performing a Fock-state number measurement. If a Fock state state \\(|n\\rangle\\) is measured, then one rounds to the nearest integer of the form \\((kq+j)/N\\), and deduces that the true state was \\(|\\overline{j}\\rangle\\).", "One can distinguish states in the dual basis by performing phase estimation on \\(\\mathrm{e}^{\\mathrm{i} \\theta \\hat n}\\). One then rounds the resulting \\(\\theta\\) to the nearest number \\(2\\pi j / qN\\) in order to determine which dual basis state \\(j \\in \\mathbb Z_q\\) it came from.", "Autonomous quantum error correction schemes for \\(S=1\\) codes \\cite{arxiv:2203.09234}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Losses or gains less than \\(N\\) are detectable. Dephasing rotations \\(\\exp(\\mathrm{i}\\theta \\hat{n})\\) can be detected whenever \\(\\theta\\) is roughly less than \\(\\pi/N\\). To get precise bounds on \\(\\theta\\), one needs to analyze the particular bosonic rotation code.", "code_id": "bosonic_rotation"}, "number_phase": {"name": "Number-phase code", "description": "Bosonic rotation code consisting of superpositions of Pegg-Barnett phase states \\cite{doi:10.1088/0305-4470/19/18/030},\n\\begin{align}\n|\\phi\\rangle \\equiv \\frac{1}{\\sqrt{2\\pi}}\\sum_{n=0}^{\\infty} \\mathrm{e}^{\\mathrm{i} n \\phi} \\ket{n}.\n\\end{align}\nSince phase states and thus the ideal codewords are not normalizable, approximate versions need to be constructed. The codes' key feature is that, in the ideal case, phase measurement has zero uncertainty, making it a good canditate for a syndrome measurement.\n\nLogical states of an order-\\(N\\) number-phase qubit encoding are \\(|\\overline{0}\\rangle= \\sum_{m=0}^{2N-1} |\\phi = m\\pi/N\\rangle\\) and \\(|\\overline{1}\\rangle = \\sum_{m=0}^{2N-1} (-1)^m |\\phi=m\\pi/N\\rangle\\). By performing the summation over \\(m\\), one finds that \\(|\\overline{0}\\rangle\\) is supported on Fock states \\(|2kN\\rangle\\), while \\(|\\overline{1}\\rangle\\) is supported on states \\(|(2k+1)N\\rangle\\), for \\(k \\geq 0\\).\n", "notes": [], "introduced": "\\cite{arxiv:1901.08071}", "short_name": "", "logical": "qubits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Fault-tolerant computation schemes with number-phase codes have been proposed based on concatenation with Bacon-Shor subsystem codes \\cite{arxiv:1901.08071}."], "threshold": [], "decoders": ["Modular phase measurement done in the logical \\(X\\), or dual, basis has zero uncertainty in the case of ideal number phase codes. This is equivalent to a quantum measurement of the spectrum of the phase operator \\cite{doi:10.1103/PhysicsPhysiqueFizika.1.49}. Approximate number-phase codes are characterized by vanishing phase uncertainty. Such measurements can be utilized for Knill error correction (a.k.a. telecorrection \\cite{arxiv:quant-ph/0601066}), which is based on teleportation \\cite{arxiv:quant-ph/0410199,arXiv:quant-ph/0312190}. This type of error correction substitutes the complicated correction procedures typical in Fock-state codes for necessity of clean codewords \\cite{arxiv:1901.08071}.", "Number measurement can be done by extracting modular number information using a CROT gate \\(\\mathrm{e}^{(2\\pi \\mathrm{i} / NM) \\hat n \\otimes \\hat n}\\) and performing phase measurements \\cite{doi:10.1007/BF01007479,doi:10.1007/978-88-7642-378-9} on an ancillary mode. See Section 4.B.1 of Ref. \\cite{arxiv:1901.08071}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "oscillators", "protection": "Number-phase codes of order \\(N\\) detect up to \\(N\\) photon loss or gain errors, and dephasing up to \\(\\theta = \\pi/N\\).", "code_id": "number_phase"}, "rotor": {"name": "Rotor code", "description": "Encodes a \\textit{logical} Hilbert space, finite- or infinite-dimensional, into a \\textit{physical} Hilbert space of \\(\\ell^2\\)-normalizable functions on either the integers \\(\\mathbb Z\\) or the circle group \\(U(1)\\).", "notes": [], "introduced": "", "short_name": "", "logical": "groups", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "", "code_id": "rotor"}, "rotor_5_1_3": {"name": "\\([[5,1,3]]_{\\mathbb Z}\\) rotor code", "description": "Extension of the five-qubit stabilizer code to the integer alphabet, i.e., the angular momentum states of a planar rotor. The code is \\(U(1)\\)-covariant and ideal codewords are not normalizable.\n", "notes": [], "introduced": "\\cite{arxiv:1902.07714}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Normalized codewords approximately protect against erasure while maintaining covariance \\cite{arxiv:1902.07714}.\n", "code_id": "rotor_5_1_3"}, "group_quantum": {"name": "Group-based quantum code", "description": "Encodes a \\textit{logical} Hilbert space, finite- or infinite-dimensional, into a \\textit{physical} Hilbert space of \\(\\ell^2\\)-normalizable functions on a second-countable unimodular group. For \\(K\\)-dimensional logical subspace and for groups \\(G^{n}\\), can be denoted as \\(((n,K))_G\\). When the logical subspace is the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(G^{ k}\\), can be denoted as \\([[n,k]]_G\\). Ideal codewords may not be normalizable, depending on whether \\(G\\) is continuous and/or noncompact, so approximate versions have to be constructed in practice.", "notes": [], "introduced": "", "short_name": "", "logical": "groups", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "", "code_id": "group_quantum"}, "rotor_gkp": {"name": "Rotor GKP code", "description": "GKP code protecting against small angular position and momentum shifts of a planar rotor.", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0008040,arxiv:1911.00099}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "", "code_id": "rotor_gkp"}, "molecular": {"name": "Molecular code", "description": "Encodes finite-dimensional Hilbert space into the Hilbert space of \\(\\ell^2\\)-normalizable functions on the group \\(SO_3\\). Construction is based on nested subgroups \\(H\\subset K \\subset SO_3\\), where \\(H,K\\) are finite. The \\(|K|/|H|\\)-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\).", "notes": ["Physical space characterizes orientations of a rigid body in 3D, which correspond to rotational states of an asymmetric molecule. See APS Physics Synopsis \\cite{doi:10.1103/Physics.13.s111} and \\href{https://www.youtube.com/watch?v=gjBbMMZ3L1k}{Physical Review Journal club} discussing molecular applications."], "introduced": "\\cite{arXiv:1911.00099}", "short_name": "", "logical": "rigid_bodies", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "Protects against generalized bit-flip errors \\(g\\in SO_3\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "code_id": "molecular"}, "quantum_double": {"name": "Quantum-double code", "description": "A family of topological codes, defined by a finite group \\( G \\),  whose generators are few-body operators associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit of dimension \\( |G| \\) located at each edge of the tesselation).\n\nThe physical Hilbert space has dimension \\( |G|^E  \\), where \\( E \\) is the number of  edges in the tessellation. The dimension of the code space is the number of orbits of the conjugation action of \\( G \\) on \\( \\text{Hom}(\\pi_1(\\Sigma),G) \\), the set of group homomorphisms from the fundamental group of the surface \\( \\Sigma \\) into the finite group \\( G \\) \\cite{arXiv:1908.02829}. When \\( G \\) is abelian, the formula for the dimension simplifies to \\( |G|^{2g} \\), where \\( g \\) is the genus of the surface \\( \\Sigma \\).\n\nThe codespace is the ground-state subspace of the quantum double model Hamiltonian. For nonabelian groups, alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model \\cite{doi:10.1007/3-540-49208-9_31,arXiv:quant-ph/0306063,doi:10.1017/CBO9780511792908}. The fusion space of such nonabelian anyons has dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.\n", "notes": ["The \\( \\Phi, \\Lambda \\)  \\href{https://citizensciencegames.com/games/decodoku/}{Decodoku game} is based on the quantum double model for the group \\(S_3\\) of permutations on three letters."], "introduced": "\\cite{arXiv:quant-ph/9707021}", "short_name": "", "logical": "groups", "realizations": [], "features": {"general_gates": [], "encoders": ["For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit \\cite{arXiv:0901.1345,arXiv:1101.0527} or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates \\cite{arXiv:0712.0348}.", "For any solvable group \\(G\\), ground-state preparation and anyon-pair creation can be done with an adaptive constant-depth circuit with geometrically local gates and measurements throughout \\cite{arXiv:2205.01933} (see Ref. \\cite{arXiv:2112.03061} for specific dihedral groups). Anyon-pair creation requires an adaptive circuit for any nonabelian \\(G\\) \\cite{arXiv:2205.01933}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["For any solvable group \\(G\\), topological charge measurements can be done with an adaptive constant-depth circuit with geometrically local gates and measurements throughout \\cite{arXiv:2205.01933}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "groups", "protection": "Error-correcting properties established in Ref. \\cite{arxiv:1908.02829}. The code distance is the number of edges in the shortest non contractible cycle in the tesselation or dual tesselation  \\cite{arXiv:quant-ph/0110143}.", "code_id": "quantum_double"}, "rotor_3_1_2": {"name": "\\([[3,1,2]]_{\\mathbb Z}\\) rotor code", "description": "Extension of the \\([[3,1,2]]_3\\) qutrit CSS code to the integer alphabet, i.e., the angular momentum states of a planar rotor. The code is \\(U(1)\\)-covariant and ideal codewords are not normalizable.\n", "notes": [], "introduced": "\\cite{arxiv:1709.04471}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Normalized codewords approximately protect against erasure while maintaining covariance \\cite{arxiv:1902.07714}.\n", "code_id": "rotor_3_1_2"}, "group_gkp": {"name": "Group GKP code", "description": "Group code whose construction is based on nested subgroups \\(H\\subset K\n\\subset G\\). Logical subspace is spanned by basis states that are equal\nsuperpositions of elements of cosets of \\(H\\) in \\(K\\), and can be finite- or\ninfinite-dimensional.\n\nThe group GKP code was originally formulated as an extension of the \\hyperref[code:gkp]{GKP code} construction, and has turned out to encompass a wide variety of codes, tabulated in \\ref{table:group-gkp-codes}.\n\\begin{table}\n  \\begin{cells}\n  \\celldata<c H, c H, c H, l H>{Space & \\(G\\) & \\(H\\) & Related code}\n  \\celldata<c, c, c, l>{\n  \\(n\\) qubits & \\(\\mathbb{Z}_2^n\\) & \\(\\mathbb{Z}_2^m\\)\n      & qubit CSS\n      \\\\\n  \\(n\\) modular qudits & \\(\\mathbb{Z}_q^n\\) & \\(\\mathbb{Z}_q^m\\)\n      & modular-qudit CSS\n      \\\\\n  \\(n\\) modes & \\( \\mathbb{R}^n \\) & \\( \\mathbb{R}^m \\)\n      & analog stabilizer\n      \\\\\n  \\(n\\) modes & \\( \\mathbb{R}^n \\) & \\( \\mathbb{Z}^n \\)\n      & multimode GKP\n      \\\\\n  \\(n\\) modes & \\( \\mathbb{R}^n \\) & \\( \\mathbb{Z}^{m<n} \\)\n      & GKP-stabilizer\n      \\\\\n  planar rotor & \\(U(1)\\) & \\(\\mathbb{Z}_n\\)\n      & rotor GKP\n      \\\\\n  rigid body & \\(SO(3)\\) & point group\n      & molecular\n  }\n  \\end{cells}\n  \\caption{Special cases of group GKP codes}\n  \\label{table:group-gkp-codes}\n\\end{table}\n", "notes": [], "introduced": "\\cite{arXiv:1911.00099}", "short_name": "", "logical": "groups", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "Group-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{ k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates representing \\(G\\) \\cite{arxiv:1902.07714}."}, "physical": "groups", "protection": "Protects against generalized bit-flip errors \\(g\\in G\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).", "code_id": "group_gkp"}, "stab_3_1_2": {"name": "Three qutrit code", "description": "A \\([[3,1,2]]_3\\) prime-qudit CSS code with stabilizer generators \\(ZZZ\\) and \\(XXX\\). The code defines a quantum secret-sharing scheme and serves as a minimal model for the AdS/CFT holographic duality. It is also the smallest non-trivial instance of a quantum maximum distance separable code (QMDS), saturating the quantum Singleton bound. The codewords are\n\\begin{align}\n  \\begin{split}\n    | \\overline{0} \\rangle &= \\frac{1}{\\sqrt{3}} (| 000 \\rangle + | 111 \\rangle + | 222 \\rangle) \\\\\n    | \\overline{1} \\rangle &= \\frac{1}{\\sqrt{3}} (| 012 \\rangle + | 120 \\rangle + | 201 \\rangle) \\\\\n    | \\overline{2} \\rangle &= \\frac{1}{\\sqrt{3}} (| 021 \\rangle + | 102 \\rangle + | 210 \\rangle)~.\n  \\end{split}\n\\end{align}\nThe elements in the superposition of each logical codeword are related to each other via cyclic permutations.\n", "notes": ["Connections to Ads/CFT from the perspetive of how arbitrary operators are encoded into the logical space. This encoding is analagous and helps explain why operators acting on the bulk are protected against localized boundary errors \\cite{arXiv:1411.7041}."], "introduced": "\\cite{arXiv:quant-ph/9901025}", "short_name": "\\([[3,1,2]]_3\\)", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": ["In addition to thinking about the encoding of states, it is also interesting to look at the trasformation of operators from the physical space into the logical space. Due to the unique structure and recovery protocol of the three qutrit code, the representation of a logical operator \\( \\overline{O} \\) is not unique. Instead, \\( \\overline{O} \\) can be constructed from unitary matricies with support on only two out of the three qutrits. Therefore, the logical operator has valid representations constructed from support on different sets of two qutrits. This operator construction is directly analogous to the construction of operators in the bulk (at the center) of the AdS\\(_3\\)-Rindler reconstruction. The three-qutrit code can then be used to describe how these local bulk operators are protected against localized boundary errors \\cite{arXiv:1411.7041}.", "This construction is related to the cleaning lemma \\cite{arXiv:0810.1983}, which was introduced in the context of constructing self-correcting quantum memories from stabilizer codes with geometrically-local generators. In this lemma, subspaces can be \\textit{cleaned out} by removing operators with support on a subset of qutrits."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["The quantum information (the secret) can be recovered from a unitary transformation acting on only two qutrits, \\( U_{ij} \\otimes I \\), where \\(U_{ij}\\) acts on qutrits \\(i,j\\) and \\(I\\) is the identity on the remaining qutrit. By the cyclic structure of the codewords, this unitary transformation performs a permutation that recovers the information and stores it in one of the two qutrits involved in recovery."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "Detects single qutrit errors and protects against a single-qutrit erasure. There does not exist a three-qubit code with analogous properties.\n\nThe code is an example of a \\( ((n = 3, k = 2)) \\) threshold scheme where a secret (the quantum information) is split into \\( n \\) shares and can be reconstructed by \\( k \\) pieces.\n\nThey key property of this code is that the reduced density matrix of any single qutrit is maximally mixed, meaning no information can be extracted from that qutrit. Therefore, a single qutrit tells you nothing about the encoded message, but access to any two pairs of qutrits will reveal the secret.\n", "code_id": "stab_3_1_2"}, "qudit_hamming_css": {"name": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\) prime-qudit CSS code", "description": "A family of CSS codes extending \\hyperref[code:quantum_hamming_css]{Hamming-based CSS codes} to prime qudits of dimension \\(p\\) by expressing the qubit code stabilizers in local-dimension-invariant (LDI) form \\cite{arxiv:2110.11510}.", "notes": [], "introduced": "\\cite{arxiv:2110.11510}", "short_name": "\\([[2^r-1, 2^r-2r-1, 3]]_p\\)", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "", "code_id": "qudit_hamming_css"}, "frobenius": {"name": "Frobenius code", "description": "Let \\(C\\) be a quantum cyclic code on \\(n\\) prime-dimensional qudits. \\(C\\) is a Frobenius code if there exists a positive integer \\(t\\) such that \\(n\\) divides \\(p^t +1\\).", "notes": ["Frobenius codes that are also stabilizer codes have been completely classified. No such codes exist when \\(t\\) is odd. All such codes with even \\(t\\) can be directly constructed."], "introduced": "\\cite{arXiv:1011.5814}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Adapted from the Berlekamp decoding algorithm for classical BCH codes. There exists a polynomial time quantum algorithm to correct errors of weight at most \\(\\tau\\), where \\(\\delta=2\\tau+1\\) is the BCH distance of the code \\cite{arXiv:1011.5814}. "], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "Protects against Pauli noise.", "code_id": "frobenius"}, "qudit_stabilizer": {"name": "Modular-qudit stabilizer code", "description": "An \\(((n,K,d))_q\\) modular-qudit code whose logical subspace is the joint eigenspace of commuting qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code.\n\nA modular-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{q}\\) or \\([[n,k,d]]_{q}\\). For composite \\(q\\), such codes need not encode an integer number of qudits, with \\(K=q^n/|\\mathsf{S}|\\) \\cite{arxiv:1101.1519}. This is because \\(|{\\mathsf{S}}|\\) need not be a power of \\(q\\), as group generators may have different orders. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\). \\textit{Prime-qudit} stabilizer codes, where \\(q=p\\) for some prime \\(p\\), do not suffer from this issue and encode \\(n-k\\) logical qudits, with \\(K=p^{n-k}\\).\n\nEach code can be represented by a \\textit{check matrix} (a.k.a. \\textit{stabilizer generator matrix}) \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(q\\)-ary symplectic representation of a stabilizer generator. The check matrix can be brought into standard form via Gaussian elimination \\cite{arxiv:1101.1519}.\n", "notes": ["A standardized definition of the qudit stabilizer group is developed in \\cite{arXiv:1101.1519}.", "The number of modular-qudit stabilizer codes was determined in Ref. \\cite{arxiv:2209.01449}."], "introduced": "\\cite{arXiv:quant-ph/9705052}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["The structure of stabilizer codes allows for \\textit{syndrome-based decoding}, where errors are corrected based on the results of stabilizer measurements (\\textit{syndromes}).", "Trellis decoder for prime-dimensional qudits, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) \\cite{arXiv:2106.08251}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).", "code_id": "qudit_stabilizer"}, "polynomial": {"name": "Quantum Reed-Solomon code", "description": "Also called \\textit{prime-qudit polynomial code (QPyC)}. Prime-qudit CSS code constructed using two Reed-Solomon codes.\n\nThe original construction \\cite{arxiv:quant-ph/9910059} was for a qubit code (\\(p=2\\)) by using a basis for a larger Galois field over \\(GF(2)\\), yielding an \\([[kN,k(N-2K),K+1]]\\) qubit code from a \\([N,K,\\delta]_{GF(2^k)}\\) RS code with \\(N=2^k-1\\) and \\(K=N-\\delta+1\\).\n\nAn alternative construction \\cite{preset:GottesmanBook} yields an \\([[n,k,n-k+1]]_p\\) (with prime \\(p>n\\)) prime-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(p)=\\mathbb{Z}_p\\).\nLet \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(\\mathbb{Z}_p\\), and let \\(g\\) be a number satisfying \\(0\\leq k \\leq g < n\\). Then, define degree-\\(g\\) polynomials\n\\begin{align}\n  f_{\\mu\\cup c}\\left(x\\right)=\\mu_{0}+\\mu_{1}x+\\cdots+\\mu_{k-1}x^{k-1}+c_{k}x^{k}+\\cdots+c_{g}x^{g}\\,,\n\\end{align}\nwhere the first \\(k\\) coefficients are indexed by the coefficient vector \\(\\mu\\in\\mathbb{Z}_p^{ k}\\), and the remaining coefficients are indexed by the vector \\(c\\in\\mathbb{Z}_p^{ (g+1-k)}\\). Logical states, labeled by \\(\\mu\\), are superpositions of canonical basis states whose \\(i\\)th bit is \\(f_{\\mu\\cup c}\\), evaluated at \\(\\alpha_i\\) and summed over all possible vectors \\(c\\),\n\\begin{align}\n  |\\overline{\\mu}\\rangle=\\sum_{c\\in\\mathbb{Z}_{p}^{(g+1-k)}}|f_{\\mu\\cup c}(\\alpha_{1}),|f_{\\mu\\cup c}(\\alpha_{2}),\\cdots,|f_{\\mu\\cup c}(\\alpha_{n})\\rangle.\n\\end{align}\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/9910059}", "short_name": "Quantum RS", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "", "code_id": "polynomial"}, "qudit_subsystem_stabilizer": {"name": "Subsystem modular-qudit stabilizer code", "description": "Modular qudit version of a subsystem qubit stabilizer code. Can be obtained by taking a modular qudit stabilizer code and assigning some of its logical qubits to be gauge qubits.\n", "notes": [], "introduced": "", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "", "code_id": "qudit_subsystem_stabilizer"}, "qudit_surface": {"name": "Modular-qudit surface code", "description": "Extension of the surface code to prime-dimensional \\cite{arXiv:quant-ph/9707021,arxiv:quant-ph/0609070} and more general modular qudits \\cite{arxiv:2211.00299}. Stabilizer generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface. Since qudits have more than one \\(X\\) and \\(Z\\)-type operator, various sets of stabilizer generators can be defined. Ground-state degeneracy and the associated phase depends on the qudit dimension and the stabilizer generators.", "notes": ["The simplest \\href{https://citizensciencegames.com/games/decodoku/}{Decodoku game} is based on the qudit surface code with \\( q=10\\)."], "introduced": "\\cite{arXiv:quant-ph/9707021,arxiv:quant-ph/0609070,arxiv:2211.00299}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "", "code_id": "qudit_surface"}, "qudits_into_qudits": {"name": "Modular-qudit code", "description": "Also called a \\(\\mathbb{Z}_q\\)\\textit{-qudit code}. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the group \\(\\mathbb{Z}_q\\) of integers \\textit{modulo} \\(q\\). Usually denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined, and with \\(q=p\\) when the dimension is prime.\n", "notes": ["See Refs. \\cite{arxiv:quant-ph/9802007,arxiv:quant-ph/0408190} for descriptions of the qudit Clifford group.", "Weight distribution of a code depends on the average entanglement of codewords \\cite{arXiv:quant-ph/0310137,arxiv:2209.07607}."], "introduced": "", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "A convenient and often considered error set is the modular-qudit analogue of the Pauli string basis for \\hyperref[code:qubits_into_qubits]{qubit} codes. For a single qudit, this set consists of products of powers of the qudit Pauli matrices \\(X\\) and \\(Z\\), which act on computational basis states \\(|k\\rangle\\) for \\(k\\in\\mathbb{Z}_q\\) as\n\\begin{align}\n  X\\left|k\\right\\rangle =\\left|k+1\\right\\rangle \\,\\,\\text{ and }\\,\\,Z\\left|k\\right\\rangle =e^{i\\frac{2\\pi}{q}k}\\left|k\\right\\rangle ~,\n\\end{align}\nwith addition performed modulo \\(q\\). For multiple qudits, error set elements are tensor products of elements of the single-qudit error set.\n\nThe Pauli error set is a unitary basis for linear operators on the multi-qudit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a nice error basis \\cite{arxiv:quant-ph/9608048}. The distance associated with this set is often the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code.\n", "code_id": "qudits_into_qudits"}, "w_state": {"name": "W-state code", "description": "Encodes a quantum state of a \\(d_L\\)-dimensional Hilbert space into\n\\(n\\) physical quantum systems, each associated with a Hilbert space\nof dimension \\(d_L+1\\).  The encoding resembles the structure of the\nW state~\\cite{arXiv:quant-ph/0005115}:\n\\begin{align}\n  \\ket\\psi\n  \\to \\frac{1}{\\sqrt{n}}\\bigl(\\ket{\\psi\\perp\\perp\\ldots}\n  + \\ket{\\perp\\psi\\perp\\ldots} + \\cdots\n  + \\ket{\\perp\\perp\\ldots\\psi}\\bigr)\\ ,\n\\end{align}\nwhere on each physical system, \\(\\ket\\perp\\) denotes the \\((d_L+1)\\)-th basis state\nand \\(\\ket\\psi\\) is encoded using the first \\(d_L\\) basis states.\n\nThis code enables universal quantum computation with transversal gates.  Indeed,\nto apply any logical unitary \\(U\\) it suffices to apply \\(U\\) on each physical system,\nwhere the unitary is taken to act nontrivially only on the \\(d_L\\) first basis states\nof each system.  Universal computation with transversal gates does not violate the\nEastin-Knill theorem because this code is an approximate error-correcting\ncode~\\cite{arXiv:1709.04471,arXiv:1902.07714} rather than an exact error-correcting\ncode.", "notes": [], "introduced": "\\cite{arXiv:1902.07714}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "All logical gates can be implemented transversally. The logical unitary \\(U_L\\) can be\nperformed with the physical unitary \\(U_L\\otimes U_L\\otimes\\cdots\\otimes U_L\\), where on\nthe physical space \\(U_L\\) is taken to act trivially on \\(\\ket\\perp\\), i.e.,\n\\( U_L\\ket\\perp = \\ket\\perp\\)."}, "physical": "qudits", "protection": "The W state code is an approximate error-correcting code.  Intuitively, if a\nsubsystem is lost to the environment, the environment only gains access to\n\\(\\ket\\psi\\) with probability of order \\(1/n\\).  Under a single located erasure,\nthe worst-cast entanglement infidelity of the W state code can be upper bound as\n\\begin{align}\n  \\epsilon_{\\mathrm{worst}} \\leq \\frac{\\sqrt{2} + d_L}{\\sqrt{n}}\\ .\n\\end{align}\n\nIn contrast to the \\ref{code:eth}, the W state code does not saturate the scaling\n\\(1/n\\) in worst-case entanglement infidelity which is known to be\noptimal for covariant approximate error-correcting codes~\\cite{arXiv:1902.07714}.", "code_id": "w_state"}, "stabilizer_over_gfqsq": {"name": "Stabilizer code over \\(GF(q^2)\\)", "description": "An \\([[n,k,d]]_{GF(q)}\\) Galois-qudit stabilizer code constructed from a classical code over \\(GF(q^2)\\) using the one-to-one correspondence between the Galois-qudit Pauli matrices and elements of the Galois field \\(GF(q^2)\\).\n\nAn \\(n\\) Galois-qudit Pauli stabilizer can be represented as a length-\\(n\\) vector over \\(GF(q^2)\\). The stabilizer commutation condition corresponds to a zero trace-alternating inner product between the corresponding vectors. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from classical trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\) \\cite{arXiv:quant-ph/0508070}.\nHermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal, and applying this construction to such codes yields a class of true stabilizer codes.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/0508070}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "", "code_id": "stabilizer_over_gfqsq"}, "qudit_css": {"name": "Modular-qudit CSS code", "description": "An \\(((n,K,d))_q\\) modular-qudit stabilizer code admitting a set of stabilizer generators that\nare either \\(Z\\)-type or \\(X\\)-type Pauli strings.\nThe stabilizer generator matrix, taking values from \\(\\mathbb{Z}_q\\), is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityq}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commQ}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nFor composite \\(q\\), such codes need not encode an integer number of qudits. For prime \\(q=p\\), properties reminiscent of qubit CSS codes are restored: encoding is based on two related \\hyperref[code:q-ary_linear]{\\(p\\)-ary linear codes}, an \\([n,k_X,d_X]_p \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_p \\) code \\(C_Z\\),\nsatisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\).\nThe \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parityq} is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\eqref{eq:commQ}.\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9512032,doi:10.1103/PhysRevLett.77.793,arXiv:quant-ph/9601029}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "", "code_id": "qudit_css"}, "galois_topological": {"name": "Galois-qudit topological code", "description": "Abelian topological code, such as a surface \\cite{arxiv:quant-ph/0609070,arxiv:1202.3338} or color \\cite{doi:10.1109/CIG.2010.5592860} code, constructed on lattices of Galois qudits.\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0609070,doi:10.1109/CIG.2010.5592860,arxiv:1202.3338}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "", "code_id": "galois_topological"}, "skew-cyclic_galois_css": {"name": "Skew-cyclic CSS code", "description": "Stub.", "notes": [], "introduced": "\\cite{doi:10.1016/j.disc.2020.112189}", "short_name": "", "logical": "qudits", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qudits", "protection": "", "code_id": "skew-cyclic_galois_css"}, "galois_bch": {"name": "Galois-qudit BCH code", "description": "True Galois-qudit stabilizer code constructed from BCH codes via either the Hermitian construction or the Galois-qudit CSS construction.\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0501126,arxiv:quant-ph/0604102,doi:10.1109/TIT.2006.890730,doi:10.26421/QIC13.1-2-3,doi:10.1103/PhysRevA.80.042331,arxiv:2007.13309}", "short_name": "Galois-qudit BCH", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "", "code_id": "galois_bch"}, "galois_stabilizer": {"name": "Galois-qudit stabilizer code", "description": "An \\(((n,K,d))_{GF(q)}\\) Galois-qudit code whose logical subspace is the joint eigenspace of commuting Galois-qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a Galois-qudit Pauli string that implements a nontrivial logical operation in the code.\n\nA Galois-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{GF(q)}\\) or \\([[n,k,d]]_{GF(q)}\\). This notation differentiates between Galois-qudit and modular-qudit stabilizer codes, although the same notation, \\([[n,k,d]]_q\\), is usually used for both. Galois-qudit stabilizer codes need not encode an integer number of qudits, with \\(K=q^{n-\\frac{r}{m}}\\), where \\(r\\) is the number of generators of the stabilizer group, and \\(q=p^m\\) given prime \\(p\\) for all Galois qudits. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\).\n\nThe stabilizer commutation condition can equivalently be stated in the symplectic representation. A pair of Galois-qudit stabilizers on \\(n\\) Galois qudits with symplectic representation vectors \\((a|b)\\) and \\((a^{\\prime}|b^{\\prime})\\) commute iff their \\textit{trace symplectic inner product} is zero,\n\\begin{align}\n\\text{tr}(a \\cdot b^{\\prime} - a^{\\prime}\\cdot b) = \\sum_{j=1}^{n} \\text{tr}(a_j b^{\\prime}_j - a^{\\prime}_i b_i) = 0~.\n\\end{align}\nSymplectic representations of stabilizer group elements thus form a self-orthogonal subspace of \\(GF(q)^{2n}\\) with respect to the trace-symplectic inner product.\n\nNote that the above trace-symplectic inner product reduces to the \\textit{symplectic inner product} when the trace is removed, and a symplectic self-orthogonal set of vectors is automatically trace-symplectic self-orthogonal. More generally, any additive classical code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code (see children).\n", "notes": ["The number of Galois-qudit stabilizer codes was determined in Ref. \\cite{arxiv:quant-ph/0602001}."], "introduced": "\\cite{doi:10.1109/18.959288,arXiv:quant-ph/0508070}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": ["As opposed to modular qudits for composite \\(q\\), Galois qudits inherit most of the properties of the prime-qudit Clifford group due to the correspondence between a \\(q=p^m\\) Galois qudit and \\(m\\) prime qudits of dimension \\(p\\) \\cite{doi:10.1109/18.959288}."], "encoders": ["Encoder with \\(O(n^2)\\) gates can be determined in classical runtime of order \\(O(n^3)\\) \\cite{arxiv:quant-ph/0211014}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. Corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qudits.", "code_id": "galois_stabilizer"}, "galois_true_stabilizer": {"name": "True Galois-qudit stabilizer code", "description": "Also called a \\textit{linear stabilizer code}. A \\([[n,k,d]]_{GF(q)}\\) stabilizer code whose stabilizer's symplectic representation forms a linear subspace. In other words, the set of \\(q\\)-ary vectors representing the stabilizer group is closed under both addition and multiplication by elements of \\(GF(q)\\). In contrast, Galois-qudit stabilizer codes admit sets of vectors that are closed under addition only.\n\nThe number of generators \\(r\\) for a true stabilizer code is a multiple of \\(m\\) (recall that \\(q=p^m\\) for Galois qudits). As a result, the number \\(k=n-r/m\\) of logical qudits is an integer.\n\nEach code can be represented by a stabilizer generator matrix \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(GF(q)\\)-valued symplectic representation of a stabilizer generator.\n\nA Hermitian self-orthogonal linear \\([n,k,d]_{GF(q^2)}\\) code can be used to construct an \\([[n,n-2k]]_{GF(q)}\\) true stabilizer code with distance no less than \\(d\\).\nThis \\textit{Hermitian construction} was first proven via the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. \\cite{doi:10.1109/18.959288}, Corr. 1), and later proven via the \\hyperref[code:stabilizer_over_gfqsq]{stabilizer-over-\\(GF(q^2)\\)} construction (showing self-orthogonality under the trace-alternating inner product; see Ref. \\cite{arxiv:quant-ph/0508070}, Corr. 19). There is an isomorphism between the symplectic and stabilizer-over-\\(GF(q^2)\\) representations (Ref. \\cite{doi:10.1201/9781315147901}, Thm. 27.3.8). The Hermitian construction has been extended to \\(q^{2m}\\)-ary Hermitian self-orthogonal linear codes \\cite{arxiv:2012.11998} and similar constructions exist \\cite{arxiv:1002.4088}.\n", "notes": [], "introduced": "\\cite{doi:10.1109/18.959288,arxiv:quant-ph/0508070,preset:GottesmanBook}", "short_name": "True stabilizer", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.", "code_id": "galois_true_stabilizer"}, "galois_grs": {"name": "Galois-qudit GRS code", "description": "True \\(q\\)-Galois-qudit stabilizer code constructed from generalized Reed-Solomon (GRS) codes via either the Hermitian construction \\cite{arxiv:1311.3009,doi:10.1142/S0219749919500060,doi:10.1109/TIT.2010.2054174} or the Galois-qudit CSS construction \\cite{arxiv:quant-ph/9906129}.\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/9906129,arxiv:1311.3009}", "short_name": "Galois GRS", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "", "code_id": "galois_grs"}, "binary_quantum_goppa": {"name": "Binary quantum Goppa code", "description": "Also known as a \\textit{quantum AG code}. Binary quantum Goppa codes are a family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes for \\( q=2^m \\), generated using classical Goppa codes.\n\nLet \\( F/GF(q) \\) be an algebraic function field of one variable, \\(\\sigma \\) be an automorphism of order 2\nof \\(F\\) which leaves \\(GF(q)\\) invariant, and \\(P_1, \\cdots, P_n \\) be pairwise distinct places of degree one such that \\( \\sigma P_i = P_j\\) for all\n\\(i,j = 1, \\cdots, n\\). A place \\( P_i \\) of \\( F/ GF(q) \\) is the unique maximal ideal of a discrete valuation ring of the function field. Let \\( \\nu \\) be a  differential\nthat satisfies the properties guaranteed by  the strong approximation theorem of discrete evaluations. Let \\(G\\) be a divisor such that \\( \\sigma G = G \\) and the\ndiscrete valuation corresponding to place \\(P_i \\) of \\(G\\) and the discrete valuation corresponding to place \\(\\sigma P_i \\) of \\(G\\) are both 0 for all \\(i\\). Then we can define\na code \\( C(G)  = \\{ f(P_1), \\cdots, f(P_n), f(\\sigma P_1), \\cdots , f(\\sigma P_n) | f \\in \\mathcal{L}(G)\\} \\subset GF(q^{2n})\\) and\na code \\(C(H)\\) where \\(H = (P_1 + \\cdots + P_n + \\sigma P_1 + \\cdots + \\sigma P_n) - G + \\nu \\). Then the dual of \\(C(G)\\) with respect to the weighted symplectic inner\nproduct with weights \\(s_i\\) on \\( GF(q^n) \\) is equivalent to \\(C(H)\\). Therefore, the orthogonal code of \\(C(G)\\) is generated by \\(H\\). Using these properties and the assumption\nthat \\(H\\) is a subgroup of \\(G\\), we can construct a classical Goppa code \\(C(D,G)\\), where \\(D\\) is the sum of all \\(P_i\\). Using \\(C(D,G)\\), we can construct a \\([[n,k,d]]_{GF(q)}\\) quantum stabilizer code such that\n\\(k  = \\text{dim} G - \\text{dim}(G-P_1 - \\cdots - P_n - \\sigma P_1 - \\cdots  - \\sigma P_n) - n~.\\)\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0501074,doi:10.1007/s11128-006-0047-9}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": ["Encoding defined in Ref. \\cite{arxiv:quant-ph/0107129} uses a technique from Ref. \\cite{arxiv:quant-ph/0005008} to encode quantum stabilizer codes."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Farran algorithm \\cite{arxiv:math/9910151}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "Protects against weight \\(t\\) errors where \\( 0 < t \\leq  \\lfloor \\frac{d^*-g-1}{2} \\rfloor \\) where \\( d^* = \\text{deg} G + 2 -2g \\) and \\(g\\) is the genus of the function field and \\(d \\geq n - \\lfloor \\frac{deg G}{2} \\rfloor\\).", "code_id": "binary_quantum_goppa"}, "galois_into_galois": {"name": "Galois-qudit code", "description": "Also called a \\(GF(q)\\)\\textit{-} or \\(\\mathbb{F}_q\\)\\textit{-qudit code}. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the \\textit{Galois field} \\(GF(q)\\) and with \\(q\\) being a power of a prime \\(p\\). A Galois field can be thought of as a vector space whose basis vectors are the \\(m\\) roots of some polynomial and whose coefficients (i.e., field) are \\(p\\)th roots of unity. Codes can be denoted as \\(((n,K))_{GF(q)}\\) or \\(((n,K,d))_{GF(q)}\\), whenever the code's distance \\(d\\) is defined. This notation differentiates between Galois-qudit and modular-qudit codes, although the same notation, \\(((n,K,d))_q\\), is usually used for both.", "notes": ["Introduction to Galois qudits by \\href{https://ethz.ch/content/vp/en/conferences/2014/qec/05_thursday/dab6ca18-7453-4197-aaaa-8b1964ece714.html}{Gottesman}.", "Wigner function for Galois qudits \\cite{arxiv:quant-ph/0401155}."], "introduced": "\\cite{doi:10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T,arXiv:quant-ph/0508070}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "A convenient and often considered error set is the Galois-qudit analogue of the Pauli string set for \\hyperref[code:qubits_into_qubits]{qubit} codes. For a single Galois qudit, this set consists of products of \\(X\\)-type and \\(Z\\)-type operators labeled by elements \\(\\beta \\in GF(q)\\), which act on computational basis states \\(|\\gamma\\rangle\\) for \\(\\gamma\\in GF(q)\\) as\n\\begin{align}\n  X_{\\beta}\\left|\\gamma\\right\\rangle =\\left|\\gamma+\\beta\\right\\rangle \\,\\,\\text{ and }\\,\\,Z_{\\beta}\\left|\\gamma\\right\\rangle =e^{i\\frac{2\\pi}{p}\\text{tr}(\\beta\\gamma)}\\left|\\gamma\\right\\rangle~,\n\\end{align}\nwhere the trace maps elements of the field to elements of \\(\\mathbb{Z}_p\\) as\n\\begin{align}\n  \\text{tr}(\\gamma)=\\sum_{k=0}^{m-1}\\gamma^{p^{k}}~.\n\\end{align}\nFor multiple Galois qudits, error set elements are tensor products of elements of the single-qudit error set.\n\nThe Galois-qudit Pauli error set is a unitary basis for linear operators on the multi-qudit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a nice error basis \\cite{arxiv:quant-ph/9608048}. The distance associated with this set is often the minimum weight of a Galois qudit Pauli string that implements a nontrivial logical operation in the code.\n", "code_id": "galois_into_galois"}, "non_stabilizer": {"name": "Galois-qudit non-stabilizer code", "description": "The projection onto a stabilizer code is proportional to an equal sum over all elements of the stabilizer group \\(\\mathsf{S}\\).\nNon-stabilizer codes generalize stabilizer codes by modifying the code projection with elements of a subset \\(\\mathsf{B}\\subset\\mathsf{S}\\) called the \\textit{Fourier description} (see proof of Thm. 2.7 in Ref. \\cite{arxiv:quant-ph/0210097}). When \\(\\mathsf{B}\\) is a subgroup of \\(\\mathsf{S}\\), then the code reduces to an ordinary stabilizer code.\n\nThe following non-stabilizer codes were constructed in Ref. \\cite{arxiv:quant-ph/0210097}: \\(((33, 155, 3))\\), \\(((15, 8, 3))\\), \\(((n, \\lceil\\frac{q^n}{n(q^2-1)}\\rceil,2))_{GF(q)}\\) and \\(((n, 1+n(q-1),2))_{GF(q)}\\), where \\(n\\) is odd. The last code family is a Galois-qudit extension of the non-additive \\(((5,6,2))\\) \\hyperref[code:qubits_into_qubits]{qubit code} from Ref. \\cite{arxiv:quant-ph/9703002}.\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/0210097}", "short_name": "Non-stabilizer", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": ["The encoding circuit involves the application of quantum Fourier transform."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["The decoding circuit involves the application of phase estimation."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "", "code_id": "non_stabilizer"}, "quantum_secret_sharing": {"name": "Approximate secret-sharing code", "description": "A family of \\( [[n,k,d]]_{GF(q)} \\) CSS codes approximately correcting errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) qubits, i.e., with approximate distance approaching the no-cloning bound \\(n/2\\). Constructed using a non-degenerate CSS code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an \\(t\\)-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.", "notes": [], "introduced": "\\cite{arXiv:quant-ph/0503139}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": ["Uses a quantum authentication scheme, which is a keyed system in which a valid state has high fidelity, and a classical secret-sharing scheme."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Decoding is analagous to reconstruction in a secret sharing scheme and is done in polynomial time. The only required operations are verification of quantum authentication, which is a pair of polynomial-time quantum algorithms that check if the fidelity of the received state is close to 1, and erasure correction for a stabilizer code, which involves solving a system of linear equations."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "Corrects up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors with fidelity exponentially lose to 1.", "code_id": "quantum_secret_sharing"}, "galois_css": {"name": "Galois-qudit CSS code", "description": "An \\([[n,k,d]]_{GF(q)} \\) Galois-qudit true stabilizer code admitting a set of stabilizer generators that\nare either \\(Z\\)-type or \\(X\\)-type Galois-qudit Pauli strings.\nThe stabilizer generator matrix, taking values from \\(GF(q)\\), is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityg}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commG}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related \\hyperref[code:q-ary_linear]{\\(q\\)-ary linear codes},\nan \\([n,k_X,d_X]_q \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_q \\) code \\(C_Z\\),\nsatisfying \\(C_X^\\perp \\subseteq C_Z\\).\nThe resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\).\nThe \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parityg} is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\eqref{eq:commG}.\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9512032,doi:10.1103/PhysRevLett.77.793,arXiv:quant-ph/9601029,arxiv:quant-ph/0312164,doi:10.1016/j.disc.2007.08.038}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.", "code_id": "galois_css"}, "galois_polynomial": {"name": "Galois-qudit RS code", "description": "Also called \\textit{polynomial code (QPyC)}. An \\([[n,k,n-k+1]]_{GF(q)}\\) (with \\(q>n\\)) Galois-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(q)\\).\n\nLet \\(C_1\\) be a \\([n,k_1,d_1]_q\\) Reed-Solomon code and \\(C_2^\\perp\\) be a \\([n,k_2,d_2]_q\\) Reed-Solomon code, modified such that \\(C_2^\\perp \\subseteq C_1\\) and \\(0\\le k_2 \\le k_1 \\le n\\). Then, a polynomial code is a non-degenerate \\([[n,k_2,d]]_{GF(q)}\\) Galois-qudit CSS code with \\(d=\\min(n-k_1+1,k_1-k_2+1)\\). The polynomial code is the span of the basis codewords over GF(\\(q\\))\n\\begin{align}\n|\\overline{\\beta_0,\\cdots,\\beta_{k_2-1}}\\rangle\n=\n\\sum_{(\\beta_{k_2},\\cdots,\\beta_{k_1-1})\\in GF(q) }\n\\bigotimes_{i=1}^{n}\n\\left|\\sum_{j=0}^{k_1-1} \\beta_j \\alpha_i^j \\right\\rangle,\n\\end{align}\nwhere \\((\\alpha_1, \\cdots, \\alpha_n)\\) are \\(n\\) distinct points chosen for code \\(C_1\\) from \\(GF(q)\\setminus \\{0\\}\\).'\n", "notes": [], "introduced": "\\cite{arxiv:quant-ph/9906129}", "short_name": "Galois RS", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "", "code_id": "galois_polynomial"}, "expander_lifted_product": {"name": "Expander lifted-product code", "description": "Family of \\(G\\)-lifted product codes constructed using two random classical \\hyperref[code:tanner]{Tanner codes} defined on expander graphs. For certain parameters, this construction yields the first asymptotically good QLDPC codes. Classical codes resulting from this construction are one of the first two families of \\(c^3\\)-LTCs.\n\nAn expander lifted-product code family is constructed as follows. First, take the Cayley graph of a finite group \\(G\\). Second, take the double cover of the graph, resulting in a graph that satisfies the requirements of participating in a \\(G\\)-lifted product (i.e., the resulting graph is a free \\({\\mathbb{F}}_q G\\)-module). Third, create a \\hyperref[code:tanner]{Tanner code} out of the graph, in which parity-check supports are defined by the graph, and bitstrings satisfying a particular parity check are defined to be the codewords of a small classical code (chosen to be a random code in the construction). Fourth, take the \\(G\\)-lifted product of two copies of the \\hyperref[code:tanner]{Tanner code}.\n\nThe small classical codes used in the construction of good QLDPC codes are required to have a certain product-expansion property (Lemma 10 in Ref. \\cite{arXiv:2111.03654}); it is proven that random codes satisfy said property in the thermodynamic limit.\n", "notes": ["Construction outlined in talk by \\href{https://www.youtube.com/watch?v=k7LuOiOBYyQ}{R. O'Donnell}.", "Popular summary in \\href{https://www.quantamagazine.org/qubits-can-be-as-safe-as-bits-researchers-show-20220106}{Quanta Magazine}."], "introduced": "\\cite{arXiv:2111.03654}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Expander lifted-product codes include the first examples \\cite{arXiv:2111.03654} of (asymptotically) \\textit{good QLDPC codes}, i.e., codes with asymptotically constant rate and linear distance. The existence of such codes proves the QLDPC conjecture \\cite{arXiv:2103.06309}. Another notable family encodes \\(k \\in \\Theta(n^\\alpha \\log n)\\) logical qubits with distance \\(d \\in \\Omega(n^{1 - \\alpha} / \\log n)\\) for any number of physical qubits \\(n\\) and any real parameter \\(0 \\leq \\alpha < 1\\) \\cite{arxiv:2012.04068}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Linear-time decoder \\cite{arxiv:2206.07571}.", "Logarithmic-time subroutine \\cite{arxiv:2208.05537}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "Code performance strongly depends on \\(G\\). Certain nonabelian groups yield asymptotically good QLDPC codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n)]]\\) \\cite{arXiv:2111.03654}. Abelian groups like \\(\\mathbb{Z}_{\\ell}\\) for \\(\\ell=\\Theta(n / \\log n)\\) yield constant-rate codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n / \\log n)]]\\) \\cite{arxiv:2012.04068}; this construction can be derandomized by being reformulated as a balanced product code \\cite{arXiv:2012.09271}.", "code_id": "expander_lifted_product"}, "lifted_product": {"name": "Lifted-product (LP) code", "description": "Also called a \\textit{Panteleev-Kalachev (PK)} code. Code that utilizes the notion of a lifted product in its construction. Lifted products of certain classical Tanner codes are the first (asymptotically) \\textit{good QLDPC codes}.\n\nA \\textit{lifted product over} a ring \\(R\\) is a product of two chain complexes whose chains are free modules over \\(R\\). An interesting case is when \\(R=\\mathbb{F}_q G\\), the group-\\(G\\) algebra over the finite field \\({\\mathbb{F}}_q = GF(q)\\); in this case, the product can be called a \\(G\\)-\\textit{lifted product}. Just like its further generalization the balanced product, a lifted product code generalizes a hypergraph product code in that a reduction of symmetry is exploited to decrease the number of physical qubits required.\n\nThe key operation behind the \\(G\\)-lifted product is the \\(G\\)-\\textit{lift}. A \\(G\\)-lift of a \\(\\mathbb{F}_q\\)-valued matrix \\(A\\) substitutes matrix elements of \\(A\\) with matrices forming the regular representation of the group algebra \\({\\mathbb{F}}_q G\\) according to some rule. A combination of the lift and the usual hypergraph product yields lifted-product codes. The two operations commute: one can first take the usual hypergraph product of two chain complexes, and then lift the resulting product complex; equivalently, one can take the hypergraph product of the two lifted complexes.\n", "notes": ["Formerly known as \\textit{generalized hypergraph product codes} \\cite{arXiv:1904.02703}, and later renamed to lifted-product codes \\cite{arXiv:2012.04068,doi:10.1103/PRXQuantum.2.040101}."], "introduced": "\\cite{arxiv:1904.02703,arXiv:2111.03654}", "short_name": "", "logical": "galois", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "There is no known simple way to compute the logical dimension \\(k\\) in the general case \\cite{arxiv:2012.04068}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "galois", "protection": "Code performance strongly depends on the group \\(G\\) used in the product \\cite{arxiv:2012.04068}.", "code_id": "lifted_product"}, "quantum_concatenated": {"name": "Concatenated quantum code", "description": "A combination of two codes, an inner code \\(C\\) and an outer code \\(C^\\prime\\), where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code \\(C^\\prime\\), and then one encodes each of the physical registers of \\(C^\\prime\\) in an inner code \\(C\\).", "notes": ["Concatenated codes can achieve the Gilbert-Varshamov bound \\cite{arxiv:1004.1127}."], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["The first method to achieve a fault-tolerant computational threshold uses concatenated stabilizer codes \\cite{arxiv:quant-ph/9702058,arxiv:quant-ph/9906129,arXiv:quant-ph/9705031,arXiv:quant-ph/0504218}."], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "quantum_concatenated"}, "qecc_finite": {"name": "Finite-dimensional quantum error-correcting code", "description": "Encodes quantum information in a \\(K\\)-dimensional (\\textit{logical}) subspace of an \\(N\\)-dimensional (\\textit{physical}) Hilbert space such that it is possible to recover said information from errors. The logical subspace is spanned by a basis comprised of \\textit{code basis states} or \\textit{codewords}.", "notes": [], "introduced": "", "short_name": "Finite QECC", "logical": null, "realizations": [], "features": {"general_gates": ["Universal gate set cannot be transversal for any code that detects single-qubit errors due to Eastin-Knill theorem \\cite{arXiv:0811.4262}."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["The operation \\(\\cal{D}\\) in the definition of this code is called the decoder. However, the term \\textit{decoder} can sometimes be used for the inverse of an encoder, which does not correct errors.", "Quantum machine-learning based decoders such as quantum convolutional neural networks \\cite{arXiv:1810.03787} and quantum autoencoders \\cite{arxiv:2202.00555}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a finite-dimensional quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{K}\\to\\mathsf{H}_{N}\\) with a set of correctable errors \\({\\cal{E}}:\\mathsf{H}_N\\to\\mathsf{H}_M\\) with the following property: there exists a quantum operation \\({\\cal{D}}:\\mathsf{H}_M\\to \\mathsf{H}_K\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{K}\\),\n\\begin{align}\n{\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\end{align}\nfor some constant \\(c\\) \\cite{preset:GottesmanBook}. A code is said to \\textit{protect against} or \\textit{correct} the errors \\(\\mathcal{E}\\).\n\n\\subsection{Knill-Laflamme error correction conditions}\n\nEquivalently, correction capability is determined by of the quantum\nerror-correction conditions\n\\cite{arXiv:quant-ph/9604034,arXiv:quant-ph/9604024}, which may admit infinite\nterms due to non-normalizability of ideal code states. A code that satisfies\nthese conditions approximately, i.e., up to some small quantifiable error, is\ncalled an \\hyperref[code:approximate_qecc]{approximate code}.\n\n\\begin{defterm}{Knill-Laflamme conditions}\nIn a finite-dimensional Hilbert space, there are necessary and sufficient\nconditions for a code to successfully\ncorrect a set of errors.  These are called the \\emph{Knill-Laflamme\nconditions}~\\cite{arXiv:quant-ph/9604034,preset:PreskillNotes}\\cite[Thm. 10.1]{doi:10.1017/CBO9780511976667}.\nA code defined by a partial isometry \\(U\\) with code space projector \\(\\Pi = U U^\\dagger\\)\ncan correct a set of errors \\(\\{ E_j \\}\\) if and only if\n\\begin{align}\n  \\Pi E_i^\\dagger E_j \\Pi = c_{ij}\\, \\Pi\\qquad\\text{for all \\(i,j\\),}\n\\end{align}\nwhere \\(c_{ij}\\) can be arbitrary numbers.\n\\end{defterm}\n\nA code is \\textit{degenerate} with respect to a noise model if different errors map code states to the same error subspace. For a linearly independent error set \\(\\cal{E}\\), degeneracy is equivalent to \\(\\text{rank}(c_{ij}) < |\\cal{E}|\\).\n", "code_id": "qecc_finite"}, "symmetry_protected_self_correct": {"name": "Symmetry-protected self-correcting quantum code", "description": "Also called a \\textit{symmetry-protected self-correcting memory}. An restricted notion of thermal stability against symmetric perturbations, i.e., perturbations that commute with a set of operators forming a group \\(G\\) called the \\textit{symmetry group}.\n\nGiven a symmetry group \\(G\\) and its unitary representation \\(S\\) on the \\(n\\)-site physical Hilbert space (in this case, a lattice), an operator \\(O\\) is \\(G\\)\\textit{-symmetric} (a.k.a. respects the \\(G\\) symmetry) if \\([S(g),O]=0\\) for all \\(g\\in G\\). A symmetry-protected self-correcting memory is a ground-state encoding of an \\(n\\)-body \\(G\\)-symmetric geometrically local Hamiltonian whose logical information is recoverable for arbitrary long times in the \\(n\\to\\infty\\) limit after a \\(G\\)-symmetric interaction with a thermal environment at sufficiently low temperature.\n\nTensor-product symmetries of the form \\(S(g)=u(g)^{\\otimes n}\\), where \\(u\\) is a unitary representation of \\(G\\ni g\\) on a site, cannot support symmetry-protected self-correction. One can instead use \\textit{1-form symmetries}, i.e., symmetries generated by operators of the form\n\\begin{align}\n  S_{\\mathcal{M}}(g)=\\bigotimes_{\\text{sites}\\in\\mathcal{M}}u(g),\n\\end{align}\nwhere \\(\\mathcal{M}\\) runs over all closed codimension-one submanifolds of the lattice. Recent work further relaxed the requirement so that symmetries need only be enforced on the system's boundaries \\cite{arxiv:2206.05294}.\n", "notes": [], "introduced": "\\cite{arXiv:1805.01474}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "The code is intended to be used as a self-correcting quantum memory when the symmetry is enforced, and protection is characterized by the scaling of the memory time \\(\\tau\\) in the system size.\n\nAnother characterization of the protection property is the symmetric version of the energy barrier \\(\\Delta\\), defined as follows.\nFor a given logical operator and a given decomposition into a product of local operators, we consider the maximal energy attained when implementing this logical operator stepwise with this decomposition. Then, \\(\\Delta\\) is defined by minimizing this quantity over all logical operators and over those decompositions for which each local operator respects the symmetry. For some models \\cite{arXiv:1805.01474}, the linear growth of \\(\\Delta\\) with system size \\(n\\) implies the exponential growth of \\(\\tau\\) below a critical temperature.\n", "code_id": "symmetry_protected_self_correct"}, "stabilizer": {"protection": "", "name": "Stabilizer code", "description": "A code whose logical subspace is the joint eigenspace (usually with eigenvalue \\(+1\\)) of a set of commuting unitary operators forming the code's stabilizer group. Stabilizer codes have been defined for qubits, modular qudits, Galois qudits, and oscillators using their respective Pauli-type groups.\n\nThe coding theory motivation for stabilizer codes came from linear binary codes, whose codewords form a closed subspace in the space of binary strings. Stabilizer codes extend this property, in various ways, to quantum error correction. The stabilizer formalism is applicable to the qubit, modular-qudit, Galois-qudit, bosonic, and fermionic kingdoms; see \\href{https://errorcorrectionzoo.org/list/stabilizer}{list of stabilizer codes} for a list of all stabilizer codes in the zoo.\n\nStabilizer codes were originally defined for qubits, where the relevant commuting operators are tensor products of Pauli matrices. The Pauli stabilizer structure is immensely useful in providing standardized encoding, gates, decoding, and performance bounds. Elements of this structure remain in qudit extensions, in particular for prime-dimensional modular qudits and Galois qudits. Other qubit-based extensions, such as \\hyperref[code:xs_stabilizer]{XS} and \\hyperref[code:xp_stabilizer]{XP} stabilizer codes, relax the mutual commutation property. Still other extensions defined for qudits include \\hyperref[code:non_stabilizer]{non-stabilizer codes}.\n\nAn important property of qubit and qudit stabilizer codes is the QLDPC property, which means (roughly) that working with them remains not too hard as number of qudits grows; these remain as the primary ingredients for a quantum memory.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "stabilizer", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "qecc": {"name": "Quantum error-correcting code (QECC)", "description": "Encodes quantum information in a (\\textit{logical}) subspace of a\n(\\textit{physical}) Hilbert space such that it is possible to recover said\ninformation from errors that act as linear maps on the physical space. The\nlogical subspace is spanned by a basis comprised of \\textit{code basis states}\nor \\textit{codewords}. Codewords may not be normalizable if the physical\nHilbert space in infinite, so approximate versions have to be constructed in\npractice.\n", "notes": [], "introduced": "", "short_name": "QECC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a quantum code\n\\((U,\\cal{E})\\) is a partial isometry\n\\(U:\\mathsf{H}_{\\text{logical}}\\to\\mathsf{H}_{\\text{physical}}\\) with a set of\ncorrectable errors \\(\\cal{E}\\) with the following property: there exists a\nquantum operation \\(\\cal{D}\\) such that for all \\(E\\in\\cal{E}\\) and states\n\\(|\\psi\\rangle\\in\\mathsf{H}_{\\text{logical}}\\),\n\\begin{align}\n  {\\cal D} (EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})\n  = c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\n\\end{align}\nfor some constant \\(c\\).\n\nEquivalently, correction capability is determined by the \\term{Knill-Laflamme conditions}, which may admit infinite terms due to non-normalizability of ideal code states in the case of codes with infinite-dimenional physical spaces. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an \\hyperref[code:approximate_qecc]{approximate code}. These conditions can also be formulated in terms of a dual Heisenberg picture, where correctability is checked for some algebra of observables \\cite{arxiv:0811.0421}.\n", "code_id": "qecc"}, "approximate_qecc": {"name": "Approximate quantum error-correcting code (AQECC)", "description": "Stub.", "notes": ["See review \\cite{arxiv:2208.00365}."], "introduced": "\\cite{arxiv:quant-ph/9704002,doi:10.1070/RM1997v052n06ABEH002155,arXiv:quant-ph/0307138,arXiv:quant-ph/0503139,arXiv:0907.4207,arXiv:0907.5391}", "short_name": "AQECC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": ["Given a decoder, an encoding that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program \\cite{arXiv:quant-ph/0109155,arXiv:quant-ph/0307138} (see also Ref. \\cite{arXiv:0706.3400})."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Given an encoding, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program \\cite{arXiv:quant-ph/0109155,arXiv:quant-ph/0307138} (see also Ref. \\cite{arXiv:0706.3400}).", "The \\textit{Petz recovery map} (a.k.a. the \\textit{transpose map}) \\cite{doi:10.1007/BF01212345,doi:10.1093/qmath/39.1.97}, a quantum channel determined by the codespace and noise channel, recovers information perfectly for strictly correctable noise and yields an infidelity of recovery that is at most twice away from the infidelity of the best possible recovery \\cite{arXiv:quant-ph/0004088}. The infidelity of a modified Petz recovery map can be bounded using relative entropies between uncorrupted and corrupted code states on countably infinite Hilbert spaces \\cite{arxiv:1509.07127}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "There exist approximate versions of the \\term{Knill-Laflamme conditions} that\ncan be used to determine the degree to which a code is an approximate\nerror-correcting code~\\cite{arXiv:0907.5391}.  Various sufficient criteria\nhave also been derived; see for instance\nrefs.~\\cite{arXiv:quant-ph/9704002,arXiv:quant-ph/0503139,\narXiv:1710.04631,arXiv:1902.07714}.\n", "code_id": "approximate_qecc"}, "holographic": {"name": "Holographic code", "description": "A code whose encoding isometry serves to model aspects of the AdS/CFT holographic duality. Encodes operators in the bulk of the Anti de Sitter (AdS) space, represented by logical qudits, into operators on the boundary of the corresponding Conformal Field Theory (CFT), represented by physical qudits. Encoding can often be represented by a tensor network associated with a tiling of hyperbolic space. See Defn 4.3 of Ref. \\cite{arxiv:2108.11402} for a technical formulation.\n\nTypically, the encoding isometry \\(U\\) obeys the \\textit{entanglement-wedge reconstruction condition}, which states that for any boundary region \\(R\\), any bulk operator \\(O\\) localized to the entanglement wedge of \\(R\\) must be implementable by some boundary operator \\(\\tilde{O}\\) localized to \\(R\\). Formally, \\(UO = \\tilde{O}U\\) and \\([\\tilde{O},UU^\\dagger] = 0\\). The entanglement wedge is the space enclosed within the Ryu\u2013Takayanagi surface in the bulk (minimal surface) with boundary \\(R\\).\n", "notes": ["All Boundary global symmetries must be dual to bulk gauge symmetries, and vice versa \\cite{arxiv:1810.05338}."], "introduced": "\\cite{arxiv:1503.06237}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": ["The ideal holographic code (perfect representation of AdS/CFT) should be able to protect a central bulk operator against erasures of half of the physical qubits on the boundary, in line with AdS-Rindler reconstruction \\cite{arxiv:1503.06237}.", "Holographic codes are argued to have a \\textit{algebraic threshold}, for which the error rate scales polynomially (as opposed to exponentially) in the thermodynamic limit \\cite{arxiv:2202.04710}. Such a threshold is governed by the underlying conformal field theory describing the boundary."], "transversal_gates": "There exist holographic approximate codes with arbitrary transversal gate sets for any compact Lie group \\cite{arxiv:2108.11402}. However, for sufficiently localized logical subsystems of holographic stabilizer codes, the set of transversally implementable logical operations is contained in the Clifford group \\cite{arXiv:2103.13404}."}, "physical": null, "protection": "Protects against erasure errors on the boundary. Error-correction properties are often stated in the Heisenberg picture, i.e., in terms of which logical operators can be \\textit{reconstructed} after erasures. Specifically, bulk operators outside the entanglement wedges of the erased boundary operators can be reconstructed using the remaining boundary operators. However, the protection can be nontrivial, and may only apply to a subalgebra of bulk operators \\cite{arxiv:1411.7041,arXiv:1612.00017}.", "code_id": "holographic"}, "quantum_random": {"protection": "", "name": "Random quantum code", "description": "Quantum code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes (e.g., random-circuit codes), to codes whose multi-step construction is deterministic with the exception of a single step (e.g., expander lifter-product codes).", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "quantum_random", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "fusion": {"name": "Fusion-based quantum computing (FBQC) code", "description": "Fusion Based Quantum Computing, or FBQC, describes a fault tolerant way to produce \\textit{fusion networks}, or large entangled states starting from small constant-sized entangled resource states along with destructive measurements called \\textit{fusions}. These large states can be produced asychronously in the fusion framework and can be used as resources, as in measurement-based quantum computation (MBQC), or as logical states of topological codes. The difference from ordinary MBQC is that error-correction is baked into the state-generation protocol.", "notes": [], "introduced": "\\cite{arXiv:2101.09310}", "short_name": "FBQC", "logical": "qubits", "realizations": [], "features": {"general_gates": ["Clifford gates by creating topological features such as boundaries, defects, or twists, which can be done by single qubit measurements.", "Logical gates can be performed by code deformation.", "Non Clifford gates by Magic-state injection", "Logical Clifford operations can be kept track of using the classical Pauli-frame register and need not be explicitly applied at the quantum level."], "encoders": ["Resource state generators, which produce small constant size cluster states, and Fusion measurements (Bell fusions)."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Fusion networks are constructed in a fault tolerant way (as a stabilizer code), and they can be created in a way that naturally encodes topological fault tolerance."], "threshold": ["\\(11.98\\%\\) against erasure in fusion measurements.", "\\(1.07\\%\\) against Pauli error.", "In linear optical systems, can tolerate \\(10.4\\%\\) probability of photon loss in each fusion.", "\\(43.2\\%\\) against fusion failure."], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "qubits", "protection": "Protects against erasure, Pauli errors, photon loss, fusion failure from non-determinism, and faulty resource states. Redundancy in fusion outcomes is captured by the check operator group. Fusion measurement outcomes form a syndrome that allows to correct for Pauli errors. There is no physical error correction, and decoding output is simply used to update the Pauli frame.", "code_id": "fusion"}, "quantum_perfect": {"name": "Perfect quantum code", "description": "A non-degenerate code constructed out of \\(q\\)-dimensional qudits and having parameters \\(((n,K,2t+1))\\) is perfect if \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the quantum Hamming bound\n\\begin{align}\n\\sum_{j=0}^{t}(q^2-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality. For example, for a qubit \\(q=2\\) code with one logical qubit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(3n+1 \\leq 2^{n-1}\\). The bound can be saturated only at certain \\(n\\).\n\nFor qubit codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-\\frac{t}{n}\\log_{2}3-h(t/n),\n\\end{align}\nwhere \\(h\\) is the binary entropy function.\n", "notes": ["Codes that are not non-degenerate can in principle violate the quantum Hamming bound. It was shown that qubit stabilizer codes up to distance \\(d\\leq 85\\) must obey the bound \\cite{arxiv:2208.11800}."], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "\\(k/n\\to 1\\) asymptotically with \\(n\\).", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Perfect codes have been classified. For qubits (\\(q=2\\)), the only codes are the stabilizer code family \\([[(4^r-1)/3, (4^r-1)/3 - 2r, 3]]\\) for \\(r \\geq 2\\) \\cite{arxiv:quant-ph/9607027,arxiv:quant-ph/9608006}. For qudits, the family is parameterized by \\(K=q^{n-2r}\\) for \\(n=\\frac{q^{2r}-1}{q^{2}-1}\\) and \\(r \\geq 2\\); all codes correct a single error (\\(t=1\\)) \\cite{arxiv:0907.0049,doi:10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T}. The trivial code (\\(k=n\\)) is also perfect.\n", "code_id": "quantum_perfect"}, "quantum_mds": {"name": "Quantum maximum-distance-separable (MDS) code", "description": "An \\(((n,q^k,d))\\) code constructed out of \\(q\\)-dimensional qudits is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the quantum Singleton bound\n\\begin{align}\n2(d-1) \\leq n-k\n\\end{align}\nbecomes an equality.\n", "notes": ["The five-qubit code and \\([[n,n-2,2]]\\) codes, where \\(n\\) is even, are the only examples of MDS qubit codes."], "introduced": "", "short_name": "Quantum MDS", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error correction properties.", "code_id": "quantum_mds"}, "quantum_lego": {"name": "Quantum Lego code", "description": "Code constructed using a tensor-network-based graphical framework from \\textit{quantum lego blocks}, which are smaller quantum codes over qubits or qudits. The class of codes constructed using the framework depends on the choice of atomic lego blocks. For instance, any stabilizer code can be built out of atomic blocks like the 2-site repetition code, single-site trivial stabilizer codes, and tensor products of the \\(|0\\rangle\\) state. Specifically, the \\hyperref[code:happy]{HaPPY} code is a quantum Lego code whose atomic Lego block is the \\hyperref[code:stab_5_1_3]{five-qubit perfect} code.\n\nThe individual lego blocks and resulting quantum lego codes can be stabilizer or non-stabilizer. However, both the logical and physical degrees of freedom must have the same local dimension.\n\nTo construct a Lego code, the encoding map \\(V\\) for each code that is to be used in the construction is converted to a tensor by decomposing it using the formula\n\\begin{align}\nV = \\sum_{i_j} V_{i_1 \\ldots i_{n+k}} | i_{k+1} \\ldots i_{k+n} \\rangle \\langle i_1 \\ldots i_k |~.\n\\end{align}\nWe then look at the codes graphically, treating each \\(i_j\\) as an edge dangling out of the tensor vertex \\(V_{i_1 \\ldots i_{n+k}}\\). These edges are either connected to another tensor vertex's edges or left dangling. If the block codes are stabilizer, then each local tensor has unitary product stabilizers (UPS). The goal is to push each UPS through the tensor network until each dangling edge has only trivial support. Otherwise, a matching value is pushed through the edge and the process is repeated on the next tensor. If a UPS can be pushed through the whole network, then a UPS for the larger network has been found. The dangling legs (edges) and UPS of the whole network can then be converted to physical/logical elements and stabilizers/logical operators for a new quantum code.\n", "notes": ["Many known codes can be created using this code's methods in order to further their understanding, including a 6 qubit implementaion of the generalized Bacon-Shor code, the Toric code, and the \\([[7,1,3]]\\) Steane code.", "For example, a simple \\( [[4,2,2]] \\) stabilizer code can be written as a rank 6 tensor. Attaching two of these via gluing together one logical leg from each can produce a \\( [[6,4,2]] \\) stabilizer code.", "Tensor-network codes are types of LEGO codes made from stabilizer codes where logical and physical legs are pre-assigned and logical legs are not contracted. In other words, logical legs resulting from the conversion of codes to tensors must remain logical in the final tensor network, and the same for physical. Contracting logical legs is another word for gluing two logical legs together."], "introduced": "\\cite{arxiv:2109.08158}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": ["Unitary-circuit encoding exists for a restricted class of tensor networks contractible via isometries \\cite{arxiv:2109.08158}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["The decoder is created by creating a decoding quantum circuit with dangling legs replaced with input/output wires, and tensors converted to unitary gates. Maximum likelihood decoding can be used when the tensors are stabilizer codes.", "Tensor-network decoder when the tensor network is contractible via stabilizer isometries \\cite{arxiv:2009.10329}.", "Tensor-network-based decoder when the encoding unitary is known \\cite{arxiv:1312.4578}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "quantum_lego"}, "self_correct": {"name": "Self-correcting quantum code", "description": "Also called a \\textit{self-correcting quantum memory} or \\textit{thermally stable encoding}. A ground-state encoding of an \\(n\\)-body geometrically local Hamiltonian whose logical information is recoverable for arbitrary long times in the \\(n\\to\\infty\\) limit after interaction with a sufficiently cold thermal environment. Typically, one also requires a decoder whose decoding time scales polynomially with \\(n\\) and a finite energy density. The original criteria for a self-correcting quantum memory, informally known as the \\textit{Caltech rules} \\cite{arxiv:1411.7046,arxiv:1501.04112}, also required finite-spin Hamiltonians.\n\nThe effect of a Markovian thermal environment consists of a Lindbladian in Davies form admitting a Gibbs steady state at some temperature \\(T\\) \\cite{arxiv:1411.6643}. To test whether a system is self-correcting, an initial codeword \\(\\rho(0)\\) is evolved under the Davies Lindbladian and the code Hamiltonian (or, if we are to allow extra passive protection, the code Lindbladian) to the state \\(\\rho(t)\\) at time \\(t\\), after which it is decoded via decoding map \\(\\cal{D}\\). The memory time \\(\\tau\\) is defined to be\n\\begin{align}\n  \\tau=\\sup\\left\\{ t>0\\,|\\left\\Vert {\\cal D}(\\rho(t))-\\rho(0)\\right\\Vert _{1}<\\epsilon\\right\\}\n\\end{align}\nfor some fixed \\(\\epsilon\\). For a self-correcting memory, there exists a critical temperature \\(T_\\star>0\\) such that \\(\\tau\\to\\infty\\) (typically, exponentially with \\(n\\)) as \\(n\\to\\infty\\) for any temperature \\(T<T_{\\star}\\) and any codeword \\(\\rho(0)\\). A memory is \\textit{partially self-correcting} if \\(\\tau\\) scales polynomially with \\(n\\) up to some cutoff \\(n_{max}\\). A self-correcting memory is typically associated with a (stable) phase of quantum matter.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/0110143,arXiv:0811.0033}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Self-correcting classical memories exist in two and higher dimensions, with the canonical example being the classical Ising model. In that model, a classical bit is stored in the overall magnetization. The magnetization is thermally stable due to the fact that there is an \\(n\\)-dependent (i.e., \\textit{macroscopic}) energy cost of flipping a contiguous region of physical bits \\cite{doi:10.1017/S0305004100019174,arxiv:1411.6643}. This cost scales with the surface area of the region, and the surface area is \\(n\\)-dependent for dimensions greater than one.\n\nSelf-correcting quantum memories currently exist in four and higher dimensions, with their existence in three dimensions being an open question. For similar reasons as the classical Ising model, the four-dimensional toric code is a self-correcting quantum memory due to an order \\(O(n)\\) energy cost of creating a logical error \\cite{arXiv:quant-ph/0110143,arXiv:0811.0033}. On the other hand, the 2D toric code is not thermally stable \\cite{arxiv:quant-ph/0702102,arxiv:0709.2717,arxiv:0911.3843} because its string-like logical operators anti-commite with stabilizer generators supported only at their ends, and thus have a constant energy cost of creation.\n\nAn \\(n\\)-dependent energy barrier to creating all logical errors is likely necessary for a thermally stable memory, having been shown as such for a large class of 2D topological phases \\cite{arXiv:1412.2858,arXiv:1601.01324,arxiv:2107.01628}. Two-dimensional stabilizer codes \\cite{arXiv:0810.1983} and encodings of frustration-free code Hamiltonians \\cite{arXiv:1209.5750} admit only constant-energy excitations, and so do not have admit such a barrier. No-go theorems for 3D models are much more restrictive, and there exist several candidates for self-correction as well as several partially self-correcting memories (see cousins below).\n", "code_id": "self_correct"}, "quantum_cyclic": {"name": "Quantum cyclic code", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) such that cyclic permutations of the subsystems leave the codespace invariant.", "notes": ["Many examples have been found by computer algebra programs. Ref. \\cite{arXiv:1007.1697} give examples of \\([[17,1,7]]\\) and \\([[17,9,3]]\\) quantum cyclic codes."], "introduced": "\\cite{arXiv:1007.1697}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Adapted from the Berlekamp decoding algorithm for classical BCH codes \\cite{arXiv:1007.1697}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Cyclic symmetry guarantees that if a single subsystem is protected against some noise, then all other subsystems are also.", "code_id": "quantum_cyclic"}, "quantum_quasi_cyclic": {"name": "Quantum quasi-cyclic code", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) such that cyclic shifts of the subsystems by \\(\\ell\\) leave the codespace invariant.", "notes": [], "introduced": "\\cite{arXiv:quant-ph/0701020}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "quantum_quasi_cyclic"}, "permutation_invariant": {"name": "Permutation-invariant code", "description": "A code \\(C\\) constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) such that any permutation of the subsystems leaves any codeword invariant.", "notes": ["Can be constructed using real polynomials for high-dimensional qudit spaces \\cite{doi:10.1016/j.laa.2017.06.031}."], "introduced": "\\cite{arXiv:quant-ph/0304153}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": ["With quantum harmonic oscillators (superconducting charge qubits in a ultrastrong coupling regime) in \\(O(N)\\) as in \\cite{doi:10.1103/PhysRevA.99.012335}. Can be done in \\(O(N^2)\\) steps using quantum circuits \\cite{arXiv:1904.07358}, or using geometric phase gates in \\(O(N)\\) \\cite{arxiv:1908.01120}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["For a family of codes, using projection, probability amplitude rebalancing, and gate teleportation can be done in \\(O(N^2)\\) \\cite{arXiv:2102.02494}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Depends on the family. The GNU permutation-invariant family (parameterized by \\(t\\)) protects against arbitrary weight \\(t\\) qubit errors and approximately corrects spontaneous decay errors \\cite{arXiv:1302.3247,doi:10.1103/PhysRevA.93.042340}. Other related codes protect against amplitude damping \\cite{doi:10.1109/TIT.2019.2956142} while admitting a constant number of excitations, and against deletion errors \\cite{arxiv:2102.02494,arXiv:2102.03015}.", "code_id": "permutation_invariant"}, "dynamic_gen": {"name": "Dynamically-generated QECC", "description": "Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process. Such processes, which are often non-deterministic, update the code structure and can include random unitary evolution or non-commuting projective measurements.", "notes": [], "introduced": "\\cite{arXiv:0708.4025}", "short_name": "Dynamically-generated", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "dynamic_gen"}, "random_circuit": {"name": "Random-circuit code", "description": "Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "A useful proxy and upper bound to the code distance \\(d\\) is the \\textit{contiguous code distance}: the contiguous length (with periodic boundary conditions) of the shortest logical operator \\cite{arxiv:0810.1983,arxiv:1905.05195}.", "code_id": "random_circuit"}, "topological": {"name": "Topological code", "description": "Stub.", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": ["The unitary circuit depth required to initialize in a general topologically ordered state using geometrically local gates on an \\(L\\times L\\) lattice is \\(\\Omega(L)\\) \\cite{arXiv:quant-ph/0603121}, irrespective of whether the ground state admits Abelian or non-Abelian anyonic excitations. However, only a finite-depth circuit and one round of measurements is required for nonabelian topological orders with a Lagrangian subgroup \\cite{arxiv:2209.03964}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Topological order cannot be stabilized via weight-two or weight-three stabilizer generators on nearly Euclideam geometries of qubits or qutrits \\cite{arxiv:quant-ph/0308021,arXiv:1102.0770}.", "code_id": "topological"}, "fracton": {"name": "Fracton code", "description": "A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "fracton"}, "hamiltonian": {"name": "Hamiltonian-based code", "description": "Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy.\n\nWhen the physical space is a tensor product of subsystems, the Hamiltonian is typically \\textit{local}, consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., \\hyperref[code:qldpc]{QLDPC codes}). When the physical space is endowed with a geometry, the Hamiltonian is typically \\textit{geometrically local}, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., \\hyperref[code:topological]{topological codes}). When the terms in a geometrically local Hamiltonian commute and can be expressed as projectors (i.e., having eigenvalues 0 or 1), the Hamiltonian is called \\textit{commuting-projector}.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": ["Lindbladian-based dissipative encoding can be constructed for a codespace that is the ground-state subspace of a frustration-free Hamiltonian \\cite{arXiv:0809.0613,arXiv:1112.4860,arxiv:0803.1447,arxiv:1802.00010}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Often determined from the underlying physical properties of the Hamiltonian.", "code_id": "hamiltonian"}, "topological_abelian": {"protection": "", "name": "Abelian topological code", "description": "Code whose codewords realize topological order associated with an abelian group. Stub.\n\nAny local quantum circuit connecting ground states of topological orders with non-isomorphic abelian groups must have depth that is at least linear in the system\u2019s diameter \\cite{arXiv:1407.2926}.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "topological_abelian", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "constant_excitation": {"name": "Constant-excitation (CE) code", "description": "Code whose codewords lie in an excited-state eigenspace of a Hamiltonian governing the total energy or total number of excitations of the underlying quantum system. For qubit codes, such a Hamiltonian is often the \\textit{total spin Hamiltonian}, \\(H=\\sum_i Z_i\\). For spin-\\(S\\) codes, this generalizes to \\(H=\\sum_i J_z^{(i)}\\), where \\(J_z\\) is the spin-\\(S\\) \\(Z\\)-operator. For bosonic codes, such as Fock-state codes, codewords are often in an eigenspace with eigenvalue \\(N>0\\) of the \\textit{total excitation} or \\textit{energy Hamiltonian}, \\(H=\\sum_i \\hat{n}_i\\).\n\nOne of the first such codes \\cite{arXiv:quant-ph/9603022} is a \\(((8,1,3))\\) qubit code, with codewords\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&= |00001111\\rangle + |11101000\\rangle \u2212 |10010110\\rangle \u2212 |01110001\\rangle\\\\\n                    & +|11010100\\rangle + |00110011\\rangle + |01001101\\rangle + |10101010\\rangle\\\\\n|\\overline{1}\\rangle&= X^{\\otimes 8} |\\overline{0}\\rangle~.\n\\end{split}\n\\end{align}\nEach logical state is a superposition of computational basis states with four excitations.\n", "notes": [], "introduced": "\\cite{arXiv:quant-ph/9603022,arXiv:quant-ph/9705044,arxiv:quant-ph/9809081}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "Fock-state CE codes can be used in a protocol that achieves the two-way quantum capacity of the pure-loss Gaussian channel \\cite{arxiv:2203.13924}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "constant_excitation"}, "qltc": {"name": "Quantum locally testable code (QLTC)", "description": "A local commuting-projector Hamiltonian-based quantum error-correcting code on a finite-tensor-product space of \\(n\\) identical factors (e.g., qubits, modular qudits, or Galois qudits) which has a nonzero average-energy penalty for creating large errors. Informally, QLTC error states that are far away from the codespace have to be excited states of many of the code's local projectors.\n\nThe average-energy penalty is quantified by the code's \\textit{soundness} \\(R\\). Typically, one looks at how \\(R\\) scales with increasing code size for infinite families of codes, defining QLTC families as those for which the soundness is asymptotically constant. QLTC families that also have asymptotically constant distance, rate, and weight of local projectors are called \\(c^3\\)\\textit{-QLTCs}; none have been found so far.\n\nMore technically, a QLTC is a code \\(\\mathsf{C}\\) defined as the ground-state space of a commuting-projector Hamiltonian \\(H\\) consisting of a sum of \\(r\\) local projectors, each of which acts on exactly \\(u\\) qubits (for some constant \\(u\\)). Such a code is a \\((u,R)\\)-QLTC with soundness function \\(R(\\delta)\\in[0,1]\\) if\n\\begin{align}\n\\label{eq:qltc}\n  \\forall \\delta > 0,|\\psi\\rangle~:~\\text{dist}(|\\psi\\rangle,C) \\geq \\delta n \\Rightarrow \\frac{1}{r}\\langle\\psi|H|\\psi\\rangle\\geq R(\\delta)~,\n\\end{align}\nwhere \\(\\text{dist}(|\\psi\\rangle,\\mathsf{C})\\) is a particular distance function between the state \\(|\\psi\\rangle\\) and the codespace \\(\\mathsf{C}\\) \\cite[Def. 13]{arxiv:1310.5664}. The locality parameter \\(u\\) is called the \\textit{query complexity} of the code.\n\nA qubit, modular-qudit, or Galois-qudit stabilizer code that is locally testable is called a \\textit{stabilizer locally testable code (SLTC)}. In other words, the code admits a set of \\(r\\) \\(u\\)-local stabilizer generators \\(S_i\\) whose corresponding code Hamiltonian \\(H=\\frac{1}{2}\\sum_{i=1}^r I-S_i\\) satisfies the requirement of being QLTC.\n\nFor example, the \\([[n=2L^2,k=2,d=L]]\\) toric code on an \\(L\\times L\\) lattice is \\textit{not} a QLTC because of the following argument. Let \\(|\\psi\\rangle\\) be a ground state that is excited by \\(L/3\\) Pauli strings, each of length \\(L/2\\). In order to fit on the lattice, such strings can, e.g., be horizontal and aligned next to each other in the vertical direction. The distance function \\(\\text{dist}(|\\psi\\rangle,\\mathsf{C})\\) is the weight of the smallest Pauli string that multiplies \\(|\\psi\\rangle\\) to yield a state in the codespace. In this case, that weight is the same as the weight of the perturbing string, i.e., \\(L^2/6\\), requiring \\(\\delta = 1/12\\) to satisfy \\eqref{eq:qltc}. There are \\(2L/3\\) violated Hamiltonian terms because each of the \\(L/3\\) strings violates only two stabilizer generators. However, there are \\(r = 2(L^2-1)\\) stabilizer generators, so the implication of \\eqref{eq:qltc} is not satisfied for nonzero soundness as \\(L\\to\\infty\\) because \\(\\frac{1}{r}\\langle\\psi|H|\\psi\\rangle = \\frac{2L/3}{2(L^2-1)}\\to 0\\).\n", "notes": ["It was shown in Ref. \\cite{doi:10.1109/FOCS.2017.46} that existence of a QLTC with constant parameters would implies resolution of the \\textit{No low-energy trivial states} (NLTS) conjecture \\cite{arxiv:1301.1363}."], "introduced": "\\cite{arxiv:1310.5664}", "short_name": "QLTC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "qltc"}, "distance_balanced": {"name": "Distance-balanced code", "description": "CSS stabilizer code constructed from a CSS code and a classical code using a distance-balancing procedure based on a generalized homological product. The initial code is said to be \\textit{unbalanced}, i.e., tailored to noise biased toward either bit- or phase-flip errors, and the procedure can result in a code that is treats both types of errors on a more equal footing. The original distance-balancing procedure \\cite{arxiv:1611.03790}, later generalized in Ref. \\cite{arxiv:2004.07935}, can yield QLDPC codes; see Thm. 1 in Ref. \\cite{arxiv:1611.03790}.", "notes": [], "introduced": "\\cite{arxiv:1611.03790,arxiv:2004.07935}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "distance_balanced"}, "translationally_invariant_stabilizer": {"name": "Translationally-invariant stabilizer code", "description": "A geometrically local qubit or qudit stabilizer code with qudits organized on a lattice modeled by the additive group \\(\\mathbb{Z}^D\\) for spatial dimension \\(D\\) such that each lattice point, referred to as a site,\ncontains \\(m\\) qudits of dimension \\(q\\). The stabilizer group of the translationally invariant code is generated by site-local Pauli operators and their translations.\n\nA single-qudit Pauli operator can be specified by the lattice coordinate of the site and the symplectic vector\nrepresentation of the Pauli operator within the site. In an extension of the sympletic representation, each lattice coordinate can be represented by a Laurent monomial of \\(D\\) formal variables. For example, when \\(D=2\\) and \\(m=1\\), the product of an \\(X\\) acting on the qubit at lattice coordinate \\((-1,2)\\) and a \\(Z\\) acting on the qubit at \\((1,0)\\) can be represented by the vector \\( (x^{-1} y^2 | x) \\). The multiplicative group of finitely supported Pauli operators modulo phase factors on the lattice of dimension \\(D\\) with \\(m\\) prime-dimensional qubits per site is isomorphic to the additive group of Laurent polynomial column vectors of length \\(2m\\) in \\(D\\) formal variables (see Ref. \\cite{arXiv:1607.01387} and Sec. IV of Ref. \\cite{arXiv:1812.01625}).\n\nTranslationally-invariant prime-qudit (\\(q=p\\)) stabilizer codes have been classified in dimensions \\(D\\in\\{1,2\\}\\), up to equivalence under local constant-depth Clifford circuits. Any 1D (2D) code can be converted to several copies of the 1D repetition code (prime-qudit 2D surface code) along with some trivial codes \\cite{arXiv:1607.01387} (\\cite{arXiv:1812.11193}). Three-dimensional qubit codes can be characterized by four\ncoarse classes \\cite{arXiv:1908.08049}:\n\n1. \\textit{Abelian topological phase}: Excitations are mobile in all 3 dimensions, as is typical in a topological code. Such codes are conjectured to be equivalent to a \\(\\mathbb{Z}_2\\) gauge theory, i.e., multiple copies of the 3D surface code or its variant where the charge excitation is a fermion.\n\n2. \\textit{Foliated type-I fracton phase}: Excitations are mobile in less than 3 dimensions, but codes can be grown by \\textit{foliation}, i.e., stacking copies of the 2D surface code.\n\n3. \\textit{Fractal type-I fracton phase}: Excitations are mobile in less than 3 dimensions, and codes are not foliated.\n\n4. \\textit{Type-II fracton phase}: Excitations are not mobile in any dimension and there are no string operators.\n", "notes": [], "introduced": "\\cite{arXiv:1101.1962,arXiv:1204.1063,doi:10.7907/GCYW-ZE58}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Clustering decoder \\cite{doi:10.7907/AHMQ-EG82,arXiv:1112.3252}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "translationally_invariant_stabilizer"}, "qldpc": {"name": "Quantum low-density parity-check (QLDPC) code", "description": "Family of \\([[n,k,d]]\\) stabilizer codes for which the number of sites (either qubit or qudit) participating in each stabilizer generator and the number of stabilizer generators that each site participates in are both bounded by a constant as \\(n\\to\\infty\\). A \\textit{geometrically local stabilizer code} is a QLDPC code where the sites involved in any syndrome bit are contained in a fixed volume that does not scale with \\(n\\). As opposed to general stabilizer codes, syndrome extraction of the constant-weight check operators of a QLDPC codes can be done using a constant-depth circuit.\n\nNotable \\([[n,k,d]]\\) QLDPC codes are summarized in \\ref{table:qldpc-codes}, demonstrating the steady improvement in code parameters that culminated in the first asymptotically good QLDPC codes.\n  \\begin{table}\n    \\begin{cells}\n    \\celldata<c H, c H, c H>{\\(k\\) & \\(d\\) & Code}\n    \\celldata<c, c, c>{\n    \\(2\\) & \\(\\sqrt{n}\\) & \\hyperref[code:surface]{Kitaev toric}\n        \\\\\n    \\(2\\) & \\(\\sqrt{n\\sqrt{\\log n}}\\) & \\hyperref[code:freedman_meyer_luo]{Freedman-Meyer-Luo}\n        \\\\\n    \\(n\\) & \\(\\sqrt{n}\\) & \\hyperref[code:hypergraph_product]{hypergraph product}\n        \\\\\n    \\(n\\) & \\(\\sqrt{n} \\log n\\) & \\hyperref[code:ramanujan_tensor_product]{Ramanujan-complex product}\n        \\\\\n    \\(\\sqrt{n}\\) & \\(\\sqrt{n} \\log^c n\\) & \\hyperref[code:iterated_ramanujan]{tensored-Ramanujan-complex product}\n        \\\\\n    \\(n^{3/5}/\\text{polylog}(n)\\) & \\(n^{3/5}/\\text{polylog}(n)\\) & \\hyperref[code:fiber_bundle]{fiber-bundle}\n        \\\\\n    \\(\\log n\\) & \\(n/\\log n\\) & \\hyperref[code:lifted_product]{lifted-product}\n        \\\\\n    \\(\\Theta(n)\\) & \\(\\Theta(n)\\) & \\hyperref[code:expander_lifted_product]{expander lifted-product}\n        \\\\\n    \\(\\Theta(n)\\) & \\(\\Theta(n)\\) & \\hyperref[code:quantum_tanner]{quantum Tanner}\n        \\\\\n    \\(\\Theta(n)\\) & \\(\\Theta(n)\\) & \\hyperref[code:dhlv]{Dinur-Hsieh-Lin-Vidick}\n    }\n    \\end{cells}\n    \\caption{Notable QLDPC codes; \\(c\\) is a positive integer.}\n    \\label{table:qldpc-codes}\n  \\end{table}\n\nStrictly speaking, the term \\textit{parity check} describes only bitwise qubit error syndromes. Nevertheless, qudit stabilizer codes satisfying the above criteria are also called QLDPC codes.\n", "notes": ["Links to code tables of notable QLDPC codes \\cite{arXiv:2103.06309}.", "Reviews of QLDPC codes provided in Refs. \\cite{doi:10.1109/ACCESS.2015.2503267,arxiv:2103.06309}."], "introduced": "\\cite{arXiv:quant-ph/0304161}", "short_name": "QLDPC", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": ["Lattice surgery techniques with ancilla qubits \\cite{arxiv:2110.10794}.", "Fault-tolerance with constant overhead can be performed on certain QLDPC codes \\cite{arXiv:1310.2984}, e.g., quantum expander codes \\cite{arXiv:1808.03821}.", "GHz state distillation for Steane error correction \\cite{arxiv:2210.14143}."], "threshold": ["QLDPC codes with a constant encoding rate can reduce the overhead of fault-tolerant quantum computation to be constant \\cite{arXiv:1310.2984}."], "decoders": ["Belief-propagation (BP) decoder \\cite{arxiv:0801.1241}.", "Non-binary decoding algorithm for CSS-type QLDPC codes \\cite{doi:10.1109/ACCESS.2015.2503267}.", "BP-OSD decoder adds a post-processing step based on ordered statistics decoding (OSD) to the belief propogation (BP) decoder \\cite{arxiv:1904.02703}.", "Soft (i.e., analog) syndrome iterative belief propagation for CSS-type QLDPC codes, utilizing the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) \\cite{arxiv:2205.02341}.", "Message-passing decoder utilizing stabilizer inactivation (MP-SI) for CSS-type QLDPC qubit codes \\cite{arxiv:2205.06125}.", "Extension of the union-find decoder for qubit QLDPC codes, as well as a related heuristic decoder \\cite{arxiv:2209.01180}."], "code_capacity_threshold": ["Bounds on code capacity thresholds using maximum-likelihood (ML) decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model \\cite{arxiv:quant-ph/0110143,arXiv:1208.2317,arXiv:1311.7688}.", "Bounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights \\cite{arxiv:1412.6172}."], "transversal_gates": ""}, "physical": null, "protection": "Detects errors on \\(d-1\\) sites, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) sites. Asymptotic scaling of \\(k\\) and \\(d\\) with \\(n\\) is often of interest, and this depends heavily on the code construction.   Geometrically local qubit codes are limited by the BPT bound \\cite{arxiv:0810.1983}, which states that \\(d=O(n^{1-1/D})\\) for \\(D\\)-dimensional lattice geometries. For general graphs, distance is limited by graphs' connectivity, and a constant relative minimum distance can be achieved only for graphs that contain expanders \\cite{arXiv:2106.00765}. Conversely, a code with parameters \\(k\\) and \\(d\\) requires a graph with \\(\\Omega(d)\\) edges of length \\(\\Omega(d/n^{1/D})\\) \\cite{arXiv:2109.10982}.\n\nCode distance may not be a reliable marker of code performance. QLDPC codes with generator weights bounded by some constant can correct many stochastic errors far beyond the distance, which may not scale as favorably. Together with more accurate, faster, and easier-to-parallelize measurements than those of general stabilizer codes, this property makes QLDPC codes interesting in practice.\n", "code_id": "qldpc"}, "good_qldpc": {"protection": "", "name": "Good QLDPC code", "description": "Also called \\textit{asymptotically good QLDPC codes}. A family of QLDPC codes \\([[n_i,k_i,d_i]]\\) whose asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.\n\nThe first good QLDPC codes are families of \\hyperref[code:expander_lifted_product]{expander lifted-product} codes, followed by \\hyperref[code:quantum_tanner]{quantum Tanner} codes and \\hyperref[code:dhlv]{Dinur-Hsieh-Lin-Vidick} codes.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "good_qldpc", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "generalized_homological_product": {"protection": "", "name": "Generalized homological product code", "description": "Stabilizer code formulated in terms a chain complex consisting of some type of product of other chain complexes. The \\ref{topic:CSS-to-homology-correspondence} yields an interpretation of codes in terms of manifolds, thus allowing for the use of various products from topology in constructing codes. The codes participating in the product can be quantum, classical, or mixed. Products can be of more than two codes, in which case the output code need not be of CSS type (e.g., for \\hyperref[code:xyz_product]{XYZ-product codes}). The simplest product is a tensor product, with more general products imposing equivalence or symmetry relations on the outputs of the tensor product. A product of two codes can be interpreted as a fiber bundle, with one element of the product being the base and the other being the fiber.\n", "notes": [], "introduced": "", "short_name": "", "logical": null, "code_id": "generalized_homological_product", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null}, "balanced_product": {"name": "Balanced product code", "description": "Family of CSS quantum codes based on products of two classical codes which share common symmetries. The balanced product can be understood as taking the usual tensor/hypergraph product and then factoring out the symmetries factored. This reduces the overall number of physical qubits \\(n\\), while, under certain circumstances, leaving the number of encoded qubits \\(k\\) and the code distance \\(d\\) invariant. This leads to a more favourable encoding rate \\(k/n\\) and normalized distance \\(d/n\\) compared to the tensor/hypergraph product.", "notes": [], "introduced": "\\cite{arXiv:2012.09271}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "A notable family of balanced product codes encode \\(k \\in \\Theta(n^{4/5})\\) logical qubits with distance \\(d \\in \\Omega(n^{3/5})\\) for any number of physical qubits \\(n\\). Additionally, it is known that the code constructed from the balanced product of two good classical LDPC codes over groups of order \\(\\Theta(n)\\) has a constant encoding rate \\cite{arxiv:2012.09271}.", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["BP-OSD decoder \\cite{arXiv:1904.02703}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Taking balanced products of two classical LDPC codes which have a symmetry group which grows linearly in their block lengths were known to give QLDPC codes with a linear rate and which were conjectured to have linear distance \\cite{arXiv:2012.09271}. This conjecture was proved in Ref. \\cite{arXiv:2111.03654}.", "code_id": "balanced_product"}, "covariant": {"name": "Covariant code", "description": "Code constructed in a physical space consisting of a tensor product of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits) that admits a group \\(G\\) of transversal gates. The group has to be finite for finite-dimensional codes due to the Eastin-Knill theorem. Continuous-\\(G\\) covariant codes, necessarily infinite-dimensional, are relevant to error correction of quantum reference frames \\cite{arxiv:1709.04471} and error-corrected parameter estimation.\n\nDenoting the code's encoding map as \\(U\\), covariance is equivalent to\n\\begin{align}\n  \\left(\\bigotimes_{j=1}^{n}V_{j}\\left(g\\right)\\right)U=UV_{L}\\left(g\\right)\\quad\\quad\\forall g\\in G\\,,\n\\end{align}\nwhere \\(V_j(g)\\) is a unitary representation of \\(g\\) acting on the \\(j\\) subsystem, and \\(V_L\\) is a unitary representation acting on the unencoded logical information.\nIn this way, covariant encoding maps are equivariant (i.e., commute) with group actions on the logical and physical spaces.\n\nAlmost always, the physical representation is defined to be the transversal one (with respect to some tensor-product decomposition), but can reduce to any representation when the code is a subspace of a larger space that is not expressed as a tensor product (\\(n=1\\)). More generally, a code is sometimes said to be \\textit{time-covariant} if it admits a continuous-parameter \\(U(1)\\) family of gates, not necessarily transversal \\cite{arxiv:2207.13707}.\n", "notes": [], "introduced": "\\cite{arxiv:1709.04471}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "\\(G\\)-covariant codes defined on a tensor product space consisting of \\(n\\) subsystems are equivalent to codes with a transversal gate set realizing \\(G\\)."}, "physical": null, "protection": "Finite-dimensional codes correcting a single-subsystem erasure and admitting a continuous-parameter family of transversal gates (assuming \\(n>1\\)) cannot exist in finite\ndimensions due to the Eastin-Knill theorem. As a result, there is generally a tradeoff between covariance and error correction.\n\nExact error-correcting \\(G\\)-covariant codes can exist in infinite dimensions, but their codewords are non-normalizable, meaning that approximate constructions have to be considered that are only approximately error correcting.\nOn the other hand, there exist exact error-correcting codes in finite dimensions that are approximately covariant \\cite{arxiv:2111.06360,arxiv:2111.06355}.\nVarious bounds quantify the covariance-performance tradeoff \\cite{arxiv:1902.07714,arxiv:2005.11918,arxiv:2004.11893,arxiv:2111.06360,arxiv:2111.06355}.\n", "code_id": "covariant"}, "metopt": {"name": "Error-corrected sensing code", "description": "Code that can be obtained via an optimization procedure that ensures correction against a set \\(\\cal{E}\\) of errors as well as guaranteeting optimal precision in locally estimating a parameter using a noiseless ancilla. For tensor-product spaces consisting of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits), the procedure can yield a code whose parameter estimation precision satisfies \\textit{Heisenberg scaling}, i.e., scales quadratically with the number \\(n\\) of subsystems.\n\nThe conditions required for a code are that it corrects errors in the set \\(\\cal{E}\\) and admits a continuous-parameter \\(U(1)\\) group of logical gates generated by some \\textit{signal Hamiltonian} \\(H\\) (with the time of evolution by \\(H\\) the parameter that is to be estimated).\nThis means that \\(H\\) cannot itself be a detectable error, i.e., \\(H\\) cannot be expressed as a linear combination of the errors, a condition known as the \\textit{Hamiltonian-not-in-Kraus-span} condition \\cite{arxiv:2003.10559} (alternatively, Hamiltonian-not-in-Lindblad-span for Markovian noise \\cite{arxiv:1706.02445}). If these conditions are satisfied, a semidefinite-program based optimization procedure yields a metrologically optimal code.\nThe procedure has been generalized to more general groups, corresponding to multiparameter estimation \\cite{arxiv:1901.00896}. If these conditions are not satisfied, Heisenberg scaling is not achievable, but metrologically optimal codes can still be obtained via another semidefinite-program based optimization procedure \\cite{arxiv:1910.08472,arxiv:2003.10559}.\n\nMetrologically optimal QECCs require error-free ancillas for optimal local parameter estimation using an entangling gate. In this sense, such codes can be thought of as being entanglement-assisted.\n\\textit{Ancilla-free} versions exist in the case when the noise commutes with the signal Hamiltonian \\cite{arxiv:1811.01450}.\n", "notes": [], "introduced": "\\cite{arxiv:1704.06280,arxiv:1706.02445}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "metopt"}, "nonabelian_covariant_erasure": {"name": "\\(U(d)\\)-covariant approximate erasure code", "description": "Stub.\n", "notes": [], "introduced": "\\cite{arxiv:2007.09154}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "", "code_id": "nonabelian_covariant_erasure"}, "g_covariant_erasure": {"name": "\\(G\\)-covariant erasure code", "description": "A \\(G\\)-covariant code constructed in a physical space consisting of a tensor product of identical subsystems (e.g., qubits, modular qudits, or Galois qudits).\nThe code is a proof-of-principle construction to demonstrate the existence of\n\\hyperref[code:covariant]{\\(G\\)-covariant codes} where \\(G\\) is a finite\ngroup, and the physical space is finite-dimensional.\n\nConsider a finite group \\(G\\) acting on a finite set\n\\(A\\) as a subgroup of the symmetric group on \\(|A|\\) elements, \\(G \\subset S_{|A|}\\).\nLet \\(U_0: \\mathsf{H}_{\\text{logical}} \\rightarrow \\mathsf{H}_{\\text{physical}}\n= \\mathsf{H}^{\\otimes n}\\) be any QECC, possibly non-covariant.  Define the covariant\nencoder \\(U \\equiv U_0^{\\otimes |A|}: \\mathsf{H}_{\\text{logical}}^{\\otimes |A|}\n\\rightarrow \\mathsf{H}_{\\text{physical}}^{\\otimes |A|}\\) on \\(|A|\\).  Then, the group acts on codewords by index\npermutation:\n\\begin{align}\nV(g) | \\phi_{a_1} \\rangle | \\phi_{a_2} \\rangle \\cdots | \\phi_{a_{|A|}} \\rangle = | \\phi_{g^{-1} a_1} \\rangle | \\phi_{g^{-1} a_2} \\rangle \\cdots | \\phi_{g^{-1} a_{|A|}} \\rangle~,\n\\end{align}\nwhere \\(V(g)\\) is the unitary representation of \\(g \\in G\\) acting on the physical space. The action of \\(V(g)\\) is transversal with respect to the partition \\(\\mathsf{H}_{\\text{physical}}^{\\otimes |A|}\\).\n", "notes": [], "introduced": "\\cite{arxiv:1709.04471}", "short_name": "", "logical": null, "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": null, "protection": "Depends on the base encoding \\(U_0\\).\n", "code_id": "g_covariant_erasure"}, "j_gross": {"name": "Gross spin code", "description": "A spin code designed to realize Clifford gates using \\(SU(2)\\) rotations. Codewords are subspaces of a spin's Hilbert space that house irreducible representations (irreps) of the single-qubit Clifford group (i.e., the binary octahedral (\\(2O\\)) subgroup of \\(SU(2)\\)). This is done by restricting the \\(SU(2)\\) irrep to \\(2O\\), and determining the carrier spaces of any nontrivial irreps of \\(2O\\). Since irreps of \\(2O\\) do not appear in integer spins, half-integer spins are used.\n\nA simple example of a codespace is a projection onto an instance of a particular irrep of \\(2O\\), referred to as either \\( \\varrho_4 \\) or \\( \\varrho_5 \\).\nIn the case of only one instance of the desired irrep present in the spin, the projection is created as follows:\n\\begin{align}\n  P_\\varrho = \\frac{\\text{dim} \\varrho}{|2O|} \\sum_{g \\in 2O} \\chi_\\varrho (g)^* D(g)~,\n\\end{align}\nwhere \\(D(g)\\) is the \\(SU(2)\\) Wigner matrix corresponding to group element \\(g\\), and the character \\(\\chi_\\varrho (g) = \\text{tr}(\\varrho(g))\\) is the trace of the desired irrep evaluated at a group element.\n\nLogical Pauli matrices \\(\\overline{\\sigma}_w\\) are defined using the above projection and the angular momentum operators:\n\\begin{align}\n  \\overline{\\sigma}_w = i P_\\varrho e^{-i \\pi J_w} P_\\varrho~.\n\\end{align}\nFinally, \\(|\\overline{0} \\rangle\\) is defined as the \\(+1\\) eigenvalue of \\(\\overline{\\sigma}_z\\) and \\(|\\overline{1} \\rangle = \\overline{\\sigma}_x |\\overline{0} \\rangle \\).\n", "notes": [], "introduced": "\\cite{arXiv:2005.10910}", "short_name": "", "logical": "spins", "realizations": [], "features": {"general_gates": ["Universal computation results from being able to prepare a single logical state, perform one measurement, and the following logical gates: the phase gate (\\( \\overline{S} \\)), the Hadamard gate (\\(\\overline{H}\\)), the conditional phase gate (\\(\\overline{CZ}\\)), and the square root of the phase gate (\\(\\overline{T}\\)). Single-qubit Cliffords can be generated using \\(\\overline{S}\\) and \\(\\overline{H}\\), the extension to multiple-qubit Cliffords is done using \\(\\overline{CZ}\\), and \\(\\overline{T}\\) is to transform to non-Clifford states. Together these gates can be used to create all logical unitaries, while preparation and measurement complete universal quantum computation."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "spins", "protection": "", "code_id": "j_gross"}, "single_spin": {"name": "Single-spin code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(2\\ell+1\\)-dimensional Hilbert space, where the latter is thought of as a spin-\\(\\ell\\) quantum system. This spin system can in turn be thought of as the maximally symmetric subspace or \\textit{collective spin} of \\(2\\ell\\) spin-half systems.\n", "notes": [], "introduced": "", "short_name": "", "logical": "spins", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": "When the physical Hilbert space is thought of a collective spin, logical gates for spin codes have the form \\(U^{\\otimes N}\\), where \\(U\\) is a local rotation on the physical system."}, "physical": "spins", "protection": "", "code_id": "single_spin"}, "spin_gkp": {"name": "Spin GKP code", "description": "An analogue of the single-mode GKP code designed for atomic ensembles. Was designed by using the Holstein-Primakoff mapping \\cite{doi:10.1103/PhysRev.58.1098} (see also \\cite{doi:10.2307/3212170}) to pull back the phase-space structure of a bosonic system to the compact phase space of a quantum spin. A different construction emerges depending on which particular expression for GKP codewords is pulled back.\n", "notes": [], "introduced": "\\cite{arXiv:2211.05181}", "short_name": "", "logical": "spins", "realizations": [], "features": {"general_gates": ["Approximate Clifford-group generators are composed of Hamiltonians at most quadratic in angular momentum operators of two spin systems. Assuming that these generators can be implemented with high fidelity, a magic state can be prepared from an atomic ensemble analog of the vacuum state"], "encoders": ["Linear combination of unitaries method \\cite{arxiv:1412.4687,arXiv:1610.06546,arXiv:2203.08882}, which may be applicable to more general codewords."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "spins", "protection": "Protect against errors native to spin systems like random rotations and stochastic relaxation.", "code_id": "spin_gkp"}, "spins_into_spins": {"name": "Spin code", "description": "Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, where the canonical qudit basis consists of states of a quantum mechanical spin. In other words, canonical single-qudit states \\(|^\\ell_m\\rangle\\) are labeled by total angular momentum \\(\\ell\\) (either integer or half-integer) and its \\(z\\)-axis projection \\(m\\), with \\(q=2\\ell+1\\).\n\nIn contrast to other qudit codes, spin codes are closely associated with the angular momentum Lie algebra and/or the Lie groups \\(SU(2)\\) or \\(SO(3)\\).\n", "notes": [], "introduced": "", "short_name": "", "logical": "spins", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "spins", "protection": "Spin codes are often designed to protect against \\(SU(2)\\) rotations by small angles.", "code_id": "spins_into_spins"}, "fermions": {"name": "Fermionic code", "description": "Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators \\cite{arXiv:quant-ph/0003137}.", "notes": [], "introduced": "", "short_name": "", "logical": "fermions", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "fermions", "protection": "", "code_id": "fermions"}, "majorana_stab": {"name": "Majorana stabilizer code", "description": "Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as \\textit{Majorana stabilizers}. The codespace is the mutual \\(+1\\) eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as \\([[n,k,d]]_{f}\\) \\cite{arXiv:1703.00459}, where \\(n\\) is the number of fermionic modes.", "notes": [], "introduced": "\\cite{arXiv:1004.3791}", "short_name": "", "logical": "fermions", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "fermions", "protection": "Detects products of Majorana operators with weight up to \\(d-1\\). Physically, protects against dephasing errors caused by coupling of fermion density to the environment and bit-flip errors caused by quasiparticle poisoning processes.", "code_id": "majorana_stab"}, "string_net": {"name": "String-net code", "description": "Also called a \\textit{Turaev-Viro} or \\textit{Levin-Wen model} code. A family of topological codes, defined by a finite unitary spherical category \\( \\mathcal{C} \\),  whose generators are few-body operators acting on a cell decomposition dual to a triangulation of a two-dimensional surface (with a qudit of dimension \\( |\\mathcal{C}| \\) located at each edge of the decomposition).\n\nThe codespace is the ground-state subspace of the Levin-Wen model Hamiltonian \\cite{arxiv:cond-mat/0404617}, a many-body Hamiltonian realizing the 3-manifold Turaev-Viro invariant \\cite{arxiv:1002.2816,arxiv:1106.6033}. Alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model \\cite{arXiv:quant-ph/0001108,arxiv:1002.2816}. The fusion space can have dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.\n", "notes": [], "introduced": "\\cite{arxiv:cond-mat/0404617,arxiv:1002.2816}", "short_name": "", "logical": "categories", "realizations": [], "features": {"general_gates": ["Gates can be implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles for triangulations of toroidal \\cite{arXiv:1806.02358,arxiv:1806.06078} and hyperbolic \\cite{arXiv:1901.11029} manifolds. Whether or not a gate set is universal depends on the choice of input category; in some cases such as the Ising category, gates can be complemented by topological charge measurements to obtain a universal gate set.", "Alternatively, one could encode the logical quantum information into the degenerate fusion space of a number of computational anyons. In this case, a universal logical gate set can be implemented through the braiding of the computational anyons \\cite{arXiv:quant-ph/0001108,arXiv:math/0103200,arxiv:1002.2816}, e.g., for the case of the \\hyperref[code:fibonacci]{Fibonacci} input category."], "encoders": ["For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit \\cite{arxiv:2110.02020}."], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": ["Syndrome measurement circuits analyzed in Ref. \\cite{arXiv:1206.6048}.", "Clustering decoder \\cite{arxiv:1607.02159}."], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "categories", "protection": "Error-correcting properties established in Ref. \\cite{arxiv:2004.11982}.", "code_id": "string_net"}, "fibonacci": {"name": "Fibonacci string-net code", "description": "Quantum error correcting code associated with the Levin-Wen string-net model with the Fibonacci input category, admitting two types of encodings.\n\nThe first type of encoding is into the ground-state subspace of the Levin-Wen model Hamiltonian, defined on a cell decomposition (dual to a triangulation) of a manifold with a qubit on each link. The code space is the simultaneous \\(+1\\) eigenspace of a set of vertex operators and plaquette operators, which are defined by the fusion rules and the numerical data of the Fibonacci category, respectively. The degeneracy of the code space is \\(4g\\),\nwere \\(g\\) is the genus of the surface on which the cell decomposition is defined.\n\nThe second type of encoding is into the degenerate fusion space of a number of anyonic quasiparticle excitations of the Levin-Wen model. This can equivalently constructed by braiding holes in a spherical geometry \\cite[Sec. 5]{arxiv:1002.2816}.\n", "notes": [], "introduced": "\\cite{arxiv:cond-mat/0404617,arxiv:1002.2816}", "short_name": "", "logical": "categories", "realizations": ["NMR: Implementation of braiding-based Hamamard gate on two qubits \\cite{arxiv:2210.12145}."], "features": {"general_gates": ["Universal gate set for the ground-state encoding is implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles. These Dehn-twists can be implemented using constant-dept circuits when allowing long-range permutations of qubits \\cite{arXiv:1806.02358,arxiv:1806.06078}.", "Universal gate set for the fusion-space encoding is implemented through braiding of the computational anyons \\cite{arXiv:quant-ph/0001108,arxiv:1002.2816}."], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": ["\\(4.7\\%\\) for depolarizing noise, \\(7.3\\%\\) for dephasing noise, and \\(3.8\\%\\) for bit-flip noise with clustering decoder, assuming perfect measurements and gates \\cite{arXiv:2012.04610}. See also Ref. \\cite{arxiv:1506.03815}.", "\\(3.0\\%\\) for depolarizing noise, \\(6.0\\%\\) for dephasing noise, and \\(2.5\\%\\) for bit-flip noise with fusion-aware iterative MWPM decoder, assuming perfect measurements and gates \\cite{arXiv:2012.04610}."], "decoders": ["Clustering decoder (provides best known threshold for this code) \\cite{arxiv:1506.03815,arxiv:1607.02159,arXiv:2012.04610}.", "Fusion-aware iterative minimum-weight perfect matching decoder. Note that ordinary MWPM decoders do not produce a threshold with this code \\cite{arXiv:2012.04610}."], "code_capacity_threshold": [], "transversal_gates": "A universal transversal gate set could be implemented in a folded version of this code using the techniques introduced in Ref.\\cite{arXiv:1711.05752}."}, "physical": "categories", "protection": "When defined on a \\(L \\times L\\) tailed honeycomb lattice on a torus, the code distance for ground-state encoding is \\(L\\).", "code_id": "fibonacci"}, "category_quantum": {"name": "Category-based quantum code", "description": "Encodes a finite-dimensional \\textit{logical} Hilbert space into a \\textit{physical} Hilbert space associated with a category. Often associated with a particular topological quantum field theory (TQFT), as the data of such theories is described by a category.", "notes": [], "introduced": "", "short_name": "", "logical": "categories", "realizations": [], "features": {"general_gates": [], "encoders": [], "rate": "", "magic_scaling_exponent": "", "fault_tolerance": [], "threshold": [], "decoders": [], "code_capacity_threshold": [], "transversal_gates": ""}, "physical": "categories", "protection": "", "code_id": "category_quantum"}}