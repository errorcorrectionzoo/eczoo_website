<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>
      Index of all codes
    [error correction zoo]
  </title>

  <!-- favicon generated with https://realfavicongenerator.net/ -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <!--<link rel="manifest" href="/site.webmanifest">-->
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#00007f">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <!-- end favicon code -->

  <link type="text/css" rel="stylesheet" href="/css/main.css" />

  <script type="text/javascript">
    window.ecz_baseurl = '/';
  </script>

  <script type="text/javascript" async
	  src="/js/misc.js">
  </script>
  <script type="text/javascript" src="/js/mathjaxinit.js" async>
  </script>



</head>
<body>

<div
  id="bodycontents"
  >

  <header id="header">
    <h1>Index of all codes</h1>
  </header><!-- #header -->

  <main id="main">

<h1>All codes in alphabetical order</h1>

<ol class="code-index">
  <li>
    <span class="code-name">
      <a href="/c/alternant">Alternant Codes</a><span class="code-introduced"><a href="#cite-0" class="cite">[1]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/approximate_qecc">Approximate quantum code</a><span class="code-introduced"><a href="#cite-1" class="cite">[2]</a><a href="#cite-2" class="cite">[3]</a><a href="#cite-3" class="cite">[4]</a><a href="#cite-4" class="cite">[5]</a><a href="#cite-5" class="cite">[6]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_secret_sharing">Approximate secret-sharing code</a><span class="code-introduced"><a href="#cite-4" class="cite">[5]</a></span></span>
    <span class="code-description">A family of <span class="inline-math">\( [[n,k,d]]_{GF(q)} \)</span> CSS codes approximately correcting errors on up to <span class="inline-math">\(\lfloor (n-1)/2 \rfloor\)</span> qubits, i.e., with approximate distance approaching the no-cloning bound <span class="inline-math">\(n/2\)</span>. Constructed using a non-degenerate CSS code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an <span class="inline-math">\(t\)</span>-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/bacon_shor">Bacon-Shor code</a></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/balanced_product">Balanced product code</a><span class="code-introduced"><a href="#cite-6" class="cite">[7]</a></span></span>
    <span class="code-description">A large family of CSS quantum codes based on products of two classical codes which share common symmetries. The balanced product can be understood as taking the usual tensor/hypergraph product and then factoring out the symmetries factored. This reduces the overall number of physical qubits n, while, under certain circumstances, leaving the number of encoded qubits k and the code distance d invariant. This leads to a more favourable encoding rate k/n and relative distance d/n compared to the tensor/hypergraph product.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/bits_into_bits">Binary code</a></span>
    <span class="code-description">Encodes <span class="inline-math">\(K\)</span> states (codewords) in <span class="inline-math">\(n\)</span> binary coordinates and has distance <span class="inline-math">\(d\)</span>. Usually denoted as <span class="inline-math">\((n,K,d)\)</span>. The distance is the minimum Hamming distance between a pair of distinct codewords.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/binary_linear">Binary linear code</a></span>
    <span class="code-description">An <span class="inline-math">\((n,2^k,d)\)</span> linear code is denoted as <span class="inline-math">\([n,k,d]\)</span>. Its codewords form a linear subspace, i.e., for any codewords <span class="inline-math">\(x,y\)</span>, <span class="inline-math">\(x+y\)</span> is also a codeword. Often defined in terms of a generator matrix <span class="inline-math">\(G\)</span>, whose rows form a basis for the subspace. Given a codeword <span class="inline-math">\(x\)</span>, the corresponding encoded codeword is <span class="inline-math">\(G^T x\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/binary_quantum_goppa">Binary quantum Goppa Code</a><span class="code-introduced"><a href="#cite-7" class="cite">[8]</a><a href="#cite-8" class="cite">[9]</a></span></span>
    <span class="code-description"><p>Also known as a <span class="textit">quantum AG code</span>. Binary quantum Goppa codes are a family of <span class="inline-math">\( [[n,k,d]]_{GF(q)} \)</span> Galois-qudit stabilizer codes for <span class="inline-math">\( q=2^m \)</span>, generated using classical Goppa codes.</p>
<p>Let <span class="inline-math">\( F/GF(q) \)</span> be an algebraic function field of one variable, <span class="inline-math">\(\sigma \)</span> be an automorphism of order 2
of <span class="inline-math">\(F\)</span> which leaves <span class="inline-math">\(GF(q)\)</span> invariant, and <span class="inline-math">\(P_1, \cdots, P_n \)</span> be pairwise distinct places of degree one such that <span class="inline-math">\( \sigma P_i = P_j\)</span> for all
<span class="inline-math">\(i,j = 1, \cdots, n\)</span>. A place <span class="inline-math">\( P_i \)</span> of <span class="inline-math">\( F/ GF(q) \)</span> is the unique maximal ideal of a discrete valuation ring of the function field. Let <span class="inline-math">\( \nu \)</span> be a  differential
that satisfies the properties guaranteed by  the strong approximation theorem of discrete evaluations. Let <span class="inline-math">\(G\)</span> be a divisor such that <span class="inline-math">\( \sigma G = G \)</span> and the
discrete valuation corresponding to place <span class="inline-math">\(P_i \)</span> of <span class="inline-math">\(G\)</span> and the discrete valuation corresponding to place <span class="inline-math">\(\sigma P_i \)</span> of <span class="inline-math">\(G\)</span> are both 0 for all <span class="inline-math">\(i\)</span>. Then we can define
a code <span class="inline-math">\( C(G)  = \{ f(P_1), \cdots, f(P_n), f(\sigma P_1), \cdots , f(\sigma P_n) | f \in \mathcal{L}(G)\} \subset GF(q^{2n})\)</span> and
a code <span class="inline-math">\(C(H)\)</span> where <span class="inline-math">\(H = (P_1 + \cdots + P_n + \sigma P_1 + \cdots + \sigma P_n) - G + \nu \)</span>. Then the dual of <span class="inline-math">\(C(G)\)</span> with respect to the weighted symplectic inner
product with weights <span class="inline-math">\(s_i\)</span> on <span class="inline-math">\( GF(q^n) \)</span> is equivalent to <span class="inline-math">\(C(H)\)</span>. Therefore, the orthogonal code of <span class="inline-math">\(C(G)\)</span> is generated by <span class="inline-math">\(H\)</span>. Using these properties and the assumption
that <span class="inline-math">\(H\)</span> is a subgroup of <span class="inline-math">\(G\)</span>, we can construct a classical Goppa code <span class="inline-math">\(C(D,G)\)</span>, where <span class="inline-math">\(D\)</span> is the sum of all <span class="inline-math">\(P_i\)</span>. Using <span class="inline-math">\(C(D,G)\)</span>, we can construct a <span class="inline-math">\([[n,k,d]]_{GF(q)}\)</span> quantum stabilizer code such that
<span class="inline-math">\(k  = \text{dim} G - \text{dim}(G-P_1 - \cdots - P_n - \sigma P_1 - \cdots  - \sigma P_n) - n~.\)</span></p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/repetition">Binary repetition code</a><span class="code-introduced"><a href="#cite-9" class="cite">[10]</a></span></span>
    <span class="code-description"><span class="inline-math">\([n,1,n]\)</span> binary linear code encoding one bit of information into an <span class="inline-math">\(n\)</span>-bit string. The length <span class="inline-math">\(n\)</span> needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a <span class="inline-math">\((n,1)\)</span>-Hamming code.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/binomial">Binomial code</a><span class="code-introduced"><a href="#cite-10" class="cite">[11]</a></span></span>
    <span class="code-description">Bosonic rotation codes designed to approximately protect against errors consisting of powers of raising and lowering operators up to some maximum power. Binomial codes can be thought of as spin-coherent states embedded into an oscillator <a href="#cite-11" class="cite">[12]</a>. The <span class="inline-math">\(q\)</span>-dimensional qudit <span class="inline-math">\((N, S)\)</span> binomial codeword states are <span class="inline-math">\(\{|\overline{i}\rangle\mid i\in \mathbb Z_q \}\)</span>, where
  <span class="display-math env-align">\begin{align}
    |\overline{i}\rangle = \frac{1}{\sqrt{q^N}} \sum_{\substack{p=0\\p\equiv i \pmod{q}}}^{(q-1)(N+1)} \sqrt{\binom{N+1}{p}_q} \ket{p(S+1)}.
\end{align}</span>
  Here, <span class="inline-math">\(\binom{N+1}{p}_q\)</span> are extended binomial coefficients, or polynomial coeffiients, defined recursively as
  <span class="display-math env-align">\begin{align}
    \binom{n}{m}_1 \equiv 1,\quad \binom{n}{m}_q \equiv \sum_{k=0}^n \binom{n}{k}\binom{k}{m-k}_{q-1}.
\end{align}</span></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/bch">Bose–Chaudhuri–Hocquenghem (BCH) code</a><span class="code-introduced"><a href="#cite-12" class="cite">[13]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/oscillators">Bosonic code</a></span>
    <span class="code-description">Also called an <span class="textit">oscillator</span> or a <span class="textit">continuous-variable (CV)</span> code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one <span class="textit">oscillator</span> (a.k.a. <span class="textit">bosonic mode</span> or <span class="textit">qumode</span>). States of a single oscillator are elements of the Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(\mathbb{R}\)</span>). Ideal codewords may not be normalizable because the space is infinite-dimensional, so approximate versions have to be constructed.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/bosonic_rotation">Bosonic rotation code</a><span class="code-introduced"><a href="#cite-13" class="cite">[14]</a></span></span>
    <span class="code-description"><p>A single-mode Fock-state bosonic code whose codespace is preserved by a phase-space rotation by a multiple of <span class="inline-math">\(2\pi/N\)</span> for some <span class="inline-math">\(N\)</span>. The rotation symmetry ensures that encoded states have support only on every <span class="inline-math">\(N^{\textrm{th}}\)</span> Fock state. For example, single-mode Fock-state codes for <span class="inline-math">\(N=2\)</span> encoding a qubit admit basis states that are, respectively, supported on Fock state sets <span class="inline-math">\(\{|0\rangle,|4\rangle,|8\rangle,\cdots\}\)</span> and <span class="inline-math">\(\{|2\rangle,|6\rangle,|10\rangle,\cdots\}\)</span>.</p>
<p>Encoding of a <span class="inline-math">\(q\)</span>-dimensional logical qudit admit a basis whose elements are eigenstates of the rotation operator <span class="inline-math">\(\exp\left(\mathrm{i} 2\pi \hat{n}/qN \right)\)</span>, where <span class="inline-math">\(\hat{n}\)</span> is the number operator diagonal in the Fock basis. Basis elements are of the form <span class="inline-math">\(\sum_{j=0}^\infty c_j |(kq+j)N \rangle\)</span> for some coefficients <span class="inline-math">\(c_j\)</span> and <span class="inline-math">\(k\)</span>. This is because the rotation acting on a general Fock-state superposition <span class="inline-math">\(\sum_n a_n |n\rangle\)</span> yields <span class="inline-math">\(\sum_n a_n \exp\left(\mathrm{i} 2\pi n / qN \right) |n\rangle\)</span>. In order for a codeword to be an eigenvector of this operation, <span class="inline-math">\(a_n\)</span> must be zero whenever <span class="inline-math">\(n \neq (kq+j)N\)</span> for some <span class="inline-math">\(k\)</span>.</p>
<p>Codewords can be uniquely specified by choosing a <span class="emph">primitive</span> state <span class="inline-math">\(|\Theta\rangle\)</span>. To ensure valid (orthogonal and nonzero) codewords, <span class="inline-math">\(|\Theta\rangle\)</span> must satisfy the following requirement: for each <span class="inline-math">\(j \in \mathbb{Z}_q\)</span>, <span class="inline-math">\(|\Theta\rangle\)</span> must have support on the Fock state <span class="inline-math">\(|(k_j q+j)N\rangle\)</span> for at least one <span class="inline-math">\(k_j \in \mathbb{N}_0\)</span>. From such a primitive, the codewords <span class="inline-math">\(\{|\overline{j}\rangle \mid j \in \mathbb{Z}_q\}\)</span> are constructed as
<span class="display-math env-align">\begin{align}
|\overline{j}\rangle \propto \sum_{m=0}^{2N-1} \mathrm{e}^{2\pi \mathrm{i} m (\hat n  / N + j) / q} |\Theta\rangle~.
\end{align}</span></p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/oscillator_stabilizer">Bosonic stabilizer code</a></span>
    <span class="code-description"><p>Bosonic code whose codespace is defined as the common <span class="inline-math">\(+1\)</span> eigenspace of a group of mutually commuting <span class="textit">displacement operators</span> (exponentials of linear combinations of position and momentum operators). Such displacement-based codes closely resemble and inherit some features of qubit stabilizer codes.</p>
<p>Stabilizer codewords encoding a logical oscillator admit a continuous stabilizer group, and can thus be defined in terms of the group&#x27;s Lie algebra, i.e., as the common <span class="inline-math">\(0\)</span>-eigenvalue eigenspace of mutually commuting linear combinations of oscillator position and momentum operators called <span class="textit">annihilators</span>. An <span class="inline-math">\(((n,k,d))_{\mathbb{R}}\)</span> <a href="/c/oscillators_into_oscillators" class="ref">oscillator-into-oscillator</a> stabilizer code is denoted as <span class="inline-math">\([[n,k,d]]_{\mathbb{R}}\)</span>, where <span class="inline-math">\(d\)</span> is the code&#x27;s distance.</p>
<p>Stabilizer codewords encoding a finite-dimensional codespace admit a discrete infinite stabilizer group. Qubit-into-oscillator stabilizer codes are equivalent to <a href="/c/gkp" class="ref">GKP codes</a>.</p>
<p>A bosonic stabilizer code admitting a set of mutually commuting operators (either annihilators or displacements) such that each operator consists of either position or momentum operators is called a <span class="textit">bosonic CSS code</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/css">Calderbank-Shor-Steane (CSS) stabilizer code</a><span class="code-introduced"><a href="#cite-14" class="cite">[15]</a><a href="#cite-15" class="cite">[16]</a><a href="#cite-16" class="cite">[17]</a></span></span>
    <span class="code-description"><p>An <span class="inline-math">\([[n,k,d]]\)</span> stabilizer code admitting a set of stabilizer generators that are either <span class="inline-math">\(Z\)</span>-type or <span class="inline-math">\(X\)</span>-type Pauli strings. The parity check matrix is of the form
<span id="eq--parity" class="display-math env-align">\begin{align}
H=\begin{pmatrix}0 &amp; H_{Z}\\
H_{X} &amp; 0
\end{pmatrix}~.
\label{eq:parity}
\end{align}</span></p>
<p>Encoding is based on two related <a href="/c/binary_linear" class="ref">binary linear codes</a>, an <span class="inline-math">\([n,k_X,d_X]\)</span> code <span class="inline-math">\(C_X\)</span> and <span class="inline-math">\([n,k_Z,d_Z]\)</span> code <span class="inline-math">\(C_Z\)</span>, satisfying <span class="inline-math">\(C_X^\perp \subseteq C_Z\)</span>. The resulting CSS code has <span class="inline-math">\(k=k_X+k_Z-n\)</span> logical qubits and distance <span class="inline-math">\(d\geq\min\{d_X,d_Z\}\)</span>. The <span class="inline-math">\(H_X\)</span> (<span class="inline-math">\(H_Z\)</span>) block of <span class="inline-math">\(H\)</span> <span class="inline-math eqref">\eqref{eq:parity}</span> is the parity-check matrix of the code <span class="inline-math">\(C_X\)</span> (<span class="inline-math">\(C_Z\)</span>). The requirement <span class="inline-math">\(C_X^\perp \subseteq C_Z\)</span> guarantees that the <span class="inline-math">\(X\)</span>-stabilizers, defined in the symplectic representation as rows of <span class="inline-math">\(H_X\)</span>, commute with the <span class="inline-math">\(Z\)</span>-stabilizers of associated with <span class="inline-math">\(H_Z\)</span>.</p>
<p>A CSS code has <span class="textit">stabilizer weight</span> <span class="inline-math">\(w\)</span> if the highest weight of any stabilizer generator is <span class="inline-math">\(w\)</span>, i.e., any row and column of <span class="inline-math">\(H_X\)</span> and <span class="inline-math">\(H_Z\)</span> has weight at most <span class="inline-math">\(w\)</span>. In the context of comparing weight as well as of noise models biased toward <span class="inline-math">\(X\)</span>- or <span class="inline-math">\(Z\)</span>-type errors, an extended notation for CSS codes is <span class="inline-math">\([[n,k,(d_X,d_Z),w]]\)</span>. The quantity <span class="inline-math">\(\min\{d_X,d_Z\}\)</span> is often called the <span class="textit">worst-case minimum distance</span>.</p>
<p>There exists a many-to-one mapping from size three chain complexes to CSS codes <a href="#cite-2" class="cite">[3]</a><a href="#cite-17" class="cite">[18]</a><a href="#cite-18" class="cite">[19]</a><a href="#cite-19" class="cite">[20]</a> that allows one to extract code properties from topological features of the complexes. Codes constructed in this manner are sometimes called <span class="textit">homological CSS codes</span>, but they are equivalent to CSS codes. This mapping has allowed the application of results from topology to error correction, yielding QLDPC codes with favorable properties.</p>
<p>A <span class="textit">chain complex</span> of size three is given by binary vector spaces <span class="inline-math">\(A_2\)</span>, <span class="inline-math">\(A_1\)</span>, <span class="inline-math">\(A_0\)</span> and binary matrices <span class="inline-math">\(\partial_{i=1,2}\)</span> (called <span class="textit">boundary operators</span>) <span class="inline-math">\(A_i\)</span> to <span class="inline-math">\(A_{i-1}\)</span> that satisfy <span class="inline-math">\(\partial_1 \partial_2 = 0\)</span>. Such a complex is typically denoted as
<span id="eq--chain" class="display-math env-align">\begin{align}
A_2 \xrightarrow{\partial_2} A_1 \xrightarrow{\partial_1} A_0~.
\label{eq:chain}
\end{align}</span>
One constructs a CSS code by associating a physical qubit to every basis element of <span class="inline-math">\(A_1\)</span>, and defining parity-check matrices <span class="inline-math">\(H_X=\partial_1^T\)</span> and <span class="inline-math">\(H_Z=\partial_2\)</span>). That way, the spaces <span class="inline-math">\(A_0\)</span> and <span class="inline-math">\(A_2\)</span> can be associated with <span class="inline-math">\(X\)</span>-type and <span class="inline-math">\(Z\)</span>-type Pauli operators, respectively, and boundary operators determine the Paulis making up the stabilizer generators. The requirement <span class="inline-math">\(\partial_1 \partial_2 = 0\)</span> guarantees that the <span class="inline-math">\(X\)</span>-stabilizers associated with <span class="inline-math">\(H_X\)</span> commute with the <span class="inline-math">\(Z\)</span>-stabilizers associated with <span class="inline-math">\(H_Z\)</span>.</p>
<p>Usually, the chain complex <span class="inline-math eqref">\eqref{eq:chain}</span> used in the construction comes from the chain complex associated with a cellulation of a manifold. When the manifold is a two-dimensional surface, its entire chain is used. Higher-dimensional manifolds allow for longer chain complexes, and one can use the three largest non-trivial vector spaces in its chain.</p>
<p>The reverse mapping is as follows <a href="#cite-18" class="cite">[19]</a><a href="#cite-20" class="cite">[21]</a>. Given a CSS code with parity check matrices <span class="inline-math">\(H_X\)</span> and <span class="inline-math">\(H_Z\)</span>, let both boundary operators be <span class="inline-math">\(\partial = H_Z^TUH_X\)</span> for an arbitrary invertible matrix <span class="inline-math">\(U\)</span>. The fact that the stabilizer generators commute ensures that the boundary operator satisfies <span class="inline-math">\(\partial^2=0\)</span>, yielding a chain complex.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/cat">Cat code</a><span class="code-introduced"><a href="#cite-21" class="cite">[22]</a><a href="#cite-22" class="cite">[23]</a></span></span>
    <span class="code-description">Rotation-symmetric bosonic Fock-state code encoding a <span class="inline-math">\(q\)</span>-dimensional qudit into one oscillator. Codewords for a qubit code (<span class="inline-math">\(q=2\)</span>) consist of a coherent state <span class="inline-math">\(|\alpha\rangle\)</span> projected onto a subspace of Fock state number modulo <span class="inline-math">\(2(S+1)\)</span>. The logical state <span class="inline-math">\(|\overline{0}\rangle\)</span> is in the <span class="inline-math">\(\{|0\rangle , |2(S+1)\rangle , |4(S+1)\rangle \cdots \}\)</span> Fock-state subspace, while <span class="inline-math">\(|\overline{1}\rangle\)</span> is in the <span class="inline-math">\(\{|(S+1)\rangle, |3(S+1)\rangle , |5(S+1)\rangle , |7(S+1)\rangle \cdots \}\)</span> subspace. An alternative basis, valid for for general <span class="inline-math">\(q\)</span> and <span class="inline-math">\(\alpha\neq 0\)</span>, consists of <span class="inline-math">\(q\)</span> coherent states distributed equidistanctly around a circle in phase space of radius <span class="inline-math">\(\alpha\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/category_quantum">Category-based quantum code</a></span>
    <span class="code-description">Encodes a finite-dimensional <span class="textit">logical</span> Hilbert space into a <span class="textit">physical</span> Hilbert space associated with a category.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/chuang-leung-yamamoto">Chuang-Leung-Yamamoto code</a><span class="code-introduced"><a href="#cite-23" class="cite">[24]</a></span></span>
    <span class="code-description">Bosonic Fock-state code that encodes <span class="inline-math">\(k\)</span> qubits into <span class="inline-math">\(n\)</span> oscillators, with each oscillator restricted to having at most <span class="inline-math">\(N\)</span> excitations. Codewords are superpositions of oscillator Fock states, either balanced (i.e., uniform) or unbalanced. Codes can be denoted as <span class="inline-math">\([[N,n,2^k,d]]\)</span>, which conflicts with <a href="/c/stabilizer" class="ref">stabilizer code</a> notation.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/cws">Codeword stabilized (CWS) code</a><span class="code-introduced"><a href="#cite-24" class="cite">[25]</a></span></span>
    <span class="code-description"><p>This family of codes strictly generalizes stabilizer codes. They are usually denoted by <span class="inline-math">\( \mathcal{Q} = (\mathcal{G},\mathcal{C}) \)</span> where <span class="inline-math">\(\mathcal{G}\)</span> is a graph and <span class="inline-math">\(\mathcal{C}\)</span> is a <span class="inline-math">\( (n,K,d) \)</span> binary classical code. From the graph we form the unique graph state (stabilizer state) <span class="inline-math">\( |G \rangle \)</span>. From the classical code we form Pauli <span class="inline-math">\(Z\)</span>-type operators <span class="inline-math">\( W_i = Z^{c_{i,1}} \otimes \cdots \otimes Z^{c_{i,n}} \)</span>, where <span class="inline-math">\(c_{i,j} \)</span> is the <span class="inline-math">\(j\)</span>-th bit of the <span class="inline-math">\(i\)</span>-th classical codeword. The CWS codewords are then <span class="inline-math">\( | i \rangle =  W_i | G \rangle \)</span>.</p>
<p>There is an alternative description to the one above that is locally Clifford-equivalent. In particular, we can describe CWS codes as <span class="inline-math">\( \mathcal{Q} = (S,\mathcal{W})\)</span> where <span class="inline-math">\(S\)</span> is a stabilizer group and <span class="inline-math">\( \mathcal{W} = \{ w_\ell \}_{\ell = 1}^K \)</span> is a family of <span class="inline-math">\(K\)</span> <span class="inline-math">\(n\)</span>-qubit Pauli strings. We then form CWS codeswords as <span class="inline-math">\( | i \rangle = w_i | S \rangle \)</span>, where <span class="inline-math">\( | S \rangle \)</span> is the (unique) stabilizer state of <span class="inline-math">\(S\)</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/color">Color code</a><span class="code-introduced"><a href="#cite-25" class="cite">[26]</a></span></span>
    <span class="code-description">Color code is a topological stabilizer code defined on a <span class="inline-math">\(D\)</span>-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial <span class="inline-math">\(D\)</span>-complex obtained as a triangulation of the interior of a <span class="inline-math">\(D\)</span>-simplex and (2) is <span class="inline-math">\(D+1\)</span>-colorable. Qubits are placed on the <span class="inline-math">\(D\)</span>-simplices and generators are supported on suitable simplices <a href="#cite-26" class="cite">[27]</a>. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face <a href="#cite-27" class="cite">[28]</a>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_concatenated">Concatened code</a></span>
    <span class="code-description">A concatened code is a combination of two codes, an inner code <span class="inline-math">\(C\)</span> and an outer code <span class="inline-math">\(C^\prime\)</span>, where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code <span class="inline-math">\(C^\prime\)</span>, and then one encodes each of the physical registers of <span class="inline-math">\(C^\prime\)</span> in an inner code <span class="inline-math">\(C\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/convolutional">Convolutional code</a><span class="code-introduced"><a href="#cite-28" class="cite">[29]</a></span></span>
    <span class="code-description">Classical codes that are formed using generator polynomials over the finite field with two elements. The encoder slides across contiguous subsets of the input bit-string (like a convolutional neural network) evaluating the polynomials on that window to obtain a number of parity bits. These parity bits are the encoded information. There are many ways to formulate these codes</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/cyclic">Cyclic code</a></span>
    <span class="code-description">A classical code <span class="inline-math">\(C\)</span> of length <span class="inline-math">\(n\)</span> over an alphabet is cyclic if, for each string <span class="inline-math">\(c_1 c_2 \cdots c_n\in C\)</span>, the cyclically shifted string <span class="inline-math">\(c_n c_1 \cdots c_{n-1}\in C\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/distance_balanced">Distance-balanced code</a><span class="code-introduced"><a href="#cite-29" class="cite">[30]</a><a href="#cite-30" class="cite">[31]</a></span></span>
    <span class="code-description">CSS stabilizer code constructed from another CSS code using a distance-balancing procedure The initial code is said to be <span class="textit">unbalanced</span>, i.e., tailored to noise biased toward either bit- or phase-flip errors.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/double_semion">Double-semion code</a><span class="code-introduced"><a href="#cite-31" class="cite">[32]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/dual">Dual linear code</a><span class="code-introduced"><a href="#cite-9" class="cite">[10]</a></span></span>
    <span class="code-description"><p>For any <span class="inline-math">\(q\)</span>-ary linear code <span class="inline-math">\(C\)</span>, the dual code
<span class="display-math env-align">\begin{align}
C^\perp = \{ y\in\mathbb{Z}_q^{\times n} ~|~ x\cdot y=0 \forall x\in C\}~.
\end{align}</span></p>
<p>A code that contains its dual, <span class="inline-math">\(C^\perp \subseteq C\)</span>, is called <span class="textit">weakly self-dual</span> or <span class="textit">self-orthogonal</span>. A code that is equal to its dual, <span class="inline-math">\(C^\perp = C\)</span>, is called <span class="textit">self-dual</span>. The dual of a dual code is the original code.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/dual_rail">Dual-rail code</a><span class="code-introduced"><a href="#cite-32" class="cite">[33]</a></span></span>
    <span class="code-description">Two-mode code encoding a logical qubit in Fock states with one excitation. The logical-zero state is represented by <span class="inline-math">\(|01\rangle\)</span>, while the logical-one state is represented by <span class="inline-math">\(|10\rangle\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/dynamic_gen">Dynamically-generated quantum error-correcting code</a><span class="code-introduced"><a href="#cite-33" class="cite">[34]</a></span></span>
    <span class="code-description">Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/eth">Eigenstate thermalization hypothesis (ETH) code</a><span class="code-introduced"><a href="#cite-34" class="cite">[35]</a></span></span>
    <span class="code-description"><p>Also called a <span class="textit">thermodynamic code</span> <a href="#cite-35" class="cite">[36]</a>. An <span class="inline-math">\(n\)</span>-qubit approximate code whose codespace is formed by eigenstates of a translationally-invariant quantum many-body system which satisfies the Eigenstate Thermalization Hypothesis (ETH). ETH ensures that codewords cannot be locally distinguished in the thermodynamic limit. Relevant many-body systems include 1D non-interacting spin chains, Motzkin chains, or Heisenberg models.</p>
<p>ETH requires that for ordered energy eigenstates <span class="inline-math">\(|E_l\rangle\)</span> and any local observable <span class="inline-math">\(O\)</span>,
<span class="display-math env-align">\begin{align}
|\langle E_l|O|E_l\rangle-\langle E_{l+1}|O|E_{l+1}\rangle|\leq\exp(-cn)
\end{align}</span>
for a constant <span class="inline-math">\(c\)</span>. This implies that energy eigenstates around some energy <span class="inline-math">\(\bar E\)</span> are approximately locally indistinguishable from one another, as their reduced density matrices on any subsystem are both approximately thermal at energy <span class="inline-math">\(\bar E\)</span>. In this way, global information is protected from local measurements by the environment as <span class="inline-math">\(n\to\infty\)</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/ecc">Error-correcting code</a></span>
    <span class="code-description">Encodes <span class="inline-math">\(K\)</span> states (codewords) over an alphabet with <span class="inline-math">\(N\)</span> elements such that it is possible to recover the codewords from errors <span class="inline-math">\(E\)</span> from some error set <span class="inline-math">\(\mathcal{E}\)</span>. Formally, an error-correcting code <span class="inline-math">\((u,\mathcal{E})\)</span> is an <span class="textit">encoder</span> function <span class="inline-math">\(u:[1\cdots K]\to[1\cdots N]\)</span> with a set of correctable errors <span class="inline-math">\(E:[1\cdots N]\to [1\cdots M]\)</span> with the following property: there exists a <span class="textit">decoder</span> function <span class="inline-math">\(d:[1\cdots M]\to [1\cdots K]\)</span> such that for all <span class="inline-math">\(E\in\cal{E}\)</span> and states <span class="inline-math">\(x\in[1\cdots K]\)</span>, <span class="inline-math">\(d(E(e(x)))=x\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/expander">Expander code</a><span class="code-introduced"><a href="#cite-36" class="cite">[37]</a></span></span>
    <span class="code-description"><p>Expander codes are binary linear codes whose parity check matrices are derived from the adjacency matrix of bipartite expander graphs. In particular, the rows of the parity check matrix correspond to the right nodes of the bipartite graph and the columns correspond to the left nodes. The codespace is equivalent to all subsets of the left nodes in the graph that have an even number of edges going into every right node of the graph. Since the expander graph is only left regular, these codes do not qualify as LDPC codes.</p>
<p>Expander codes are important because they admit efficient encoding and decoding algorithms and have the desirable property that their rate and relative distance are constant. The rate and distance of the expander code depend on specific parameters of the corresponding graph. A (<span class="inline-math">\(n, m, D, \gamma, \alpha\)</span>) bipartite expander graph is defined as a <span class="inline-math">\(D\)</span>-left-regular graph with <span class="inline-math">\(n\)</span> left nodes, and <span class="inline-math">\(m\)</span> right nodes such that for any subset of left nodes <span class="inline-math">\(S\)</span> of size at most <span class="inline-math">\(\gamma n\)</span> the neighborhood <span class="inline-math">\(N(S)\)</span> is at least of size <span class="inline-math">\(\alpha|S|\)</span>. Given a (<span class="inline-math">\(n, m, D, \gamma, (1-\epsilon)D\)</span>) expander graph, the corresponding expander code has rate of <span class="inline-math">\(1 - m/n\)</span> and a distance of at least <span class="inline-math">\(2(1-\epsilon)\gamma n\)</span> for any <span class="inline-math">\(\epsilon &lt; 1/2\)</span>. Explicit constructions for expander graphs with any ratio <span class="inline-math">\(n/m\)</span> are known where <span class="inline-math">\(D = \text{polylog}(n/m)\)</span>, <span class="inline-math">\(\gamma = \Omega(1/D)\)</span> and arbitrary <span class="inline-math">\(\epsilon\)</span> <a href="#cite-37" class="cite">[38]</a>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/fermions">Fermionic code</a></span>
    <span class="code-description">Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators <a href="#cite-38" class="cite">[39]</a>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/qecc_finite">Finite-dimensional quantum code</a></span>
    <span class="code-description">A quantum error-correcting code that encodes quantum information in a <span class="inline-math">\(K\)</span>-dimensional (<span class="textit">logical</span>) subspace <span class="inline-math">\(\mathsf{H}_K\)</span> of an <span class="inline-math">\(N\)</span>-dimensional (<span class="textit">physical</span>) Hilbert space <span class="inline-math">\(\mathsf{H}_N\)</span> such that it is possible to recover said information from errors.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/floquet">Floquet code</a><span class="code-introduced"><a href="#cite-39" class="cite">[40]</a></span></span>
    <span class="code-description">Dynamically-generated stabilizer-based code whose logical qubits are generated through a particular sequence of measurements such that the number of logical qubits is larger than when the code is viewed as a static subsystem stabilizer code. The code space is the <span class="inline-math">\(+1\)</span> eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured. As opposed to subsystem codes, only specific measurement sequences maintain the codespace.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/fock_state">Fock-state bosonic code</a></span>
    <span class="code-description">Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. The simplest example is the dual-rail code, which has codewords consisting of single Fock states <span class="inline-math">\(|10\rangle\)</span> and <span class="inline-math">\(|01\rangle\)</span>. This code can detect a single loss error since a loss operator in either mode maps one of the codewords to a different Fock state <span class="inline-math">\(|00\rangle\)</span>. More involved codewords consist of several well-separated Fock states such that multiple loss events can be detected and corrected.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/fracton">Fracton code</a></span>
    <span class="code-description">A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/freedman_meyer_luo">Freedman-Meyer-Luo code</a><span class="code-introduced"><a href="#cite-40" class="cite">[41]</a></span></span>
    <span class="code-description">Hyperbolic surface code constructed using cellulation of a Riemann Manifold <span class="inline-math">\(M\)</span> exhibitng systolic freedom <a href="#cite-41" class="cite">[42]</a>. Codes derived from such manifolds can achieve distances scaling better than <span class="inline-math">\(\sqrt{n}\)</span>, something that is impossible using closed 2D surfaces or 2D surfaces with boundaries <a href="#cite-42" class="cite">[43]</a>. Improved codes are obtained by studying a weak family of Riemann metrics on closed 4-dimensional manifolds <span class="inline-math">\(S^2\otimes S^2\)</span> with the <span class="inline-math">\(Z_2-homology\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/frobenius">Frobenius code</a><span class="code-introduced"><a href="#cite-43" class="cite">[44]</a></span></span>
    <span class="code-description">Let <span class="inline-math">\(C\)</span> be a quantum cyclic code on <span class="inline-math">\(n\)</span> prime-dimensional qudits. <span class="inline-math">\(C\)</span> is a Frobenius code if there exists a positive integer <span class="inline-math">\(t\)</span> such that <span class="inline-math">\(n\)</span> divides <span class="inline-math">\(p^t +1\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/fusion">Fusion-based quantum computing (FBQC) code</a><span class="code-introduced"><a href="#cite-44" class="cite">[45]</a></span></span>
    <span class="code-description">Fusion Based Quantum Computing, or FBQC, describes a fault tolerant way to produce <span class="textit">fusion networks</span>, or large entangled states starting from small constant-sized entangled resource states along with destructive measurements called <span class="textit">fusions</span>. These large states can be produced asychronously in the fusion framework and can be used as resources, as in measurement-based quantum computation (MBQC), or as logical states of topological codes. The difference from ordinary MBQC is that error-correction is baked into the state-generation protocol.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/gnu_permutation_invariant">GNU permutation-invariant code</a><span class="code-introduced"><a href="#cite-45" class="cite">[46]</a></span></span>
    <span class="code-description"><p>Can be expressed in terms of Dicke states where the logical states are
<span class="display-math env-align">\begin{align}
|\overline{\pm}\rangle = \sum_{\ell=0}^{n} \frac{(\pm 1)^\ell}{\sqrt{2^n}} \sqrt{n \choose \ell} |D^m_{g \ell}\rangle~.
\end{align}</span>
Here, <span class="inline-math">\(m\)</span> is the number of particles used for encoding <span class="inline-math">\(1\)</span> qubit, and <span class="inline-math">\(g, n \leq m\)</span> are arbitrary positive integers. The state <span class="inline-math">\(|D^m_w\rangle\)</span> is a Dicke state -- a normalized permutation-invariant state on <span class="inline-math">\(m\)</span> qubits with <span class="inline-math">\(w\)</span> excitations, i.e., a normalized sum over all basis elements with <span class="inline-math">\(w\)</span> ones and <span class="inline-math">\(m - w\)</span> zeroes.</p>
<p>A qudit extension of such codes, based on a correspondence with binomial codes, exists <a href="#cite-11" class="cite">[12]</a>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/galois_css">Galois-qudit CSS code</a></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/galois_into_galois">Galois-qudit code</a><span class="code-introduced"><a href="#cite-46" class="cite">[47]</a></span></span>
    <span class="code-description">Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into a <span class="inline-math">\(q^n\)</span>-dimensional (<span class="inline-math">\(n\)</span>-qudit) Hilbert space, with canonical qudit states <span class="inline-math">\(|k\rangle\)</span> labeled by elements <span class="inline-math">\(k\)</span> of the <span class="textit">Galois field</span> <span class="inline-math">\(GF(q)\)</span> and with <span class="inline-math">\(q\)</span> being a power of a prime <span class="inline-math">\(p\)</span>. A Galois field can be thought of as a vector space whose basis vectors are the <span class="inline-math">\(m\)</span> roots of some polynomial and whose coefficients (i.e., field) are <span class="inline-math">\(p\)</span>th roots of unity. Codes can be denoted as <span class="inline-math">\(((n,K))_{GF(q)}\)</span> or <span class="inline-math">\(((n,K,d))_{GF(q)}\)</span>, whenever the code&#x27;s distance <span class="inline-math">\(d\)</span> is defined.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/galois_polynomial">Galois-qudit polynomial code (QPyC)</a><span class="code-introduced"><a href="#cite-47" class="cite">[48]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/galois_stabilizer">Galois-qudit stabilizer code</a><span class="code-introduced"><a href="#cite-48" class="cite">[49]</a></span></span>
    <span class="code-description">An <span class="inline-math">\(((n,p^k,d))_{GF(q)}\)</span> stabilizer code is denoted as <span class="inline-math">\([[n,k]]_{GF(q)}\)</span> or <span class="inline-math">\([[n,k,d]]_{GF(q)}\)</span>, where <span class="inline-math">\(d\)</span> is the code&#x27;s distance. Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/galois_true_stabilizer">Galois-qudit true stabilizer code</a></span>
    <span class="code-description"><p>Also called a linear stabilizer code. A <span class="inline-math">\([[n,k,d]]_{GF(q)}\)</span> stabilizer code whose stabilizer&#x27;s symplectic representation forms a linear subspace. In other words, the set of <span class="inline-math">\(q\)</span>-ary vectors representing the stabilizer group is closed under both addition and multiplication by elements of <span class="inline-math">\(GF(q)\)</span>. In contrast, Galois-qudit stabilizer codes admit sets of vectors that are closed under addition only.</p>
<p>The number of generators <span class="inline-math">\(r\)</span> is a multiple of <span class="inline-math">\(m\)</span> (recall that <span class="inline-math">\(q=p^m\)</span> for Galois qudits). As a result, the number <span class="inline-math">\(k=n-r/m\)</span> of logical qudits is an integer.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/generalized_concatenated">Generalized concatenated classical code</a></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/goppa">Goppa Code</a><span class="code-introduced"><a href="#cite-49" class="cite">[50]</a><a href="#cite-50" class="cite">[51]</a><a href="#cite-51" class="cite">[52]</a></span></span>
    <span class="code-description">Let <span class="inline-math">\( G(z) \)</span>  be a polynomial describing a projective plane curve with coefficients from <span class="inline-math">\( GF(q^m) \)</span> for some fixed integer <span class="inline-math">\(m\)</span>. Let <span class="inline-math">\( L \)</span> be a finite subset of the extension field <span class="inline-math">\( GF(q^m) \)</span>  where <span class="inline-math">\(q\)</span> is prime, meaning <span class="inline-math">\( L  = \{\alpha_1, \cdots, \alpha_n\} \)</span> is a subset of nonzero elements of <span class="inline-math">\( GF(q^m) \)</span>. A Goppa code <span class="inline-math">\( \Gamma(L,G) \)</span> is an <span class="inline-math">\([n,k,d]\)</span> linear code consisting of all vectors <span class="inline-math">\(a = a_1, \cdots, a_n\)</span> such that <span class="inline-math">\( R_a(z) =0 \)</span> modulo <span class="inline-math">\(G(z)\)</span>, where <span class="inline-math">\( R_a(z) = \sum_{i=1}^n \frac{a_i}{z - \alpha_i} \)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/gkp">Gottesman-Kitaev-Preskill (GKP) code</a><span class="code-introduced"><a href="#cite-52" class="cite">[53]</a></span></span>
    <span class="code-description">Bosonic qudit-into-oscillator code whose stabilizers are oscillator displacement operators <span class="inline-math">\(\hat{S}_q(2\alpha)=e^{-2i\alpha \hat{p}}\)</span> and <span class="inline-math">\(\hat{S}_p(2\beta)=e^{2i\beta \hat{q}}\)</span>. To ensure <span class="inline-math">\(\hat{S}_q(2\alpha)\)</span> and <span class="inline-math">\(\hat{S}_p(2\beta)\)</span> generate a stabilizer group that is Abelian, there is another constraint that <span class="inline-math">\(\alpha\beta=2k\pi\)</span> where <span class="inline-math">\(k\)</span> is an integer. Codewords can be expressed as equal weight superpositions of coherent states on an infinite lattice, such as a square lattice in phase space with spatial period <span class="inline-math">\(2\sqrt{\pi}\)</span>. The exact GKP state is non-normalizable, so approximate constructs have to be considered.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/homological_classical">Graph homology code</a><span class="code-introduced"><a href="#cite-17" class="cite">[18]</a></span></span>
    <span class="code-description">This code&#x27;s properties are derived from the size two chain complex associated with a particular graph. Given a connected simplicial (no self loops or muliedges) graph <span class="inline-math">\(G = (V, E)\)</span>, which is not a tree, with incidence matrix <span class="inline-math">\(\Gamma\)</span> we can construct a code by choosing a parity check matrix which consists of all the linearly independent rows of <span class="inline-math">\(\Gamma\)</span>. This is a <span class="inline-math">\([n,k,d]\)</span> code with <span class="inline-math">\(n = |E|\)</span>, <span class="inline-math">\(k = 1 - \mathcal{X}(G) = 1-|V|+|E|\)</span>, where <span class="inline-math">\( \mathcal{X}(G)\)</span> is the euler characteristic of the graph. The code distance is equal to the shortest size of a cycle, guaranteed to exist since <span class="inline-math">\(G\)</span> is not a tree.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/group_gkp">Group GKP code</a><span class="code-introduced"><a href="#cite-53" class="cite">[54]</a></span></span>
    <span class="code-description">Group code whose construction is based on nested subgroups <span class="inline-math">\(H\subset K \subset G\)</span>. Logical subspace is spanned by basis states that are equal superpositions of elements of cosets of <span class="inline-math">\(H\)</span> in <span class="inline-math">\(K\)</span>, and can be finite- or infinite-dimensional. Extension of the <a href="/c/gkp" class="ref">GKP code</a> construction.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/group">Group code</a></span>
    <span class="code-description"><p>An <span class="inline-math">\( [n,k]_{q} \)</span> code based on a finite group <span class="inline-math">\( G \)</span> of size <span class="inline-math">\(n \)</span>. A group code for an abelian group is called an <span class="textit">abelian group code</span>.</p>
<p>The code is a <span class="inline-math">\( k \)</span>-dimensional linear subspace of the group algebra of <span class="inline-math">\( G\)</span> with coefficients in the field <span class="inline-math">\(GF(q) = \mathbb{F}_q\)</span> with <span class="inline-math">\(q\)</span> elements. To be precise, the code must be closed under permutations corresponding to the elements of the group <span class="inline-math">\( G \)</span>; therefore, <span class="inline-math">\( G \)</span> must be a subgroup of the permutation automorphism group of the code, which is defined as the group of permutations of the physical bits that preserve the code space. This leads us to the formal definition of a group code: a group code is an ideal in the group algebra <span class="inline-math">\( \mathbb{F}_q G \)</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/group_quantum">Group-based quantum code</a></span>
    <span class="code-description">Encodes a <span class="textit">logical</span> Hilbert space, finite- or infinite-dimensional, into a <span class="textit">physical</span> Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on a second-countable unimodular group. For <span class="inline-math">\(K\)</span>-dimensional logical subspace and for groups <span class="inline-math">\(G^{\times n}\)</span>, can be denoted as <span class="inline-math">\(((n,K))_G\)</span>. When the logical subspace is the Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(G^{\times k}\)</span>, can be denoted as <span class="inline-math">\([[n,k]]_G\)</span>. Ideal codewords may not be normalizable, depending on whether <span class="inline-math">\(G\)</span> is continuous and/or noncompact, so approximate versions have to be constructed.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/four_dimensional_hyperbolic">Guth-Lubotzky code</a><span class="code-introduced"><a href="#cite-54" class="cite">[55]</a></span></span>
    <span class="code-description"><p>Hyperbolic surface code based on cellulations of certain four-dimensional manifolds. The manifolds are shown to have good homology and systolic properties for the purposes of code construction, with corresponding codes exhibiting linear rate.</p>
<p>Guth and Lubotzky <a href="#cite-54" class="cite">[55]</a> show that there exists <span class="inline-math">\(\epsilon\)</span>, a four-dimensional hyperbolic manifold <span class="inline-math">\(M\)</span>, and a sequence of manifolds <span class="inline-math">\(M_i\)</span> such that
each <span class="inline-math">\(M_i\)</span> is a finite sheeted <a href="https://en.wikipedia.org/wiki/Covering_space" target="_blank" class="href">covering</a> of <span class="inline-math">\(M\)</span>, and the four-dimensional volumes of the manifolds <span class="inline-math">\(\text{Vol}_4(M_i)\)</span> of the sequence tend to infinity.
Also, the dimension of the second homology and size of systoles are bounded by <span class="inline-math">\(H_2(M_i, Z_2) \geq \frac{\text{Vol}_4(M_i)}{100}\)</span> and <span class="inline-math">\(\text{Sys}_2(M_i) \geq \text{Vol}_4(M_i)^\epsilon\)</span>, respectively.</p>
<p>Then given any cellulation of <span class="inline-math">\(M\)</span>, it can naturally be extended to cellulations for each of the manifolds <span class="inline-math">\(M_i\)</span> and used to define CSS codes via the homological construction by choosing the size three chain complex consisting of the <span class="inline-math">\(3,2\)</span> and <span class="inline-math">\(1\)</span>-cells of the cellulations.</p>
<p>For dense cellulations (i.e. large <span class="inline-math">\(n\)</span>) the number of physical qubits for these codes will scale with the volume of the manifolds.
Therefore, bounds on the dimension of the second homology and size of systoles are achieved in terms of <span class="inline-math">\(n\)</span> for large <span class="inline-math">\(n\)</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/haah_cubic">Haah cubic code</a><span class="code-introduced"><a href="#cite-55" class="cite">[56]</a></span></span>
    <span class="code-description">Class of stabilizer codes on a length-<span class="inline-math">\(L\)</span> cubic lattice with one or two qubits per site. We also require that the stabilizer group <span class="inline-math">\(\mathsf{S}\)</span> is translation invariant and generated by two types of operators with support on a cube. In the non-CSS case, these two are related by spatial inversion. For CSS codes, we require that the product of all corner operators is the identity. We lastly require that there are no non-trival &#x27;string operators&#x27;, meaning that single-site operators are a phase, and any period one logical operator <span class="inline-math">\(l \in \mathsf{S}^{\perp}\)</span> is just a phase. Haah showed in his original construction that there is exactly one non-CSS code of this form, and 17 CSS codes <a href="#cite-55" class="cite">[56]</a>. The non-CSS code is labeled code 0, and the rest are numbered from 1 - 17. Codes 1-4 do not have string logical operators, while codes 11-17 do.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/haar_random">Haar-random code</a><span class="code-introduced"><a href="#cite-56" class="cite">[57]</a><a href="#cite-57" class="cite">[58]</a><a href="#cite-58" class="cite">[59]</a><a href="#cite-59" class="cite">[60]</a></span></span>
    <span class="code-description"><p>Haar-random codewords are generated in a process involving averaging over unitary operations distributed accoding to the Haar measure. Random codes are used to prove statements about the capacity of a quantum channel to transmit quantum information <a href="#cite-60" class="cite">[61]</a>, but encoding and decoding in random <span class="inline-math">\(n\)</span>-qubit codes quickly becomes impractical as <span class="inline-math">\(n\to\infty\)</span>.</p>
<p>There are different approaches to create random codewords. In the construction of Ref. <a href="#cite-57" class="cite">[58]</a>, random codewords are produced by performing a unitarily covariant projective measurement on a <span class="textit">typical</span> subspace of a tensor-power state. Reference <a href="#cite-57" class="cite">[58]</a> showed that the capacity of a noisy quantum channel can be achieved by encoding in such Haar-random codes. In particular, random codes achieve perfect transmission in the <span class="inline-math">\(n\to\infty\)</span>) limit by proving that the encoded information becomes decoupled from the environment. This is a necessary and sufficient condition for successful decoding since measurements of the environment should never reveal the encoded information <a href="#cite-61" class="cite">[62]</a>.</p>
<p>Intuitively, coupling with the environment can be decreased by projecting the system onto a random codespace. The more qubits that are randomly discarded, the more the codespace is decoupled from the environment. One may ask what is the least amount of qubits that can be discarded, i.e. the largest remaining codespace, that still achieves decoupling. It can be shown through the decoupling inequality <a href="#cite-62" class="cite">[63]</a> that the largest possible dimension of the random codespace that achieves arbitrarily large decoupling is exponential in the coherent information of the channel. Therefore, there exist codes that can transmit information with rate equal to the coherent information. Furthermore, these codes can be constructed with high probability by performing a Haar-random isometry embedding a <span class="inline-math">\(k\)</span>-dimensional logical subspace into an <span class="inline-math">\(n\)</span>-dimensional physical space, where <span class="inline-math">\(k/n\)</span> is equal to the coherent information. Such an isometry can be produced by QR decomposition of a Gaussian random matrix <a href="#cite-63" class="cite">[64]</a>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/hadamard">Hadamard code</a></span>
    <span class="code-description">The Hadamard code is dual to the extended Hamming Code.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/hamiltonian">Hamiltonian-based code</a></span>
    <span class="code-description">Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy. When the physical space is a tensor product of subsystems, the Hamiltonian is typically <span class="textit">local</span>, consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., <a href="/c/quantum_ldpc" class="ref">quantum LDPC codes</a>). When the physical space is endowed with a geometry, the Hamiltonian is typically <span class="textit">geometrically local</span>, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., <a href="/c/topological" class="ref">topological codes</a>).</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/hamming">Hamming code</a><span class="code-introduced"><a href="#cite-64" class="cite">[65]</a></span></span>
    <span class="code-description">Hamming codes are a family of linear codes with parameters <span class="inline-math">\((2^r-1,2^r-r-1, 3)\)</span> for any <span class="inline-math">\(r\)</span>. The <span class="inline-math">\(r \times (2^r-1) \)</span> parity check matrix, <span class="inline-math">\(H\)</span>, has all possible non-zero r-bit strings as its columns. The codewords are <span class="inline-math">\({x|Hx=0}\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/fiber_bundle">Hastings-Haah-O&#x27;Donnell fiber-bundle code</a><span class="code-introduced"><a href="#cite-65" class="cite">[66]</a></span></span>
    <span class="code-description">Code constructed by combining a random LDPC code as the base and a cyclic repetition code as the fiber of a fiber bundle. After applying distance balancing, a QLDPC code with distance <span class="inline-math">\(\Omega(n^{3/5}\text{polylog}(n))\)</span> and rate <span class="inline-math">\(\Omega(n^{-2/5}\text{polylog}(n))\)</span> is obtained.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/holographic">Holographic code</a><span class="code-introduced"><a href="#cite-66" class="cite">[67]</a></span></span>
    <span class="code-description"><p>A code whose encoding isometry serves to model aspects of the AdS/CFT holographic duality. Encodes operators in the bulk of the Anti de Sitter (AdS) space, represented by logical qudits, into operators on the boundary of the corresponding Conformal Field Theory (CFT), represented by physical qudits. Encoding can often be represented by a tensor network associated with a tiling of hyperbolic space. See Defn 4.3 of Ref. <a href="#cite-67" class="cite">[68]</a> for a technical formulation.</p>
<p>Typically, the encoding isometry <span class="inline-math">\(U\)</span> obeys the <span class="textit">entanglement-wedge reconstruction condition</span>, which states that for any boundary region <span class="inline-math">\(R\)</span>, any bulk operator <span class="inline-math">\(O\)</span> localized to the entanglement wedge of <span class="inline-math">\(R\)</span> must be implementable by some boundary operator <span class="inline-math">\(\tilde{O}\)</span> localized to <span class="inline-math">\(R\)</span>. Formally, <span class="inline-math">\(UO = \tilde{O}U\)</span> and <span class="inline-math">\([\tilde{O},UU^\dagger] = 0\)</span>. The entanglement wedge is the space enclosed within the Ryu–Takayanagi surface in the bulk (minimal surface) with boundary <span class="inline-math">\(R\)</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/homological_cv">Homological continuous-variable (CV) Code</a><span class="code-introduced"><a href="#cite-68" class="cite">[69]</a></span></span>
    <span class="code-description"><p>An <span class="inline-math">\([[n,1]]_{\mathbb{R}}\)</span> <a href="/c/oscillator_stabilizer" class="ref">oscillator-into-oscillator CSS code</a> defined using homological structres associated with an <span class="inline-math">\(n-1\)</span> simplex.</p>
<p>Stabilizer generators are defined by two orthogonal subspaces of the <span class="inline-math">\(C_1\)</span> in the chain complex. <span class="inline-math">\(C_X = \partial_2 C_2\)</span> and <span class="inline-math">\(C_P = \partial_1^T Q\)</span> for some <span class="inline-math">\(Q \subset C_0\)</span>. The standard approach would use <span class="inline-math">\(Q = C_0\)</span>, which would mean the logical dimension would be the dimension of the 1st homology group <span class="inline-math">\(H^1\)</span>. However, <span class="inline-math">\(H^1\)</span> is trivial for the <span class="inline-math">\(n-1\)</span> simplex, so one chooses <span class="inline-math">\(Q \neq C_0\)</span> such that exactly one stabilizer is removed, yielding a stabilizer code instead of a single stabilized state.&#x27;</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/homological_product">Homological product code</a><span class="code-introduced"><a href="#cite-18" class="cite">[19]</a></span></span>
    <span class="code-description">CSS code formulated using the <a href="/c/css" class="ref">CSS chain-complex</a> construction using chain complexes consisting of products of two other chain complexes.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/honeycomb">Honeycomb code</a><span class="code-introduced"><a href="#cite-39" class="cite">[40]</a></span></span>
    <span class="code-description"><p>Floquet code inspired by the Kitaev honeycomb model <a href="#cite-69" class="cite">[70]</a> whose logical qubits are generated through a particular sequence of measurements.</p>
<p>The code is defined on a hexagonal (honeycomb) lattice with a physical qubit located at each vertex. Edges are labeled <span class="inline-math">\(x\)</span>, <span class="inline-math">\(y\)</span>, and <span class="inline-math">\(z\)</span>, such that one edge of each label meet at every vertex. Check operators are defined as <span class="inline-math">\(XX\)</span> acting on any two qubits joined by an <span class="inline-math">\(x\)</span> edge, and similarly for <span class="inline-math">\(y\)</span> and <span class="inline-math">\(z\)</span>. The hexagonal lattice is 3-colorable, so the hexagons may be labeled 0, 1, 2 such that no two neighboring hexagons have the same label.</p>
<p>The code-generating measurement pattern consists of measuring the check operators located on all of the <span class="inline-math">\(r\)</span>-labeled edges in round <span class="inline-math">\(r\)</span> mod 3. The code space is the <span class="inline-math">\(+1\)</span> eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/hybrid_qudit_oscillator">Hybrid qudit-oscillator code</a></span>
    <span class="code-description">Encodes a <span class="inline-math">\(K\)</span>-dimensional logical Hilbert space into <span class="inline-math">\(n_1\)</span> qudits of dimension <span class="inline-math">\(q\)</span> and <span class="inline-math">\(n_2 \neq 0\)</span> oscillators, i.e., the Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(\mathbb{Z}_q^{n_1} \times \mathbb{R}^{n_2}\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/hyperbolic_surface">Hyperbolic surface code</a></span>
    <span class="code-description">An extension of the Kitaev surface code construction to hyperbolic manifolds in dimension two or greater. Given a cellulation of a manifold, qubits are put on <span class="inline-math">\(i\)</span>-dimensional faces, <span class="inline-math">\(X\)</span>-type stabilizers are associated with <span class="inline-math">\((i-1)\)</span>-faces, while <span class="inline-math">\(Z\)</span>-type stabilizers are associated with <span class="inline-math">\(i+1\)</span>-faces.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/hypergraph_product">Hypergraph product code</a><span class="code-introduced"><a href="#cite-70" class="cite">[71]</a><a href="#cite-71" class="cite">[72]</a></span></span>
    <span class="code-description">A family of <span class="inline-math">\([[n,k,d]]\)</span> CSS codes whose construction is based on two binary linear <span class="textit">seed</span> codes <span class="inline-math">\(C_1\)</span> and <span class="inline-math">\(C_2\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/surface">Kitaev surface code</a><span class="code-introduced"><a href="#cite-2" class="cite">[3]</a><a href="#cite-72" class="cite">[73]</a><a href="#cite-73" class="cite">[74]</a></span></span>
    <span class="code-description"><p>A family of <a href="/c/css" class="ref">CSS stabilizer</a> codes whose generators are few-body <span class="inline-math">\(X\)</span>-type and <span class="inline-math">\(Z\)</span>-type Pauli strings associated to the stars and plaquettes, respectively, of a cellulation of a two-dimensional surface (with a qubit located at each edge of the cellulation). <span class="textit">Toric code</span> often either refers to the construction on the two-dimensional torus or is an alternative name for the general construction. The construction on surfaces with boundaries is often called the <span class="textit">planar code</span> <a href="#cite-74" class="cite">[75]</a>.</p>
<p>The original construction can be naturally extended to arbitrary dimensional manifolds <a href="#cite-40" class="cite">[41]</a><a href="#cite-75" class="cite">[76]</a>. Given a cellulation, qubits are put on <span class="inline-math">\(i\)</span>-dimensional faces, <span class="inline-math">\(X\)</span>-type stabilizers are associated with <span class="inline-math">\((i-1)\)</span>-faces, while <span class="inline-math">\(Z\)</span>-type stabilizers are associated with <span class="inline-math">\(i+1\)</span>-faces. Several constructions based on hyperbolic manifolds (see code children below) have yielded distances scaling favorably with the number of qubits.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/levin_wen">Levin-Wen model code</a><span class="code-introduced"><a href="#cite-31" class="cite">[32]</a></span></span>
    <span class="code-description">Also called a <span class="textit">string-net model</span> code. Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/lifted_product">Lifted-product code</a><span class="code-introduced"><a href="#cite-76" class="cite">[77]</a></span></span>
    <span class="code-description">A QLDPC code that is the &quot;lifted version&quot; of a hypergraph product code. The construction of a lifted product code is similar to that of a hypergraph product code; a sort of &#x27;&#x27;product&#x27;&#x27; is taken between two input classical codes to produce a CSS code. What differentiates a lifted product code from a hypergraph product code is that a reduction of symmetry is exploited to decrease the number of physical qubits required. Lifted product codes are notable because they were the first QLDPC codes to achieve almost linear distance.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/t-designs">Local Haar-random circuit code</a><span class="code-introduced"><a href="#cite-77" class="cite">[78]</a></span></span>
    <span class="code-description">An <span class="inline-math">\(n\)</span>-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal <span class="inline-math">\(n\)</span>-qubit states and acting with a random unitary circuit of depth polynomial in <span class="inline-math">\(n\)</span>. Two states are <span class="textit">locally indistinguishable</span> if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about <span class="inline-math">\(n/2\)</span> two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries.
The above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (<span class="inline-math">\(D=1\)</span>, while codes for higher-dimensional geometries require <span class="inline-math">\(O(n^{1/D})\)</span>-depth circuits <a href="#cite-77" class="cite">[78]</a>. Follow-up work <a href="#cite-78" class="cite">[79]</a> revealed that optimal code properties require only <span class="inline-math">\(O(\sqrt{n})\)</span>-depth circuits for that case, and <span class="inline-math">\(O(\sqrt{n})\)</span>-depth circuits for a two-dimensional square-lattice geometry.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/ldpc">Low-density parity-check (LDPC) code</a></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/majorana_stab">Majorana stabilizer code</a><span class="code-introduced"><a href="#cite-79" class="cite">[80]</a></span></span>
    <span class="code-description">Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as <span class="textit">Majorana stabilizers</span>. The codespace is the mutual <span class="inline-math">\(+1\)</span> eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as <span class="inline-math">\([[n,k,d]]_{f}\)</span> <a href="#cite-80" class="cite">[81]</a>, where <span class="inline-math">\(n\)</span> is the number of fermionic modes.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/matching">Matching code</a><span class="code-introduced"><a href="#cite-81" class="cite">[82]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/mds">Maximum distance separable (MDS) code</a><span class="code-introduced"><a href="#cite-82" class="cite">[83]</a></span></span>
    <span class="code-description">A <span class="inline-math">\([n,k,d]_q\)</span> <span class="inline-math">\(q\)</span>-ary linear code is an MDS code if parameters <span class="inline-math">\(n\)</span>, <span class="inline-math">\(k\)</span>, <span class="inline-math">\(d\)</span>, and <span class="inline-math">\(q\)</span> are such that the Singleton bound
<span class="display-math env-align">\begin{align}
d \leq n-k+1
\end{align}</span>
becomes an equality. A bound for general <span class="inline-math">\(q\)</span>-ary codes can also be formulated; see Thm. 1.9.10 in Ref. <a href="#cite-9" class="cite">[10]</a>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/maximum_rank_distance">Maximum-rank code</a><span class="code-introduced"><a href="#cite-83" class="cite">[84]</a><a href="#cite-84" class="cite">[85]</a></span></span>
    <span class="code-description">Linear rank-metric code with maximum rank <span class="inline-math">\([n,k,n-k+1]_q\)</span> over rank metric. For any vector <span class="inline-math">\(g=(g_1, \ldots, g_n)\)</span> with linearly independent elements <span class="inline-math">\(g_i\)</span> over <span class="inline-math">\(GF(q)\)</span>,
the generator matrix
<span class="display-math env-align">\begin{align}
G = \begin{pmatrix} g_1^{[0]} &amp; g_2^{[0]} &amp; \ldots &amp; g_n^{[0]} \\ g_1^{[1]} &amp; g_2^{[1]} &amp; \ldots &amp; g_n^{[1]} \\ g_1^{[k-1]} &amp; g_2^{[k-1]} &amp; \ldots &amp; g_n^{[k-1]} \end{pmatrix}~,
\end{align}</span>
where <span class="inline-math">\([i]:=q^i\)</span> and <span class="inline-math">\(k=n-d+1\)</span> defines a maximum rank distance code.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/qudit_css">Modular-qudit CSS code</a></span>
    <span class="code-description">Often, but not always, defined for prime qudits (<span class="inline-math">\(q=p\)</span>). Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/qudits_into_qudits">Modular-qudit code</a></span>
    <span class="code-description">Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into a <span class="inline-math">\(q^n\)</span>-dimensional (<span class="inline-math">\(n\)</span>-qudit) Hilbert space, with canonical qudit states <span class="inline-math">\(|k\rangle\)</span> labeled by elements <span class="inline-math">\(k\)</span> of the group <span class="inline-math">\(\mathbb{Z}_q\)</span> of integers <span class="textit">modulo</span> <span class="inline-math">\(q\)</span>. Usually denoted as <span class="inline-math">\(((n,K))_q\)</span> or <span class="inline-math">\(((n,K,d))_q\)</span>, whenever the code&#x27;&#x27;s distance <span class="inline-math">\(d\)</span> is defined, and with <span class="inline-math">\(q=p\)</span> when the dimension is prime.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/qudit_stabilizer">Modular-qudit stabilizer code</a></span>
    <span class="code-description">An <span class="inline-math">\(((n,p^k,d))_q\)</span> (with <span class="inline-math">\(q\)</span> not necessarily prime) stabilizer code is denoted as <span class="inline-math">\([[n,k]]_q\)</span> or <span class="inline-math">\([[n,k,d]]_q\)</span>, where <span class="inline-math">\(d\)</span> is the code&#x27;s distance. Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/molecular">Molecular code</a><span class="code-introduced"><a href="#cite-53" class="cite">[54]</a></span></span>
    <span class="code-description">Encodes finite-dimensional Hilbert space into the Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on the group <span class="inline-math">\(SO_3\)</span>. Construction is based on nested subgroups <span class="inline-math">\(H\subset K \subset SO_3\)</span>, where <span class="inline-math">\(H,K\)</span> are finite. The <span class="inline-math">\(|K|/|H|\)</span>-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of <span class="inline-math">\(H\)</span> in <span class="inline-math">\(K\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/monitored_random_circuits">Monitored random-circuit code</a><span class="code-introduced"><a href="#cite-85" class="cite">[86]</a><a href="#cite-86" class="cite">[87]</a><a href="#cite-87" class="cite">[88]</a></span></span>
    <span class="code-description"><p>Error-correcting code arising from a monitored random circuit. Such a circuit is described by a series of intermittant random local projective Pauli measurements with random unitary time-evolution operators. An important sub-family consists of <span class="textit">Clifford monitored random circuits</span>, where unitaries are sampled from the Clifford group <a href="#cite-88" class="cite">[89]</a>. When the rate of projective measurements is independently controlled by a probability parameter <span class="inline-math">\(p\)</span>, there can exist two stable phases, one described by volume-law entanglement entropy and the other by area-law entanglement entropy. The phases and their transition can be understood from the perspective of quantum error correction, information scrambling, and channel capacities <a href="#cite-89" class="cite">[90]</a><a href="#cite-90" class="cite">[91]</a>.</p>
<p>Monitored random circuits have a finite information capacity that decays exponentially with respect to system size <a href="#cite-90" class="cite">[91]</a>. When <span class="inline-math">\( p = 0 \)</span>, the random circuit achieves channel capacity, meaning that it stores the most amount of information possible. This notion quantifies the recoverability of information and the reversability of the system under the monitored random dynamics. In the volume-law phase (<span class="inline-math">\( p &lt; p_c \)</span> for some critical probability <span class="inline-math">\(p_c\)</span>), the channel capacity remains non-zero, and the monitored channel projects an initial state into a random error-correcting code <a href="#cite-90" class="cite">[91]</a>. With appropriately chosen evolution operators and measurements, the code is a stabilizer code whose parameters depend on time, <span class="inline-math">\( [[n,k(t),d(t)]] \)</span>. A similar notion applies to Haar random circuits with measurements <a href="#cite-91" class="cite">[92]</a>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/movassagh_ouyang">Movassagh-Ouyang Hamiltonian code</a><span class="code-introduced"><a href="#cite-92" class="cite">[93]</a></span></span>
    <span class="code-description"><p>This is a family of codes derived via an algorithm that takes as input <span class="textit">any</span> binary classical code and outputs a quantum code (note that this framework can be extended to <span class="inline-math">\(q\)</span>-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.</p>
<p>This family strictly generalizes CSS codes (because CSS codes come only from linear or self orthogonal classical codes). These codes can be shown to be realized as a subspace of the ground space of a (geometrically) local Hamiltonian.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/niset_andersen_cerf">Niest-Andersen-Cerf code</a><span class="code-introduced"><a href="#cite-93" class="cite">[94]</a></span></span>
    <span class="code-description">Encodes two-mode coherent states <span class="inline-math">\(\{|\alpha\rangle, |\beta\rangle\}\)</span> over two modes into four modes such that the values <span class="inline-math">\((\alpha,\beta)\)</span> are recoverable after a single-mode erasure. There are two variations of the storage procedure: a deterministic protocol that offers recovery against a single mode erasure, and a probabalistic that can protect against multiple errors with post selection. This code is effectively protecting classical information stored in <span class="inline-math">\((\alpha,\beta)\)</span> using quantum operations.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/number_phase">Number-phase code</a><span class="code-introduced"><a href="#cite-13" class="cite">[14]</a></span></span>
    <span class="code-description"><p>Bosonic rotation code consisting of superpositions of Pegg-Barnett phase states <a href="#cite-94" class="cite">[95]</a>,
<span class="display-math env-align">\begin{align}
|\phi\rangle \equiv \frac{1}{\sqrt{2\pi}}\sum_{n=0}^{\infty} \mathrm{e}^{\mathrm{i} n \phi} \ket{n}.
\end{align}</span>
Since phase states and thus the ideal codewords are not normalizable, approximate versions need to be constructed. The codes&#x27; key feature is that, in the ideal case, phase measurement has zero uncertainty, making it a good canditate for a syndrome measurement.</p>
<p>Logical states of an order-<span class="inline-math">\(N\)</span> number-phase qubit encoding are <span class="inline-math">\(|\overline{0}\rangle= \sum_{m=0}^{2N-1} |\phi = m\pi/N\rangle\)</span> and <span class="inline-math">\(|\overline{1}\rangle = \sum_{m=0}^{2N-1} (-1)^m |\phi=m\pi/N\rangle\)</span>. By performing the summation over <span class="inline-math">\(m\)</span>, one finds that <span class="inline-math">\(|\overline{0}\rangle\)</span> is supported on Fock states <span class="inline-math">\(|2kN\rangle\)</span>, while <span class="inline-math">\(|\overline{1}\rangle\)</span> is supported on states <span class="inline-math">\(|(2k+1)N\rangle\)</span>, for <span class="inline-math">\(k \geq 0\)</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/oaecc">Operator-algebra error-correcting code</a><span class="code-introduced"><a href="#cite-95" class="cite">[96]</a><a href="#cite-96" class="cite">[97]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/oscillators_into_oscillators">Oscillator-into-oscillator code</a><span class="code-introduced"><a href="#cite-97" class="cite">[98]</a><a href="#cite-98" class="cite">[99]</a></span></span>
    <span class="code-description">Encodes Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(\mathbb{R}^k\)</span> into that on <span class="inline-math">\(\mathbb{R}^n\)</span>. Usually denoted as <span class="inline-math">\(((n,k))_{\mathbb{R}}\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/parity_check">Parity-check code</a></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/happy">Pastawski-Yoshida-Harlow-Preskill (HaPPY) code</a><span class="code-introduced"><a href="#cite-66" class="cite">[67]</a></span></span>
    <span class="code-description"><p>Holographic code constructed out of a network of perfect tensors that tesselates hyperbolic space. Physical qubits are associated with uncontracted tensor legs at the boundary of the tesselation, while logical qubits are associated with uncontracted legs in the bulk. The code serves as a minimal model for several aspects of the AdS/CFT holographic duality. The construction below is described for qubits, but straightforward generalizations exist to modular qudits, oscillators, and rotors <a href="#cite-35" class="cite">[36]</a>.</p>
<p>Encoding is accomplished using a tensor network of <span class="inline-math">\([[5,1,3]]\)</span> encoding isometries, which are six-legged perfect tensors (with five legs corresponding to the physical qubits and one for the encoded logical qubit). A <span class="inline-math">\(2n\)</span>-legged <span class="textit">perfect tensor</span> is proportional to an isometry for any bipartition of its indices into a set <span class="inline-math">\(A\)</span> and a complementary set <span class="inline-math">\(A^{\perp}\)</span> such that <span class="inline-math">\(|A|\leq|A^{\perp}|\)</span>.</p>
<p>To construct the encoding, one first uniformly tiles the hyperbolic AdS/CFT disc using pentagons and hexagons. Then, one places a 6-legged <span class="inline-math">\([[5,1,3]]\)</span> encoding tensor at each hexagon and pentagon, contracting legs between neighboring shapes and leaving one leg uncontracted at each pentagon. This construction forms an encoding isometry from the uncontracted legs in the bulk to the uncontracted legs at the boundary.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/perfect">Perfect code</a></span>
    <span class="code-description"><p>An <span class="inline-math">\((n,K,2t+1)_q\)</span> <span class="inline-math">\(q\)</span>-ary code is perfect if parameters <span class="inline-math">\(n\)</span>, <span class="inline-math">\(K\)</span>, <span class="inline-math">\(t\)</span>, and <span class="inline-math">\(q\)</span> are such that the Hamming (a.k.a. sphere-packing) bound
<span class="display-math env-align">\begin{align}
\sum_{j=0}^{t}(q-1)^{j}{n \choose j}\leq q^{n}/K
\end{align}</span>
becomes an equality. For example, for a binary <span class="inline-math">\(q=2\)</span> code with one logical bit (<span class="inline-math">\(K=2\)</span>) and <span class="inline-math">\(t=1\)</span>, the bound becomes <span class="inline-math">\(n+1 \leq 2^{n-1}\)</span>.</p>
<p>For binary codes with <span class="inline-math">\(K=2^k\)</span>, one can work out an asymptotic Hamming bound in the large-<span class="inline-math">\(n,k,t\)</span> limit,
<span class="display-math env-align">\begin{align}
\frac{k}{n}\leq 1-H(t/n),
\end{align}</span>
where <span class="inline-math">\(H\)</span> is the binary entropy function.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_perfect">Perfect quantum code</a></span>
    <span class="code-description"><p>A non-degenerate code constructed out of <span class="inline-math">\(q\)</span>-dimensional qudits and having parameters <span class="inline-math">\(((n,K,2t+1))\)</span> is perfect if <span class="inline-math">\(n\)</span>, <span class="inline-math">\(K\)</span>, <span class="inline-math">\(t\)</span>, and <span class="inline-math">\(q\)</span> are such that the quantum Hamming bound
<span class="display-math env-align">\begin{align}
\sum_{j=0}^{t}(q^2-1)^{j}{n \choose j}\leq q^{n}/K
\end{align}</span>
becomes an equality. For example, for a qubit <span class="inline-math">\(q=2\)</span> code with one logical qubit (<span class="inline-math">\(K=2\)</span>) and <span class="inline-math">\(t=1\)</span>, the bound becomes <span class="inline-math">\(3n+1 \leq 2^{n-1}\)</span>. The bound can be saturated only at certain <span class="inline-math">\(n\)</span>.</p>
<p>For qubit codes with <span class="inline-math">\(K=2^k\)</span>, one can work out an asymptotic Hamming bound in the large-<span class="inline-math">\(n,k,t\)</span> limit,
<span class="display-math env-align">\begin{align}
\frac{k}{n}\leq 1-\frac{t}{n}\log_{2}3-H(t/n),
\end{align}</span>
where <span class="inline-math">\(H\)</span> is the binary entropy function.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/permutation_invariant">Permutation-invariant code</a><span class="code-introduced"><a href="#cite-99" class="cite">[100]</a></span></span>
    <span class="code-description">Codes which are stabilized by the symmetric group <span class="inline-math">\(S_n\)</span> on <span class="inline-math">\(n\)</span> elements, in a generalization of stabilizer codes to binary codes utilizing (non-abelian) group actions (in particular, <span class="inline-math">\(S_n\)</span> is non-abelian).</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/polar">Polar code</a><span class="code-introduced"><a href="#cite-100" class="cite">[101]</a></span></span>
    <span class="code-description">In its basic version, a binary linear polar code encodes <span class="inline-math">\(K\)</span> message bits into <span class="inline-math">\(N=2^n\)</span> bits. The linear transformation that defines the code is given by the matrix <span class="inline-math">\(G^{(n)}=B_N G^{\otimes n}\)</span>, where <span class="inline-math">\(B_N\)</span> is a certain <span class="inline-math">\(N\times N\)</span> permutation matrix, and <span class="inline-math">\(G^{\otimes n}\)</span> is the <span class="inline-math">\(n\)</span>th Kronecker power of the <span class="inline-math">\(2\times 2\)</span> <span class="textit">kernel</span> matrix <span class="inline-math">\(G=\left[\begin{smallmatrix}1 &amp; 0\\ 1 &amp; 1 \end{smallmatrix}\right]\)</span>. To encode <span class="inline-math">\(K\)</span> message bits, one forms an <span class="inline-math">\(N\)</span>-vector <span class="inline-math">\(u\)</span> in which <span class="inline-math">\(K\)</span> coordinates represent the message bits. The remaining <span class="inline-math">\(N-K\)</span> coordinates are set to some fixed values and are said to be <span class="textit">frozen</span>. The codeword <span class="inline-math">\(x \in \{0,1\}^N\)</span> is obtained as <span class="inline-math">\(x=u G^{\otimes n}\)</span>. The choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/polynomial">Prime-qudit polynomial code (QPyC)</a><span class="code-introduced"><a href="#cite-101" class="cite">[102]</a></span></span>
    <span class="code-description">Also called <span class="textit">quantum Reed-Solomon code</span>. Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/prime_qudit_stabilizer">Prime-qudit stabilizer code</a><span class="code-introduced"><a href="#cite-102" class="cite">[103]</a></span></span>
    <span class="code-description">An <span class="inline-math">\(((n,p^k,d))_p\)</span> (with <span class="inline-math">\(p\)</span> prime) stabilizer code is denoted as <span class="inline-math">\([[n,k]]_p\)</span> or <span class="inline-math">\([[n,k,d]]_p\)</span>, where <span class="inline-math">\(d\)</span> is the code&#x27;s distance. Logical subspace is the joint <span class="inline-math">\(+1\)</span> eigenspace of a set of <span class="inline-math">\(p^{n-k}\)</span> commuting qudit Pauli operators forming the code&#x27;s stabilizer group, which cannot contain <span class="inline-math">\(-I\)</span>. The distance is the minimum weight of an error that implements a nontrivial logical operation on the code.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/real_projective_plane">Projective-plane surface code</a><span class="code-introduced"><a href="#cite-103" class="cite">[104]</a></span></span>
    <span class="code-description">A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold <span class="inline-math">\(\mathbb{R}P^2\)</span> (in contrast to a genus-<span class="inline-math">\(g\)</span> surface). Whereas genus-<span class="inline-math">\(g\)</span> surface codes require <span class="inline-math">\(2g\)</span> logical qubits, qubit codes on <span class="inline-math">\(\mathbb{R}P^2\)</span> are made from a single logical qubit.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_reed_muller">Quantum Reed-Muller code</a><span class="code-introduced"><a href="#cite-104" class="cite">[105]</a></span></span>
    <span class="code-description">A CSS code formed from a classical Reed-Muller code in which polynomials over finite fields encode data. This is done by transforming these polynomials into the stabilizer generator matrices</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_convolutional">Quantum convolutional code</a><span class="code-introduced"><a href="#cite-105" class="cite">[106]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_cyclic">Quantum cyclic code</a><span class="code-introduced"><a href="#cite-106" class="cite">[107]</a></span></span>
    <span class="code-description">A code <span class="inline-math">\(C\)</span> constructed in a physical space consisting of a tensor product of <span class="inline-math">\(n\)</span> subsystems (e.g., qubits) is cyclic if a cyclic permutation of the subsystems leaves the code subspace invariant.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/qecc">Quantum error-correcting code (QECC)</a></span>
    <span class="code-description">Encodes quantum information in a (<span class="textit">logical</span>) subspace of a (<span class="textit">physical</span>) Hilbert space such that it is possible to recover said information from errors that act as linear maps on the physical space. The logical subspace is spanned by a basis comprised of <span class="textit">code basis states</span> or <span class="textit">codewords</span>. Codewords may not be normalizable if the physical Hilbert space in infinite, so approximate versions have to be constructed.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_expander">Quantum expander code</a><span class="code-introduced"><a href="#cite-107" class="cite">[108]</a></span></span>
    <span class="code-description">CSS codes constructed from bipartite expander graphs with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as <span class="inline-math">\(X\)</span> checks, and the parity check matrix of the other as <span class="inline-math">\(Z\)</span> checks.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_ldpc">Quantum low-density parity-check (QLDPC) code</a></span>
    <span class="code-description">Family of <span class="inline-math">\([[n,k,d]]\)</span> stabilizer codes for which the number of qubits participating in each stabilizer generator and the number of stabilizer generators that each qubit participates in are both bounded by a constant as <span class="inline-math">\(n\to\infty\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_parity">Quantum parity code (QPC)</a><span class="code-introduced"><a href="#cite-108" class="cite">[109]</a><a href="#cite-109" class="cite">[110]</a></span></span>
    <span class="code-description">A <span class="inline-math">\([[m_1 m_2,1,\min(m_1,m_2)]]\)</span> CSS code family obtained from concatenating an <span class="inline-math">\(m_1\)</span>-qubit phase-flip repetition code with an <span class="inline-math">\(m_2\)</span>-qubit bit-flip repetition code. Logical codewords are
<span class="display-math env-align">\begin{align}
\begin{split}
|\overline{0}\rangle&amp;=\frac{1}{2^{m_2/2}}\left(|0\rangle^{\otimes m_1}+|1\rangle^{\otimes m_1}\right)^{\otimes m_2}\\
|\overline{1}\rangle&amp;=\frac{1}{2^{m_2/2}}\left(|0\rangle^{\otimes m_1}-|1\rangle^{\otimes m_1}\right)^{\otimes m_2}~.
\end{split}
\end{align}</span></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_polar">Quantum polar code</a><span class="code-introduced"><a href="#cite-110" class="cite">[111]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_repetition">Quantum repetition code</a></span>
    <span class="code-description">Encodes <span class="inline-math">\(1\)</span> qubit into <span class="inline-math">\(n\)</span> qubits according to <span class="inline-math">\(|0\rangle\to|\phi_0\rangle^{\otimes n}\)</span> and <span class="inline-math">\(|1\rangle\to|\phi_1\rangle^{\otimes n}\)</span>. Also known as a <span class="textit">bit-flip</span> code when <span class="inline-math">\(|\phi_i\rangle = |i\rangle\)</span>, and a <span class="textit">phase-flip</span> code when <span class="inline-math">\(|\phi_0\rangle = |+\rangle\)</span> and <span class="inline-math">\(|\phi_1\rangle = |-\rangle\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_double">Quantum-double code</a><span class="code-introduced"><a href="#cite-73" class="cite">[74]</a></span></span>
    <span class="code-description"><p>A family of topological codes, defined by a finite group <span class="inline-math">\( G \)</span>,  whose generators are few-body operators associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit of dimension <span class="inline-math">\( |G| \)</span> located at each edge of the tesselation).</p>
<p>The physical Hilbert space has dimension <span class="inline-math">\( |G|^E  \)</span>, where <span class="inline-math">\( E \)</span> is the number of  edges in the tessellation. The dimension of the code space is the number of orbits of the conjugation action of <span class="inline-math">\( G \)</span> on <span class="inline-math">\( \text{Hom}(\pi_1(\Sigma),G) \)</span>,  the set of group homomorphisms from the fundamental group of the surface <span class="inline-math">\( \Sigma \)</span> into the finite group <span class="inline-math">\( G \)</span> <a href="#cite-111" class="cite">[112]</a>. When <span class="inline-math">\( G \)</span> is abelian, the formula for the dimension simplifies to <span class="inline-math">\( |G|^{2g} \)</span>, where <span class="inline-math">\( g \)</span> is the genus of the surface <span class="inline-math">\( \Sigma \)</span>.</p>
<p>The codespace is the ground-state subspace of the quantum double model Hamiltonian. For nonabelian groups, alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic excitations of model <a href="#cite-112" class="cite">[113]</a><a href="#cite-113" class="cite">[114]</a><a href="#cite-114" class="cite">[115]</a>. The fusion space of such nonabelian anyons has dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quasi_cyclic">Quasi-cyclic code</a><span class="code-introduced"><a href="#cite-115" class="cite">[116]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/qubits_into_qubits">Qubit code</a></span>
    <span class="code-description">Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into a <span class="inline-math">\(2^n\)</span>-dimensional (i.e., <span class="inline-math">\(n\)</span>-qubit) Hilbert space. Usually denoted as <span class="inline-math">\(((n,K))\)</span> or <span class="inline-math">\(((n,K,d))\)</span>, where <span class="inline-math">\(d\)</span> is the code&#x27;s distance.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/qudit_surface">Qudit surface code</a><span class="code-introduced"><a href="#cite-73" class="cite">[74]</a></span></span>
    <span class="code-description">A family of stabilizer codes whose generators are few-body <span class="inline-math">\(X\)</span>-type and <span class="inline-math">\(Z\)</span>-type Pauli strings associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit located at each edge of the tesselation). The code has <span class="inline-math">\( n=E \)</span> many physical qudits, where <span class="inline-math">\( E \)</span> is the number of edges of the tesselation, and <span class="inline-math">\( k=2g \)</span> many logical qudits, where <span class="inline-math">\( g \)</span> is the genus of the surface.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/qudits_into_oscillators">Qudit-into-oscillator code</a></span>
    <span class="code-description">Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(\mathbb{R}^n\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/ramanujan_tensor_product">Ramanujan tensor-product code</a><span class="code-introduced"><a href="#cite-30" class="cite">[31]</a></span></span>
    <span class="code-description">Constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/random_circuit">Random-circuit code</a></span>
    <span class="code-description">Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/gabidulin">Rank code</a><span class="code-introduced"><a href="#cite-83" class="cite">[84]</a><a href="#cite-84" class="cite">[85]</a></span></span>
    <span class="code-description"><p>Also called <span class="textit">Gabidulin</span> or <span class="textit">(matrix) rank-metric code</span>. The code corrects errors over rank metric instead of the traditional Hamming distance. The rank of an <span class="inline-math">\(n\)</span>-dimensional vector over <span class="inline-math">\(GF(q^N)\)</span> is the maximum number of its linearly independent coordinates.</p>
<p>Given <span class="inline-math">\(X^n\)</span>, an <span class="inline-math">\(n\)</span>-dimensional vector space over <span class="inline-math">\(GF(q^N)\)</span> where <span class="inline-math">\(q\)</span> is a power of a prime number, the <span class="textit">rank metric</span> <span class="inline-math">\(d(x, y)\)</span> is defined via the rank norm <span class="inline-math">\(r(x, q) = \mathrm{rank}(A(x))\)</span>, where
<span class="display-math env-align">\begin{align}
A(x) = \begin{pmatrix} a_{11} &amp; a_{12} &amp; \ldots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \ldots &amp; a_{2n} \\  a_{N1} &amp; a_{N2} &amp; \ldots &amp; a_{Nn} \end{pmatrix}
\end{align}</span>
and <span class="inline-math">\(x_i = a_{1i} u_1 + a_{2i} u_2 + \ldots + a_{Ni}u_N \)</span> for some fixed basis <span class="inline-math">\(\{u_i\}_{i=1}^N\)</span>.</p>
<p>If the vector set <span class="inline-math">\(\{x_1, x_2, \ldots, x_M\}\)</span> defines a <span class="inline-math">\(k\)</span>-dimensional subspace, then the code is <span class="inline-math">\([n,k]\)</span>-linear.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/reed_muller">Reed-Muller code</a><span class="code-introduced"><a href="#cite-116" class="cite">[117]</a><a href="#cite-117" class="cite">[118]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/reed_solomon">Reed-Solomon code</a><span class="code-introduced"><a href="#cite-118" class="cite">[119]</a></span></span>
    <span class="code-description"><span class="inline-math">\([n,k,n-k+1]_q\)</span> linear code based on polynomials over <span class="inline-math">\(GF(q)\)</span>. Let <span class="inline-math">\(\{\alpha_1,\cdots,\alpha_n\}\)</span> be <span class="inline-math">\(n\)</span> distinct nonzero elements of <span class="inline-math">\(GF(q)\)</span> for prime <span class="inline-math">\(q&gt;n\)</span>. Encodes <span class="inline-math">\(\mu=\{\mu_0,\cdots,\mu_{k-1}\}\)</span> into <span class="inline-math">\(\{f_\mu(\alpha_1),\cdots,f_\mu(\alpha_n)\}\)</span> with polynomial <span class="inline-math">\(f_\mu(x)=\mu_0+\mu_1 x + \cdots + \mu_{k-1}x^{k-1}\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/rotor_gkp">Rotor GKP code</a><span class="code-introduced"><a href="#cite-52" class="cite">[53]</a><a href="#cite-53" class="cite">[54]</a></span></span>
    <span class="code-description">GKP code protecting against small angular position and momentum shifts of a planar rotor.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/shor_nine">Shor <span class="inline-math">\([[9,1,3]]\)</span> code</a><span class="code-introduced"><a href="#cite-119" class="cite">[120]</a></span></span>
    <span class="code-description">Nine-qubit CSS code that is the smallest such code to correct a single-qubit error. Shor&#x27;s code works by concatenating each qubit of a phase-flip with a bit-flip repetition code. Therefore, the code can correct both type of errors simultaneously. To be specific, a state is phase-flip error-corrected by a three-qubit phase-flip correction code, with parity checks of <span class="inline-math">\(X_0 X_1I_2\)</span> and <span class="inline-math">\(X_0I_1X_2\)</span> in <span class="inline-math">\(X\)</span> basis, where the subscript represents the qubit index. Each logical qubit is encoded using <span id="eq--phase-flip" class="display-math env-align">\begin{align} \label{eq:phase-flip} \begin{split} |0\rangle_{L_P} &amp;= |+_0+_1+_2\rangle \\ |1\rangle_{L_P} &amp;= |-_0-_1-_2\rangle . \end{split}\end{align}</span> Then, each physical qubit used in <span class="inline-math eqref">\eqref{eq:phase-flip}</span> is further encoded in the three-qubit bit-flip correction code: <span class="display-math env-align">\begin{align} |\pm _j \rangle  = \frac{1}{\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\rangle \pm |1_{j0}1_{j1}1_{j2}\rangle),\end{align}</span> each with bit-flip error parity check <span class="inline-math">\(Z_{j0}Z_{j1}I_{j2}\)</span> and  <span class="inline-math">\(Z_{j0}I_{j1}Z_{j2} \)</span>, where <span class="inline-math">\(j=0,1,2\)</span>. Notice now the phase-flip error parity check is extended as <span class="inline-math">\(X_j = X_{j0}X_{j1}X_{j2}\)</span>. As a result, the overall parity checks with the flattened qubit index are <span class="display-math env-align">\begin{align} \begin{split} Z_{j0}Z_{j1}I_{j2} &amp;\rightarrow \{Z_0Z_1, Z_3Z_4, Z_6Z_7\} \\ Z_{j0}I_{j1}Z_{j2} &amp;\rightarrow \{Z_0Z_2, Z_3Z_5, Z_6Z_8\} \\ X_0 X_1I_2  &amp;\rightarrow  \{X_0X_1X_2X_3X_4X_5\}\\ X_0 I_1X_2  &amp;\rightarrow  \{X_0X_1X_2X_6X_7X_8\}. \end{split}\end{align}</span> The logical state is encoded using <span class="display-math env-align">\begin{align} \begin{split} |\overline{0}\rangle&amp;=\frac{1}{2\sqrt{2}}\left(|000\rangle+|111\rangle\right)^{\otimes3}\\ |\overline{1}\rangle&amp;=\frac{1}{2\sqrt{2}}\left(|000\rangle-|111\rangle\right)^{\otimes3}~. \end{split}\end{align}</span></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/single_parity_check">Single parity-check code</a></span>
    <span class="code-description">An <span class="inline-math">\([n,n-1,2]\)</span> binary linear error-detecting code encoding an <span class="inline-math">\(n\)</span>-bit codeword into an <span class="inline-math">\((n+1)\)</span>-bit string. In this code, parity information of a codeword is sotred in an extra parity bit. If the Hamming weight of a codeword is odd, then its parity is 1. If the Hamming weight of a codeword is even, then its parity is 0. This code is inexpensive since it only requires an extra parity bit and a single parity check.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/skew-cyclic_galois_css">Skew-cyclic CSS code</a><span class="code-introduced"><a href="#cite-120" class="cite">[121]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/skew_cyclic">Skew-cyclic code</a><span class="code-introduced"><a href="#cite-121" class="cite">[122]</a></span></span>
    <span class="code-description">A classical code <span class="inline-math">\(C\)</span> of length <span class="inline-math">\(n\)</span> over <span class="inline-math">\(GF(q)\)</span> is skew-cyclic if there exists an automorphism, <span class="inline-math">\(\theta\)</span>, of <span class="inline-math">\(GF(q)\)</span>, such that for each string <span class="inline-math">\(c_1 c_2 \cdots c_n\in C\)</span>, the skew-cyclically shifted string <span class="inline-math">\(\theta(c_n) \theta(c_1) \cdots \theta(c_{n-1})\in C\)</span>. We say that <span class="inline-math">\(C\)</span> is a <span class="inline-math">\(\theta\)</span>-cyclic code over <span class="inline-math">\(GF(q)\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/stabilizer">Stabilizer code</a><span class="code-introduced"><a href="#cite-122" class="cite">[123]</a><a href="#cite-102" class="cite">[103]</a></span></span>
    <span class="code-description">An <span class="inline-math">\(((n,2^k,d))\)</span> stabilizer code is denoted as <span class="inline-math">\([[n,k]]\)</span> or <span class="inline-math">\([[n,k,d]]\)</span>, where <span class="inline-math">\(d\)</span> is the code&#x27;s distance. Logical subspace is the joint <span class="inline-math">\(+1\)</span> eigenspace of a set of <span class="inline-math">\(2^{n-k}\)</span> commuting Pauli operators <span class="inline-math">\(S\)</span> forming the code&#x27;s stabilizer group <span class="inline-math">\(\mathsf{S}\)</span>, which cannot contain <span class="inline-math">\(-I\)</span>. The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation on the code.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/stabilizer_over_gf4">Stabilizer code over <span class="inline-math">\(GF(4)\)</span></a><span class="code-introduced"><a href="#cite-123" class="cite">[124]</a></span></span>
    <span class="code-description">An <span class="inline-math">\([[n,k,d]]\)</span> stabilizer code whose encoding is based on a self-dual quaternary <span class="inline-math">\([n, n-k, d^*]_4\)</span> code over <span class="inline-math">\(GF(4)^n\)</span> with respect to the trace inner product where <span class="inline-math">\(d \ge d^*\)</span>.
<span class="inline-math">\(GF(4)\)</span> consists of <span class="inline-math">\(\{0, 1, w, \bar{w}\}\)</span>, with <span class="inline-math">\(\bar{w} = w^2 = w + 1\)</span>, <span class="inline-math">\(\mathrm{Tr}(x) = x+\bar{x}\)</span>, and trace inner product <span class="inline-math">\(u * v = \mathrm{Tr}(u \cdot \bar{v})\)</span>.
There is a mapping <span class="inline-math">\(L\)</span> between Pauli matrices <span class="inline-math">\(I, Y, Z, X\)</span> and <span class="inline-math">\(0, 1, \bar{w}, w\)</span>, in turn <span class="inline-math">\([A, B] \Leftrightarrow Tr\langle L(A), L(A)\rangle\)</span>.
The classical self-dual code <span class="inline-math">\(C\)</span> over <span class="inline-math">\(GF(4)^n\)</span> corresponds to the stabilizer group <span class="inline-math">\(\mathsf{S}\)</span> while <span class="inline-math">\(C^{\perp}\)</span> corresponds to <span class="inline-math">\(\mathsf{N(S)}\)</span>.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/steane">Steane <span class="inline-math">\([[7,1,3]]\)</span> code</a><span class="code-introduced"><a href="#cite-16" class="cite">[17]</a></span></span>
    <span class="code-description">A <span class="inline-math">\([[7,1,3]]\)</span> CSS code that uses the classical binary <span class="inline-math">\([7,4,3]\)</span> Hamming code for protecting against <span class="inline-math">\(X\)</span> errors and its dual <span class="inline-math">\([7,3,4]\)</span> for <span class="inline-math">\(Z\)</span> errors. The parity-check matrix for the <span class="inline-math">\([7,4,3]\)</span> Hamming code is
<span class="display-math env-align">\begin{align}
  H = \left(\begin{matrix}
    1&amp;0&amp;0&amp;1&amp;0&amp;1&amp;1\\
    0&amp;1&amp;0&amp;1&amp;1&amp;0&amp;1\\
    0&amp;0&amp;1&amp;0&amp;1&amp;1&amp;1
  \end{matrix}\right),
\end{align}</span>
and the check matrix for the Steane code is therefore
<span class="display-math env-align">\begin{align}
  \left(\begin{matrix}
    0&amp;H\\
    H&amp;0
  \end{matrix}\right).
\end{align}</span>
The stabilizer group for the Steane code has six generators.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/oecc">Subsystem code</a><span class="code-introduced"><a href="#cite-124" class="cite">[125]</a><a href="#cite-125" class="cite">[126]</a></span></span>
    <span class="code-description">Also called an operator error-correcting code. Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/subsystem_color">Subsystem color code</a><span class="code-introduced"><a href="#cite-126" class="cite">[127]</a><a href="#cite-127" class="cite">[128]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/subsystem_stabilizer">Subsystem stabilizer code</a><span class="code-introduced"><a href="#cite-128" class="cite">[129]</a></span></span>
    <span class="code-description"><p>Also called a <span class="textit">gauge stabilizer code</span>. A stabilizer code with some of its logical qubits denoted as <span class="textit">gauge</span> qubits and not used for storage of logical information. Note that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by <span class="inline-math">\([[n,k,r,d]]\)</span>, similar to stabilizer codes, but with an extra parameter <span class="inline-math">\(r\)</span> denoting the number of gauge qubits.</p>
<p>To create these codes proceed as follows. Choose <span class="inline-math">\(2n\)</span> operators <span class="inline-math">\(\{ \tilde{X}_j,\tilde{Z}_j\}_{j=1}^n\)</span> from <span class="inline-math">\(\mathsf{P}_n\)</span>, the Pauli group on <span class="inline-math">\(n\)</span> qubits, such that they obey the same commutation relations as the regular <span class="inline-math">\(n\)</span>-qubit Pauli generators <span class="inline-math">\( \{X_j,Z_j\}_{j=1}^n \)</span> (the subscript on these latter operators indicates the single qubit the Pauli matrix acts on). The tilde operators might act on more than one physical (or <span class="textit">bare</span>) qubit but they behave as if they acted only on a single qubit. WLOG we can choose a stabilizer group as <span class="inline-math">\( \mathsf{S} = \langle Z_1,\dots,Z_s \rangle \)</span>. It follows that the normalizer of <span class="inline-math">\(\mathsf{S} \)</span> is <span class="inline-math">\( N(\mathsf{S}) = \langle i, \tilde{Z}_1,\dots, \tilde{Z}_n, \tilde{X}_{s+1},\dots, \tilde{X}_n \rangle \)</span>. We now choose a gauge group as <span class="inline-math">\( \mathsf{G} = \langle i, \tilde{Z}_1,\dots, \tilde{Z}_s, \tilde{X}_{s+1}, \tilde{Z}_{s+1}, \dots, \tilde{X}_{s+r}, \tilde{Z}_{s+r} \rangle \)</span> with <span class="inline-math">\( s + r \leq n \)</span>. The logical group is choosen as <span class="inline-math">\( \mathsf{L} = N(\mathsf{S})/\mathsf{G} \simeq \langle \tilde{X}_{s+r+1},\tilde{Z}_{s+r+1}, \dots, \tilde{X}_n,\tilde{Z}_n \rangle \)</span>. Now the codespace <span class="inline-math">\( C \)</span> is as usual the <span class="inline-math">\(+1\)</span> eigenspace of the stabilizer <span class="inline-math">\( \mathsf{S} \)</span>. But the gauge and logical groups have further decomposed this space into <span class="inline-math">\( C = A \otimes B \simeq (\mathbb{C}^2)^{\otimes k} \otimes (\mathbb{C}^2)^{\otimes r} \)</span>. Thus the Hilbert space is partitioned into 3 sets; <span class="inline-math">\(k\)</span> logical qubits, <span class="inline-math">\(r\)</span> gauge qubits, and <span class="inline-math">\(s\)</span> stabilizer qubits, with <span class="inline-math">\(s+r+k=n\)</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/tanner">Tanner code</a></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/stab_3_1_2">Three qutrit Code</a><span class="code-introduced"><a href="#cite-129" class="cite">[130]</a></span></span>
    <span class="code-description">A <span class="inline-math">\([[3,1,2]]_3\)</span> prime-qudit CSS code with stabilizer generators <span class="inline-math">\(ZZZ\)</span> and <span class="inline-math">\(XXX\)</span>. The code defines a quantum secret-sharing scheme and serves as a minimal model for the AdS/CFT holographic duality. The codewords are
<span class="display-math env-align">\begin{align}
  \begin{split}
    | \overline{0} \rangle &amp;= \frac{1}{\sqrt{3}} (| 000 \rangle + | 111 \rangle + | 222 \rangle) \\
    | \overline{1} \rangle &amp;= \frac{1}{\sqrt{3}} (| 012 \rangle + | 120 \rangle + | 201 \rangle) \\
    | \overline{2} \rangle &amp;= \frac{1}{\sqrt{3}} (| 021 \rangle + | 102 \rangle + | 210 \rangle)~.
  \end{split}
\end{align}</span>
The elements in the superposition of each logical codeword are related to each other via cyclic permutations.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/topological">Topological code</a></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_triorthogonal">Triorthogonal code</a><span class="code-introduced"><a href="#cite-130" class="cite">[131]</a></span></span>
    <span class="code-description">A triorthogonal <span class="inline-math">\(m \times n\)</span> binary matrix is triorthogonal if its rows <span class="inline-math">\(r_1, \ldots, r_m\)</span> satisfy <span class="inline-math">\(|r_i \cdot r_j| = 0\)</span> and <span class="inline-math">\(|r_i \cdot r_j \cdot r_k| = 0\)</span>, where addition and multiplication are done on <span class="inline-math">\(\mathbb{Z}_2\)</span>. The triorthogonal code associated with the matrix is constructed by mapping non-zero entries in even-weight rows to <span class="inline-math">\(X\)</span> operators, and <span class="inline-math">\(Z\)</span> operators for each row in the orthogonal complement.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/turaev_viro">Turaev-Viro code</a><span class="code-introduced"><a href="#cite-131" class="cite">[132]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/two_dimensional_hyperbolic_surface">Two-dimensional hyperbolic surface code</a><span class="code-introduced"><a href="#cite-132" class="cite">[133]</a></span></span>
    <span class="code-description"><p>Hyperbolic surface codes based on a tessellation of a closed 2D manifold with a hyperbolic geometry (i.e., non-Euclidean geometry, e.g., saddle surfaces when defined on a 2D plane).</p>
<p>For a tessellation involving regular polygons with <span class="inline-math">\( r \)</span> sides and <span class="inline-math">\( s \)</span> polygons meeting at each edge, the number of logical qubits is given by <span class="inline-math">\( k = (1-2/r - 2/s) n + 2 \)</span>. Some possible tilings are <span class="inline-math">\( {r,s}: {7,3}, {5,4} \)</span>. The weight of the stabilizer generators are dependent on the tiling, with <span class="inline-math">\({5,4}\)</span> having lower weight than <span class="inline-math">\({7,3}\)</span>.</p></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/very-small-logical-qubit">Very small logical qubit (VSLQ) code</a><span class="code-introduced"><a href="#cite-133" class="cite">[134]</a></span></span>
    <span class="code-description">The two logical codewords are <span class="inline-math">\(|\pm\rangle \propto (|0\rangle\pm|2\rangle)(|0\rangle\pm|2\rangle)|0\rangle|0\rangle\)</span>, where the total Hilbert space is the tensor product of two qudits (whose ground states <span class="inline-math">\(|0\rangle\)</span> and second excited states <span class="inline-math">\(|2\rangle\)</span> are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/wasilewski-banaszek">Wasilewski-Banaszek code</a><span class="code-introduced"><a href="#cite-134" class="cite">[135]</a></span></span>
    <span class="code-description">Three-oscillator Fock-state code encoding a single logical qubit using codewords <span class="display-math env-align">\begin{align} \begin{split} |\overline{0}\rangle &amp;= \frac{1}{\sqrt{3}}(|003\rangle+|030\rangle+|300\rangle)\\ |\overline{1}\rangle &amp;= |111\rangle \end{split}.\end{align}</span></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/xyz_product">XYZ product code</a><span class="code-introduced"><a href="#cite-135" class="cite">[136]</a></span></span>
    <span class="code-description">A non-CSS QLDPC code constructed from three classical codes. The construction of an XYZ product code is similar to that of a hypergraph product code and related codes. The idea is that rather than taking a product of only two classical codes to produce a CSS code, a third classical code is considered, acting with Pauli-<span class="inline-math">\(Y\)</span> operators.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/xyz_hexagonal">XYZ<span class="inline-math">\(^2\)</span> hexagonal stabilizer code</a><span class="code-introduced"><a href="#cite-136" class="cite">[137]</a></span></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/xzzx">XZZX surface code</a><span class="code-introduced"><a href="#cite-137" class="cite">[138]</a></span></span>
    <span class="code-description">A family of stabilizer codes whose generators are <span class="inline-math">\(XZXZ\)</span> Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/stab_15_1_3"><span class="inline-math">\([[15,1,3]]\)</span> Reed-Muller code</a></span>
    <span class="code-description"><span class="inline-math">\([[15,1,3]]\)</span> CSS code that is most easily thought of as a tetrahedral 3D color code.
This code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center.
The tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers.
Each colored cell corresponds to a weight-8 <span class="inline-math">\(X\)</span>-check, and each face corresponds to a weight-4 <span class="inline-math">\(Z\)</span>-check.
A logical <span class="inline-math">\(Z\)</span> is any weight-3 <span class="inline-math">\(Z\)</span>-string along an edge of the entire tetrahedron.
The logical <span class="inline-math">\(X\)</span> is any weight-7 <span class="inline-math">\(X\)</span>-face of the entire tetrahedron.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_hamming_css"><span class="inline-math">\([[2^r - 1, 2^r - 2r - 1, 3]]\)</span> Hamming-based CSS code</a></span>
    <span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/quantum_hamming"><span class="inline-math">\([[2^r, 2^r-r-2, 3]]\)</span> quantum Hamming code</a><span class="code-introduced"><a href="#cite-138" class="cite">[139]</a></span></span>
    <span class="code-description">A family of stabilizer codes of distance <span class="inline-math">\(3\)</span> that asymptotically saturate quantum Hamming bound.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/stab_4_2_2"><span class="inline-math">\([[4,2,2]]\)</span> CSS code</a><span class="code-introduced"><a href="#cite-139" class="cite">[140]</a></span></span>
    <span class="code-description">Four-qubit CSS stabilizer code with generators <span class="inline-math">\(\{XXXX, ZZZZ\} \)</span> and codewords <span class="display-math env-align">\begin{align} \begin{split} |\overline{00}\rangle = (|0000\rangle + |1111\rangle)/\sqrt{2}\\ |\overline{01}\rangle = (|0011\rangle + |1100\rangle)/\sqrt{2}\\ |\overline{10}\rangle = (|0101\rangle + |1010\rangle)/\sqrt{2}\\ |\overline{11}\rangle = (|0110\rangle + |1001\rangle)/\sqrt{2} \end{split}.\end{align}</span> Its subcode is the <span class="inline-math">\([[4,1,2]]\)</span> code, whose <span class="inline-math">\(\pm\)</span>-basis codewords can be written as <span class="display-math env-align">\begin{align} |\overline{\pm}\rangle = \frac{1}{2}(|00\rangle \pm |11\rangle)^{\otimes 2}\\\end{align}</span> This code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/stab_5_1_3"><span class="inline-math">\([[5,1,3]]\)</span> code</a><span class="code-introduced"><a href="#cite-140" class="cite">[141]</a></span></span>
    <span class="code-description">Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, <span class="display-math env-align">\begin{align} \begin{split} S_1 &amp;= IXZZX \\ S_2 &amp;= XZZXI \\ S_3 &amp;= ZZXIX \\ S_4 &amp;= ZXIXZ. \end{split}\end{align}</span></span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/q-ary_digits_into_q-ary_digits"><span class="inline-math">\(q\)</span>-ary code</a></span>
    <span class="code-description">Encodes <span class="inline-math">\(K\)</span> states (codewords) in <span class="inline-math">\(n\)</span> <span class="inline-math">\(q\)</span>-ary coordinates and has distance <span class="inline-math">\(d\)</span>. Usually denoted as <span class="inline-math">\((n,K,d)_q\)</span>. The distance is the minimum number of coordinates where two strings in the code differ.</span>
  </li>
  <li>
    <span class="code-name">
      <a href="/c/q-ary_linear"><span class="inline-math">\(q\)</span>-ary linear code</a></span>
    <span class="code-description">An <span class="inline-math">\((n,K,d)_q\)</span> linear code is denoted as <span class="inline-math">\([n,k,d]_q\)</span>, where <span class="inline-math">\(k=\log_{q}K\)</span> need not be an integer. Its codewords form a linear subspace, i.e., for any codewords <span class="inline-math">\(x,y\)</span>, <span class="inline-math">\(\alpha x+ \beta y\)</span> is also a codeword for any <span class="inline-math">\(q\)</span>-ary digits <span class="inline-math">\(\alpha,\beta\)</span>. Often defined in terms of a generator matrix <span class="inline-math">\(G\)</span>, whose rows form a basis for the subspace. Given a codeword <span class="inline-math">\(x\)</span>, the corresponding encoded codeword is <span class="inline-math">\(G^T x\)</span>.</span>
  </li>
</ol>


   <div id="endnotes">
    <dl id="citations">
      <!-- Citation:  -->
      <dt id="cite-0">[1]</dt>
      <dd>
        H. J. Helgert, “Alternant codes”, Information and Control <span class="textbf">26</span>, 369 (1974). <a href="https://doi.org/10.1016/S0019-9958(74)80005-7" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-1">[2]</dt>
      <dd>
        D. W. Leung et al., “Approximate quantum error correction can lead to better codes”, Physical Review A <span class="textbf">56</span>, 2567 (1997). <a href="https://doi.org/10.1103/PhysRevA.56.2567" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9704002" target="_blank" class="href">quant-ph/9704002</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-2">[3]</dt>
      <dd>
        A. Y. Kitaev, “Quantum computations: algorithms and error correction”, Russian Mathematical Surveys <span class="textbf">52</span>, 1191 (1997). <a href="https://doi.org/10.1070/RM1997v052n06ABEH002155" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-3">[4]</dt>
      <dd>
        M. Reimpell and R. F. Werner, “Iterative Optimization of Quantum Error Correcting Codes”, Physical Review Letters <span class="textbf">94</span>, (2005). <a href="https://doi.org/10.1103/PhysRevLett.94.080501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0307138" target="_blank" class="href">quant-ph/0307138</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-4">[5]</dt>
      <dd>
        Claude Crepeau, Daniel Gottesman, and Adam Smith, “Approximate Quantum Error-Correcting Codes and Secret Sharing Schemes”. <a href="https://arxiv.org/abs/quant-ph/0503139" target="_blank" class="href">quant-ph/0503139</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-5">[6]</dt>
      <dd>
        C. Bény and O. Oreshkov, “General Conditions for Approximate Quantum Error Correction and Near-Optimal Recovery Channels”, Physical Review Letters <span class="textbf">104</span>, (2010). <a href="https://doi.org/10.1103/PhysRevLett.104.120501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0907.5391" target="_blank" class="href">0907.5391</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-6">[7]</dt>
      <dd>
        N. P. Breuckmann and J. N. Eberhardt, “Balanced Product Quantum Codes”, IEEE Transactions on Information Theory <span class="textbf">67</span>, 6653 (2021). <a href="https://doi.org/10.1109/TIT.2021.3097347" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/2012.09271" target="_blank" class="href">2012.09271</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-7">[8]</dt>
      <dd>
        Annika Niehage, “Quantum Goppa Codes over Hyperelliptic Curves”. <a href="https://arxiv.org/abs/quant-ph/0501074" target="_blank" class="href">quant-ph/0501074</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-8">[9]</dt>
      <dd>
        A. Niehage, “Nonbinary Quantum Goppa Codes Exceeding the Quantum Gilbert-Varshamov Bound”, Quantum Information Processing <span class="textbf">6</span>, 143 (2006). <a href="https://doi.org/10.1007/s11128-006-0047-9" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-9">[10]</dt>
      <dd>
        W. C. Huffman, J.-L. Kim, and P. Solé, <span class="textit">Concise Encyclopedia of Coding Theory</span> (Chapman and Hall/CRC, 2021). <a href="https://doi.org/10.1201/9781315147901" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-10">[11]</dt>
      <dd>
        M. H. Michael et al., “New Class of Quantum Error-Correcting Codes for a Bosonic Mode”, Physical Review X <span class="textbf">6</span>, (2016). <a href="https://doi.org/10.1103/PhysRevX.6.031006" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1602.00008" target="_blank" class="href">1602.00008</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-11">[12]</dt>
      <dd>
        V. V. Albert et al., “Performance and structure of single-mode bosonic codes”, Physical Review A <span class="textbf">97</span>, (2018). <a href="https://doi.org/10.1103/PhysRevA.97.032346" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1708.05010" target="_blank" class="href">1708.05010</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-12">[13]</dt>
      <dd>
        R. C. Bose and D. K. Ray-Chaudhuri, “On a class of error correcting binary group codes”, Information and Control <span class="textbf">3</span>, 68 (1960). <a href="https://doi.org/10.1016/s0019-9958(60)90287-4" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-13">[14]</dt>
      <dd>
        A. L. Grimsmo, J. Combes, and B. Q. Baragiola, “Quantum Computing with Rotation-Symmetric Bosonic Codes”, Physical Review X <span class="textbf">10</span>, (2020). <a href="https://doi.org/10.1103/PhysRevX.10.011058" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1901.08071" target="_blank" class="href">1901.08071</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-14">[15]</dt>
      <dd>
        A. R. Calderbank and P. W. Shor, “Good quantum error-correcting codes exist”, Physical Review A <span class="textbf">54</span>, 1098 (1996). <a href="https://doi.org/10.1103/PhysRevA.54.1098" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9512032" target="_blank" class="href">quant-ph/9512032</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-15">[16]</dt>
      <dd>
        A. M. Steane, “Error Correcting Codes in Quantum Theory”, Physical Review Letters <span class="textbf">77</span>, 793 (1996). <a href="https://doi.org/10.1103/PhysRevLett.77.793" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-16">[17]</dt>
      <dd>
        “Multiple-particle interference and quantum error correction”, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences <span class="textbf">452</span>, 2551 (1996). <a href="https://doi.org/10.1098/rspa.1996.0136" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9601029" target="_blank" class="href">quant-ph/9601029</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-17">[18]</dt>
      <dd>
        H. Bombin and M. A. Martin-Delgado, “Homological error correction: Classical and quantum codes”, Journal of Mathematical Physics <span class="textbf">48</span>, 052105 (2007). <a href="https://doi.org/10.1063/1.2731356" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0605094" target="_blank" class="href">quant-ph/0605094</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-18">[19]</dt>
      <dd>
        Sergey Bravyi and Matthew B. Hastings, “Homological Product Codes”. <a href="https://arxiv.org/abs/1311.0885" target="_blank" class="href">1311.0885</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-19">[20]</dt>
      <dd>
        Nikolas P. Breuckmann, “PhD thesis: Homological Quantum Codes Beyond the Toric Code”. <a href="https://arxiv.org/abs/1802.01520" target="_blank" class="href">1802.01520</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-20">[21]</dt>
      <dd>
        T. Jochym-O&#x27;Connor, “Fault-tolerant gates via homological product codes”, Quantum <span class="textbf">3</span>, 120 (2019). <a href="https://doi.org/10.22331/q-2019-02-04-120" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1807.09783" target="_blank" class="href">1807.09783</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-21">[22]</dt>
      <dd>
        P. T. Cochrane, G. J. Milburn, and W. J. Munro, “Macroscopically distinct quantum-superposition states as a bosonic code for amplitude damping”, Physical Review A <span class="textbf">59</span>, 2631 (1999). <a href="https://doi.org/10.1103/PhysRevA.59.2631" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9809037" target="_blank" class="href">quant-ph/9809037</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-22">[23]</dt>
      <dd>
        Z. Leghtas et al., “Hardware-Efficient Autonomous Quantum Memory Protection”, Physical Review Letters <span class="textbf">111</span>, (2013). <a href="https://doi.org/10.1103/PhysRevLett.111.120501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1207.0679" target="_blank" class="href">1207.0679</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-23">[24]</dt>
      <dd>
        I. L. Chuang, D. W. Leung, and Y. Yamamoto, “Bosonic quantum codes for amplitude damping”, Physical Review A <span class="textbf">56</span>, 1114 (1997). <a href="https://doi.org/10.1103/PhysRevA.56.1114" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-24">[25]</dt>
      <dd>
        A. Cross et al., “Codeword Stabilized Quantum Codes”, IEEE Transactions on Information Theory <span class="textbf">55</span>, 433 (2009). <a href="https://doi.org/10.1109/TIT.2008.2008136" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0708.1021" target="_blank" class="href">0708.1021</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-25">[26]</dt>
      <dd>
        H. Bombin and M. A. Martin-Delgado, “Topological Quantum Distillation”, Physical Review Letters <span class="textbf">97</span>, (2006). <a href="https://doi.org/10.1103/PhysRevLett.97.180501" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-26">[27]</dt>
      <dd>
        A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. <a href="https://doi.org/10.7907/059V-MG69" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-27">[28]</dt>
      <dd>
        H. Bombin, “An Introduction to Topological Quantum Codes”. <a href="https://arxiv.org/abs/1311.0277" target="_blank" class="href">1311.0277</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-28">[29]</dt>
      <dd>
        Peter Elias. Coding for noisy channels. IRE Convention Records, 3(4):37–46, 1955.
      </dd>
      <!-- Citation:  -->
      <dt id="cite-29">[30]</dt>
      <dd>
        M. B. Hastings, “Weight Reduction for Quantum Codes”. <a href="https://arxiv.org/abs/1611.03790" target="_blank" class="href">1611.03790</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-30">[31]</dt>
      <dd>
        Shai Evra, Tali Kaufman, and Gilles Zémor, “Decodable quantum LDPC codes beyond the <span class="inline-math">$\sqrt{n}$</span> distance barrier using high dimensional expanders”. <a href="https://arxiv.org/abs/2004.07935" target="_blank" class="href">2004.07935</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-31">[32]</dt>
      <dd>
        M. A. Levin and X.-G. Wen, “String-net condensation: A physical mechanism for topological phases”, Physical Review B <span class="textbf">71</span>, (2005). <a href="https://doi.org/10.1103/PhysRevB.71.045110" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/cond-mat/0404617" target="_blank" class="href">cond-mat/0404617</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-32">[33]</dt>
      <dd>
        I. L. Chuang and Y. Yamamoto, “Simple quantum computer”, Physical Review A <span class="textbf">52</span>, 3489 (1995). <a href="https://doi.org/10.1103/PhysRevA.52.3489" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-33">[34]</dt>
      <dd>
        P. Hayden and J. Preskill, “Black holes as mirrors: quantum information in random subsystems”, Journal of High Energy Physics <span class="textbf">2007</span>, 120 (2007). <a href="https://doi.org/10.1088/1126-6708/2007/09/120" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0708.4025" target="_blank" class="href">0708.4025</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-34">[35]</dt>
      <dd>
        F. G. S. L. Brandão et al., “Quantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains”, Physical Review Letters <span class="textbf">123</span>, (2019). <a href="https://doi.org/10.1103/PhysRevLett.123.110502" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1710.04631" target="_blank" class="href">1710.04631</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-35">[36]</dt>
      <dd>
        P. Faist et al., “Continuous Symmetries and Approximate Quantum Error Correction”, Physical Review X <span class="textbf">10</span>, (2020). <a href="https://doi.org/10.1103/PhysRevX.10.041018" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1902.07714" target="_blank" class="href">1902.07714</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-36">[37]</dt>
      <dd>
        M. Sipser and D. A. Spielman, “Expander codes”, IEEE Transactions on Information Theory <span class="textbf">42</span>, 1710 (1996). <a href="https://doi.org/10.1109/18.556667" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-37">[38]</dt>
      <dd>
        M. Capalbo et al., “Randomness conductors and constant-degree lossless expanders”, Proceedings of the thiry-fourth annual ACM symposium on Theory of computing  - STOC &#x27;02 (2002). <a href="https://doi.org/10.1145/509907.510003" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-38">[39]</dt>
      <dd>
        S. B. Bravyi and A. Y. Kitaev, “Fermionic Quantum Computation”, Annals of Physics <span class="textbf">298</span>, 210 (2002). <a href="https://doi.org/10.1006/aphy.2002.6254" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0003137" target="_blank" class="href">quant-ph/0003137</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-39">[40]</dt>
      <dd>
        M. B. Hastings and J. Haah, “Dynamically Generated Logical Qubits”, Quantum <span class="textbf">5</span>, 564 (2021). <a href="https://doi.org/10.22331/q-2021-10-19-564" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/2107.02194" target="_blank" class="href">2107.02194</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-40">[41]</dt>
      <dd>
        “Z2-systolic freedom and quantum codes”, Mathematics of Quantum Computation 303 (2002). <a href="https://doi.org/10.1201/9781420035377-13" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-41">[42]</dt>
      <dd>
        M. H. Freedman, “Z2–Systolic-Freedom”, Proceedings of the Kirbyfest (1999). <a href="https://doi.org/10.2140/gtm.1999.2.113" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-42">[43]</dt>
      <dd>
        E. Fetaya, “Bounding the distance of quantum surface codes”, Journal of Mathematical Physics <span class="textbf">53</span>, 062202 (2012). <a href="https://doi.org/10.1063/1.4726034" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-43">[44]</dt>
      <dd>
        Sagarmoy Dutta and Piyush P Kurur, “Quantum Cyclic Code of length dividing <span class="inline-math">$p^{t}+1$</span>”. <a href="https://arxiv.org/abs/1011.5814" target="_blank" class="href">1011.5814</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-44">[45]</dt>
      <dd>
        Sara Bartolucci et al., “Fusion-based quantum computation”. <a href="https://arxiv.org/abs/2101.09310" target="_blank" class="href">2101.09310</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-45">[46]</dt>
      <dd>
        Y. Ouyang, “Permutation-invariant quantum codes”, Physical Review A <span class="textbf">90</span>, (2014). <a href="https://doi.org/10.1103/PhysRevA.90.062317" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1302.3247" target="_blank" class="href">1302.3247</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-46">[47]</dt>
      <dd>
        J. Bierbrauer and Y. Edel, “Quantum twisted codes”, Journal of Combinatorial Designs <span class="textbf">8</span>, 174 (2000). <a href="https://doi.org/10.1002/(SICI)1520-6610(2000)8:3&amp;lt;174::AID-JCD3&amp;gt;3.0.CO;2-T" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-47">[48]</dt>
      <dd>
        Dorit Aharonov and Michael Ben-Or, “Fault-Tolerant Quantum Computation With Constant Error Rate”. <a href="https://arxiv.org/abs/quant-ph/9906129" target="_blank" class="href">quant-ph/9906129</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-48">[49]</dt>
      <dd>
        Alexei Ashikhmin and Emanuel Knill, “Nonbinary Quantum Stabilizer Codes”. <a href="https://arxiv.org/abs/quant-ph/0005008" target="_blank" class="href">quant-ph/0005008</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-49">[50]</dt>
      <dd>
        V. D. Goppa, &quot;A new class of linear error-correcting codes&quot;, Probl. Peredach. Inform., vol. 6, no. 3, pp. 24-30, Sept. 1970.
      </dd>
      <!-- Citation:  -->
      <dt id="cite-50">[51]</dt>
      <dd>
        V. D. Goppa, &quot;Rational representation of codes and (Lg) codes&quot;, Probl. Peredach. Inform., vol. 7, no. 3, pp. 41-49, Sept. 1971.
      </dd>
      <!-- Citation:  -->
      <dt id="cite-51">[52]</dt>
      <dd>
        E. Berlekamp, “Goppa codes”, IEEE Transactions on Information Theory <span class="textbf">19</span>, 590 (1973). <a href="https://doi.org/10.1109/TIT.1973.1055088" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-52">[53]</dt>
      <dd>
        D. Gottesman, A. Kitaev, and J. Preskill, “Encoding a qubit in an oscillator”, Physical Review A <span class="textbf">64</span>, (2001). <a href="https://doi.org/10.1103/PhysRevA.64.012310" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0008040" target="_blank" class="href">quant-ph/0008040</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-53">[54]</dt>
      <dd>
        V. V. Albert, J. P. Covey, and J. Preskill, “Robust Encoding of a Qubit in a Molecule”, Physical Review X <span class="textbf">10</span>, (2020). <a href="https://doi.org/10.1103/PhysRevX.10.031050" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1911.00099" target="_blank" class="href">1911.00099</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-54">[55]</dt>
      <dd>
        L. Guth and A. Lubotzky, “Quantum error correcting codes and 4-dimensional arithmetic hyperbolic manifolds”, Journal of Mathematical Physics <span class="textbf">55</span>, 082202 (2014). <a href="https://doi.org/10.1063/1.4891487" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1310.5555" target="_blank" class="href">1310.5555</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-55">[56]</dt>
      <dd>
        J. Haah, “Local stabilizer codes in three dimensions without string logical operators”, Physical Review A <span class="textbf">83</span>, (2011). <a href="https://doi.org/10.1103/PhysRevA.83.042330" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1101.1962" target="_blank" class="href">1101.1962</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-56">[57]</dt>
      <dd>
        Peter W. Shor, <a href="https://github.com/errorcorrectionzoo/eczoo_data/files/7808154/shor.pdf" target="_blank" class="href">The quantum channel capacity and coherent information</a>, 2002 (obtained from the MSRI Workshop on Quantum Computation website).
      </dd>
      <!-- Citation:  -->
      <dt id="cite-57">[58]</dt>
      <dd>
        P. Hayden et al., “A Decoupling Approach to the Quantum Capacity”, Open Systems &amp; Information Dynamics <span class="textbf">15</span>, 7 (2008). <a href="https://doi.org/10.1142/S1230161208000043" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0702005" target="_blank" class="href">quant-ph/0702005</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-58">[59]</dt>
      <dd>
        I. Devetak, “The private classical capacity and quantum capacity of a quantum channel”. <a href="https://arxiv.org/abs/quant-ph/0304127" target="_blank" class="href">quant-ph/0304127</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-59">[60]</dt>
      <dd>
        Rochus Klesse, “A random-coding based proof for the quantum coding theorem”. <a href="https://arxiv.org/abs/0712.2558" target="_blank" class="href">0712.2558</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-60">[61]</dt>
      <dd>
        M. M. Wilde, “Preface to the Second Edition”, Quantum Information Theory xi. <a href="https://doi.org/10.1017/9781316809976.001" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1106.1445" target="_blank" class="href">1106.1445</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-61">[62]</dt>
      <dd>
        B. Schumacher and M. A. Nielsen, “Quantum data processing and error correction”, Physical Review A <span class="textbf">54</span>, 2629 (1996). <a href="https://doi.org/10.1103/PhysRevA.54.2629" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9604022" target="_blank" class="href">quant-ph/9604022</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-62">[63]</dt>
      <dd>
        M. Horodecki, J. Oppenheim, and A. Winter, “Quantum State Merging and Negative Information”, Communications in Mathematical Physics <span class="textbf">269</span>, 107 (2006). <a href="https://doi.org/10.1007/s00220-006-0118-x" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0512247" target="_blank" class="href">quant-ph/0512247</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-63">[64]</dt>
      <dd>
        G. W. Stewart, “The Efficient Generation of Random Orthogonal Matrices with an Application to Condition Estimators”, SIAM Journal on Numerical Analysis <span class="textbf">17</span>, 403 (1980). <a href="https://doi.org/10.1137/0717034" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-64">[65]</dt>
      <dd>
        R. W. Hamming, “Error Detecting and Error Correcting Codes”, Bell System Technical Journal <span class="textbf">29</span>, 147 (1950). <a href="https://doi.org/10.1002/j.1538-7305.1950.tb00463.x" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-65">[66]</dt>
      <dd>
        Matthew B. Hastings, Jeongwan Haah, and Ryan O&#x27;Donnell, “Fiber Bundle Codes: Breaking the <span class="inline-math">$N^{1/2} \operatorname{polylog}(N)$</span> Barrier for Quantum LDPC Codes”. <a href="https://arxiv.org/abs/2009.03921" target="_blank" class="href">2009.03921</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-66">[67]</dt>
      <dd>
        F. Pastawski et al., “Holographic quantum error-correcting codes: toy models for the bulk/boundary correspondence”, Journal of High Energy Physics <span class="textbf">2015</span>, (2015). <a href="https://doi.org/10.1007/JHEP06(2015)149" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1503.06237" target="_blank" class="href">1503.06237</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-67">[68]</dt>
      <dd>
        Kfir Dolev et al., “Gauging the bulk: generalized gauging maps and holographic codes”. <a href="https://arxiv.org/abs/2108.11402" target="_blank" class="href">2108.11402</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-68">[69]</dt>
      <dd>
        P. Hayden et al., “Spacetime replication of continuous variable quantum information”, New Journal of Physics <span class="textbf">18</span>, 083043 (2016). <a href="https://doi.org/10.1088/1367-2630/18/8/083043" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1601.02544" target="_blank" class="href">1601.02544</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-69">[70]</dt>
      <dd>
        A. Kitaev, “Anyons in an exactly solved model and beyond”, Annals of Physics <span class="textbf">321</span>, 2 (2006). <a href="https://doi.org/10.1016/j.aop.2005.10.005" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/cond-mat/0506438" target="_blank" class="href">cond-mat/0506438</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-70">[71]</dt>
      <dd>
        J.-P. Tillich and G. Zemor, “Quantum LDPC Codes With Positive Rate and Minimum Distance Proportional to the Square Root of the Blocklength”, IEEE Transactions on Information Theory <span class="textbf">60</span>, 1193 (2014). <a href="https://doi.org/10.1109/TIT.2013.2292061" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0903.0566" target="_blank" class="href">0903.0566</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-71">[72]</dt>
      <dd>
        A. A. Kovalev and L. P. Pryadko, “Improved quantum hypergraph-product LDPC codes”, 2012 IEEE International Symposium on Information Theory Proceedings (2012). <a href="https://doi.org/10.1109/ISIT.2012.6284206" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1202.0928" target="_blank" class="href">1202.0928</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-72">[73]</dt>
      <dd>
        A. Y. Kitaev, “Quantum Error Correction with Imperfect Gates”, Quantum Communication, Computing, and Measurement 181 (1997). <a href="https://doi.org/10.1007/978-1-4615-5923-8_19" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-73">[74]</dt>
      <dd>
        A. Y. Kitaev, “Fault-tolerant quantum computation by anyons”, Annals of Physics <span class="textbf">303</span>, 2 (2003). <a href="https://doi.org/10.1016/S0003-4916(02)00018-0" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9707021" target="_blank" class="href">quant-ph/9707021</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-74">[75]</dt>
      <dd>
        S. B. Bravyi and A. Yu. Kitaev, “Quantum codes on a lattice with boundary”. <a href="https://arxiv.org/abs/quant-ph/9811052" target="_blank" class="href">quant-ph/9811052</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-75">[76]</dt>
      <dd>
        G. Zémor, “On Cayley Graphs, Surface Codes, and the Limits of Homological Coding for Quantum Error Correction”, Lecture Notes in Computer Science 259 (2009). <a href="https://doi.org/10.1007/978-3-642-01877-0_21" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-76">[77]</dt>
      <dd>
        P. Panteleev and G. Kalachev, “Degenerate Quantum LDPC Codes With Good Finite Length Performance”, Quantum <span class="textbf">5</span>, 585 (2021). <a href="https://doi.org/10.22331/q-2021-11-22-585" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1904.02703" target="_blank" class="href">1904.02703</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-77">[78]</dt>
      <dd>
        F. G. S. L. Brandão, A. W. Harrow, and M. Horodecki, “Local Random Quantum Circuits are Approximate Polynomial-Designs”, Communications in Mathematical Physics <span class="textbf">346</span>, 397 (2016). <a href="https://doi.org/10.1007/s00220-016-2706-8" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-78">[79]</dt>
      <dd>
        M. J. Gullans et al., “Quantum Coding with Low-Depth Random Circuits”, Physical Review X <span class="textbf">11</span>, (2021). <a href="https://doi.org/10.1103/PhysRevX.11.031066" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/2010.09775" target="_blank" class="href">2010.09775</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-79">[80]</dt>
      <dd>
        S. Bravyi, B. M. Terhal, and B. Leemhuis, “Majorana fermion codes”, New Journal of Physics <span class="textbf">12</span>, 083039 (2010). <a href="https://doi.org/10.1088/1367-2630/12/8/083039" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1004.3791" target="_blank" class="href">1004.3791</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-80">[81]</dt>
      <dd>
        Sagar Vijay and Liang Fu, “Quantum Error Correction for Complex and Majorana Fermion Qubits”. <a href="https://arxiv.org/abs/1703.00459" target="_blank" class="href">1703.00459</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-81">[82]</dt>
      <dd>
        J. R. Wootton, “A family of stabilizer codes for <span class="inline-math">$D({{\mathbb{Z}}_{2}})$</span> anyons and Majorana modes”, Journal of Physics A: Mathematical and Theoretical <span class="textbf">48</span>, 215302 (2015). <a href="https://doi.org/10.1088/1751-8113/48/21/215302" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1501.07779" target="_blank" class="href">1501.07779</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-82">[83]</dt>
      <dd>
        R. Singleton, “Maximum distance&amp;lt;tex&amp;gt;q&amp;lt;/tex&amp;gt;-nary codes”, IEEE Transactions on Information Theory <span class="textbf">10</span>, 116 (1964). <a href="https://doi.org/10.1109/TIT.1964.1053661" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-83">[84]</dt>
      <dd>
        E. M. Gabidulin, &quot;Theory of Codes with Maximum Rank Distance&quot;, Problemy Peredachi Informacii, Volume 21, Issue 1, <span class="emph">3–16</span> (1985)
      </dd>
      <!-- Citation:  -->
      <dt id="cite-84">[85]</dt>
      <dd>
        R. M. Roth, “Maximum-rank array codes and their application to crisscross error correction”, IEEE Transactions on Information Theory <span class="textbf">37</span>, 328 (1991). <a href="https://doi.org/10.1109/18.75248" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-85">[86]</dt>
      <dd>
        B. Skinner, J. Ruhman, and A. Nahum, “Measurement-Induced Phase Transitions in the Dynamics of Entanglement”, Physical Review X <span class="textbf">9</span>, (2019). <a href="https://doi.org/10.1103/PhysRevX.9.031009" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-86">[87]</dt>
      <dd>
        Y. Li, X. Chen, and M. P. A. Fisher, “Quantum Zeno effect and the many-body entanglement transition”, Physical Review B <span class="textbf">98</span>, (2018). <a href="https://doi.org/10.1103/PhysRevB.98.205136" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-87">[88]</dt>
      <dd>
        A. Chan et al., “Unitary-projective entanglement dynamics”, Physical Review B <span class="textbf">99</span>, (2019). <a href="https://doi.org/10.1103/PhysRevB.99.224307" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1808.05949" target="_blank" class="href">1808.05949</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-88">[89]</dt>
      <dd>
        Y. Li, X. Chen, and M. P. A. Fisher, “Measurement-driven entanglement transition in hybrid quantum circuits”, Physical Review B <span class="textbf">100</span>, (2019). <a href="https://doi.org/10.1103/PhysRevB.100.134306" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1901.08092" target="_blank" class="href">1901.08092</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-89">[90]</dt>
      <dd>
        S. Choi et al., “Quantum Error Correction in Scrambling Dynamics and Measurement-Induced Phase Transition”, Physical Review Letters <span class="textbf">125</span>, (2020). <a href="https://doi.org/10.1103/PhysRevLett.125.030505" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1903.05124" target="_blank" class="href">1903.05124</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-90">[91]</dt>
      <dd>
        M. J. Gullans and D. A. Huse, “Dynamical Purification Phase Transition Induced by Quantum Measurements”, Physical Review X <span class="textbf">10</span>, (2020). <a href="https://doi.org/10.1103/PhysRevX.10.041020" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1905.05195" target="_blank" class="href">1905.05195</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-91">[92]</dt>
      <dd>
        A. Zabalo et al., “Critical properties of the measurement-induced transition in random quantum circuits”, Physical Review B <span class="textbf">101</span>, (2020). <a href="https://doi.org/10.1103/PhysRevB.101.060301" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1911.00008" target="_blank" class="href">1911.00008</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-92">[93]</dt>
      <dd>
        Ramis Movassagh and Yingkai Ouyang, “Constructing quantum codes from any classical code and their embedding in ground space of local Hamiltonians”. <a href="https://arxiv.org/abs/2012.01453" target="_blank" class="href">2012.01453</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-93">[94]</dt>
      <dd>
        J. Niset, U. L. Andersen, and N. J. Cerf, “Experimentally Feasible Quantum Erasure-Correcting Code for Continuous Variables”, Physical Review Letters <span class="textbf">101</span>, (2008). <a href="https://doi.org/10.1103/PhysRevLett.101.130503" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0710.4858" target="_blank" class="href">0710.4858</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-94">[95]</dt>
      <dd>
        S. M. Barnett and D. T. Pegg, “Phase in quantum optics”, Journal of Physics A: Mathematical and General <span class="textbf">19</span>, 3849 (1986). <a href="https://doi.org/10.1088/0305-4470/19/18/030" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-95">[96]</dt>
      <dd>
        Greg Kuperberg, “The capacity of hybrid quantum memory”. <a href="https://arxiv.org/abs/quant-ph/0203105" target="_blank" class="href">quant-ph/0203105</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-96">[97]</dt>
      <dd>
        C. Bény, A. Kempf, and D. W. Kribs, “Quantum error correction of observables”, Physical Review A <span class="textbf">76</span>, (2007). <a href="https://doi.org/10.1103/PhysRevA.76.042303" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0705.1574" target="_blank" class="href">0705.1574</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-97">[98]</dt>
      <dd>
        S. Lloyd and J.-J. E. Slotine, “Analog Quantum Error Correction”, Physical Review Letters <span class="textbf">80</span>, 4088 (1998). <a href="https://doi.org/10.1103/PhysRevLett.80.4088" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9711021" target="_blank" class="href">quant-ph/9711021</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-98">[99]</dt>
      <dd>
        S. L. Braunstein, “Error Correction for Continuous Quantum Variables”, Physical Review Letters <span class="textbf">80</span>, 4084 (1998). <a href="https://doi.org/10.1103/PhysRevLett.80.4084" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9711049" target="_blank" class="href">quant-ph/9711049</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-99">[100]</dt>
      <dd>
        Harriet Pollatsek and Mary Beth Ruskai, “Permutationally Invariant Codes for Quantum Error Correction”. <a href="https://arxiv.org/abs/quant-ph/0304153" target="_blank" class="href">quant-ph/0304153</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-100">[101]</dt>
      <dd>
        E. Arikan, “Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels”, IEEE Transactions on Information Theory <span class="textbf">55</span>, 3051 (2009). <a href="https://doi.org/10.1109/TIT.2009.2021379" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-101">[102]</dt>
      <dd>
        M. Grassl, W. Geiselmann, and T. Beth, “Quantum Reed—Solomon Codes”, Applied Algebra, Algebraic Algorithms and Error-Correcting Codes 231 (1999). <a href="https://doi.org/10.1007/3-540-46796-3_23" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9910059" target="_blank" class="href">quant-ph/9910059</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-102">[103]</dt>
      <dd>
        Daniel Gottesman, “Stabilizer Codes and Quantum Error Correction”. <a href="https://arxiv.org/abs/quant-ph/9705052" target="_blank" class="href">quant-ph/9705052</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-103">[104]</dt>
      <dd>
        Michael H. Freedman and David A. Meyer, “Projective plane and planar quantum codes”. <a href="https://arxiv.org/abs/quant-ph/9810055" target="_blank" class="href">quant-ph/9810055</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-104">[105]</dt>
      <dd>
        Andrew Steane, “Quantum Reed-Muller Codes”. <a href="https://arxiv.org/abs/quant-ph/9608026" target="_blank" class="href">quant-ph/9608026</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-105">[106]</dt>
      <dd>
        G. D. Forney, M. Grassl, and S. Guha, “Convolutional and Tail-Biting Quantum Error-Correcting Codes”, IEEE Transactions on Information Theory <span class="textbf">53</span>, 865 (2007). <a href="https://doi.org/10.1109/TIT.2006.890698" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0511016" target="_blank" class="href">quant-ph/0511016</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-106">[107]</dt>
      <dd>
        Sagarmoy Dutta and Piyush P Kurur, “Quantum Cyclic Code”. <a href="https://arxiv.org/abs/1007.1697" target="_blank" class="href">1007.1697</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-107">[108]</dt>
      <dd>
        A. Leverrier, J.-P. Tillich, and G. Zemor, “Quantum Expander Codes”, 2015 IEEE 56th Annual Symposium on Foundations of Computer Science (2015). <a href="https://doi.org/10.1109/FOCS.2015.55" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-108">[109]</dt>
      <dd>
        T. C. Ralph, A. J. F. Hayes, and A. Gilchrist, “Loss-Tolerant Optical Qubits”, Physical Review Letters <span class="textbf">95</span>, (2005). <a href="https://doi.org/10.1103/PhysRevLett.95.100501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0501184" target="_blank" class="href">quant-ph/0501184</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-109">[110]</dt>
      <dd>
        E. Knill, R. Laflamme, and G. Milburn, “Efficient Linear Optics Quantum Computation”. <a href="https://arxiv.org/abs/quant-ph/0006088" target="_blank" class="href">quant-ph/0006088</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-110">[111]</dt>
      <dd>
        J. M. Renes, F. Dupuis, and R. Renner, “Efficient Polar Coding of Quantum Information”, Physical Review Letters <span class="textbf">109</span>, (2012). <a href="https://doi.org/10.1103/PhysRevLett.109.050504" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1109.3195" target="_blank" class="href">1109.3195</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-111">[112]</dt>
      <dd>
        S. X. Cui et al., “Kitaev&#x27;s quantum double model as an error correcting code”, Quantum <span class="textbf">4</span>, 331 (2020). <a href="https://doi.org/10.22331/q-2020-09-24-331" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1908.02829" target="_blank" class="href">1908.02829</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-112">[113]</dt>
      <dd>
        R. Walter Ogburn and J. Preskill, “Topological Quantum Computation”, Quantum Computing and Quantum Communications 341 (1999). <a href="https://doi.org/10.1007/3-540-49208-9_31" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-113">[114]</dt>
      <dd>
        C. Mochon, “Anyon computers with smaller groups”, Physical Review A <span class="textbf">69</span>, (2004). <a href="https://doi.org/10.1103/PhysRevA.69.032306" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0306063" target="_blank" class="href">quant-ph/0306063</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-114">[115]</dt>
      <dd>
        J. K. Pachos, <span class="textit">Introduction to Topological Quantum Computation</span> (Cambridge University Press, 2009). <a href="https://doi.org/10.1017/CBO9780511792908" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-115">[116]</dt>
      <dd>
        R. Townsend and E. Weldon, “Self-orthogonal quasi-cyclic codes”, IEEE Transactions on Information Theory <span class="textbf">13</span>, 183 (1967). <a href="https://doi.org/10.1109/TIT.1967.1053974" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-116">[117]</dt>
      <dd>
        D. E. Muller, “Application of Boolean algebra to switching circuit design and to error detection”, Transactions of the I.R.E. Professional Group on Electronic Computers <span class="textbf">EC-3</span>, 6 (1954). <a href="https://doi.org/10.1109/irepgelc.1954.6499441" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-117">[118]</dt>
      <dd>
        I. Reed, “A class of multiple-error-correcting codes and the decoding scheme”, Transactions of the IRE Professional Group on Information Theory <span class="textbf">4</span>, 38 (1954). <a href="https://doi.org/10.1109/tit.1954.1057465" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-118">[119]</dt>
      <dd>
        I. S. Reed and G. Solomon, “Polynomial Codes Over Certain Finite Fields”, Journal of the Society for Industrial and Applied Mathematics <span class="textbf">8</span>, 300 (1960). <a href="https://doi.org/10.1137/0108018" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-119">[120]</dt>
      <dd>
        P. W. Shor, “Scheme for reducing decoherence in quantum computer memory”, Physical Review A <span class="textbf">52</span>, R2493 (1995). <a href="https://doi.org/10.1103/PhysRevA.52.R2493" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-120">[121]</dt>
      <dd>
        H. Q. Dinh et al., “A class of skew cyclic codes and application in quantum codes construction”, Discrete Mathematics <span class="textbf">344</span>, 112189 (2021). <a href="https://doi.org/10.1016/j.disc.2020.112189" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-121">[122]</dt>
      <dd>
        Delphine Boucher, Willi Geiselmann, and Félix Ulmer, “Skew-cyclic codes”. <a href="https://arxiv.org/abs/math/0604603" target="_blank" class="href">math/0604603</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-122">[123]</dt>
      <dd>
        A. R. Calderbank et al., “Quantum Error Correction and Orthogonal Geometry”, Physical Review Letters <span class="textbf">78</span>, 405 (1997). <a href="https://doi.org/10.1103/PhysRevLett.78.405" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9605005" target="_blank" class="href">quant-ph/9605005</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-123">[124]</dt>
      <dd>
        A. R. Calderbank et al., “Quantum Error Correction via Codes over GF(4)”. <a href="https://arxiv.org/abs/quant-ph/9608006" target="_blank" class="href">quant-ph/9608006</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-124">[125]</dt>
      <dd>
        D. Kribs, R. Laflamme, and D. Poulin, “Unified and Generalized Approach to Quantum Error Correction”, Physical Review Letters <span class="textbf">94</span>, (2005). <a href="https://doi.org/10.1103/PhysRevLett.94.180501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0412076" target="_blank" class="href">quant-ph/0412076</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-125">[126]</dt>
      <dd>
        David W. Kribs et al., “Operator quantum error correction”. <a href="https://arxiv.org/abs/quant-ph/0504189" target="_blank" class="href">quant-ph/0504189</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-126">[127]</dt>
      <dd>
        H. Bombin, “Topological subsystem codes”, Physical Review A <span class="textbf">81</span>, (2010). <a href="https://doi.org/10.1103/PhysRevA.81.032301" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0908.4246" target="_blank" class="href">0908.4246</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-127">[128]</dt>
      <dd>
        H. Bombin, “Gauge Color Codes: Optimal Transversal Gates and Gauge Fixing in Topological Stabilizer Codes”. <a href="https://arxiv.org/abs/1311.0879" target="_blank" class="href">1311.0879</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-128">[129]</dt>
      <dd>
        D. Poulin, “Stabilizer Formalism for Operator Quantum Error Correction”, Physical Review Letters <span class="textbf">95</span>, (2005). <a href="https://doi.org/10.1103/PhysRevLett.95.230504" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0508131" target="_blank" class="href">quant-ph/0508131</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-129">[130]</dt>
      <dd>
        R. Cleve, D. Gottesman, and H.-K. Lo, “How to Share a Quantum Secret”, Physical Review Letters <span class="textbf">83</span>, 648 (1999). <a href="https://doi.org/10.1103/PhysRevLett.83.648" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9901025" target="_blank" class="href">quant-ph/9901025</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-130">[131]</dt>
      <dd>
        S. Bravyi and J. Haah, “Magic-state distillation with low overhead”, Physical Review A <span class="textbf">86</span>, (2012). <a href="https://doi.org/10.1103/PhysRevA.86.052329" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1209.2426" target="_blank" class="href">1209.2426</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-131">[132]</dt>
      <dd>
        R. Koenig, G. Kuperberg, and B. W. Reichardt, “Quantum computation with Turaev–Viro codes”, Annals of Physics <span class="textbf">325</span>, 2707 (2010). <a href="https://doi.org/10.1016/j.aop.2010.08.001" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1002.2816" target="_blank" class="href">1002.2816</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-132">[133]</dt>
      <dd>
        N. P. Breuckmann and B. M. Terhal, “Constructions and Noise Threshold of Hyperbolic Surface Codes”, IEEE Transactions on Information Theory <span class="textbf">62</span>, 3731 (2016). <a href="https://doi.org/10.1109/TIT.2016.2555700" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1506.04029" target="_blank" class="href">1506.04029</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-133">[134]</dt>
      <dd>
        E. Kapit, “Hardware-Efficient and Fully Autonomous Quantum Error Correction in Superconducting Circuits”, Physical Review Letters <span class="textbf">116</span>, (2016). <a href="https://doi.org/10.1103/PhysRevLett.116.150501" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-134">[135]</dt>
      <dd>
        W. Wasilewski and K. Banaszek, “Protecting an optical qubit against photon loss”, Physical Review A <span class="textbf">75</span>, (2007). <a href="https://doi.org/10.1103/PhysRevA.75.042316" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-135">[136]</dt>
      <dd>
        Anthony Leverrier, Simon Apers, and Christophe Vuillot, “Quantum XYZ Product Codes”. <a href="https://arxiv.org/abs/2011.09746" target="_blank" class="href">2011.09746</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-136">[137]</dt>
      <dd>
        Basudha Srivastava, Anton Frisk Kockum, and Mats Granath, “The XYZ<span class="inline-math">$^2$</span> hexagonal stabilizer code”. <a href="https://arxiv.org/abs/2112.06036" target="_blank" class="href">2112.06036</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-137">[138]</dt>
      <dd>
        J. P. Bonilla Ataides et al., “The XZZX surface code”, Nature Communications <span class="textbf">12</span>, (2021). <a href="https://doi.org/10.1038/s41467-021-22274-1" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/2009.07851" target="_blank" class="href">2009.07851</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-138">[139]</dt>
      <dd>
        D. Gottesman, “Class of quantum error-correcting codes saturating the quantum Hamming bound”, Physical Review A <span class="textbf">54</span>, 1862 (1996). <a href="https://doi.org/10.1103/PhysRevA.54.1862" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9604038" target="_blank" class="href">quant-ph/9604038</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-139">[140]</dt>
      <dd>
        L. Vaidman, L. Goldenberg, and S. Wiesner, “Error prevention scheme with four particles”, Physical Review A <span class="textbf">54</span>, R1745 (1996). <a href="https://doi.org/10.1103/PhysRevA.54.R1745" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9603031" target="_blank" class="href">quant-ph/9603031</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-140">[141]</dt>
      <dd>
        Raymond Laflamme et al., “Perfect Quantum Error Correction Code”. <a href="https://arxiv.org/abs/quant-ph/9602019" target="_blank" class="href">quant-ph/9602019</a>
      </dd>
    
    </dl>
   </div>

  </main><!-- #main -->


  <nav id="sidebar">
    <div class="sidebarbox">
      <!--<h1>Pages</h1>-->
      <ul class="navlinks">
        <li><a href="/">Home</a></li>
        <li><a href="/code_graph">Code graph</a></li>
        <li><a href="/all">All codes</a></li>
        <li><a href="/search">Search</a></li>
      </ul>
      <h1><a href="/domain/classical_domain">Classical Domain</a></h1>
      <ul class="navlinks">
        <li><a href="/kingdom/bits_into_bits">Binary Kingdom</a></li>
        <li><a href="/kingdom/q-ary_digits_into_q-ary_digits"><span class="inline-math">\(q\)</span>-ary Digits Kingdom</a></li>
      </ul>
      <h1><a href="/domain/quantum_domain">Quantum Domain</a></h1>
      <ul class="navlinks">
        <li><a href="/kingdom/qubits_into_qubits">Qubit Kingdom</a></li>
        <li><a href="/kingdom/qudits_into_qudits">Cyclic-qudit Kingdom</a></li>
        <li><a href="/kingdom/galois_into_galois">Galois-qudit Kingdom</a></li>
        <li><a href="/kingdom/oscillators">Bosonic Kingdom</a></li>
        <li><a href="/kingdom/fermions">Fermionic Kingdom</a></li>
        <li><a href="/kingdom/group_quantum">Group Kingdom</a></li>
        <li><a href="/kingdom/category_quantum">Category Kingdom</a></li>
      </ul>
      <h1>More</h1>
      <ul class="navlinks">
        <li><a href="/edit_code">Add new code</a></li>
        <li><a href="/additional_resources">Additional resources</a></li>
        <li><a href="/about">About</a></li>
      </ul>
      <!-- <h1>Additional resources</h1> -->
      <!-- <ul class="navlinks"> -->
      <!--   <li>…</li> -->
      <!-- </ul> -->
    </div>
  </nav><!-- #sidebar -->
  <footer id="footer">
    <div class="footer-stuff">
Error correction zoo by Victor V. Albert, Philippe Faist, and
<a href="/about">many contributors</a>.    </div>
  </footer>

</div>
</body>
</html>