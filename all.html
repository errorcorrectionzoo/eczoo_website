<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>
    Index of all codes
 [error correction zoo]
  </title>

  <!-- favicon generated with https://realfavicongenerator.net/ -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <!--<link rel="manifest" href="/site.webmanifest">-->
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#00007f">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <!-- end favicon code -->

  <link type="text/css" rel="stylesheet" href="/css/main.css" />

  <script type="text/javascript">
    window.ecz_baseurl = '/';
  </script>

  <script type="text/javascript" async
	  src="/js/misc.js">
  </script>
  <script type="text/javascript" src="/js/mathjaxinit.js" async>
  </script>



</head>
<body>


<div
  id="bodycontents"
  >

  <div id="header-bg-decoration"></div>

  <a id="logo" href="/"></a>

  <header id="header"></header>

  <main id="main">

Here are a gigantic list of all the codes, sorted alphabetically, that were
included in the error correction zoo.


<ol class="code-index">
  <li>
    <span class="code-name"><a href="/c/topological_abelian">Abelian topological code</a></span><span class="code-description">Code whose codewords realize topological order associated with an abelian group. Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/alternant">Alternant code</a><span class="code-introduced"><a href="#cite-0" class="cite">[1]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/approximate_qecc">Approximate quantum code</a><span class="code-introduced"><a href="#cite-1" class="cite">[2]</a><a href="#cite-2" class="cite">[3]</a><a href="#cite-3" class="cite">[4]</a><a href="#cite-4" class="cite">[5]</a><a href="#cite-5" class="cite">[6]</a><a href="#cite-6" class="cite">[7]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_secret_sharing">Approximate secret-sharing code</a><span class="code-introduced"><a href="#cite-4" class="cite">[5]</a></span></span><span class="code-description">A family of <span class="inline-math">\( [[n,k,d]]_{GF(q)} \)</span> CSS codes approximately correcting errors on up to <span class="inline-math">\(\lfloor (n-1)/2 \rfloor\)</span> qubits, i.e., with approximate distance approaching the no-cloning bound <span class="inline-math">\(n/2\)</span>. Constructed using a non-degenerate CSS code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an <span class="inline-math">\(t\)</span>-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/bacon_shor">Bacon-Shor code</a><span class="code-introduced"><a href="#cite-7" class="cite">[8]</a><a href="#cite-8" class="cite">[9]</a></span></span><span class="code-description">CSS subsystem stabilizer code defined on an <span class="inline-math">\(m_1 \times m_2\)</span> lattice of qubits. It is said to be symmetric when <span class="inline-math">\(m_1=m_2\)</span>. The <span class="inline-math">\(X\)</span>-type and <span class="inline-math">\(Z\)</span>-type stabilizers defined as <span class="inline-math">\(X\)</span> and <span class="inline-math">\(Z\)</span> operators acting on all qubits on adjacent columns and rows, respectively. Let <span class="inline-math">\(O_{i,j}\)</span> denote an operator acting on the qubit at a position <span class="inline-math">\((i,j)\)</span> on the lattice, with <span class="inline-math">\(i\in\{0,1,\ldots ,m_1-1\}\)</span> and <span class="inline-math">\(j\in\{0,1,\ldots,m_2-1\}\)</span>. The code&#x27;s stabilizer group is
<span class="display-math env-align">\begin{align}
\mathsf{S}=\langle X_{i,*}X_{i+1,*},Z_{*,j}Z_{*,j+1}\rangle~,
\end{align}</span>
with generators expressed as products of nearest-neightbour 2-qubit gauge operators,
<span class="display-math env-align">\begin{align}
\begin{split}
X_{i,*}X_{i+1,*}= \bigotimes_{k=0}^{m_2-1} X_{i,k}X_{i+1,k} \\
Z_{*,j}Z_{*,j+1}=\bigotimes_{k=0}^{m_1-1} Z_{k,j}Z_{k,j+1}~.
\end{split}
\end{align}</span>
Syndrome extraction can be done by measuring these gauge operators, which are on fewer qubits and local.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/balanced_product">Balanced product code</a><span class="code-introduced"><a href="#cite-9" class="cite">[10]</a></span></span><span class="code-description">Family of CSS quantum codes based on products of two classical codes which share common symmetries. The balanced product can be understood as taking the usual tensor/hypergraph product and then factoring out the symmetries factored. This reduces the overall number of physical qubits <span class="inline-math">\(n\)</span>, while, under certain circumstances, leaving the number of encoded qubits <span class="inline-math">\(k\)</span> and the code distance <span class="inline-math">\(d\)</span> invariant. This leads to a more favourable encoding rate <span class="inline-math">\(k/n\)</span> and normalized distance <span class="inline-math">\(d/n\)</span> compared to the tensor/hypergraph product.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/bits_into_bits">Binary code</a></span><span class="code-description">Encodes <span class="inline-math">\(K\)</span> states (codewords) in <span class="inline-math">\(n\)</span> binary coordinates and has distance <span class="inline-math">\(d\)</span>. Usually denoted as <span class="inline-math">\((n,K,d)\)</span>. The distance is the minimum Hamming distance between a pair of distinct codewords.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/binary_quantum_goppa">Binary quantum Goppa code</a><span class="code-introduced"><a href="#cite-10" class="cite">[11]</a><a href="#cite-11" class="cite">[12]</a></span></span><span class="code-description">Also known as a <span class="textit">quantum AG code</span>. Binary quantum Goppa codes are a family of <span class="inline-math">\( [[n,k,d]]_{GF(q)} \)</span> CSS codes for <span class="inline-math">\( q=2^m \)</span>, generated using classical Goppa codes.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/repetition">Binary repetition code</a><span class="code-introduced"><a href="#cite-12" class="cite">[13]</a></span></span><span class="code-description"><span class="inline-math">\([n,1,n]\)</span> binary linear code encoding one bit of information into an <span class="inline-math">\(n\)</span>-bit string. The length <span class="inline-math">\(n\)</span> needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a <span class="inline-math">\((n,1)\)</span>-Hamming code.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/binomial">Binomial code</a><span class="code-introduced"><a href="#cite-13" class="cite">[14]</a></span></span><span class="code-description">Bosonic rotation codes designed to approximately protect against errors consisting of powers of raising and lowering operators up to some maximum power. Binomial codes can be thought of as spin-coherent states embedded into an oscillator <a href="#cite-14" class="cite">[15]</a>. The <span class="inline-math">\(q\)</span>-dimensional qudit <span class="inline-math">\((N, S)\)</span> binomial codeword states are <span class="inline-math">\(\{|\overline{i}\rangle\mid i\in \mathbb Z_q \}\)</span>, where
  <span class="display-math env-align">\begin{align}
    |\overline{i}\rangle = \frac{1}{\sqrt{q^N}} \sum_{\substack{p=0\\p\equiv i \pmod{q}}}^{(q-1)(N+1)} \sqrt{\binom{N+1}{p}_q} \ket{p(S+1)}.
  \end{align}</span>
  Here, <span class="inline-math">\(\binom{N+1}{p}_q\)</span> are extended binomial coefficients, or polynomial coeffiients, defined recursively as
  <span class="display-math env-align">\begin{align}
    \binom{n}{m}_1 \equiv 1,\quad \binom{n}{m}_q \equiv \sum_{k=0}^n \binom{n}{k}\binom{k}{m-k}_{q-1}.
  \end{align}</span>
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/bch">Bose–Chaudhuri–Hocquenghem (BCH) code</a><span class="code-introduced"><a href="#cite-15" class="cite">[16]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/oscillators">Bosonic code</a></span><span class="code-description">Also called an <span class="textit">oscillator</span> or a <span class="textit">continuous-variable (CV)</span> code. Encodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one <span class="textit">oscillator</span> (a.k.a. <span class="textit">bosonic mode</span> or <span class="textit">qumode</span>). States of a single oscillator are elements of the Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(\mathbb{R}\)</span>). Ideal codewords may not be normalizable because the space is infinite-dimensional, so approximate versions have to be constructed in practice.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/bosonic_rotation">Bosonic rotation code</a><span class="code-introduced"><a href="#cite-16" class="cite">[17]</a></span></span><span class="code-description">A single-mode Fock-state bosonic code whose codespace is preserved by a phase-space rotation by a multiple of <span class="inline-math">\(2\pi/N\)</span> for some <span class="inline-math">\(N\)</span>. The rotation symmetry ensures that encoded states have support only on every <span class="inline-math">\(N^{\textrm{th}}\)</span> Fock state. For example, single-mode Fock-state codes for <span class="inline-math">\(N=2\)</span> encoding a qubit admit basis states that are, respectively, supported on Fock state sets <span class="inline-math">\(\{|0\rangle,|4\rangle,|8\rangle,\cdots\}\)</span> and <span class="inline-math">\(\{|2\rangle,|6\rangle,|10\rangle,\cdots\}\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/oscillator_stabilizer">Bosonic stabilizer code</a></span><span class="code-description">Bosonic code whose codespace is defined as the common <span class="inline-math">\(+1\)</span> eigenspace of a group of mutually commuting <span class="textit">displacement operators</span> (exponentials of linear combinations of position and momentum operators). Such displacement-based codes closely resemble and inherit some features of qubit stabilizer codes.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/bravyi_bacon_shor">Bravyi-Bacon-Shor (BBS) code</a><span class="code-introduced"><a href="#cite-17" class="cite">[18]</a></span></span><span class="code-description">An <span class="inline-math">\([[n,k,d]]\)</span> CSS subsystem stabilizer code generalizing Bacon-Shor codes to a larger set of qubit geometries. Defined through a binary matrix <span class="inline-math">\(A\)</span> such that physical qubits live on sites <span class="inline-math">\((i,j)\)</span> whenever <span class="inline-math">\(A_{i,j}=1\)</span>. The gauge group is generated by 2-qubit operators, including <span class="inline-math">\(XX\)</span> interations between any two qubits sharing a column in <span class="inline-math">\(A\)</span>, and <span class="inline-math">\(ZZ\)</span> interations between two qubits sharing a row. The code parameters are: <span class="inline-math">\(n=\sum_{i,j}A_{i,j}\)</span>, <span class="inline-math">\(k=\text{rank}(A)\)</span>, and the distance is the minimum weight of any row or column.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/css">Calderbank-Shor-Steane (CSS) stabilizer code</a><span class="code-introduced"><a href="#cite-18" class="cite">[19]</a><a href="#cite-19" class="cite">[20]</a><a href="#cite-20" class="cite">[21]</a></span></span><span class="code-description">An <span class="inline-math">\([[n,k,d]]\)</span> stabilizer code admitting a set of stabilizer generators that are either <span class="inline-math">\(Z\)</span>-type or <span class="inline-math">\(X\)</span>-type Pauli strings. The stabilizer generator matrix is of the form
<span class="display-math env-align">\begin{align}
H=\begin{pmatrix}0 &amp; H_{Z}\\
H_{X} &amp; 0
\end{pmatrix}
\label{eq:parity}
\end{align}</span>
such that the rows of the two blocks must be orthogonal
<span class="display-math env-align">\begin{align}
H_X H_Z^T=0~.
\label{eq:comm}
\end{align}</span>
The above condition guarantees that the <span class="inline-math">\(X\)</span>-stabilizer generators, defined in the symplectic representation as rows of <span class="inline-math">\(H_X\)</span>, commute with the <span class="inline-math">\(Z\)</span>-stabilizer generators associated with <span class="inline-math">\(H_Z\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/cat">Cat code</a><span class="code-introduced"><a href="#cite-21" class="cite">[22]</a><a href="#cite-22" class="cite">[23]</a></span></span><span class="code-description">Rotation-symmetric bosonic Fock-state code encoding a <span class="inline-math">\(q\)</span>-dimensional qudit into one oscillator. Codewords for a qubit code (<span class="inline-math">\(q=2\)</span>) consist of a coherent state <span class="inline-math">\(|\alpha\rangle\)</span> projected onto a subspace of Fock state number modulo <span class="inline-math">\(2(S+1)\)</span>. The logical state <span class="inline-math">\(|\overline{0}\rangle\)</span> is in the <span class="inline-math">\(\{|0\rangle , |2(S+1)\rangle , |4(S+1)\rangle \cdots \}\)</span> Fock-state subspace, while <span class="inline-math">\(|\overline{1}\rangle\)</span> is in the <span class="inline-math">\(\{|(S+1)\rangle, |3(S+1)\rangle , |5(S+1)\rangle , |7(S+1)\rangle \cdots \}\)</span> subspace. An alternative basis, valid for for general <span class="inline-math">\(q\)</span> and <span class="inline-math">\(\alpha\neq 0\)</span>, consists of <span class="inline-math">\(q\)</span> coherent states distributed equidistanctly around a circle in phase space of radius <span class="inline-math">\(\alpha\)</span>.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/category_quantum">Category-based quantum code</a></span><span class="code-description">Encodes a finite-dimensional <span class="textit">logical</span> Hilbert space into a <span class="textit">physical</span> Hilbert space associated with a category. Often associated with a particular topological quantum field theory (TQFT), as the data of such theories is described by a category.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/chuang-leung-yamamoto">Chuang-Leung-Yamamoto code</a><span class="code-introduced"><a href="#cite-23" class="cite">[24]</a></span></span><span class="code-description">Bosonic Fock-state code that encodes <span class="inline-math">\(k\)</span> qubits into <span class="inline-math">\(n\)</span> oscillators, with each oscillator restricted to having at most <span class="inline-math">\(N\)</span> excitations. Codewords are superpositions of oscillator Fock states, either balanced (i.e., uniform) or unbalanced. Codes can be denoted as <span class="inline-math">\([[N,n,2^k,d]]\)</span>, which conflicts with <a href="/c/stabilizer" class="ref">stabilizer code</a> notation.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/clifford-deformed_surface">Clifford-deformed surface code (CDSC)</a><span class="code-introduced"><a href="#cite-24" class="cite">[25]</a></span></span><span class="code-description">A generally non-CSS derivative of the surface code defined by applying a constant-depth Clifford circuit to the original (CSS) surface code. Unlike the surface code, CDSCs include codes whose thresholds and subthreshold performance are enhanced under noise biased towards dephasing. Examples of CDSCs include the XY code, XZZX code, and random CDSCs.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/cws">Codeword stabilized (CWS) code</a><span class="code-introduced"><a href="#cite-25" class="cite">[26]</a></span></span><span class="code-description">This family of codes strictly generalizes stabilizer codes. They are usually denoted by <span class="inline-math">\( \mathcal{Q} = (\mathcal{G},\mathcal{C}) \)</span> where <span class="inline-math">\(\mathcal{G}\)</span> is a graph and <span class="inline-math">\(\mathcal{C}\)</span> is a <span class="inline-math">\( (n,K,d) \)</span> binary classical code. From the graph we form the unique graph state (stabilizer state) <span class="inline-math">\( |G \rangle \)</span>. From the classical code we form Pauli <span class="inline-math">\(Z\)</span>-type operators <span class="inline-math">\( W_i = Z^{c_{i,1}} \otimes \cdots \otimes Z^{c_{i,n}} \)</span>, where <span class="inline-math">\(c_{i,j} \)</span> is the <span class="inline-math">\(j\)</span>-th bit of the <span class="inline-math">\(i\)</span>-th classical codeword. The CWS codewords are then <span class="inline-math">\( | i \rangle =  W_i | G \rangle \)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/color">Color code</a><span class="code-introduced"><a href="#cite-26" class="cite">[27]</a></span></span><span class="code-description">A family of abelian topological <a href="/c/css" class="ref">CSS stabilizer</a> codes defined on a <span class="inline-math">\(D\)</span>-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial <span class="inline-math">\(D\)</span>-complex obtained as a triangulation of the interior of a <span class="inline-math">\(D\)</span>-simplex and (2) is <span class="inline-math">\(D+1\)</span>-colorable. Qubits are placed on the <span class="inline-math">\(D\)</span>-simplices and generators are supported on suitable simplices <a href="#cite-27" class="cite">[28]</a>. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face <a href="#cite-28" class="cite">[29]</a>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_concatenated">Concatenated code</a></span><span class="code-description">A concatenated code is a combination of two codes, an inner code <span class="inline-math">\(C\)</span> and an outer code <span class="inline-math">\(C^\prime\)</span>, where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code <span class="inline-math">\(C^\prime\)</span>, and then one encodes each of the physical registers of <span class="inline-math">\(C^\prime\)</span> in an inner code <span class="inline-math">\(C\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/convolutional">Convolutional code</a><span class="code-introduced"><a href="#cite-29" class="cite">[30]</a></span></span><span class="code-description">Classical codes that are formed using generator polynomials over the finite field with two elements. The encoder slides across contiguous subsets of the input bit-string (like a convolutional neural network) evaluating the polynomials on that window to obtain a number of parity bits. These parity bits are the encoded information. There are many ways to formulate these codes</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/cyclic">Cyclic code</a></span><span class="code-description">A classical code <span class="inline-math">\(C\)</span> of length <span class="inline-math">\(n\)</span> over an alphabet is cyclic if, for each string <span class="inline-math">\(c_1 c_2 \cdots c_n\in C\)</span>, the cyclically shifted string <span class="inline-math">\(c_n c_1 \cdots c_{n-1}\in C\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/distance_balanced">Distance-balanced code</a><span class="code-introduced"><a href="#cite-30" class="cite">[31]</a><a href="#cite-31" class="cite">[32]</a></span></span><span class="code-description">CSS stabilizer code constructed from a CSS code and a classical code using a distance-balancing procedure based on a generalized homological product. The initial code is said to be <span class="textit">unbalanced</span>, i.e., tailored to noise biased toward either bit- or phase-flip errors, and the procedure can result in a code that is treats both types of errors on a more equal footing. The original distance-balancing procedure <a href="#cite-30" class="cite">[31]</a>, later generalized in Ref. <a href="#cite-31" class="cite">[32]</a>, can yield QLDPC codes; see Thm. 1 in Ref. <a href="#cite-30" class="cite">[31]</a>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/double_semion">Double-semion code</a><span class="code-introduced"><a href="#cite-32" class="cite">[33]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/dual">Dual linear code</a><span class="code-introduced"><a href="#cite-12" class="cite">[13]</a></span></span><span class="code-description">For any  <span class="inline-math">\([n,k]_q\)</span> linear code <span class="inline-math">\(C\)</span>, the dual code,
<span class="display-math env-align">\begin{align}
C^\perp = \{ y\in GF(q)^{\times n} ~|~ x\cdot y=0 \forall x\in C\},
\end{align}</span>
is the row space of the parity check matrix of <span class="inline-math">\(C\)</span>. The dual code is the kernel of the encoding map for <span class="inline-math">\(C\)</span>, and <span class="inline-math">\(\dim C^\perp = n-k\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/dual_rail">Dual-rail code</a><span class="code-introduced"><a href="#cite-33" class="cite">[34]</a></span></span><span class="code-description">Two-mode code encoding a logical qubit in Fock states with one excitation. The logical-zero state is represented by <span class="inline-math">\(|01\rangle\)</span>, while the logical-one state is represented by <span class="inline-math">\(|10\rangle\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/dynamic_gen">Dynamically-generated quantum error-correcting code</a><span class="code-introduced"><a href="#cite-34" class="cite">[35]</a></span></span><span class="code-description">Code whose natural definition is in terms of a many-body scaling limit of a local dynamical process. Such processes update the code structure and can include random unitary evolution or non-commuting projective measurements.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/eth">Eigenstate thermalization hypothesis (ETH) code</a><span class="code-introduced"><a href="#cite-35" class="cite">[36]</a></span></span><span class="code-description">Also called a <span class="textit">thermodynamic code</span> <a href="#cite-36" class="cite">[37]</a>. An <span class="inline-math">\(n\)</span>-qubit approximate code whose codespace is formed by eigenstates of a translationally-invariant quantum many-body system which satisfies the Eigenstate Thermalization Hypothesis (ETH). ETH ensures that codewords cannot be locally distinguished in the thermodynamic limit. Relevant many-body systems include 1D non-interacting spin chains, Motzkin chains, or Heisenberg models.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/ecc">Error-correcting code</a></span><span class="code-description">A <span class="textit">code</span> is a subset of a set or <span class="textit">alphabet</span>, with each element called a <span class="textit">codeword</span>. An <span class="textit">error-correcting code</span> consists of <span class="inline-math">\(K\)</span> codewords over an alphabet with <span class="inline-math">\(N\)</span> elements such that it is possible to recover the codewords from errors <span class="inline-math">\(E\)</span> from some error set <span class="inline-math">\(\mathcal{E}\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/expander">Expander code</a><span class="code-introduced"><a href="#cite-37" class="cite">[38]</a></span></span><span class="code-description">Expander codes are binary linear codes whose parity check matrices are derived from the adjacency matrix of bipartite expander graphs. In particular, the rows of the parity check matrix correspond to the right nodes of the bipartite graph and the columns correspond to the left nodes. The codespace is equivalent to all subsets of the left nodes in the graph that have an even number of edges going into every right node of the graph. Since the expander graph is only left regular, these codes do not qualify as LDPC codes.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/expander_lifted_product">Expander lifted-product code</a><span class="code-introduced"><a href="#cite-38" class="cite">[39]</a></span></span><span class="code-description">Family of <span class="inline-math">\(G\)</span>-lifted product codes constructed using two random classical <a href="/c/tanner" class="ref">Tanner codes</a> defined on expander graphs. For certain parameters, this construction yields the first asymptotically good QLDPC codes <a href="#cite-38" class="cite">[39]</a>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/fermions">Fermionic code</a></span><span class="code-description">Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators <a href="#cite-39" class="cite">[40]</a>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/fiber_bundle">Fiber-bundle code</a><span class="code-introduced"><a href="#cite-40" class="cite">[41]</a></span></span><span class="code-description">CSS code constructed by combining a random LDPC code as the base and a cyclic repetition code as the fiber of a fiber bundle. After applying distance balancing, a QLDPC code with distance <span class="inline-math">\(\Omega(n^{3/5}\text{polylog}(n))\)</span> and rate <span class="inline-math">\(\Omega(n^{-2/5}\text{polylog}(n))\)</span> is obtained.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/fibonacci">Fibonacci string-net code</a><span class="code-introduced"><a href="#cite-32" class="cite">[33]</a></span></span><span class="code-description">Quantum error correcting code associated with the Levin-Wen string-net model with the Fibonacci input category, admitting two types of encodings.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qecc_finite">Finite-dimensional quantum error-correcting code</a></span><span class="code-description">Encodes quantum information in a <span class="inline-math">\(K\)</span>-dimensional (<span class="textit">logical</span>) subspace of an <span class="inline-math">\(N\)</span>-dimensional (<span class="textit">physical</span>) Hilbert space such that it is possible to recover said information from errors. The logical subspace is spanned by a basis comprised of <span class="textit">code basis states</span> or <span class="textit">codewords</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/floquet">Floquet code</a><span class="code-introduced"><a href="#cite-41" class="cite">[42]</a></span></span><span class="code-description">Dynamically-generated stabilizer-based code whose logical qubits are generated through a particular sequence of measurements such that the number of logical qubits is larger than when the code is viewed as a static subsystem stabilizer code. The code space is the <span class="inline-math">\(+1\)</span> eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured. As opposed to subsystem codes, only specific measurement sequences maintain the codespace.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/fock_state">Fock-state bosonic code</a></span><span class="code-description">Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. The simplest example is the dual-rail code, which has codewords consisting of single Fock states <span class="inline-math">\(|10\rangle\)</span> and <span class="inline-math">\(|01\rangle\)</span>. This code can detect a single loss error since a loss operator in either mode maps one of the codewords to a different Fock state <span class="inline-math">\(|00\rangle\)</span>. More involved codewords consist of several well-separated Fock states such that multiple loss events can be detected and corrected.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/fractal_surface">Fractal surface code</a><span class="code-introduced"><a href="#cite-42" class="cite">[43]</a><a href="#cite-43" class="cite">[44]</a></span></span><span class="code-description">Kitaev surface code on a fractal geometry, which is obtained by removing qubits from the surface code on a cubic lattice. Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/fracton">Fracton code</a></span><span class="code-description">A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/freedman_meyer_luo">Freedman-Meyer-Luo code</a><span class="code-introduced"><a href="#cite-44" class="cite">[45]</a></span></span><span class="code-description">Hyperbolic surface code constructed using cellulation of a Riemann Manifold <span class="inline-math">\(M\)</span> exhibitng systolic freedom <a href="#cite-45" class="cite">[46]</a>. Codes derived from such manifolds can achieve distances scaling better than <span class="inline-math">\(\sqrt{n}\)</span>, something that is impossible using closed 2D surfaces or 2D surfaces with boundaries <a href="#cite-46" class="cite">[47]</a>. Improved codes are obtained by studying a weak family of Riemann metrics on closed 4-dimensional manifolds <span class="inline-math">\(S^2\otimes S^2\)</span> with the <span class="inline-math">\(Z_2\)</span>-homology.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/frobenius">Frobenius code</a><span class="code-introduced"><a href="#cite-47" class="cite">[48]</a></span></span><span class="code-description">Let <span class="inline-math">\(C\)</span> be a quantum cyclic code on <span class="inline-math">\(n\)</span> prime-dimensional qudits. <span class="inline-math">\(C\)</span> is a Frobenius code if there exists a positive integer <span class="inline-math">\(t\)</span> such that <span class="inline-math">\(n\)</span> divides <span class="inline-math">\(p^t +1\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/fusion">Fusion-based quantum computing (FBQC) code</a><span class="code-introduced"><a href="#cite-48" class="cite">[49]</a></span></span><span class="code-description">Fusion Based Quantum Computing, or FBQC, describes a fault tolerant way to produce <span class="textit">fusion networks</span>, or large entangled states starting from small constant-sized entangled resource states along with destructive measurements called <span class="textit">fusions</span>. These large states can be produced asychronously in the fusion framework and can be used as resources, as in measurement-based quantum computation (MBQC), or as logical states of topological codes. The difference from ordinary MBQC is that error-correction is baked into the state-generation protocol.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/gnu_permutation_invariant">GNU permutation-invariant code</a><span class="code-introduced"><a href="#cite-49" class="cite">[50]</a></span></span><span class="code-description">Can be expressed in terms of Dicke states where the logical states are
<span class="display-math env-align">\begin{align}
|\overline{\pm}\rangle = \sum_{\ell=0}^{n} \frac{(\pm 1)^\ell}{\sqrt{2^n}} \sqrt{n \choose \ell} |D^m_{g \ell}\rangle~.
\end{align}</span>
Here, <span class="inline-math">\(m\)</span> is the number of particles used for encoding <span class="inline-math">\(1\)</span> qubit, and <span class="inline-math">\(g, n \leq m\)</span> are arbitrary positive integers. The state <span class="inline-math">\(|D^m_w\rangle\)</span> is a Dicke state -- a normalized permutation-invariant state on <span class="inline-math">\(m\)</span> qubits with <span class="inline-math">\(w\)</span> excitations, i.e., a normalized sum over all basis elements with <span class="inline-math">\(w\)</span> ones and <span class="inline-math">\(m - w\)</span> zeroes.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/q-ary_digits_into_q-ary_digits">Galois-field <span class="inline-math">\(q\)</span>-ary code</a></span><span class="code-description">Encodes <span class="inline-math">\(K\)</span> states (codewords) in <span class="inline-math">\(n\)</span> <span class="inline-math">\(q\)</span>-ary coordinates over the field <span class="inline-math">\(GF(q)=\mathbb{F}_q\)</span> and has distance <span class="inline-math">\(d\)</span>. Usually denoted as <span class="inline-math">\((n,K,d)_q\)</span>. The distance is the minimum number of coordinates where two strings in the code differ.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/galois_css">Galois-qudit CSS code</a><span class="code-introduced"><a href="#cite-50" class="cite">[51]</a><a href="#cite-51" class="cite">[52]</a></span></span><span class="code-description">An <span class="inline-math">\([[n,k,d]]_{GF(q)} \)</span> Galois-qudit true stabilizer code admitting a set of stabilizer generators that
are either <span class="inline-math">\(Z\)</span>-type or <span class="inline-math">\(X\)</span>-type Galois-qudit Pauli strings.
The stabilizer generator matrix, taking values from <span class="inline-math">\(GF(q)\)</span>, is of the form
<span class="display-math env-align">\begin{align}
H=\begin{pmatrix}0 &amp; H_{Z}\\
H_{X} &amp; 0
\end{pmatrix}
\label{eq:parityg}
\end{align}</span>
such that the rows of the two blocks must be orthogonal
<span class="display-math env-align">\begin{align}
H_X H_Z^T=0~.
\label{eq:commG}
\end{align}</span>
The above condition guarantees that the <span class="inline-math">\(X\)</span>-stabilizer generators, defined in the symplectic representation as rows of <span class="inline-math">\(H_X\)</span>, commute with the <span class="inline-math">\(Z\)</span>-stabilizer generators associated with <span class="inline-math">\(H_Z\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/galois_into_galois">Galois-qudit code</a><span class="code-introduced"><a href="#cite-52" class="cite">[53]</a><a href="#cite-51" class="cite">[52]</a></span></span><span class="code-description">Also called a <span class="inline-math">\(GF(q)\)</span><span class="textit">-</span> or <span class="inline-math">\(\mathbb{F}_q\)</span><span class="textit">-qudit code</span>. Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into a <span class="inline-math">\(q^n\)</span>-dimensional (<span class="inline-math">\(n\)</span>-qudit) Hilbert space, with canonical qudit states <span class="inline-math">\(|k\rangle\)</span> labeled by elements <span class="inline-math">\(k\)</span> of the <span class="textit">Galois field</span> <span class="inline-math">\(GF(q)\)</span> and with <span class="inline-math">\(q\)</span> being a power of a prime <span class="inline-math">\(p\)</span>. A Galois field can be thought of as a vector space whose basis vectors are the <span class="inline-math">\(m\)</span> roots of some polynomial and whose coefficients (i.e., field) are <span class="inline-math">\(p\)</span>th roots of unity. Codes can be denoted as <span class="inline-math">\(((n,K))_{GF(q)}\)</span> or <span class="inline-math">\(((n,K,d))_{GF(q)}\)</span>, whenever the code&#x27;s distance <span class="inline-math">\(d\)</span> is defined. This notation differentiates between Galois-qudit and modular-qudit codes, although the same notation, <span class="inline-math">\(((n,K,d))_q\)</span>, is usually used for both.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/galois_polynomial">Galois-qudit polynomial code (QPyC)</a><span class="code-introduced"><a href="#cite-53" class="cite">[54]</a></span></span><span class="code-description">Also called <span class="textit">quantum Reed-Solomon code</span>. An <span class="inline-math">\([[n,k,n-k+1]]_{GF(q)}\)</span> (with <span class="inline-math">\(q&gt;n\)</span>) Galois-qudit CSS code constructed using two Reed-Solomon codes over <span class="inline-math">\(GF(q)\)</span>. Let <span class="inline-math">\(C_1\)</span> be a <span class="inline-math">\([n,k_1,d_1]_q\)</span> Reed-Solomon code and <span class="inline-math">\(C_2^\perp\)</span> be a <span class="inline-math">\([n,k_2,d_2]_q\)</span> Reed-Solomon code, modified such that <span class="inline-math">\(C_2^\perp \subseteq C_1\)</span> and <span class="inline-math">\(0\le k_2 \le k_1 \le n\)</span>. Then, a polynomial code is a non-degenerate <span class="inline-math">\([[n,k_2,d]]_{GF(q)}\)</span> Galois-qudit CSS code with <span class="inline-math">\(d=\min(n-k_1+1,k_1-k_2+1)\)</span>. The polynomial code is the span of the basis codewords over GF(<span class="inline-math">\(q\)</span>) <span class="display-math env-align">\begin{align} |\overline{\beta_0,\cdots,\beta_{k_2-1}}\rangle = \sum_{(\beta_{k_2},\cdots,\beta_{k_1-1})\in GF(q) } \bigotimes_{i=1}^{n} \left|\sum_{j=0}^{k_1-1} \beta_j \alpha_i^j \right\rangle, \end{align}</span> where <span class="inline-math">\((\alpha_1, \cdots, \alpha_n)\)</span> are <span class="inline-math">\(n\)</span> distinct points chosen for code <span class="inline-math">\(C_1\)</span> from <span class="inline-math">\(GF(q)\setminus \{0\}\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/galois_stabilizer">Galois-qudit stabilizer code</a><span class="code-introduced"><a href="#cite-50" class="cite">[51]</a><a href="#cite-51" class="cite">[52]</a></span></span><span class="code-description">An <span class="inline-math">\(((n,K,d))_{GF(q)}\)</span> Galois-qudit code whose logical subspace is the joint <span class="inline-math">\(+1\)</span> eigenspace of a set of <span class="inline-math">\(|{\mathsf{S}}|\)</span> commuting Galois-qudit Pauli operators forming the code&#x27;s stabilizer group <span class="inline-math">\(\mathsf{S}\)</span>, which cannot contain <span class="inline-math">\(e^{i\phi}I\)</span> for any <span class="inline-math">\(\phi \neq 0\)</span>. The distance <span class="inline-math">\(d\)</span> is the minimum weight of a Galois-qudit Pauli string that implements a nontrivial logical operation in the code.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/generalized_reed_solomon">Generalized Reed-Solomon code</a><span class="code-introduced"><a href="#cite-54" class="cite">[55]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/generalized_concatenated">Generalized concatenated classical code</a></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/generalized_homological_product">Generalized homological product code</a></span><span class="code-description">Stabilizer code formulated using the <a href="/c/css" class="ref">CSS chain-complex</a> construction, with chain complexes consisting of products of other chain complexes. The chain-complex construction of codes yields an interpretation of codes in terms of manifolds, thus allowing for the use of various products from topology in constructing codes. The codes participating in the product can be quantum, classical, or mixed. Products can be of more than two codes, in which case the output code need not be of CSS type (e.g., for <a href="/c/xyz_product" class="ref">XYZ-product codes</a>). The simplest product is a tensor product, with more general products imposing equivalence or symmetry relations on the outputs of the tensor product. A product of two codes can be interpreted as a fiber bundle, with one element of the product being the base and the other being the fiber.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/goppa">Goppa code</a><span class="code-introduced"><a href="#cite-55" class="cite">[56]</a><a href="#cite-56" class="cite">[57]</a><a href="#cite-57" class="cite">[58]</a></span></span><span class="code-description">Let <span class="inline-math">\( G(z) \)</span>  be a polynomial describing a projective plane curve with coefficients from <span class="inline-math">\( GF(q^m) \)</span> for some fixed integer <span class="inline-math">\(m\)</span>. Let <span class="inline-math">\( L \)</span> be a finite subset of the extension field <span class="inline-math">\( GF(q^m) \)</span>  where <span class="inline-math">\(q\)</span> is prime, meaning <span class="inline-math">\( L  = \{\alpha_1, \cdots, \alpha_n\} \)</span> is a subset of nonzero elements of <span class="inline-math">\( GF(q^m) \)</span>. A Goppa code <span class="inline-math">\( \Gamma(L,G) \)</span> is an <span class="inline-math">\([n,k,d]\)</span> linear code consisting of all vectors <span class="inline-math">\(a = a_1, \cdots, a_n\)</span> such that <span class="inline-math">\( R_a(z) =0 \)</span> modulo <span class="inline-math">\(G(z)\)</span>, where <span class="inline-math">\( R_a(z) = \sum_{i=1}^n \frac{a_i}{z - \alpha_i} \)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/gkp">Gottesman-Kitaev-Preskill (GKP) code</a><span class="code-introduced"><a href="#cite-58" class="cite">[59]</a></span></span><span class="code-description">Bosonic qudit-into-oscillator code whose stabilizers are oscillator displacement operators <span class="inline-math">\(\hat{S}_q(2\alpha)=e^{-2i\alpha \hat{p}}\)</span> and <span class="inline-math">\(\hat{S}_p(2\beta)=e^{2i\beta \hat{q}}\)</span>. To ensure <span class="inline-math">\(\hat{S}_q(2\alpha)\)</span> and <span class="inline-math">\(\hat{S}_p(2\beta)\)</span> generate a stabilizer group that is Abelian, there is another constraint that <span class="inline-math">\(\alpha\beta=2k\pi\)</span> where <span class="inline-math">\(k\)</span> is an integer. Codewords can be expressed as equal weight superpositions of coherent states on an infinite lattice, such as a square lattice in phase space with spatial period <span class="inline-math">\(2\sqrt{\pi}\)</span>. The exact GKP state is non-normalizable, so approximate constructs have to be considered.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/homological_classical">Graph homology code</a><span class="code-introduced"><a href="#cite-59" class="cite">[60]</a></span></span><span class="code-description">This code&#x27;s properties are derived from the size two chain complex associated with a particular graph. Given a connected simplicial (no self loops or muliedges) graph <span class="inline-math">\(G = (V, E)\)</span>, which is not a tree, with incidence matrix <span class="inline-math">\(\Gamma\)</span> we can construct a code by choosing a parity check matrix which consists of all the linearly independent rows of <span class="inline-math">\(\Gamma\)</span>. This is a <span class="inline-math">\([n,k,d]\)</span> code with <span class="inline-math">\(n = |E|\)</span>, <span class="inline-math">\(k = 1 - \mathcal{X}(G) = 1-|V|+|E|\)</span>, where <span class="inline-math">\( \mathcal{X}(G)\)</span> is the euler characteristic of the graph. The code distance is equal to the shortest size of a cycle, guaranteed to exist since <span class="inline-math">\(G\)</span> is not a tree.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/group_gkp">Group GKP code</a><span class="code-introduced"><a href="#cite-60" class="cite">[61]</a></span></span><span class="code-description">Group code whose construction is based on nested subgroups <span class="inline-math">\(H\subset K \subset G\)</span>. Logical subspace is spanned by basis states that are equal superpositions of elements of cosets of <span class="inline-math">\(H\)</span> in <span class="inline-math">\(K\)</span>, and can be finite- or infinite-dimensional. Extension of the <a href="/c/gkp" class="ref">GKP code</a> construction.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/group">Group code</a></span><span class="code-description">An <span class="inline-math">\( [n,k]_{q} \)</span> code based on a finite group <span class="inline-math">\( G \)</span> of size <span class="inline-math">\(n \)</span>. A group code for an abelian group is called an <span class="textit">abelian group code</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/group_quantum">Group-based quantum code</a></span><span class="code-description">Encodes a <span class="textit">logical</span> Hilbert space, finite- or infinite-dimensional, into a <span class="textit">physical</span> Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on a second-countable unimodular group. For <span class="inline-math">\(K\)</span>-dimensional logical subspace and for groups <span class="inline-math">\(G^{\times n}\)</span>, can be denoted as <span class="inline-math">\(((n,K))_G\)</span>. When the logical subspace is the Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(G^{\times k}\)</span>, can be denoted as <span class="inline-math">\([[n,k]]_G\)</span>. Ideal codewords may not be normalizable, depending on whether <span class="inline-math">\(G\)</span> is continuous and/or noncompact, so approximate versions have to be constructed in practice.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/four_dimensional_hyperbolic">Guth-Lubotzky code</a><span class="code-introduced"><a href="#cite-61" class="cite">[62]</a></span></span><span class="code-description">Hyperbolic surface code based on cellulations of certain four-dimensional manifolds. The manifolds are shown to have good homology and systolic properties for the purposes of code construction, with corresponding codes exhibiting linear rate.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/haah_cubic">Haah cubic code</a><span class="code-introduced"><a href="#cite-62" class="cite">[63]</a></span></span><span class="code-description">Class of stabilizer codes on a length-<span class="inline-math">\(L\)</span> cubic lattice with one or two qubits per site. We also require that the stabilizer group <span class="inline-math">\(\mathsf{S}\)</span> is translation invariant and generated by two types of operators with support on a cube. In the non-CSS case, these two are related by spatial inversion. For CSS codes, we require that the product of all corner operators is the identity. We lastly require that there are no non-trival &#x27;&#x27;string operators&#x27;&#x27;, meaning that single-site operators are a phase, and any period one logical operator <span class="inline-math">\(l \in \mathsf{S}^{\perp}\)</span> is just a phase. Haah showed in his original construction that there is exactly one non-CSS code of this form, and 17 CSS codes <a href="#cite-62" class="cite">[63]</a>. The non-CSS code is labeled code 0, and the rest are numbered from 1 - 17. Codes 1-4 do not have string logical operators, while codes 11-17 do.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/haar_random">Haar-random code</a><span class="code-introduced"><a href="#cite-63" class="cite">[64]</a><a href="#cite-64" class="cite">[65]</a><a href="#cite-65" class="cite">[66]</a><a href="#cite-66" class="cite">[67]</a></span></span><span class="code-description">Haar-random codewords are generated in a process involving averaging over unitary operations distributed accoding to the Haar measure. Random codes are used to prove statements about the capacity of a quantum channel to transmit quantum information <a href="#cite-67" class="cite">[68]</a>, but encoding and decoding in random <span class="inline-math">\(n\)</span>-qubit codes quickly becomes impractical as <span class="inline-math">\(n\to\infty\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/hadamard">Hadamard code</a></span><span class="code-description">The Hadamard code is dual to the extended Hamming Code.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/hamiltonian">Hamiltonian-based code</a></span><span class="code-description">Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian. The codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/hamming">Hamming code</a><span class="code-introduced"><a href="#cite-68" class="cite">[69]</a></span></span><span class="code-description">Hamming codes are an infinite family of linear codes with parameters <span class="inline-math">\((2^r-1,2^r-r-1, 3)\)</span> for <span class="inline-math">\(r \geq 3\)</span>. The <span class="inline-math">\(r \times (2^r-1) \)</span> parity check matrix <span class="inline-math">\(H\)</span> has all possible non-zero <span class="inline-math">\(r\)</span>-bit strings as its columns. The codewords are <span class="inline-math">\(\{x|Hx=0\}\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/higher_dimensional_surface">Higher-dimensional surface code</a><span class="code-introduced"><a href="#cite-69" class="cite">[70]</a></span></span><span class="code-description">A family of Kitaev surface codes on planar or toric surfaces of dimension greater than two. Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/holographic">Holographic code</a><span class="code-introduced"><a href="#cite-70" class="cite">[71]</a></span></span><span class="code-description">A code whose encoding isometry serves to model aspects of the AdS/CFT holographic duality. Encodes operators in the bulk of the Anti de Sitter (AdS) space, represented by logical qudits, into operators on the boundary of the corresponding Conformal Field Theory (CFT), represented by physical qudits. Encoding can often be represented by a tensor network associated with a tiling of hyperbolic space. See Defn 4.3 of Ref. <a href="#cite-71" class="cite">[72]</a> for a technical formulation.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/homological_cv">Homological bosonic code</a><span class="code-introduced"><a href="#cite-72" class="cite">[73]</a></span></span><span class="code-description">An <span class="inline-math">\([[n,1]]_{\mathbb{R}}\)</span> <a href="/c/oscillator_stabilizer" class="ref">oscillator-into-oscillator CSS code</a> defined using homological structres associated with an <span class="inline-math">\(n-1\)</span> simplex.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/homological_product">Homological product code</a><span class="code-introduced"><a href="#cite-73" class="cite">[74]</a><a href="#cite-74" class="cite">[75]</a></span></span><span class="code-description">CSS code formulated using the <a href="/c/css" class="ref">CSS chain-complex</a> construction in the homological product construction. Stub.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/honeycomb">Honeycomb code</a><span class="code-introduced"><a href="#cite-41" class="cite">[42]</a></span></span><span class="code-description">Floquet code inspired by the Kitaev honeycomb model <a href="#cite-75" class="cite">[76]</a> whose logical qubits are generated through a particular sequence of measurements.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/hybrid_qudit_oscillator">Hybrid qudit-oscillator code</a></span><span class="code-description">Encodes a <span class="inline-math">\(K\)</span>-dimensional logical Hilbert space into <span class="inline-math">\(n_1\)</span> qudits of dimension <span class="inline-math">\(q\)</span> and <span class="inline-math">\(n_2 \neq 0\)</span> oscillators, i.e., the Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(\mathbb{Z}_q^{n_1} \times \mathbb{R}^{n_2}\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/hyperbolic_surface">Hyperbolic surface code</a></span><span class="code-description">An extension of the Kitaev surface code construction to hyperbolic manifolds in dimension two or greater. Given a cellulation of a manifold, qubits are put on <span class="inline-math">\(i\)</span>-dimensional faces, <span class="inline-math">\(X\)</span>-type stabilizers are associated with <span class="inline-math">\((i-1)\)</span>-faces, while <span class="inline-math">\(Z\)</span>-type stabilizers are associated with <span class="inline-math">\(i+1\)</span>-faces.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/hypergraph_product">Hypergraph product code</a><span class="code-introduced"><a href="#cite-76" class="cite">[77]</a><a href="#cite-77" class="cite">[78]</a></span></span><span class="code-description">A family of <span class="inline-math">\([[n,k,d]]\)</span> CSS codes whose construction is based on two binary linear <span class="textit">seed</span> codes <span class="inline-math">\(C_1\)</span> and <span class="inline-math">\(C_2\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/surface">Kitaev surface code</a><span class="code-introduced"><a href="#cite-2" class="cite">[3]</a><a href="#cite-78" class="cite">[79]</a><a href="#cite-79" class="cite">[80]</a>
</span></span><span class="code-description">A family of abelian topological <a href="/c/css" class="ref">CSS stabilizer</a> codes
whose generators are few-body <span class="inline-math">\(X\)</span>-type and <span class="inline-math">\(Z\)</span>-type Pauli strings
associated to the stars and plaquettes, respectively, of a cellulation of a
two-dimensional surface (with a qubit located at each edge of the
cellulation). <span class="textit">Toric code</span> often either refers to the construction on
the two-dimensional torus or is an alternative name for the general
construction. The construction on surfaces with boundaries is often called the
<span class="textit">planar code</span> <a href="#cite-80" class="cite">[81]</a>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/points_into_lattices">Lattice-based code</a></span><span class="code-description">Encodes states (codewords) in coordinates of a lattice in the <span class="inline-math">\(n\)</span>-dimensional real coordinate space <span class="inline-math">\(\mathbb{R}^n\)</span>. The number of codewords may be infinite because the coordinate space is infinite-dimensional, so various restricted versions have to be constructed in practice. Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/lifted_product">Lifted-product (LP) code</a><span class="code-introduced"><a href="#cite-81" class="cite">[82]</a><a href="#cite-38" class="cite">[39]</a></span></span><span class="code-description">Code that utilizes the notion of a lifted product in its construction. Lifted products of certain classical Tanner codes are the first (asymptotically) <span class="textit">good QLDPC codes</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/q-ary_linear">Linear <span class="inline-math">\(q\)</span>-ary code</a></span><span class="code-description">An <span class="inline-math">\((n,K,d)_q\)</span> linear code is denoted as <span class="inline-math">\([n,k,d]_q\)</span>, where <span class="inline-math">\(k=\log_{q}K\)</span> need not be an integer. Its codewords form a linear subspace, i.e., for any codewords <span class="inline-math">\(x,y\)</span>, <span class="inline-math">\(\alpha x+ \beta y\)</span> is also a codeword for any <span class="inline-math">\(q\)</span>-ary digits <span class="inline-math">\(\alpha,\beta\)</span>. Often defined in terms of a generator matrix <span class="inline-math">\(G\)</span>, whose rows form a basis for the subspace. Given a codeword <span class="inline-math">\(x\)</span>, the corresponding encoded codeword is <span class="inline-math">\(G^T x\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/binary_linear">Linear binary code</a></span><span class="code-description">An <span class="inline-math">\((n,2^k,d)\)</span> linear code is denoted as <span class="inline-math">\([n,k,d]\)</span>. Its codewords form a linear subspace, i.e., for any codewords <span class="inline-math">\(x,y\)</span>, <span class="inline-math">\(x+y\)</span> is also a codeword. Often defined in terms of a <span class="textit">generator matrix</span> <span class="inline-math">\(G\)</span>, whose rows form a basis for the <span class="inline-math">\(k\)</span>-dimensional codespace. Given a codeword <span class="inline-math">\(x\)</span>, the corresponding encoded codeword is <span class="inline-math">\(G^T x\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/t-designs">Local Haar-random circuit code</a><span class="code-introduced"><a href="#cite-82" class="cite">[83]</a></span></span><span class="code-description">An <span class="inline-math">\(n\)</span>-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal <span class="inline-math">\(n\)</span>-qubit states and acting with a random unitary circuit of depth polynomial in <span class="inline-math">\(n\)</span>. Two states are <span class="textit">locally indistinguishable</span> if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about <span class="inline-math">\(n/2\)</span> two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries.
The above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (<span class="inline-math">\(D=1\)</span>, while codes for higher-dimensional geometries require <span class="inline-math">\(O(n^{1/D})\)</span>-depth circuits <a href="#cite-82" class="cite">[83]</a>. Follow-up work <a href="#cite-83" class="cite">[84]</a> revealed that optimal code properties require only <span class="inline-math">\(O(\sqrt{n})\)</span>-depth circuits for that case, and <span class="inline-math">\(O(\sqrt{n})\)</span>-depth circuits for a two-dimensional square-lattice geometry.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/ldpc">Low-density parity-check (LDPC) code</a></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/nonlocal_lowdepth">Low-depth random Clifford-circuit code</a><span class="code-introduced"><a href="#cite-84" class="cite">[85]</a></span></span><span class="code-description">An encoder for an <span class="inline-math">\([[n,k]]\)</span> quantum error correcting code, is an <span class="inline-math">\(n\)</span>-qubit unitary transformation that takes a <span class="inline-math">\(k\)</span>-qubit state as input (with <span class="inline-math">\(k\leq n\)</span>, and the remaining <span class="inline-math">\(n-k\)</span> qubits initialized to <span class="inline-math">\(|0\rangle^{\otimes n-k}\)</span> ) to give a corresponding state in the codespace as the output. An n-qubit quantum circuit with random 2-qubit Clifford gates can act as an encoder into a code with distance <span class="inline-math">\(d\)</span> with high probability, with a size (i.e. number of gates in the circuit) at most <span class="inline-math">\(O(n^2 log n)\)</span>). Noting that two gates acting on disjoint qubits could in fact be executed simultaneously, this is equivalent to the depth (number of time steps in the circuit) being at most <span class="inline-math">\(O(log^3 n)\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/majorana_stab">Majorana stabilizer code</a><span class="code-introduced"><a href="#cite-85" class="cite">[86]</a></span></span><span class="code-description">Majorana fermion stabilizer codes are stabilizer codes whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as <span class="textit">Majorana stabilizers</span>. The codespace is the mutual <span class="inline-math">\(+1\)</span> eigenspace of all Majorana stabilizers. In such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes. Codes can be denoted as <span class="inline-math">\([[n,k,d]]_{f}\)</span> <a href="#cite-86" class="cite">[87]</a>, where <span class="inline-math">\(n\)</span> is the number of fermionic modes.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/matching">Matching code</a><span class="code-introduced"><a href="#cite-87" class="cite">[88]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/matrices_into_matrices">Matrix code</a></span><span class="code-description">Encodes <span class="inline-math">\(K\)</span> states (codewords) in an <span class="inline-math">\(m\times n\)</span>-dimensional <span class="textit">matrix</span> of coordinates over the field <span class="inline-math">\(GF(q)\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/mds">Maximum distance separable (MDS) code</a><span class="code-introduced"><a href="#cite-88" class="cite">[89]</a></span></span><span class="code-description">A <span class="inline-math">\([n,k,d]_q\)</span> <span class="inline-math">\(q\)</span>-ary linear code is an MDS code if parameters <span class="inline-math">\(n\)</span>, <span class="inline-math">\(k\)</span>, <span class="inline-math">\(d\)</span>, and <span class="inline-math">\(q\)</span> are such that the Singleton bound
<span class="display-math env-align">\begin{align}
d \leq n-k+1
\end{align}</span>
becomes an equality. A bound for general <span class="inline-math">\(q\)</span>-ary codes can also be formulated; see Thm. 1.9.10 in Ref. <a href="#cite-12" class="cite">[13]</a>.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/maximum_rank_distance">Maximum-rank vector code</a><span class="code-introduced"><a href="#cite-89" class="cite">[90]</a><a href="#cite-90" class="cite">[91]</a></span></span><span class="code-description">Linear rank-metric code with maximum rank <span class="inline-math">\([n,k,n-k+1]_q\)</span> over rank metric. For any vector <span class="inline-math">\(g=(g_1, \ldots, g_n)\)</span> with linearly independent elements <span class="inline-math">\(g_i\)</span> over <span class="inline-math">\(GF(q)\)</span>,
the generator matrix
<span class="display-math env-align">\begin{align}
G = \begin{pmatrix} g_1^{[0]} &amp; g_2^{[0]} &amp; \ldots &amp; g_n^{[0]} \\ g_1^{[1]} &amp; g_2^{[1]} &amp; \ldots &amp; g_n^{[1]} \\ g_1^{[k-1]} &amp; g_2^{[k-1]} &amp; \ldots &amp; g_n^{[k-1]} \end{pmatrix}~,
\end{align}</span>
where <span class="inline-math">\([i]:=q^i\)</span> and <span class="inline-math">\(k=n-d+1\)</span> defines a maximum rank distance code.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qudit_css">Modular-qudit CSS code</a><span class="code-introduced"><a href="#cite-50" class="cite">[51]</a><a href="#cite-51" class="cite">[52]</a></span></span><span class="code-description">An <span class="inline-math">\(((n,K,d))_q\)</span> modular-qudit stabilizer code admitting a set of stabilizer generators that
are either <span class="inline-math">\(Z\)</span>-type or <span class="inline-math">\(X\)</span>-type Pauli strings.
The stabilizer generator matrix, taking values from <span class="inline-math">\(\mathbb{Z}_q\)</span>, is of the form
<span class="display-math env-align">\begin{align}
H=\begin{pmatrix}0 &amp; H_{Z}\\
H_{X} &amp; 0
\end{pmatrix}
\label{eq:parityq}
\end{align}</span>
such that the rows of the two blocks must be orthogonal
<span class="display-math env-align">\begin{align}
H_X H_Z^T=0~.
\label{eq:commQ}
\end{align}</span>
The above condition guarantees that the <span class="inline-math">\(X\)</span>-stabilizer generators, defined in the symplectic representation as rows of <span class="inline-math">\(H_X\)</span>, commute with the <span class="inline-math">\(Z\)</span>-stabilizer generators associated with <span class="inline-math">\(H_Z\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qudits_into_qudits">Modular-qudit code</a></span><span class="code-description">Also called a <span class="inline-math">\(\mathbb{Z}_q\)</span><span class="textit">-qudit code</span>. Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into a <span class="inline-math">\(q^n\)</span>-dimensional (<span class="inline-math">\(n\)</span>-qudit) Hilbert space, with canonical qudit states <span class="inline-math">\(|k\rangle\)</span> labeled by elements <span class="inline-math">\(k\)</span> of the group <span class="inline-math">\(\mathbb{Z}_q\)</span> of integers <span class="textit">modulo</span> <span class="inline-math">\(q\)</span>. Usually denoted as <span class="inline-math">\(((n,K))_q\)</span> or <span class="inline-math">\(((n,K,d))_q\)</span>, whenever the code&#x27;s distance <span class="inline-math">\(d\)</span> is defined, and with <span class="inline-math">\(q=p\)</span> when the dimension is prime.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qudit_stabilizer">Modular-qudit stabilizer code</a><span class="code-introduced"><a href="#cite-91" class="cite">[92]</a></span></span><span class="code-description">An <span class="inline-math">\(((n,K,d))_q\)</span> modular-qudit code whose logical subspace is the joint <span class="inline-math">\(+1\)</span> eigenspace of a set of <span class="inline-math">\(|{\mathsf{S}}|\)</span> commuting qudit Pauli operators forming the code&#x27;s stabilizer group <span class="inline-math">\({\mathsf{S}}\)</span>, which cannot contain <span class="inline-math">\(e^{i \phi} I\)</span> for any <span class="inline-math">\(\phi \neq 0\)</span>. The distance <span class="inline-math">\(d\)</span> is the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qudit_surface">Modular-qudit surface code</a><span class="code-introduced"><a href="#cite-79" class="cite">[80]</a></span></span><span class="code-description">A family of stabilizer codes whose generators are few-body <span class="inline-math">\(X\)</span>-type and <span class="inline-math">\(Z\)</span>-type Pauli strings associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit located at each edge of the tesselation). The code has <span class="inline-math">\( n=E \)</span> many physical qudits, where <span class="inline-math">\( E \)</span> is the number of edges of the tesselation, and <span class="inline-math">\( k=2g \)</span> many logical qudits, where <span class="inline-math">\( g \)</span> is the genus of the surface.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/molecular">Molecular code</a><span class="code-introduced"><a href="#cite-60" class="cite">[61]</a></span></span><span class="code-description">Encodes finite-dimensional Hilbert space into the Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on the group <span class="inline-math">\(SO_3\)</span>. Construction is based on nested subgroups <span class="inline-math">\(H\subset K \subset SO_3\)</span>, where <span class="inline-math">\(H,K\)</span> are finite. The <span class="inline-math">\(|K|/|H|\)</span>-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of <span class="inline-math">\(H\)</span> in <span class="inline-math">\(K\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/monitored_random_circuits">Monitored random-circuit code</a><span class="code-introduced"><a href="#cite-92" class="cite">[93]</a><a href="#cite-93" class="cite">[94]</a><a href="#cite-94" class="cite">[95]</a></span></span><span class="code-description">Error-correcting code arising from a monitored random circuit. Such a circuit is described by a series of intermittant random local projective Pauli measurements with random unitary time-evolution operators. An important sub-family consists of <span class="textit">Clifford monitored random circuits</span>, where unitaries are sampled from the Clifford group <a href="#cite-95" class="cite">[96]</a>. When the rate of projective measurements is independently controlled by a probability parameter <span class="inline-math">\(p\)</span>, there can exist two stable phases, one described by volume-law entanglement entropy and the other by area-law entanglement entropy. The phases and their transition can be understood from the perspective of quantum error correction, information scrambling, and channel capacities <a href="#cite-96" class="cite">[97]</a><a href="#cite-97" class="cite">[98]</a>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/movassagh_ouyang">Movassagh-Ouyang Hamiltonian code</a><span class="code-introduced"><a href="#cite-98" class="cite">[99]</a></span></span><span class="code-description">This is a family of codes derived via an algorithm that takes as input <span class="textit">any</span> binary classical code and outputs a quantum code (note that this framework can be extended to <span class="inline-math">\(q\)</span>-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/niset_andersen_cerf">Niest-Andersen-Cerf code</a><span class="code-introduced"><a href="#cite-99" class="cite">[100]</a></span></span><span class="code-description">Encodes two-mode coherent states <span class="inline-math">\(\{|\alpha\rangle, |\beta\rangle\}\)</span> over two modes into four modes such that the values <span class="inline-math">\((\alpha,\beta)\)</span> are recoverable after a single-mode erasure. There are two variations of the storage procedure: a deterministic protocol that offers recovery against a single mode erasure, and a probabalistic that can protect against multiple errors with post selection. This code is effectively protecting classical information stored in <span class="inline-math">\((\alpha,\beta)\)</span> using quantum operations.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/number_phase">Number-phase code</a><span class="code-introduced"><a href="#cite-16" class="cite">[17]</a></span></span><span class="code-description">Bosonic rotation code consisting of superpositions of Pegg-Barnett phase states <a href="#cite-100" class="cite">[101]</a>,
<span class="display-math env-align">\begin{align}
|\phi\rangle \equiv \frac{1}{\sqrt{2\pi}}\sum_{n=0}^{\infty} \mathrm{e}^{\mathrm{i} n \phi} \ket{n}.
\end{align}</span>
Since phase states and thus the ideal codewords are not normalizable, approximate versions need to be constructed. The codes&#x27; key feature is that, in the ideal case, phase measurement has zero uncertainty, making it a good canditate for a syndrome measurement.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/oaecc">Operator-algebra error-correcting code</a><span class="code-introduced"><a href="#cite-101" class="cite">[102]</a><a href="#cite-102" class="cite">[103]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/oscillators_into_oscillators">Oscillator-into-oscillator code</a><span class="code-introduced"><a href="#cite-103" class="cite">[104]</a><a href="#cite-104" class="cite">[105]</a></span></span><span class="code-description">Encodes Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(\mathbb{R}^k\)</span> into that on <span class="inline-math">\(\mathbb{R}^n\)</span>. Usually denoted as <span class="inline-math">\(((n,k))_{\mathbb{R}}\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/parity_check">Parity-check code</a></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/happy">Pastawski-Yoshida-Harlow-Preskill (HaPPY) code</a><span class="code-introduced"><a href="#cite-70" class="cite">[71]</a></span></span><span class="code-description">Holographic code constructed out of a network of perfect tensors that tesselates hyperbolic space. Physical qubits are associated with uncontracted tensor legs at the boundary of the tesselation, while logical qubits are associated with uncontracted legs in the bulk. The code serves as a minimal model for several aspects of the AdS/CFT holographic duality. The construction below is described for qubits, but straightforward generalizations exist to modular qudits, oscillators, and rotors <a href="#cite-36" class="cite">[37]</a>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/perfect">Perfect code</a></span><span class="code-description">An <span class="inline-math">\((n,K,2t+1)_q\)</span> <span class="inline-math">\(q\)</span>-ary code is perfect if parameters <span class="inline-math">\(n\)</span>, <span class="inline-math">\(K\)</span>, <span class="inline-math">\(t\)</span>, and <span class="inline-math">\(q\)</span> are such that the Hamming (a.k.a. sphere-packing) bound
<span class="display-math env-align">\begin{align}
\sum_{j=0}^{t}(q-1)^{j}{n \choose j}\leq q^{n}/K
\end{align}</span>
becomes an equality. For example, for a binary <span class="inline-math">\(q=2\)</span> code with one logical bit (<span class="inline-math">\(K=2\)</span>) and <span class="inline-math">\(t=1\)</span>, the bound becomes <span class="inline-math">\(n+1 \leq 2^{n-1}\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_perfect">Perfect quantum code</a></span><span class="code-description">A non-degenerate code constructed out of <span class="inline-math">\(q\)</span>-dimensional qudits and having parameters <span class="inline-math">\(((n,K,2t+1))\)</span> is perfect if <span class="inline-math">\(n\)</span>, <span class="inline-math">\(K\)</span>, <span class="inline-math">\(t\)</span>, and <span class="inline-math">\(q\)</span> are such that the quantum Hamming bound
<span class="display-math env-align">\begin{align}
\sum_{j=0}^{t}(q^2-1)^{j}{n \choose j}\leq q^{n}/K
\end{align}</span>
becomes an equality. For example, for a qubit <span class="inline-math">\(q=2\)</span> code with one logical qubit (<span class="inline-math">\(K=2\)</span>) and <span class="inline-math">\(t=1\)</span>, the bound becomes <span class="inline-math">\(3n+1 \leq 2^{n-1}\)</span>. The bound can be saturated only at certain <span class="inline-math">\(n\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/permutation_invariant">Permutation-invariant code</a><span class="code-introduced"><a href="#cite-105" class="cite">[106]</a></span></span><span class="code-description">Codes which are stabilized by the symmetric group <span class="inline-math">\(S_n\)</span> on <span class="inline-math">\(n\)</span> elements, in a generalization of stabilizer codes to binary codes utilizing (non-abelian) group actions (in particular, <span class="inline-math">\(S_n\)</span> is non-abelian).</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/polar">Polar code</a><span class="code-introduced"><a href="#cite-106" class="cite">[107]</a></span></span><span class="code-description">In its basic version, a binary linear polar code encodes <span class="inline-math">\(K\)</span> message bits into <span class="inline-math">\(N=2^n\)</span> bits. The linear transformation that defines the code is given by the matrix <span class="inline-math">\(G^{(n)}=B_N G^{\otimes n}\)</span>, where <span class="inline-math">\(B_N\)</span> is a certain <span class="inline-math">\(N\times N\)</span> permutation matrix, and <span class="inline-math">\(G^{\otimes n}\)</span> is the <span class="inline-math">\(n\)</span>th Kronecker power of the <span class="inline-math">\(2\times 2\)</span> <span class="textit">kernel</span> matrix <span class="inline-math">\(G=\left[\begin{smallmatrix}1 &amp; 0\\ 1 &amp; 1 \end{smallmatrix}\right]\)</span>. To encode <span class="inline-math">\(K\)</span> message bits, one forms an <span class="inline-math">\(N\)</span>-vector <span class="inline-math">\(u\)</span> in which <span class="inline-math">\(K\)</span> coordinates represent the message bits. The remaining <span class="inline-math">\(N-K\)</span> coordinates are set to some fixed values and are said to be <span class="textit">frozen</span>. The codeword <span class="inline-math">\(x \in \{0,1\}^N\)</span> is obtained as <span class="inline-math">\(x=u G^{\otimes n}\)</span>. The choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/polynomial">Prime-qudit polynomial code (QPyC)</a><span class="code-introduced"><a href="#cite-107" class="cite">[108]</a></span></span><span class="code-description">Also called <span class="textit">quantum Reed-Solomon code</span>. An <span class="inline-math">\([[n,k,n-k+1]]_p\)</span> (with prime <span class="inline-math">\(p&gt;n\)</span>) prime-qudit CSS code constructed using two Reed-Solomon codes over <span class="inline-math">\(GF(p)=\mathbb{Z}_p\)</span>. Let <span class="inline-math">\(\{\alpha_1,\cdots,\alpha_n\}\)</span> be <span class="inline-math">\(n\)</span> distinct nonzero elements of <span class="inline-math">\(\mathbb{Z}_p\)</span>, and let <span class="inline-math">\(g\)</span> be a number satisfying <span class="inline-math">\(0\leq k \leq g &lt; n\)</span>. Then, define degree-<span class="inline-math">\(g\)</span> polynomials
<span class="display-math env-align">\begin{align}
  f_{\mu\cup c}\left(x\right)=\mu_{0}+\mu_{1}x+\cdots+\mu_{k-1}x^{k-1}+c_{k}x^{k}+\cdots+c_{g}x^{g}\,,
\end{align}</span>
where the first <span class="inline-math">\(k\)</span> coefficients are indexed by the coefficient vector <span class="inline-math">\(\mu\in\mathbb{Z}_p^{\times k}\)</span>, and the remaining coefficients are indexed by the vector <span class="inline-math">\(c\in\mathbb{Z}_p^{\times (g+1-k)}\)</span>. Logical states, labeled by <span class="inline-math">\(\mu\)</span>, are superpositions of canonical basis states whose <span class="inline-math">\(i\)</span>th bit is <span class="inline-math">\(f_{\mu\cup c}\)</span>, evaluated at <span class="inline-math">\(\alpha_i\)</span> and summed over all possible vectors <span class="inline-math">\(c\)</span>,
<span class="display-math env-align">\begin{align}
  |\overline{\mu}\rangle=\sum_{c\in\mathbb{Z}_{p}^{\times(g+1-k)}}|f_{\mu\cup c}(\alpha_{1}),|f_{\mu\cup c}(\alpha_{2}),\cdots,|f_{\mu\cup c}(\alpha_{n})\rangle.
\end{align}</span>
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/real_projective_plane">Projective-plane surface code</a><span class="code-introduced"><a href="#cite-108" class="cite">[109]</a></span></span><span class="code-description">A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold <span class="inline-math">\(\mathbb{R}P^2\)</span> (in contrast to a genus-<span class="inline-math">\(g\)</span> surface). Whereas genus-<span class="inline-math">\(g\)</span> surface codes require <span class="inline-math">\(2g\)</span> logical qubits, qubit codes on <span class="inline-math">\(\mathbb{R}P^2\)</span> are made from a single logical qubit.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_reed_muller">Quantum Reed-Muller code</a><span class="code-introduced"><a href="#cite-109" class="cite">[110]</a></span></span><span class="code-description">A CSS code formed from a classical Reed-Muller code in which polynomials over finite fields encode data. This is done by transforming these polynomials into the stabilizer generator matrices</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_convolutional">Quantum convolutional code</a><span class="code-introduced"><a href="#cite-110" class="cite">[111]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_cyclic">Quantum cyclic code</a><span class="code-introduced"><a href="#cite-111" class="cite">[112]</a></span></span><span class="code-description">A code <span class="inline-math">\(C\)</span> constructed in a physical space consisting of a tensor product of <span class="inline-math">\(n\)</span> subsystems (e.g., qubits) is cyclic if a cyclic permutation of the subsystems leaves the code subspace invariant.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qecc">Quantum error-correcting code (QECC)</a></span><span class="code-description">Encodes quantum information in a (<span class="textit">logical</span>) subspace of a (<span class="textit">physical</span>) Hilbert space such that it is possible to recover said information from errors that act as linear maps on the physical space. The logical subspace is spanned by a basis comprised of <span class="textit">code basis states</span> or <span class="textit">codewords</span>. Codewords may not be normalizable if the physical Hilbert space in infinite, so approximate versions have to be constructed in practice.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_expander">Quantum expander code</a><span class="code-introduced"><a href="#cite-112" class="cite">[113]</a></span></span><span class="code-description">CSS codes constructed from a hypergraph product of bipartite expander graphs with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as <span class="inline-math">\(X\)</span> checks, and the parity check matrix of the other as <span class="inline-math">\(Z\)</span> checks.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qldpc">Quantum low-density parity-check (QLDPC) code</a><span class="code-introduced"><a href="#cite-113" class="cite">[114]</a></span></span><span class="code-description">Family of <span class="inline-math">\([[n,k,d]]\)</span> stabilizer codes for which the number of sites (either qubit or qudit) participating in each stabilizer generator and the number of stabilizer generators that each site participates in are both bounded by a constant as <span class="inline-math">\(n\to\infty\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_mds">Quantum maximum-distance-separable (MDS) code</a></span><span class="code-description">An <span class="inline-math">\(((n,q^k,d))\)</span> code constructed out of <span class="inline-math">\(q\)</span>-dimensional qudits is an MDS code if parameters <span class="inline-math">\(n\)</span>, <span class="inline-math">\(k\)</span>, <span class="inline-math">\(d\)</span>, and <span class="inline-math">\(q\)</span> are such that the quantum Singleton bound
<span class="display-math env-align">\begin{align}
2(d-1) \leq n-k
\end{align}</span>
becomes an equality.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_parity">Quantum parity code (QPC)</a><span class="code-introduced"><a href="#cite-114" class="cite">[115]</a><a href="#cite-115" class="cite">[116]</a></span></span><span class="code-description">A <span class="inline-math">\([[m_1 m_2,1,\min(m_1,m_2)]]\)</span> CSS code family obtained from concatenating an <span class="inline-math">\(m_1\)</span>-qubit phase-flip repetition code with an <span class="inline-math">\(m_2\)</span>-qubit bit-flip repetition code. Logical codewords are
<span class="display-math env-align">\begin{align}
\begin{split}
|\overline{0}\rangle&amp;=\frac{1}{2^{m_2/2}}\left(|0\rangle^{\otimes m_1}+|1\rangle^{\otimes m_1}\right)^{\otimes m_2}\\
|\overline{1}\rangle&amp;=\frac{1}{2^{m_2/2}}\left(|0\rangle^{\otimes m_1}-|1\rangle^{\otimes m_1}\right)^{\otimes m_2}~.
\end{split}
\end{align}</span>
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_polar">Quantum polar code</a><span class="code-introduced"><a href="#cite-116" class="cite">[117]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_repetition">Quantum repetition code</a></span><span class="code-description">Encodes <span class="inline-math">\(1\)</span> qubit into <span class="inline-math">\(n\)</span> qubits according to <span class="inline-math">\(|0\rangle\to|\phi_0\rangle^{\otimes n}\)</span> and <span class="inline-math">\(|1\rangle\to|\phi_1\rangle^{\otimes n}\)</span>. Also known as a <span class="textit">bit-flip</span> code when <span class="inline-math">\(|\phi_i\rangle = |i\rangle\)</span>, and a <span class="textit">phase-flip</span> code when <span class="inline-math">\(|\phi_0\rangle = |+\rangle\)</span> and <span class="inline-math">\(|\phi_1\rangle = |-\rangle\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_double">Quantum-double code</a><span class="code-introduced"><a href="#cite-79" class="cite">[80]</a></span></span><span class="code-description">A family of topological codes, defined by a finite group <span class="inline-math">\( G \)</span>,  whose generators are few-body operators associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit of dimension <span class="inline-math">\( |G| \)</span> located at each edge of the tesselation).</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quasi_cyclic">Quasi-cyclic code</a><span class="code-introduced"><a href="#cite-117" class="cite">[118]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qubits_into_qubits">Qubit code</a></span><span class="code-description">Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into a <span class="inline-math">\(2^n\)</span>-dimensional (i.e., <span class="inline-math">\(n\)</span>-qubit) Hilbert space. Usually denoted as <span class="inline-math">\(((n,K))\)</span> or <span class="inline-math">\(((n,K,d))\)</span>, where <span class="inline-math">\(d\)</span> is the code&#x27;s distance.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qudits_into_oscillators">Qudit-into-oscillator code</a></span><span class="code-description">Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into Hilbert space of <span class="inline-math">\(\ell^2\)</span>-normalizable functions on <span class="inline-math">\(\mathbb{R}^n\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/ramanujan_tensor_product">Ramanujan tensor-product code</a><span class="code-introduced"><a href="#cite-31" class="cite">[32]</a></span></span><span class="code-description">CSS code constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/random_circuit">Random-circuit code</a></span><span class="code-description">Code whose encoding is naturally constructed by randomly sampling from a large set of quantum circuits.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/reed_muller">Reed-Muller code</a><span class="code-introduced"><a href="#cite-118" class="cite">[119]</a><a href="#cite-119" class="cite">[120]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/reed_solomon">Reed-Solomon code</a><span class="code-introduced"><a href="#cite-120" class="cite">[121]</a></span></span><span class="code-description">An <span class="inline-math">\([n,k,n-k+1]_q\)</span> linear code based on polynomials over <span class="inline-math">\(GF(q)\)</span>. Let <span class="inline-math">\(\{\alpha_1,\cdots,\alpha_n\}\)</span> be <span class="inline-math">\(n\)</span> distinct nonzero elements of <span class="inline-math">\(GF(q)\)</span> with <span class="inline-math">\(q&gt;n\)</span>. Encodes <span class="inline-math">\(\mu=\{\mu_0,\cdots,\mu_{k-1}\}\)</span> into <span class="inline-math">\(\{f_\mu(\alpha_1),\cdots,f_\mu(\alpha_n)\}\)</span>, with polynomial
<span class="display-math env-align">\begin{align}
f_\mu(x)=\mu_0+\mu_1 x + \cdots + \mu_{k-1}x^{k-1}.
\end{align}</span>
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/rings_into_rings">Ring code</a></span><span class="code-description">Encodes <span class="inline-math">\(K\)</span> states (codewords) in <span class="inline-math">\(n\)</span> coordinates over a ring <span class="inline-math">\(R\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/rotor_gkp">Rotor GKP code</a><span class="code-introduced"><a href="#cite-58" class="cite">[59]</a><a href="#cite-60" class="cite">[61]</a></span></span><span class="code-description">GKP code protecting against small angular position and momentum shifts of a planar rotor.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/shor_nine">Shor <span class="inline-math">\([[9,1,3]]\)</span> code</a><span class="code-introduced"><a href="#cite-7" class="cite">[8]</a></span></span><span class="code-description">Nine-qubit <a href="/c/css" class="ref">CSS code</a> that is the smallest such code to correct a single-qubit error. The logical state is encoded using
<span class="display-math env-align">\begin{align}
\begin{split}
|\overline{0}\rangle&amp;=\frac{1}{2\sqrt{2}}\left(|000\rangle+|111\rangle\right)^{\otimes3}\\
|\overline{1}\rangle&amp;=\frac{1}{2\sqrt{2}}\left(|000\rangle-|111\rangle\right)^{\otimes3}~.
\end{split}
\end{align}</span>
The code works by <a href="/c/quantum_concatenated" class="ref">concatenating</a> each qubit of a phase-flip with a bit-flip <a href="/c/quantum_repetition" class="ref">repetition code</a>. Therefore, the code can correct both type of errors simultaneously.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/single_parity_check">Single parity-check code</a></span><span class="code-description">An <span class="inline-math">\([n,n-1,2]\)</span> binary linear error-detecting code encoding an <span class="inline-math">\(n\)</span>-bit codeword into an <span class="inline-math">\((n+1)\)</span>-bit string. In this code, parity information of a codeword is sotred in an extra parity bit. If the Hamming weight of a codeword is odd, then its parity is 1. If the Hamming weight of a codeword is even, then its parity is 0. This code is inexpensive since it only requires an extra parity bit and a single parity check. </span>
  </li>
  <li>
    <span class="code-name"><a href="/c/skew-cyclic_galois_css">Skew-cyclic CSS code</a><span class="code-introduced"><a href="#cite-121" class="cite">[122]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/skew_cyclic">Skew-cyclic code</a><span class="code-introduced"><a href="#cite-122" class="cite">[123]</a></span></span><span class="code-description">A classical code <span class="inline-math">\(C\)</span> of length <span class="inline-math">\(n\)</span> over <span class="inline-math">\(GF(q)\)</span> is skew-cyclic if there exists an automorphism, <span class="inline-math">\(\theta\)</span>, of <span class="inline-math">\(GF(q)\)</span>, such that for each string <span class="inline-math">\(c_1 c_2 \cdots c_n\in C\)</span>, the skew-cyclically shifted string <span class="inline-math">\(\theta(c_n) \theta(c_1) \cdots \theta(c_{n-1})\in C\)</span>. We say that <span class="inline-math">\(C\)</span> is a <span class="inline-math">\(\theta\)</span>-cyclic code over <span class="inline-math">\(GF(q)\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/points_into_spheres">Spherical code</a></span><span class="code-description">Encodes states (codewords) into points on an <span class="inline-math">\(n\)</span>-dimensional sphere <span class="inline-math">\(S^n\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/spins_into_spins">Spin code</a></span><span class="code-description">Encodes <span class="inline-math">\(K\)</span>-dimensional Hilbert space into a <span class="inline-math">\(q^n\)</span>-dimensional (<span class="inline-math">\(n\)</span>-qudit) Hilbert space, with canonical qudit states are associated with states of a quantum mechanical spin. In other words, canonical single-qudit states <span class="inline-math">\(|^\ell_m\rangle\)</span> are labeled by total angular momentum <span class="inline-math">\(\ell\)</span> (either integer or half-integer) and its <span class="inline-math">\(z\)</span>-axis projection <span class="inline-math">\(m\)</span>, with <span class="inline-math">\(q=2\ell+1\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/stabilizer">Stabilizer code</a><span class="code-introduced"><a href="#cite-123" class="cite">[124]</a><a href="#cite-91" class="cite">[92]</a></span></span><span class="code-description">An <span class="inline-math">\(((n,2^k,d))\)</span> qubit stabilizer code is denoted as <span class="inline-math">\([[n,k]]\)</span> or <span class="inline-math">\([[n,k,d]]\)</span>, where <span class="inline-math">\(d\)</span> is the code&#x27;s distance. Logical subspace is the joint <span class="inline-math">\(+1\)</span> eigenspace of a set of <span class="inline-math">\(2^{n-k}\)</span> commuting Pauli operators forming the code&#x27;s stabilizer group <span class="inline-math">\(\mathsf{S}\)</span>, which cannot contain <span class="inline-math">\(-I\)</span>. The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation in the code.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/stabilizer_over_gf4">Stabilizer code over <span class="inline-math">\(GF(4)\)</span></a><span class="code-introduced"><a href="#cite-124" class="cite">[125]</a></span></span><span class="code-description">An <span class="inline-math">\([[n,k,d]]\)</span> stabilizer code whose encoding is based on a self-dual quaternary <span class="inline-math">\([n, n-k, d^*]_4\)</span> code over <span class="inline-math">\(GF(4)^n\)</span> with respect to the trace inner product where <span class="inline-math">\(d \ge d^*\)</span>.
The field <span class="inline-math">\(GF(4)=\mathbf{F}_4\)</span> consists of <span class="inline-math">\(\{0, 1, w, \bar{w}\}\)</span>, with <span class="inline-math">\(\bar{w} = w^2 = w + 1\)</span>, <span class="inline-math">\(\mathrm{Tr}(x) = x+\bar{x}\)</span>, and trace inner product <span class="inline-math">\(u * v = \mathrm{Tr}(u \cdot \bar{v})\)</span>.
There is a mapping <span class="inline-math">\(L\)</span> between Pauli matrices <span class="inline-math">\(I, Y, Z, X\)</span> and <span class="inline-math">\(0, 1, \bar{w}, w\)</span>, in turn <span class="inline-math">\([A, B] \Leftrightarrow Tr\langle L(A), L(A)\rangle\)</span>.
The classical self-dual code <span class="inline-math">\(C\)</span> over <span class="inline-math">\(GF(4)^n\)</span> corresponds to the stabilizer group <span class="inline-math">\(\mathsf{S}\)</span> while <span class="inline-math">\(C^{\perp}\)</span> corresponds to <span class="inline-math">\(\mathsf{N(S)}\)</span>.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/steane">Steane <span class="inline-math">\([[7,1,3]]\)</span> code</a><span class="code-introduced"><a href="#cite-20" class="cite">[21]</a></span></span><span class="code-description">A <span class="inline-math">\([[7,1,3]]\)</span> CSS code that uses the classical binary <span class="inline-math">\([7,4,3]\)</span> Hamming code for protecting against <span class="inline-math">\(X\)</span> errors and its dual <span class="inline-math">\([7,3,4]\)</span> for <span class="inline-math">\(Z\)</span> errors. The parity-check matrix for the <span class="inline-math">\([7,4,3]\)</span> Hamming code is
<span class="display-math env-align">\begin{align}
  H = \left(\begin{matrix}
    1&amp;0&amp;0&amp;1&amp;0&amp;1&amp;1\\
    0&amp;1&amp;0&amp;1&amp;1&amp;0&amp;1\\
    0&amp;0&amp;1&amp;0&amp;1&amp;1&amp;1
  \end{matrix}\right),
\end{align}</span>
and the check matrix for the Steane code is therefore
<span class="display-math env-align">\begin{align}
  \left(\begin{matrix}
    0&amp;H\\
    H&amp;0
  \end{matrix}\right).
\end{align}</span>
The stabilizer group for the Steane code has six generators.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/string_net">String-net code</a><span class="code-introduced"><a href="#cite-32" class="cite">[33]</a><a href="#cite-125" class="cite">[126]</a></span></span><span class="code-description">Also called a <span class="textit">Turaev-Viro</span> or <span class="textit">Levin-Wen model</span> code. A family of topological codes, defined by a finite unitary spherical category <span class="inline-math">\( \mathcal{C} \)</span>,  whose generators are few-body operators acting on a cell decomposition dual to a triangulation of a two-dimensional surface (with a qudit of dimension <span class="inline-math">\( |\mathcal{C}| \)</span> located at each edge of the decomposition).</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/subsystem_color">Subsystem color code</a><span class="code-introduced"><a href="#cite-126" class="cite">[127]</a><a href="#cite-127" class="cite">[128]</a></span></span><span class="code-description">Stub.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/oecc">Subsystem quantum error-correcting code</a><span class="code-introduced"><a href="#cite-128" class="cite">[129]</a><a href="#cite-129" class="cite">[130]</a></span></span><span class="code-description">A subsystem code, also known as an <span class="textit">operator QECC</span>, encodes information in a subsystem <span class="inline-math">\(\mathsf{A}\)</span> of the code space <span class="inline-math">\(\mathsf{C}\)</span>, which is part of the system Hilbert space <span class="inline-math">\(\mathsf{H}\)</span>.
<span class="display-math env-align">\begin{align}
\mathsf{H}=\mathsf{C} \oplus \mathsf{C}^{\perp} = \mathsf{A} \otimes \mathsf{B} \oplus \mathsf{C}^{\perp}
\end{align}</span>
Following an error, it is sufficient to revert back to the original state modulo a transformation on the auxiliary or <span class="textit">gauge</span> subsystem <span class="inline-math">\(\mathsf{B}\)</span>. The subsystem <span class="inline-math">\(\mathsf{B}\)</span> therefore gives additional freedom to the error correction process, and is said to encode <span class="textit">gauge qubits</span> when its dimension is a power of two. While strictly speaking all operator QECCs are also ordinary QECCs, the attachment of a subsystem to a code can yield more efficient correction procedures and a wider variety of encoding procedures.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/subsystem_stabilizer">Subsystem stabilizer code</a><span class="code-introduced"><a href="#cite-130" class="cite">[131]</a></span></span><span class="code-description">Also called a <span class="textit">gauge stabilizer code</span>. A stabilizer code with some of its logical qubits denoted as <span class="textit">gauge</span> qubits and not used for storage of logical information. Note that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by <span class="inline-math">\([[n,k,r,d]]\)</span>, similar to stabilizer codes, but with an extra parameter <span class="inline-math">\(r\)</span> denoting the number of gauge qubits.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/tanner">Tanner code</a><span class="code-introduced"><a href="#cite-131" class="cite">[132]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/stab_3_1_2">Three qutrit code</a><span class="code-introduced"><a href="#cite-132" class="cite">[133]</a></span></span><span class="code-description">A <span class="inline-math">\([[3,1,2]]_3\)</span> prime-qudit CSS code with stabilizer generators <span class="inline-math">\(ZZZ\)</span> and <span class="inline-math">\(XXX\)</span>. The code defines a quantum secret-sharing scheme and serves as a minimal model for the AdS/CFT holographic duality. The codewords are
<span class="display-math env-align">\begin{align}
  \begin{split}
    | \overline{0} \rangle &amp;= \frac{1}{\sqrt{3}} (| 000 \rangle + | 111 \rangle + | 222 \rangle) \\
    | \overline{1} \rangle &amp;= \frac{1}{\sqrt{3}} (| 012 \rangle + | 120 \rangle + | 201 \rangle) \\
    | \overline{2} \rangle &amp;= \frac{1}{\sqrt{3}} (| 021 \rangle + | 102 \rangle + | 210 \rangle)~.
  \end{split}
\end{align}</span>
The elements in the superposition of each logical codeword are related to each other via cyclic permutations.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/topological">Topological code</a></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_triorthogonal">Triorthogonal code</a><span class="code-introduced"><a href="#cite-133" class="cite">[134]</a></span></span><span class="code-description">A triorthogonal <span class="inline-math">\(m \times n\)</span> binary matrix is triorthogonal if its rows <span class="inline-math">\(r_1, \ldots, r_m\)</span> satisfy <span class="inline-math">\(|r_i \cdot r_j| = 0\)</span> and <span class="inline-math">\(|r_i \cdot r_j \cdot r_k| = 0\)</span>, where addition and multiplication are done on <span class="inline-math">\(\mathbb{Z}_2\)</span>. The triorthogonal code associated with the matrix is constructed by mapping non-zero entries in even-weight rows to <span class="inline-math">\(X\)</span> operators, and <span class="inline-math">\(Z\)</span> operators for each row in the orthogonal complement.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/galois_true_stabilizer">True Galois-qudit stabilizer code</a></span><span class="code-description">Also called a <span class="textit">linear stabilizer code</span>. A <span class="inline-math">\([[n,k,d]]_{GF(q)}\)</span> stabilizer code whose stabilizer&#x27;s symplectic representation forms a linear subspace. In other words, the set of <span class="inline-math">\(q\)</span>-ary vectors representing the stabilizer group is closed under both addition and multiplication by elements of <span class="inline-math">\(GF(q)\)</span>. In contrast, Galois-qudit stabilizer codes admit sets of vectors that are closed under addition only.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/two_dimensional_hyperbolic_surface">Two-dimensional hyperbolic surface code</a><span class="code-introduced"><a href="#cite-134" class="cite">[135]</a></span></span><span class="code-description">Hyperbolic surface codes based on a tessellation of a closed 2D manifold with a hyperbolic geometry (i.e., non-Euclidean geometry, e.g., saddle surfaces when defined on a 2D plane).</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/gabidulin">Vector code</a><span class="code-introduced"><a href="#cite-89" class="cite">[90]</a><a href="#cite-90" class="cite">[91]</a></span></span><span class="code-description">Also called <span class="textit">Gabidulin</span> or <span class="textit">vector rank-metric code</span>. The code corrects errors over rank metric instead of the traditional Hamming distance. The rank of an <span class="inline-math">\(n\)</span>-dimensional vector over <span class="inline-math">\(GF(q)^N\)</span> is the maximum number of its linearly independent coordinates.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/very-small-logical-qubit">Very small logical qubit (VSLQ) code</a><span class="code-introduced"><a href="#cite-135" class="cite">[136]</a></span></span><span class="code-description">The two logical codewords are <span class="inline-math">\(|\pm\rangle \propto (|0\rangle\pm|2\rangle)(|0\rangle\pm|2\rangle)|0\rangle|0\rangle\)</span>, where the total Hilbert space is the tensor product of two qudits (whose ground states <span class="inline-math">\(|0\rangle\)</span> and second excited states <span class="inline-math">\(|2\rangle\)</span> are used in the codewords) and two oscillators. In the original proposal for implementation, the single logical qubit is given by the two lowest energy states of a circuit composed of two transmons coupled to two lossy resonators, but the resonators can also be thought of as qubits since only a few low-lying Fock states are used by the code.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/wasilewski-banaszek">Wasilewski-Banaszek code</a><span class="code-introduced"><a href="#cite-136" class="cite">[137]</a></span></span><span class="code-description">Three-oscillator Fock-state code encoding a single logical qubit using codewords <span class="display-math env-align">\begin{align} \begin{split} |\overline{0}\rangle &amp;= \frac{1}{\sqrt{3}}(|003\rangle+|030\rangle+|300\rangle)\\ |\overline{1}\rangle &amp;= |111\rangle \end{split}. \end{align}</span></span>
  </li>
  <li>
    <span class="code-name"><a href="/c/xysurface">XY surface code</a><span class="code-introduced"><a href="#cite-137" class="cite">[138]</a></span></span><span class="code-description">Non-CSS derivative of the surface code whose generators are <span class="inline-math">\(XXXX\)</span>  and <span class="inline-math">\(YYYY\)</span>, obtained by mapping <span class="inline-math">\(Z \to Y\)</span> in the surface code.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/xyz_product">XYZ product code</a><span class="code-introduced"><a href="#cite-138" class="cite">[139]</a></span></span><span class="code-description">A non-CSS QLDPC code constructed from three classical codes. The construction of an XYZ product code is similar to that of a hypergraph product code and related codes. The idea is that rather than taking a product of only two classical codes to produce a CSS code, a third classical code is considered, acting with Pauli-<span class="inline-math">\(Y\)</span> operators.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/xyz_hexagonal">XYZ<span class="inline-math">\(^2\)</span> hexagonal stabilizer code</a><span class="code-introduced"><a href="#cite-139" class="cite">[140]</a><a href="#cite-140" class="cite">[141]</a></span></span><span class="code-description">Stub.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/xzzx">XZZX surface code</a><span class="code-introduced"><a href="#cite-141" class="cite">[142]</a></span></span><span class="code-description">Non-CSS derivative of the surface code whose generators are <span class="inline-math">\(XZXZ\)</span> Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/stab_15_1_3"><span class="inline-math">\([[15,1,3]]\)</span> Reed-Muller code</a></span><span class="code-description"><span class="inline-math">\([[15,1,3]]\)</span> CSS code that is most easily thought of as a tetrahedral 3D color code.
This code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center.
The tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers.
Each colored cell corresponds to a weight-8 <span class="inline-math">\(X\)</span>-check, and each face corresponds to a weight-4 <span class="inline-math">\(Z\)</span>-check.
A logical <span class="inline-math">\(Z\)</span> is any weight-3 <span class="inline-math">\(Z\)</span>-string along an edge of the entire tetrahedron.
The logical <span class="inline-math">\(X\)</span> is any weight-7 <span class="inline-math">\(X\)</span>-face of the entire tetrahedron.
</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_hamming"><span class="inline-math">\([[2^r, 2^r-r-2, 3]]\)</span> quantum Hamming code</a><span class="code-introduced"><a href="#cite-142" class="cite">[143]</a></span></span><span class="code-description">A family of stabilizer codes of distance <span class="inline-math">\(3\)</span> that asymptotically saturate quantum Hamming bound.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/quantum_hamming_css"><span class="inline-math">\([[2^r-1, 2^r-2r-1, 3]]\)</span> Hamming-based CSS code</a></span><span class="code-description">A Hamming-based CSS code is a CCS code constructed with a classical Hamming code <span class="inline-math">\([2^r-1,2^r-1-r,3]=C_X=C_Z\)</span>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/qudit_hamming_css"><span class="inline-math">\([[2^r-1, 2^r-2r-1, 3]]_p\)</span> prime-qudit CSS code</a><span class="code-introduced"><a href="#cite-143" class="cite">[144]</a></span></span><span class="code-description">A family of CSS codes extending <a href="/c/quantum_hamming_css" class="ref">Hamming-based CSS codes</a> to prime qudits of dimension <span class="inline-math">\(p\)</span> by expressing the qubit code stabilizers in local-dimension-invariant (LDI) form <a href="#cite-143" class="cite">[144]</a>.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/stab_4_2_2"><span class="inline-math">\([[4,2,2]]\)</span> CSS code</a><span class="code-introduced"><a href="#cite-144" class="cite">[145]</a></span></span><span class="code-description"> Four-qubit CSS stabilizer code with generators <span class="inline-math">\(\{XXXX, ZZZZ\} \)</span> and codewords <span class="display-math env-align">\begin{align} \begin{split} |\overline{00}\rangle = (|0000\rangle + |1111\rangle)/\sqrt{2}\\ |\overline{01}\rangle = (|0011\rangle + |1100\rangle)/\sqrt{2}\\ |\overline{10}\rangle = (|0101\rangle + |1010\rangle)/\sqrt{2}\\ |\overline{11}\rangle = (|0110\rangle + |1001\rangle)/\sqrt{2} \end{split}. \end{align}</span> Its subcode is the <span class="inline-math">\([[4,1,2]]\)</span> code, whose <span class="inline-math">\(\pm\)</span>-basis codewords can be written as <span class="display-math env-align">\begin{align} |\overline{\pm}\rangle = \frac{1}{2}(|00\rangle \pm |11\rangle)^{\otimes 2}\\ \end{align}</span> This code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code.</span>
  </li>
  <li>
    <span class="code-name"><a href="/c/stab_5_1_3"><span class="inline-math">\([[5,1,3]]\)</span> code</a><span class="code-introduced"><a href="#cite-145" class="cite">[146]</a></span></span><span class="code-description">Five-qubit stabilizer code with generators that are symmetric under cyclic permutation of qubits, <span class="display-math env-align">\begin{align} \begin{split} S_1 &amp;= IXZZX \\ S_2 &amp;= XZZXI \\ S_3 &amp;= ZZXIX \\ S_4 &amp;= ZXIXZ. \end{split} \end{align}</span></span>
  </li>
</ol>



  <div id="endnotes" class="">
    <h2>References</h2>
    <dl id="citations">
      <!-- Citation:  -->
      <dt id="cite-0">[1]</dt>
      <dd>
        H. J. Helgert, “Alternant codes”, Information and Control <span class="textbf">26</span>, 369 (1974). <a href="https://doi.org/10.1016/S0019-9958(74)80005-7" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-1">[2]</dt>
      <dd>
        D. W. Leung et al., “Approximate quantum error correction can lead to better codes”, Physical Review A <span class="textbf">56</span>, 2567 (1997). <a href="https://doi.org/10.1103/PhysRevA.56.2567" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9704002" target="_blank" class="href">quant-ph/9704002</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-2">[3]</dt>
      <dd>
        A. Y. Kitaev, “Quantum computations: algorithms and error correction”, Russian Mathematical Surveys <span class="textbf">52</span>, 1191 (1997). <a href="https://doi.org/10.1070/RM1997v052n06ABEH002155" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-3">[4]</dt>
      <dd>
        M. Reimpell and R. F. Werner, “Iterative Optimization of Quantum Error Correcting Codes”, Physical Review Letters <span class="textbf">94</span>, (2005). <a href="https://doi.org/10.1103/PhysRevLett.94.080501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0307138" target="_blank" class="href">quant-ph/0307138</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-4">[5]</dt>
      <dd>
        Claude Crepeau, Daniel Gottesman, and Adam Smith, “Approximate Quantum Error-Correcting Codes and Secret Sharing Schemes”. <a href="https://arxiv.org/abs/quant-ph/0503139" target="_blank" class="href">quant-ph/0503139</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-5">[6]</dt>
      <dd>
        Cédric Bény, “Conditions for the approximate correction of algebras”. <a href="https://arxiv.org/abs/0907.4207" target="_blank" class="href">0907.4207</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-6">[7]</dt>
      <dd>
        C. Bény and O. Oreshkov, “General Conditions for Approximate Quantum Error Correction and Near-Optimal Recovery Channels”, Physical Review Letters <span class="textbf">104</span>, (2010). <a href="https://doi.org/10.1103/PhysRevLett.104.120501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0907.5391" target="_blank" class="href">0907.5391</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-7">[8]</dt>
      <dd>
        P. W. Shor, “Scheme for reducing decoherence in quantum computer memory”, Physical Review A <span class="textbf">52</span>, R2493 (1995). <a href="https://doi.org/10.1103/PhysRevA.52.R2493" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-8">[9]</dt>
      <dd>
        D. Bacon, “Operator quantum error-correcting subsystems for self-correcting quantum memories”, Physical Review A <span class="textbf">73</span>, (2006). <a href="https://doi.org/10.1103/PhysRevA.73.012340" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0506023" target="_blank" class="href">quant-ph/0506023</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-9">[10]</dt>
      <dd>
        N. P. Breuckmann and J. N. Eberhardt, “Balanced Product Quantum Codes”, IEEE Transactions on Information Theory <span class="textbf">67</span>, 6653 (2021). <a href="https://doi.org/10.1109/TIT.2021.3097347" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/2012.09271" target="_blank" class="href">2012.09271</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-10">[11]</dt>
      <dd>
        Annika Niehage, “Quantum Goppa Codes over Hyperelliptic Curves”. <a href="https://arxiv.org/abs/quant-ph/0501074" target="_blank" class="href">quant-ph/0501074</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-11">[12]</dt>
      <dd>
        A. Niehage, “Nonbinary Quantum Goppa Codes Exceeding the Quantum Gilbert-Varshamov Bound”, Quantum Information Processing <span class="textbf">6</span>, 143 (2006). <a href="https://doi.org/10.1007/s11128-006-0047-9" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-12">[13]</dt>
      <dd>
        W. C. Huffman, J.-L. Kim, and P. Solé, <span class="textit">Concise Encyclopedia of Coding Theory</span> (Chapman and Hall/CRC, 2021). <a href="https://doi.org/10.1201/9781315147901" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-13">[14]</dt>
      <dd>
        M. H. Michael et al., “New Class of Quantum Error-Correcting Codes for a Bosonic Mode”, Physical Review X <span class="textbf">6</span>, (2016). <a href="https://doi.org/10.1103/PhysRevX.6.031006" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1602.00008" target="_blank" class="href">1602.00008</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-14">[15]</dt>
      <dd>
        V. V. Albert et al., “Performance and structure of single-mode bosonic codes”, Physical Review A <span class="textbf">97</span>, (2018). <a href="https://doi.org/10.1103/PhysRevA.97.032346" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1708.05010" target="_blank" class="href">1708.05010</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-15">[16]</dt>
      <dd>
        R. C. Bose and D. K. Ray-Chaudhuri, “On a class of error correcting binary group codes”, Information and Control <span class="textbf">3</span>, 68 (1960). <a href="https://doi.org/10.1016/s0019-9958(60)90287-4" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-16">[17]</dt>
      <dd>
        A. L. Grimsmo, J. Combes, and B. Q. Baragiola, “Quantum Computing with Rotation-Symmetric Bosonic Codes”, Physical Review X <span class="textbf">10</span>, (2020). <a href="https://doi.org/10.1103/PhysRevX.10.011058" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1901.08071" target="_blank" class="href">1901.08071</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-17">[18]</dt>
      <dd>
        S. Bravyi, “Subsystem codes with spatially local generators”, Physical Review A <span class="textbf">83</span>, (2011). <a href="https://doi.org/10.1103/PhysRevA.83.012320" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1008.1029" target="_blank" class="href">1008.1029</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-18">[19]</dt>
      <dd>
        A. R. Calderbank and P. W. Shor, “Good quantum error-correcting codes exist”, Physical Review A <span class="textbf">54</span>, 1098 (1996). <a href="https://doi.org/10.1103/PhysRevA.54.1098" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9512032" target="_blank" class="href">quant-ph/9512032</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-19">[20]</dt>
      <dd>
        A. M. Steane, “Error Correcting Codes in Quantum Theory”, Physical Review Letters <span class="textbf">77</span>, 793 (1996). <a href="https://doi.org/10.1103/PhysRevLett.77.793" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-20">[21]</dt>
      <dd>
        “Multiple-particle interference and quantum error correction”, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences <span class="textbf">452</span>, 2551 (1996). <a href="https://doi.org/10.1098/rspa.1996.0136" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9601029" target="_blank" class="href">quant-ph/9601029</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-21">[22]</dt>
      <dd>
        P. T. Cochrane, G. J. Milburn, and W. J. Munro, “Macroscopically distinct quantum-superposition states as a bosonic code for amplitude damping”, Physical Review A <span class="textbf">59</span>, 2631 (1999). <a href="https://doi.org/10.1103/PhysRevA.59.2631" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9809037" target="_blank" class="href">quant-ph/9809037</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-22">[23]</dt>
      <dd>
        Z. Leghtas et al., “Hardware-Efficient Autonomous Quantum Memory Protection”, Physical Review Letters <span class="textbf">111</span>, (2013). <a href="https://doi.org/10.1103/PhysRevLett.111.120501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1207.0679" target="_blank" class="href">1207.0679</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-23">[24]</dt>
      <dd>
        I. L. Chuang, D. W. Leung, and Y. Yamamoto, “Bosonic quantum codes for amplitude damping”, Physical Review A <span class="textbf">56</span>, 1114 (1997). <a href="https://doi.org/10.1103/PhysRevA.56.1114" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-24">[25]</dt>
      <dd>
        Arpit Dua et al., “Clifford-deformed Surface Codes”. <a href="https://arxiv.org/abs/2201.07802" target="_blank" class="href">2201.07802</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-25">[26]</dt>
      <dd>
        A. Cross et al., “Codeword Stabilized Quantum Codes”, IEEE Transactions on Information Theory <span class="textbf">55</span>, 433 (2009). <a href="https://doi.org/10.1109/TIT.2008.2008136" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0708.1021" target="_blank" class="href">0708.1021</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-26">[27]</dt>
      <dd>
        H. Bombin and M. A. Martin-Delgado, “Topological Quantum Distillation”, Physical Review Letters <span class="textbf">97</span>, (2006). <a href="https://doi.org/10.1103/PhysRevLett.97.180501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0605138" target="_blank" class="href">quant-ph/0605138</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-27">[28]</dt>
      <dd>
        A. M. Kubica, The Abcs of the Color Code: A Study of Topological Quantum Codes as Toy Models for Fault-tolerant Quantum Computation and Quantum Phases of Matter, California Institute of Technology, 2018. <a href="https://doi.org/10.7907/059V-MG69" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-28">[29]</dt>
      <dd>
        H. Bombin, “An Introduction to Topological Quantum Codes”. <a href="https://arxiv.org/abs/1311.0277" target="_blank" class="href">1311.0277</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-29">[30]</dt>
      <dd>
        Peter Elias. Coding for noisy channels. IRE Convention Records, 3(4):37–46, 1955.
      </dd>
      <!-- Citation:  -->
      <dt id="cite-30">[31]</dt>
      <dd>
        M. B. Hastings, “Weight Reduction for Quantum Codes”. <a href="https://arxiv.org/abs/1611.03790" target="_blank" class="href">1611.03790</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-31">[32]</dt>
      <dd>
        Shai Evra, Tali Kaufman, and Gilles Zémor, “Decodable quantum LDPC codes beyond the <span class="inline-math">$\sqrt{n}$</span> distance barrier using high dimensional expanders”. <a href="https://arxiv.org/abs/2004.07935" target="_blank" class="href">2004.07935</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-32">[33]</dt>
      <dd>
        M. A. Levin and X.-G. Wen, “String-net condensation: A physical mechanism for topological phases”, Physical Review B <span class="textbf">71</span>, (2005). <a href="https://doi.org/10.1103/PhysRevB.71.045110" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/cond-mat/0404617" target="_blank" class="href">cond-mat/0404617</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-33">[34]</dt>
      <dd>
        I. L. Chuang and Y. Yamamoto, “Simple quantum computer”, Physical Review A <span class="textbf">52</span>, 3489 (1995). <a href="https://doi.org/10.1103/PhysRevA.52.3489" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-34">[35]</dt>
      <dd>
        P. Hayden and J. Preskill, “Black holes as mirrors: quantum information in random subsystems”, Journal of High Energy Physics <span class="textbf">2007</span>, 120 (2007). <a href="https://doi.org/10.1088/1126-6708/2007/09/120" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0708.4025" target="_blank" class="href">0708.4025</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-35">[36]</dt>
      <dd>
        F. G. S. L. Brandão et al., “Quantum Error Correcting Codes in Eigenstates of Translation-Invariant Spin Chains”, Physical Review Letters <span class="textbf">123</span>, (2019). <a href="https://doi.org/10.1103/PhysRevLett.123.110502" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1710.04631" target="_blank" class="href">1710.04631</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-36">[37]</dt>
      <dd>
        P. Faist et al., “Continuous Symmetries and Approximate Quantum Error Correction”, Physical Review X <span class="textbf">10</span>, (2020). <a href="https://doi.org/10.1103/PhysRevX.10.041018" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1902.07714" target="_blank" class="href">1902.07714</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-37">[38]</dt>
      <dd>
        M. Sipser and D. A. Spielman, “Expander codes”, IEEE Transactions on Information Theory <span class="textbf">42</span>, 1710 (1996). <a href="https://doi.org/10.1109/18.556667" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-38">[39]</dt>
      <dd>
        Pavel Panteleev and Gleb Kalachev, “Asymptotically Good Quantum and Locally Testable Classical LDPC Codes”. <a href="https://arxiv.org/abs/2111.03654" target="_blank" class="href">2111.03654</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-39">[40]</dt>
      <dd>
        S. B. Bravyi and A. Y. Kitaev, “Fermionic Quantum Computation”, Annals of Physics <span class="textbf">298</span>, 210 (2002). <a href="https://doi.org/10.1006/aphy.2002.6254" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0003137" target="_blank" class="href">quant-ph/0003137</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-40">[41]</dt>
      <dd>
        Matthew B. Hastings, Jeongwan Haah, and Ryan O&#x27;Donnell, “Fiber Bundle Codes: Breaking the <span class="inline-math">$N^{1/2} \operatorname{polylog}(N)$</span> Barrier for Quantum LDPC Codes”. <a href="https://arxiv.org/abs/2009.03921" target="_blank" class="href">2009.03921</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-41">[42]</dt>
      <dd>
        M. B. Hastings and J. Haah, “Dynamically Generated Logical Qubits”, Quantum <span class="textbf">5</span>, 564 (2021). <a href="https://doi.org/10.22331/q-2021-10-19-564" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/2107.02194" target="_blank" class="href">2107.02194</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-42">[43]</dt>
      <dd>
        Guanyu Zhu, Tomas Jochym-O&#x27;Connor, and Arpit Dua, “Topological Order, Quantum Codes and Quantum Computation on Fractal Geometries”. <a href="https://arxiv.org/abs/2108.00018" target="_blank" class="href">2108.00018</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-43">[44]</dt>
      <dd>
        Arpit Dua, Tomas Jochym-O&#x27;Connor, and Guanyu Zhu, “Quantum error correction with fractal topological codes”. <a href="https://arxiv.org/abs/2201.03568" target="_blank" class="href">2201.03568</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-44">[45]</dt>
      <dd>
        “Z2-systolic freedom and quantum codes”, Mathematics of Quantum Computation 303 (2002). <a href="https://doi.org/10.1201/9781420035377-13" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-45">[46]</dt>
      <dd>
        M. H. Freedman, “Z2–Systolic-Freedom”, Proceedings of the Kirbyfest (1999). <a href="https://doi.org/10.2140/gtm.1999.2.113" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-46">[47]</dt>
      <dd>
        E. Fetaya, “Bounding the distance of quantum surface codes”, Journal of Mathematical Physics <span class="textbf">53</span>, 062202 (2012). <a href="https://doi.org/10.1063/1.4726034" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-47">[48]</dt>
      <dd>
        Sagarmoy Dutta and Piyush P Kurur, “Quantum Cyclic Code of length dividing <span class="inline-math">$p^{t}+1$</span>”. <a href="https://arxiv.org/abs/1011.5814" target="_blank" class="href">1011.5814</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-48">[49]</dt>
      <dd>
        Sara Bartolucci et al., “Fusion-based quantum computation”. <a href="https://arxiv.org/abs/2101.09310" target="_blank" class="href">2101.09310</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-49">[50]</dt>
      <dd>
        Y. Ouyang, “Permutation-invariant quantum codes”, Physical Review A <span class="textbf">90</span>, (2014). <a href="https://doi.org/10.1103/PhysRevA.90.062317" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1302.3247" target="_blank" class="href">1302.3247</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-50">[51]</dt>
      <dd>
        Alexei Ashikhmin and Emanuel Knill, “Nonbinary Quantum Stabilizer Codes”. <a href="https://arxiv.org/abs/quant-ph/0005008" target="_blank" class="href">quant-ph/0005008</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-51">[52]</dt>
      <dd>
        Avanti Ketkar et al., “Nonbinary stabilizer codes over finite fields”. <a href="https://arxiv.org/abs/quant-ph/0508070" target="_blank" class="href">quant-ph/0508070</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-52">[53]</dt>
      <dd>
        J. Bierbrauer and Y. Edel, “Quantum twisted codes”, Journal of Combinatorial Designs <span class="textbf">8</span>, 174 (2000). <a href="https://doi.org/10.1002/(SICI)1520-6610(2000)8:3&lt;174::AID-JCD3&gt;3.0.CO;2-T" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-53">[54]</dt>
      <dd>
        Dorit Aharonov and Michael Ben-Or, “Fault-Tolerant Quantum Computation With Constant Error Rate”. <a href="https://arxiv.org/abs/quant-ph/9906129" target="_blank" class="href">quant-ph/9906129</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-54">[55]</dt>
      <dd>
        Florence Jessie MacWilliams and Neil James
  Alexander Sloane. <span class="emph">The theory of error correcting codes</span>.
  Ch.10, Sec.8. Vol. 16. Elsevier, 1977
      </dd>
      <!-- Citation:  -->
      <dt id="cite-55">[56]</dt>
      <dd>
        V. D. Goppa, &quot;A new class of linear error-correcting codes&quot;, Probl. Peredach. Inform., vol. 6, no. 3, pp. 24-30, Sept. 1970.
      </dd>
      <!-- Citation:  -->
      <dt id="cite-56">[57]</dt>
      <dd>
        V. D. Goppa, &quot;Rational representation of codes and (Lg) codes&quot;, Probl. Peredach. Inform., vol. 7, no. 3, pp. 41-49, Sept. 1971.
      </dd>
      <!-- Citation:  -->
      <dt id="cite-57">[58]</dt>
      <dd>
        E. Berlekamp, “Goppa codes”, IEEE Transactions on Information Theory <span class="textbf">19</span>, 590 (1973). <a href="https://doi.org/10.1109/TIT.1973.1055088" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-58">[59]</dt>
      <dd>
        D. Gottesman, A. Kitaev, and J. Preskill, “Encoding a qubit in an oscillator”, Physical Review A <span class="textbf">64</span>, (2001). <a href="https://doi.org/10.1103/PhysRevA.64.012310" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0008040" target="_blank" class="href">quant-ph/0008040</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-59">[60]</dt>
      <dd>
        H. Bombin and M. A. Martin-Delgado, “Homological error correction: Classical and quantum codes”, Journal of Mathematical Physics <span class="textbf">48</span>, 052105 (2007). <a href="https://doi.org/10.1063/1.2731356" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0605094" target="_blank" class="href">quant-ph/0605094</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-60">[61]</dt>
      <dd>
        V. V. Albert, J. P. Covey, and J. Preskill, “Robust Encoding of a Qubit in a Molecule”, Physical Review X <span class="textbf">10</span>, (2020). <a href="https://doi.org/10.1103/PhysRevX.10.031050" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1911.00099" target="_blank" class="href">1911.00099</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-61">[62]</dt>
      <dd>
        L. Guth and A. Lubotzky, “Quantum error correcting codes and 4-dimensional arithmetic hyperbolic manifolds”, Journal of Mathematical Physics <span class="textbf">55</span>, 082202 (2014). <a href="https://doi.org/10.1063/1.4891487" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1310.5555" target="_blank" class="href">1310.5555</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-62">[63]</dt>
      <dd>
        J. Haah, “Local stabilizer codes in three dimensions without string logical operators”, Physical Review A <span class="textbf">83</span>, (2011). <a href="https://doi.org/10.1103/PhysRevA.83.042330" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1101.1962" target="_blank" class="href">1101.1962</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-63">[64]</dt>
      <dd>
        Peter W. Shor, <a href="https://github.com/errorcorrectionzoo/eczoo_data/files/7808154/shor.pdf" target="_blank" class="href">The quantum channel capacity and coherent information</a>, 2002 (obtained from the MSRI Workshop on Quantum Computation website).
      </dd>
      <!-- Citation:  -->
      <dt id="cite-64">[65]</dt>
      <dd>
        P. Hayden et al., “A Decoupling Approach to the Quantum Capacity”, Open Systems &amp; Information Dynamics <span class="textbf">15</span>, 7 (2008). <a href="https://doi.org/10.1142/S1230161208000043" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0702005" target="_blank" class="href">quant-ph/0702005</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-65">[66]</dt>
      <dd>
        I. Devetak, “The private classical capacity and quantum capacity of a quantum channel”. <a href="https://arxiv.org/abs/quant-ph/0304127" target="_blank" class="href">quant-ph/0304127</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-66">[67]</dt>
      <dd>
        Rochus Klesse, “A random-coding based proof for the quantum coding theorem”. <a href="https://arxiv.org/abs/0712.2558" target="_blank" class="href">0712.2558</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-67">[68]</dt>
      <dd>
        M. M. Wilde, “Preface to the Second Edition”, Quantum Information Theory xi. <a href="https://doi.org/10.1017/9781316809976.001" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1106.1445" target="_blank" class="href">1106.1445</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-68">[69]</dt>
      <dd>
        R. W. Hamming, “Error Detecting and Error Correcting Codes”, Bell System Technical Journal <span class="textbf">29</span>, 147 (1950). <a href="https://doi.org/10.1002/j.1538-7305.1950.tb00463.x" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-69">[70]</dt>
      <dd>
        E. Dennis et al., “Topological quantum memory”, Journal of Mathematical Physics <span class="textbf">43</span>, 4452 (2002). <a href="https://doi.org/10.1063/1.1499754" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0110143" target="_blank" class="href">quant-ph/0110143</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-70">[71]</dt>
      <dd>
        F. Pastawski et al., “Holographic quantum error-correcting codes: toy models for the bulk/boundary correspondence”, Journal of High Energy Physics <span class="textbf">2015</span>, (2015). <a href="https://doi.org/10.1007/JHEP06(2015)149" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1503.06237" target="_blank" class="href">1503.06237</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-71">[72]</dt>
      <dd>
        Kfir Dolev et al., “Gauging the bulk: generalized gauging maps and holographic codes”. <a href="https://arxiv.org/abs/2108.11402" target="_blank" class="href">2108.11402</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-72">[73]</dt>
      <dd>
        P. Hayden et al., “Spacetime replication of continuous variable quantum information”, New Journal of Physics <span class="textbf">18</span>, 083043 (2016). <a href="https://doi.org/10.1088/1367-2630/18/8/083043" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1601.02544" target="_blank" class="href">1601.02544</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-73">[74]</dt>
      <dd>
        M. H. Freedman and M. B. Hastings, “Quantum Systems on Non-<span class="inline-math">$k$</span>-Hyperfinite Complexes: A Generalization of Classical Statistical Mechanics on Expander Graphs”. <a href="https://arxiv.org/abs/1301.1363" target="_blank" class="href">1301.1363</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-74">[75]</dt>
      <dd>
        Sergey Bravyi and Matthew B. Hastings, “Homological Product Codes”. <a href="https://arxiv.org/abs/1311.0885" target="_blank" class="href">1311.0885</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-75">[76]</dt>
      <dd>
        A. Kitaev, “Anyons in an exactly solved model and beyond”, Annals of Physics <span class="textbf">321</span>, 2 (2006). <a href="https://doi.org/10.1016/j.aop.2005.10.005" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/cond-mat/0506438" target="_blank" class="href">cond-mat/0506438</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-76">[77]</dt>
      <dd>
        J.-P. Tillich and G. Zemor, “Quantum LDPC Codes With Positive Rate and Minimum Distance Proportional to the Square Root of the Blocklength”, IEEE Transactions on Information Theory <span class="textbf">60</span>, 1193 (2014). <a href="https://doi.org/10.1109/TIT.2013.2292061" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0903.0566" target="_blank" class="href">0903.0566</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-77">[78]</dt>
      <dd>
        A. A. Kovalev and L. P. Pryadko, “Improved quantum hypergraph-product LDPC codes”, 2012 IEEE International Symposium on Information Theory Proceedings (2012). <a href="https://doi.org/10.1109/ISIT.2012.6284206" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1202.0928" target="_blank" class="href">1202.0928</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-78">[79]</dt>
      <dd>
        A. Y. Kitaev, “Quantum Error Correction with Imperfect Gates”, Quantum Communication, Computing, and Measurement 181 (1997). <a href="https://doi.org/10.1007/978-1-4615-5923-8_19" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-79">[80]</dt>
      <dd>
        A. Y. Kitaev, “Fault-tolerant quantum computation by anyons”, Annals of Physics <span class="textbf">303</span>, 2 (2003). <a href="https://doi.org/10.1016/S0003-4916(02)00018-0" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9707021" target="_blank" class="href">quant-ph/9707021</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-80">[81]</dt>
      <dd>
        S. B. Bravyi and A. Yu. Kitaev, “Quantum codes on a lattice with boundary”. <a href="https://arxiv.org/abs/quant-ph/9811052" target="_blank" class="href">quant-ph/9811052</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-81">[82]</dt>
      <dd>
        P. Panteleev and G. Kalachev, “Degenerate Quantum LDPC Codes With Good Finite Length Performance”, Quantum <span class="textbf">5</span>, 585 (2021). <a href="https://doi.org/10.22331/q-2021-11-22-585" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1904.02703" target="_blank" class="href">1904.02703</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-82">[83]</dt>
      <dd>
        F. G. S. L. Brandão, A. W. Harrow, and M. Horodecki, “Local Random Quantum Circuits are Approximate Polynomial-Designs”, Communications in Mathematical Physics <span class="textbf">346</span>, 397 (2016). <a href="https://doi.org/10.1007/s00220-016-2706-8" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-83">[84]</dt>
      <dd>
        M. J. Gullans et al., “Quantum Coding with Low-Depth Random Circuits”, Physical Review X <span class="textbf">11</span>, (2021). <a href="https://doi.org/10.1103/PhysRevX.11.031066" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/2010.09775" target="_blank" class="href">2010.09775</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-84">[85]</dt>
      <dd>
        W. Brown and O. Fawzi, “Short random circuits define good quantum error correcting codes”, 2013 IEEE International Symposium on Information Theory (2013). <a href="https://doi.org/10.1109/ISIT.2013.6620245" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1312.7646" target="_blank" class="href">1312.7646</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-85">[86]</dt>
      <dd>
        S. Bravyi, B. M. Terhal, and B. Leemhuis, “Majorana fermion codes”, New Journal of Physics <span class="textbf">12</span>, 083039 (2010). <a href="https://doi.org/10.1088/1367-2630/12/8/083039" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1004.3791" target="_blank" class="href">1004.3791</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-86">[87]</dt>
      <dd>
        Sagar Vijay and Liang Fu, “Quantum Error Correction for Complex and Majorana Fermion Qubits”. <a href="https://arxiv.org/abs/1703.00459" target="_blank" class="href">1703.00459</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-87">[88]</dt>
      <dd>
        J. R. Wootton, “A family of stabilizer codes for <span class="inline-math">$D({{\mathbb{Z}}_{2}})$</span> anyons and Majorana modes”, Journal of Physics A: Mathematical and Theoretical <span class="textbf">48</span>, 215302 (2015). <a href="https://doi.org/10.1088/1751-8113/48/21/215302" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1501.07779" target="_blank" class="href">1501.07779</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-88">[89]</dt>
      <dd>
        R. Singleton, “Maximum distance&amp;lt;tex&amp;gt;q&amp;lt;/tex&amp;gt;-nary codes”, IEEE Transactions on Information Theory <span class="textbf">10</span>, 116 (1964). <a href="https://doi.org/10.1109/TIT.1964.1053661" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-89">[90]</dt>
      <dd>
        E. M. Gabidulin, &quot;Theory of Codes with Maximum Rank Distance&quot;, Problemy Peredachi Informacii, Volume 21, Issue 1, <span class="emph">3–16</span> (1985)
      </dd>
      <!-- Citation:  -->
      <dt id="cite-90">[91]</dt>
      <dd>
        R. M. Roth, “Maximum-rank array codes and their application to crisscross error correction”, IEEE Transactions on Information Theory <span class="textbf">37</span>, 328 (1991). <a href="https://doi.org/10.1109/18.75248" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-91">[92]</dt>
      <dd>
        Daniel Gottesman, “Stabilizer Codes and Quantum Error Correction”. <a href="https://arxiv.org/abs/quant-ph/9705052" target="_blank" class="href">quant-ph/9705052</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-92">[93]</dt>
      <dd>
        B. Skinner, J. Ruhman, and A. Nahum, “Measurement-Induced Phase Transitions in the Dynamics of Entanglement”, Physical Review X <span class="textbf">9</span>, (2019). <a href="https://doi.org/10.1103/PhysRevX.9.031009" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-93">[94]</dt>
      <dd>
        Y. Li, X. Chen, and M. P. A. Fisher, “Quantum Zeno effect and the many-body entanglement transition”, Physical Review B <span class="textbf">98</span>, (2018). <a href="https://doi.org/10.1103/PhysRevB.98.205136" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-94">[95]</dt>
      <dd>
        A. Chan et al., “Unitary-projective entanglement dynamics”, Physical Review B <span class="textbf">99</span>, (2019). <a href="https://doi.org/10.1103/PhysRevB.99.224307" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1808.05949" target="_blank" class="href">1808.05949</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-95">[96]</dt>
      <dd>
        Y. Li, X. Chen, and M. P. A. Fisher, “Measurement-driven entanglement transition in hybrid quantum circuits”, Physical Review B <span class="textbf">100</span>, (2019). <a href="https://doi.org/10.1103/PhysRevB.100.134306" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1901.08092" target="_blank" class="href">1901.08092</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-96">[97]</dt>
      <dd>
        S. Choi et al., “Quantum Error Correction in Scrambling Dynamics and Measurement-Induced Phase Transition”, Physical Review Letters <span class="textbf">125</span>, (2020). <a href="https://doi.org/10.1103/PhysRevLett.125.030505" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1903.05124" target="_blank" class="href">1903.05124</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-97">[98]</dt>
      <dd>
        M. J. Gullans and D. A. Huse, “Dynamical Purification Phase Transition Induced by Quantum Measurements”, Physical Review X <span class="textbf">10</span>, (2020). <a href="https://doi.org/10.1103/PhysRevX.10.041020" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1905.05195" target="_blank" class="href">1905.05195</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-98">[99]</dt>
      <dd>
        Ramis Movassagh and Yingkai Ouyang, “Constructing quantum codes from any classical code and their embedding in ground space of local Hamiltonians”. <a href="https://arxiv.org/abs/2012.01453" target="_blank" class="href">2012.01453</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-99">[100]</dt>
      <dd>
        J. Niset, U. L. Andersen, and N. J. Cerf, “Experimentally Feasible Quantum Erasure-Correcting Code for Continuous Variables”, Physical Review Letters <span class="textbf">101</span>, (2008). <a href="https://doi.org/10.1103/PhysRevLett.101.130503" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0710.4858" target="_blank" class="href">0710.4858</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-100">[101]</dt>
      <dd>
        S. M. Barnett and D. T. Pegg, “Phase in quantum optics”, Journal of Physics A: Mathematical and General <span class="textbf">19</span>, 3849 (1986). <a href="https://doi.org/10.1088/0305-4470/19/18/030" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-101">[102]</dt>
      <dd>
        Greg Kuperberg, “The capacity of hybrid quantum memory”. <a href="https://arxiv.org/abs/quant-ph/0203105" target="_blank" class="href">quant-ph/0203105</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-102">[103]</dt>
      <dd>
        C. Bény, A. Kempf, and D. W. Kribs, “Quantum error correction of observables”, Physical Review A <span class="textbf">76</span>, (2007). <a href="https://doi.org/10.1103/PhysRevA.76.042303" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0705.1574" target="_blank" class="href">0705.1574</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-103">[104]</dt>
      <dd>
        S. Lloyd and J.-J. E. Slotine, “Analog Quantum Error Correction”, Physical Review Letters <span class="textbf">80</span>, 4088 (1998). <a href="https://doi.org/10.1103/PhysRevLett.80.4088" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9711021" target="_blank" class="href">quant-ph/9711021</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-104">[105]</dt>
      <dd>
        S. L. Braunstein, “Error Correction for Continuous Quantum Variables”, Physical Review Letters <span class="textbf">80</span>, 4084 (1998). <a href="https://doi.org/10.1103/PhysRevLett.80.4084" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9711049" target="_blank" class="href">quant-ph/9711049</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-105">[106]</dt>
      <dd>
        Harriet Pollatsek and Mary Beth Ruskai, “Permutationally Invariant Codes for Quantum Error Correction”. <a href="https://arxiv.org/abs/quant-ph/0304153" target="_blank" class="href">quant-ph/0304153</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-106">[107]</dt>
      <dd>
        E. Arikan, “Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels”, IEEE Transactions on Information Theory <span class="textbf">55</span>, 3051 (2009). <a href="https://doi.org/10.1109/TIT.2009.2021379" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-107">[108]</dt>
      <dd>
        M. Grassl, W. Geiselmann, and T. Beth, “Quantum Reed—Solomon Codes”, Applied Algebra, Algebraic Algorithms and Error-Correcting Codes 231 (1999). <a href="https://doi.org/10.1007/3-540-46796-3_23" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9910059" target="_blank" class="href">quant-ph/9910059</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-108">[109]</dt>
      <dd>
        Michael H. Freedman and David A. Meyer, “Projective plane and planar quantum codes”. <a href="https://arxiv.org/abs/quant-ph/9810055" target="_blank" class="href">quant-ph/9810055</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-109">[110]</dt>
      <dd>
        Andrew Steane, “Quantum Reed-Muller Codes”. <a href="https://arxiv.org/abs/quant-ph/9608026" target="_blank" class="href">quant-ph/9608026</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-110">[111]</dt>
      <dd>
        G. D. Forney, M. Grassl, and S. Guha, “Convolutional and Tail-Biting Quantum Error-Correcting Codes”, IEEE Transactions on Information Theory <span class="textbf">53</span>, 865 (2007). <a href="https://doi.org/10.1109/TIT.2006.890698" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0511016" target="_blank" class="href">quant-ph/0511016</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-111">[112]</dt>
      <dd>
        Sagarmoy Dutta and Piyush P Kurur, “Quantum Cyclic Code”. <a href="https://arxiv.org/abs/1007.1697" target="_blank" class="href">1007.1697</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-112">[113]</dt>
      <dd>
        A. Leverrier, J.-P. Tillich, and G. Zemor, “Quantum Expander Codes”, 2015 IEEE 56th Annual Symposium on Foundations of Computer Science (2015). <a href="https://doi.org/10.1109/FOCS.2015.55" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1504.00822" target="_blank" class="href">1504.00822</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-113">[114]</dt>
      <dd>
        D. J. C. MacKay, G. Mitchison, and P. L. McFadden, “Sparse-Graph Codes for Quantum Error Correction”, IEEE Transactions on Information Theory <span class="textbf">50</span>, 2315 (2004). <a href="https://doi.org/10.1109/TIT.2004.834737" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0304161" target="_blank" class="href">quant-ph/0304161</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-114">[115]</dt>
      <dd>
        T. C. Ralph, A. J. F. Hayes, and A. Gilchrist, “Loss-Tolerant Optical Qubits”, Physical Review Letters <span class="textbf">95</span>, (2005). <a href="https://doi.org/10.1103/PhysRevLett.95.100501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0501184" target="_blank" class="href">quant-ph/0501184</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-115">[116]</dt>
      <dd>
        E. Knill, R. Laflamme, and G. Milburn, “Efficient Linear Optics Quantum Computation”. <a href="https://arxiv.org/abs/quant-ph/0006088" target="_blank" class="href">quant-ph/0006088</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-116">[117]</dt>
      <dd>
        J. M. Renes, F. Dupuis, and R. Renner, “Efficient Polar Coding of Quantum Information”, Physical Review Letters <span class="textbf">109</span>, (2012). <a href="https://doi.org/10.1103/PhysRevLett.109.050504" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1109.3195" target="_blank" class="href">1109.3195</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-117">[118]</dt>
      <dd>
        R. Townsend and E. Weldon, “Self-orthogonal quasi-cyclic codes”, IEEE Transactions on Information Theory <span class="textbf">13</span>, 183 (1967). <a href="https://doi.org/10.1109/TIT.1967.1053974" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-118">[119]</dt>
      <dd>
        D. E. Muller, “Application of Boolean algebra to switching circuit design and to error detection”, Transactions of the I.R.E. Professional Group on Electronic Computers <span class="textbf">EC-3</span>, 6 (1954). <a href="https://doi.org/10.1109/irepgelc.1954.6499441" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-119">[120]</dt>
      <dd>
        I. Reed, “A class of multiple-error-correcting codes and the decoding scheme”, Transactions of the IRE Professional Group on Information Theory <span class="textbf">4</span>, 38 (1954). <a href="https://doi.org/10.1109/tit.1954.1057465" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-120">[121]</dt>
      <dd>
        I. S. Reed and G. Solomon, “Polynomial Codes Over Certain Finite Fields”, Journal of the Society for Industrial and Applied Mathematics <span class="textbf">8</span>, 300 (1960). <a href="https://doi.org/10.1137/0108018" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-121">[122]</dt>
      <dd>
        H. Q. Dinh et al., “A class of skew cyclic codes and application in quantum codes construction”, Discrete Mathematics <span class="textbf">344</span>, 112189 (2021). <a href="https://doi.org/10.1016/j.disc.2020.112189" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-122">[123]</dt>
      <dd>
        Delphine Boucher, Willi Geiselmann, and Félix Ulmer, “Skew-cyclic codes”. <a href="https://arxiv.org/abs/math/0604603" target="_blank" class="href">math/0604603</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-123">[124]</dt>
      <dd>
        A. R. Calderbank et al., “Quantum Error Correction and Orthogonal Geometry”, Physical Review Letters <span class="textbf">78</span>, 405 (1997). <a href="https://doi.org/10.1103/PhysRevLett.78.405" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9605005" target="_blank" class="href">quant-ph/9605005</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-124">[125]</dt>
      <dd>
        A. R. Calderbank et al., “Quantum Error Correction via Codes over GF(4)”. <a href="https://arxiv.org/abs/quant-ph/9608006" target="_blank" class="href">quant-ph/9608006</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-125">[126]</dt>
      <dd>
        R. Koenig, G. Kuperberg, and B. W. Reichardt, “Quantum computation with Turaev–Viro codes”, Annals of Physics <span class="textbf">325</span>, 2707 (2010). <a href="https://doi.org/10.1016/j.aop.2010.08.001" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1002.2816" target="_blank" class="href">1002.2816</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-126">[127]</dt>
      <dd>
        H. Bombin, “Topological subsystem codes”, Physical Review A <span class="textbf">81</span>, (2010). <a href="https://doi.org/10.1103/PhysRevA.81.032301" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/0908.4246" target="_blank" class="href">0908.4246</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-127">[128]</dt>
      <dd>
        H. Bombin, “Gauge Color Codes: Optimal Transversal Gates and Gauge Fixing in Topological Stabilizer Codes”. <a href="https://arxiv.org/abs/1311.0879" target="_blank" class="href">1311.0879</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-128">[129]</dt>
      <dd>
        D. Kribs, R. Laflamme, and D. Poulin, “Unified and Generalized Approach to Quantum Error Correction”, Physical Review Letters <span class="textbf">94</span>, (2005). <a href="https://doi.org/10.1103/PhysRevLett.94.180501" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0412076" target="_blank" class="href">quant-ph/0412076</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-129">[130]</dt>
      <dd>
        David W. Kribs et al., “Operator quantum error correction”. <a href="https://arxiv.org/abs/quant-ph/0504189" target="_blank" class="href">quant-ph/0504189</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-130">[131]</dt>
      <dd>
        D. Poulin, “Stabilizer Formalism for Operator Quantum Error Correction”, Physical Review Letters <span class="textbf">95</span>, (2005). <a href="https://doi.org/10.1103/PhysRevLett.95.230504" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/0508131" target="_blank" class="href">quant-ph/0508131</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-131">[132]</dt>
      <dd>
        R. Tanner, “A recursive approach to low complexity codes”, IEEE Transactions on Information Theory <span class="textbf">27</span>, 533 (1981). <a href="https://doi.org/10.1109/TIT.1981.1056404" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-132">[133]</dt>
      <dd>
        R. Cleve, D. Gottesman, and H.-K. Lo, “How to Share a Quantum Secret”, Physical Review Letters <span class="textbf">83</span>, 648 (1999). <a href="https://doi.org/10.1103/PhysRevLett.83.648" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9901025" target="_blank" class="href">quant-ph/9901025</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-133">[134]</dt>
      <dd>
        S. Bravyi and J. Haah, “Magic-state distillation with low overhead”, Physical Review A <span class="textbf">86</span>, (2012). <a href="https://doi.org/10.1103/PhysRevA.86.052329" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1209.2426" target="_blank" class="href">1209.2426</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-134">[135]</dt>
      <dd>
        N. P. Breuckmann and B. M. Terhal, “Constructions and Noise Threshold of Hyperbolic Surface Codes”, IEEE Transactions on Information Theory <span class="textbf">62</span>, 3731 (2016). <a href="https://doi.org/10.1109/TIT.2016.2555700" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1506.04029" target="_blank" class="href">1506.04029</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-135">[136]</dt>
      <dd>
        E. Kapit, “Hardware-Efficient and Fully Autonomous Quantum Error Correction in Superconducting Circuits”, Physical Review Letters <span class="textbf">116</span>, (2016). <a href="https://doi.org/10.1103/PhysRevLett.116.150501" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-136">[137]</dt>
      <dd>
        W. Wasilewski and K. Banaszek, “Protecting an optical qubit against photon loss”, Physical Review A <span class="textbf">75</span>, (2007). <a href="https://doi.org/10.1103/PhysRevA.75.042316" target="_blank" class="href">DOI</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-137">[138]</dt>
      <dd>
        D. K. Tuckett, S. D. Bartlett, and S. T. Flammia, “Ultrahigh Error Threshold for Surface Codes with Biased Noise”, Physical Review Letters <span class="textbf">120</span>, (2018). <a href="https://doi.org/10.1103/PhysRevLett.120.050505" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/1708.08474" target="_blank" class="href">1708.08474</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-138">[139]</dt>
      <dd>
        Anthony Leverrier, Simon Apers, and Christophe Vuillot, “Quantum XYZ Product Codes”. <a href="https://arxiv.org/abs/2011.09746" target="_blank" class="href">2011.09746</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-139">[140]</dt>
      <dd>
        James R. Wootton, “Hexagonal matching codes with 2-body measurements”. <a href="https://arxiv.org/abs/2109.13308" target="_blank" class="href">2109.13308</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-140">[141]</dt>
      <dd>
        Basudha Srivastava, Anton Frisk Kockum, and Mats Granath, “The XYZ<span class="inline-math">$^2$</span> hexagonal stabilizer code”. <a href="https://arxiv.org/abs/2112.06036" target="_blank" class="href">2112.06036</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-141">[142]</dt>
      <dd>
        J. P. Bonilla Ataides et al., “The XZZX surface code”, Nature Communications <span class="textbf">12</span>, (2021). <a href="https://doi.org/10.1038/s41467-021-22274-1" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/2009.07851" target="_blank" class="href">2009.07851</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-142">[143]</dt>
      <dd>
        D. Gottesman, “Class of quantum error-correcting codes saturating the quantum Hamming bound”, Physical Review A <span class="textbf">54</span>, 1862 (1996). <a href="https://doi.org/10.1103/PhysRevA.54.1862" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9604038" target="_blank" class="href">quant-ph/9604038</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-143">[144]</dt>
      <dd>
        Arun J. Moorthy and Lane G. Gunderman, “Local-dimension-invariant Calderbank-Shor-Steane Codes with an Improved Distance Promise”. <a href="https://arxiv.org/abs/2110.11510" target="_blank" class="href">2110.11510</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-144">[145]</dt>
      <dd>
        L. Vaidman, L. Goldenberg, and S. Wiesner, “Error prevention scheme with four particles”, Physical Review A <span class="textbf">54</span>, R1745 (1996). <a href="https://doi.org/10.1103/PhysRevA.54.R1745" target="_blank" class="href">DOI</a>; <a href="https://arxiv.org/abs/quant-ph/9603031" target="_blank" class="href">quant-ph/9603031</a>
      </dd>
      <!-- Citation:  -->
      <dt id="cite-145">[146]</dt>
      <dd>
        Raymond Laflamme et al., “Perfect Quantum Error Correction Code”. <a href="https://arxiv.org/abs/quant-ph/9602019" target="_blank" class="href">quant-ph/9602019</a>
      </dd>
    
    </dl>
  </div>

  </main><!-- #main -->

  <nav id="navigation">

<ul class="navlinks"><li><a href="/">Home</a></li><li><a href="/code_graph">Code graph</a></li><li><a href="/lists">Code lists</a></li><li><a href="/search">Search</a></li></ul><h1><a href="/domain/classical_domain">Classical Domain</a></h1><ul class="navlinks"><li><a href="/kingdom/bits_into_bits">Binary Kingdom</a></li><li><a href="/kingdom/q-ary_digits_into_q-ary_digits">Galois-field Kingdom</a></li><li><a href="/kingdom/matrices_into_matrices">Matrix Kingdom</a></li><li><a href="/kingdom/points_into_lattices">Lattice Kingdom</a></li><li><a href="/kingdom/points_into_spheres">Spherical Kingdom</a></li><li><a href="/kingdom/rings_into_rings">Ring Kingdom</a></li></ul><h1><a href="/domain/quantum_domain">Quantum Domain</a></h1><ul class="navlinks"><li><a href="/kingdom/qubits_into_qubits">Qubit Kingdom</a></li><li><a href="/kingdom/qudits_into_qudits">Modular-qudit Kingdom</a></li><li><a href="/kingdom/galois_into_galois">Galois-qudit Kingdom</a></li><li><a href="/kingdom/oscillators">Bosonic Kingdom</a></li><li><a href="/kingdom/fermions">Fermionic Kingdom</a></li><li><a href="/kingdom/spins_into_spins">Spin Kingdom</a></li><li><a href="/kingdom/group_quantum">Group Kingdom</a></li><li><a href="/kingdom/category_quantum">Category Kingdom</a></li></ul><h1></h1><ul class="navlinks"><li><a href="/edit_code">Add new code</a></li><!--<li><a href="/additional_resources">Additional resources</a></li>--><li><a href="/team">Team</a></li><li><a href="/about">About</a></li></ul>
  </nav><!-- #navigation -->

  <nav id="navigation-shortcuts">
    <a href="#navigation" id="nav-shortcut-to-navigation-links">&#8801;</a>
  </nav>
  <footer id="footer">
    <div class="footer-stuff">
<a href="/about">Error correction zoo</a>
by Victor V. Albert, Philippe Faist, and
<a href="/team">many contributors</a>.    </div>
  </footer>

</div>
</body>
</html>